<?xml version='1.0' encoding='UTF-8'?>
<search_results><query id="7416">release date bioshock infinite</query><engine status="OK" timestamp="2014-04-19 20:02:54" name="CiteSeerX" id="FW14-e004"/><snippets><snippet id="FW14-e004-7416-01"><link cache="FW14-topics-docs/e004/7416_01.html" timestamp="2014-04-19 20:03:00">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.33.1637&amp;rank=1</link><title>Composing Specifications</title><description>Composing Specifications

by Martín Abadi, Leslie Lamport \- ACM TRANSACTIONS ON PROGRAMMING LANGUAGES AND SYSTEMS , 1993

"... date appear, and notice is given that copying is by permission of the Association for Computing ..."

Abstract \- Cited by 540 (19 self) \- Add to MetaCart

Abstract not found</description></snippet><snippet id="FW14-e004-7416-02"><link cache="FW14-topics-docs/e004/7416_02.html" timestamp="2014-04-19 20:03:42">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.117.2921&amp;rank=2</link><title>A Performance Comparison of Multi-Hop Wireless Ad Hoc Network Routing Protocols</title><description>A Performance Comparison of Multi-Hop Wireless Ad Hoc Network Routing Protocols

by Josh Broch, David A. Maltz, David B. Johnson, Yih-chun Hu, Jorjeta Jetcheva , 1998

"... in such environments. Berkeley has recently released ns code that provides some support for modeling wireless LANs ..."

Abstract \- Cited by 1396 (26 self) \- Add to MetaCart

An ad hoc network is a collection of wireless mobile nodes dynamically forming a temporary network without the use of any existing network infrastructure or centralized administration. Due to the limited transmission range of wireless network interfaces, multiple network &amp;quot;hops &amp;quot; may be needed for one node to exchange data with another across the network. In recent years, a variety of new routing protocols targeted specifically at this environment have been developed, but little performance information on each protocol and no realistic performance comparison between them is available. This paper presents the results of a detailed packet-level simulation comparing four multi-hop wireless ad hoc network routing protocols that cover a range of design choices: DSDV, TORA, DSR, and AODV. We have extended the ns-2 network simulator to accurately model the MAC and physical-layer behavior of the IEEE 802.11 wireless LAN standard, including a realistic wireless transmission channel model, and present the results of simulations of networks of 50 mobile nodes. 1</description></snippet><snippet id="FW14-e004-7416-03"><link cache="FW14-topics-docs/e004/7416_03.html" timestamp="2014-04-19 20:04:33">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.12.448&amp;rank=3</link><title>Disconnected Operation in the Coda File System</title><description>Disconnected Operation in the Coda File System

by James J. Kistler, M. Satyanarayanan \- ACM Transactions on Computer Systems , 1992

"... for direct commercial advantage, the ACM copyright notice and the title of the publication and its date ..."

Abstract \- Cited by 916 (34 self) \- Add to MetaCart

Disconnected operation is a mode of operation that enables a client to continue accessing critical data during temporary failures of a shared data repository. An important, though not exclusive, application of disconnected operation is in supporting portable computers. In this paper, we show that disconnected operation is feasible, efficient and usable by describing its design and implementation in the Coda File System. The central idea behind our work is that caching of data, now widely used for performance, can also be exploited to improve availability.</description></snippet><snippet id="FW14-e004-7416-04"><link cache="FW14-topics-docs/e004/7416_04.html" timestamp="2014-04-19 20:05:26">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.101.8988&amp;rank=4</link><title>On optimistic methods for concurrency control</title><description>On optimistic methods for concurrency control

by H. T. Kung, John T. Robinson \- ACM Transactions on Database Systems , 1981

"... date appear, and notice is given that copying is by permission of the Association for Computing ..."

Abstract \- Cited by 447 (0 self) \- Add to MetaCart

Most current approaches to concurrency control in database systems rely on locking of data objects as a control mechanism. In this paper, two families of nonlocking concurrency controls are presented. The methods used are “optimistic ” in the sense that they rely mainly on transaction backup as a control mechanism, “hoping ” that conflicts between transactions will not occur. Applications for which these methods should be more efficient than locking are discussed.</description></snippet><snippet id="FW14-e004-7416-05"><link cache="FW14-topics-docs/e004/7416_05.html" timestamp="2014-04-19 20:06:15">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.131.1243&amp;rank=5</link><title>LLVM: A compilation framework for lifelong program analysis &amp; transformation</title><description>LLVM: A compilation framework for lifelong program analysis &amp; transformation

by Chris Lattner, Vikram Adve , 2004

"... , and an explicit dataflow representation (using an infinite, typed register set in Static Single Assignment form ..."

Abstract \- Cited by 421 (13 self) \- Add to MetaCart

... a compiler framework designed to support transparent, lifelong program analysis and transformation for arbitrary programs, by providing high-level information to compiler transformations at compile-time, link-time, run-time, and in idle time between runs. LLVM defines a common, low-level code representation in Static Single Assignment (SSA) form, with several novel features: a simple, language-independent type-system that exposes the primitives commonly used to implement high-level language features; an instruction for typed address arithmetic; and a simple mechanism that can be used to implement the exception handling features of high-level languages (and setjmp/longjmp in C) uniformly and efficiently. The LLVM compiler framework and code representation together provide a combination of key capabilities that are important for practical, lifelong analysis and transformation of programs. To our knowledge, no existing compilation approach provides all these capabilities. We describe the design of the LLVM representation and compiler framework, and evaluate the design in three ways: (a) the size and effectiveness of the representation, including the type information it provides; (b) compiler performance for several interprocedural problems; and (c) illustrative examples of the benefits LLVM provides for several challenging compiler problems.</description></snippet><snippet id="FW14-e004-7416-06"><link cache="FW14-topics-docs/e004/7416_06.html" timestamp="2014-04-19 20:07:09">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.120.6506&amp;rank=6</link><title>Proofs that Yield Nothing but Their Validity or All Languages in NP Have Zero-Knowledge Proof Systems</title><description>Proofs that Yield Nothing but Their Validity or All Languages in NP Have Zero-Knowledge Proof Systems

by Silvio Micali \- Journal of the ACM , 1991

"... for direct commercial advantage, the ACM copyright notice and the title of the publication and its date ..."

Abstract \- Cited by 377 (47 self) \- Add to MetaCart

Abstract. In this paper the generality and wide applicability of Zero-knowledge proofs, a notion introduced by Goldwasser, Micali, and Rackoff is demonstrated. These are probabilistic and interactive proofs that, for the members of a language, efficiently demonstrate membership in the language without conveying any additional knowledge. All previously known zero-knowledge proofs were only for number-theoretic languages in NP fl CONP. Under the assumption that secure encryption functions exist or by using “physical means for hiding information, ‘ ‘ it is shown that all languages in NP have zero-knowledge proofs. Loosely speaking, it is possible to demonstrate that a CNF formula is satisfiable without revealing any other property of the formula, in particular, without yielding neither a</description></snippet><snippet id="FW14-e004-7416-07"><link cache="FW14-topics-docs/e004/7416_07.html" timestamp="2014-04-19 20:08:00">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.299.2673&amp;rank=7</link><title>Observations on the dynamics of a congestion control algorithm: The effects of two-way traffic</title><description>Observations on the dynamics of a congestion control algorithm: The effects of two-way traffic

by Lixia Zhang, Scott Shenker, David D. Clark \- In Proceedings of ACM SIGCOMM , 1991

"... date appear, and notice is given that copying ia by permission of the Association for Computing ..."

Abstract \- Cited by 340 (6 self) \- Add to MetaCart

We use simulation to study the dynamics of the congestion cent rol algorithm embedded in the BSD 4.3-Tahoe TCP implementation. We investigate the simple case of a few TCP connections, originating and terminating at the same pair of hosts, using a single bottleneck link. This work is an extension of our earlier work ([16]), where one-way traffic (i.e., all of the sources are on the same host and all of the destinations are on the other host) was studied. In this paper we investigate the dynamics that results from two-way traffic (in which there are data sources on both hosts). We find that the one-way traffic clustering and loss-synchronization phenomena d~cussed in [16] persist in this new situation, albeit in a slightly modified form. In addition, there are two new phenomena not present in the earlier study: (1) ACK-compression, which is due to the interaction of data and ACK packets and gives rise to rapid fluctuations in queue length, and (2) an out-of-phase queue-synchronization mode, which keeps link utilization less than optimal even in the limit of very large buffers. These phenomena are helpful in understanding results from an earlier study of network oscillations ([19]). 1</description></snippet><snippet id="FW14-e004-7416-08"><link cache="FW14-topics-docs/e004/7416_08.html" timestamp="2014-04-19 20:08:53">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.217.1215&amp;rank=8</link><title>High performance messaging on workstations: Illinois Fast Messages (FM) for Myrinet</title><description>High performance messaging on workstations: Illinois Fast Messages (FM) for Myrinet

by Scott Pakin, Mario Lauria, Andrew Chien \- In Supercomputing , 1995

"... , to date the most common messaging layers used for clusters (TCP/IP [9], PVM [27]) generally have ..."

Abstract \- Cited by 292 (16 self) \- Add to MetaCart

In most computer systems, software overhead dominates the cost of messaging, reducing delivered performance, especially for short messages. Efficient software messaging layers are needed to deliver the hardware performance to the application level and to support tightly-coupled workstation clusters. Illinois Fast Messages (FM) 1.0 is a high speed messaging layer that delivers low latency and high bandwidth for short messages. For 128-byte packets, FM achieves bandwidths of 16.2 MB/s and one-way latencies 32 s on Myrinet-connected SPARCstations (user-level to user-level). For shorter packets, we have measured one-way latencies of 25 s, and for larger packets, bandwidth as high as to 19.6 MB/s — delivered bandwidth greater than OC-3. FM is also superior to the Myrinet API messaging layer, not just in terms of latency and usable bandwidth, but also in terms of the message half-power point (n 1 2 which is two orders of magnitude smaller (54 vs. 4,409 bytes). We describe the FM messaging primitives and the critical design issues in building a low-latency messaging layers for workstation clusters. Several issues are critical: the division of labor between host and network coprocessor, management of the input/output (I/O) bus, and buffer management. To achieve high performance, messaging layers should assign as much functionality as possible to the host. If the network interface has DMA capability, the I/O bus should be used asymmetrically, with</description></snippet><snippet id="FW14-e004-7416-09"><link cache="FW14-topics-docs/e004/7416_09.html" timestamp="2014-04-19 20:09:43">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.198.8918&amp;rank=9</link><title>A unified theory of underreaction, momentum trading and overreaction in asset markets</title><description>A unified theory of underreaction, momentum trading and overreaction in asset markets

by Harrison Hong, Jeremy C. Stein , 1999

"... develop a simple infinite-horizon model that captures these ideas. We begin in Section I by giving ..."

Abstract \- Cited by 285 (23 self) \- Add to MetaCart

We model a market populated by two groups of boundedly rational agents: “newswatchers” and “momentum traders.” Each newswatcher observes some private information, but fails to extract other newswatchers’ information from prices. If information diffuses gradually across the population, prices underreact in the short run. The underreaction means that the momentum traders can profit by trendchasing. However, if they can only implement simple (i.e., univariate) strategies, their attempts at arbitrage must inevitably lead to overreaction at long horizons. In addition to providing a unified account of under- and overreactions, the model generates several other distinctive implications.</description></snippet><snippet id="FW14-e004-7416-10"><link cache="FW14-topics-docs/e004/7416_10.html" timestamp="2014-04-19 20:10:40">http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=88CB446827C8E4AA1FEBAB64C0D36ED0?doi=10.1.1.48.4048&amp;rank=10</link><title>XSB as an Efficient Deductive Database Engine</title><description>XSB as an Efficient Deductive Database Engine

by Konstantinos Sagonas, Terrance Swift, David S. Warren \- In Proceedings of the ACM SIGMOD International Conference on the Management of Data , 1994

"... of that interpretation to avoid infinite loops and redundancy. In addition to its declarative language features, XSB ..."

Abstract \- Cited by 213 (31 self) \- Add to MetaCart

This paper describes the XSB system, and its use as an in-memory deductive database engine. XSB began from a Prolog foundation, and traditional Prolog systems are known to have serious deficiencies when used as database systems. Accordingly, XSB has a fundamental bottom-up extension, introduced through tabling (or memoing) [5], which makes it appropriate as an underlying query engine for deductive database systems. Because it eliminates redundant computation, the tabling extension makes XSB able to compute all modularly stratified datalog programs finitely and with polynomial data complexity. For non-stratified programs, a metainterpreter with the same properties is provided. In addition XSB significantly extends and improves the indexing capabilities over those of standard Prolog. Finally, its syntactic basis in HiLog [2], lends it flexibility for data modelling. The implementation of XSB derives from the WAM, the most common Prolog engine. XSB inherits the WAM's efficiency and can ta...</description></snippet></snippets></search_results>