<?xml version='1.0' encoding='UTF-8'?>
<search_results><query id="7152">haskell hash string</query><engine status="OK" timestamp="2014-04-19 23:51:35" name="CiteULike" id="FW14-e005"/><snippets><snippet id="FW14-e005-7152-01"><link cache="FW14-topics-docs/e005/7152_01.html" timestamp="2014-04-19 23:51:39">http://www.citeulike.org/user/mogwaing/article/4995243</link><title>Cache-Conscious Collision Resolution in String Hash Tables</title><description>In-memory hash tables provide fast access to large numbers of strings, with less space overhead than sorted structures such as tries and binary trees. If chains are used for collision resolution, hash tables scale well, particularly if the pattern of access to the stored strings is skew. However, typical implementations of string hash tables, with lists of nodes, are not cache-efficient. In this paper we explore two alternatives to the standard representation: the simple expedient of including the string in its ...</description></snippet><snippet id="FW14-e005-7152-02"><link cache="FW14-topics-docs/e005/7152_02.html" timestamp="2014-04-19 23:54:21">http://www.citeulike.org/user/gendobr/article/3089095</link><title>Optimal Exact String Matching Based on Suffix Arrays</title><description>Using the suffix tree of a string S, decision queries of the type Is P a substring of S? can be answered in O(|P|) time and enumeration queries of the type Where are all z occurrences of P in S? can be answered in O(|P|+z) time, totally independent of the size of S. However, in large scale applications as genome analysis, the space requirements of the suffix tree are a severe drawback. The suffix array is a ...</description></snippet><snippet id="FW14-e005-7152-03"><link cache="FW14-topics-docs/e005/7152_03.html" timestamp="2014-04-19 23:56:37">http://www.citeulike.org/user/montelatici/article/6767384</link><title>Typing Haskell in Haskell</title><description>Haskell benefits from a sophisticated type system, but implementors, programmers, and researchers suffer because it has no formal description. To remedy this shortcoming, we present a Haskell program that implements a Haskell typechecker, thus providing a mathematically rigorous specification in a notation that is familiar to Haskell users. We expect this program to fill a serious gap in current descriptions of Haskell, both as a starting point for discussions about existing features of the type system, and as a platform from ...</description></snippet><snippet id="FW14-e005-7152-04"><link cache="FW14-topics-docs/e005/7152_04.html" timestamp="2014-04-20 00:00:05">http://www.citeulike.org/user/jlxu/article/562838</link><title>Universal classes of hash functions</title><description>This paper gives an input independent average linear time algorithm for storage and retrieval on keys. The algorithm makes a random choice of hash function from a suitable class of hash functions. Given any sequence of inputs the expected time (averaging over all functions in the class) to store and retrieve elements is linear in the length of the sequence. The number of references to the data base required by the algorithm for any input is extremely close to the theoretical ...</description></snippet><snippet id="FW14-e005-7152-05"><link cache="FW14-topics-docs/e005/7152_05.html" timestamp="2014-04-20 00:01:01">http://www.citeulike.org/user/msakai/article/3578466</link><title>A recursive do for Haskell</title><description>Certain programs making use of monads need to perform recursion over the values of monadic actions. Although the do-notation of Haskell provides a convenient framework for monadic programming, it lacks the generality to support such recursive bindings. In this paper, we describe an enhanced translation schema for the donotation and its integration into Haskell. The new translation allows variables to be bound recursively, provided the underlying monad comes equipped with an appropriate fixed-point operator. ...</description></snippet><snippet id="FW14-e005-7152-06"><link cache="FW14-topics-docs/e005/7152_06.html" timestamp="2014-04-20 00:03:09">http://www.citeulike.org/user/montelatici/article/3211</link><title>Template meta-programming for Haskell</title><description>We propose a new extension to the purely functional programming language Haskell that supports compile-time meta-programming. The purpose of the system is to support the algorithmic construction of programs at compile-time.The ability to generate code at compile time allows the programmer to implement such features as polytypic programs, macro-like expansion, user directed optimization (such as inlining), and the generation of supporting data structures and functions from existing data structures and functions.Our design is being implemented in the ...</description></snippet><snippet id="FW14-e005-7152-07"><link cache="FW14-topics-docs/e005/7152_07.html" timestamp="2014-04-20 00:05:37">http://www.citeulike.org/user/benchambers/article/342280</link><title>Haskell on a shared-memory multiprocessor</title><description>Multi-core processors are coming, and we need ways to program them. The combination of purely-functional programming and explicit, monadic threads, communicating using transactional memory, looks like a particularly promising way to do so. This paper describes a full-scale implementation of shared-memory parallel Haskell, based on the Glasgow Haskell Compiler. Our main technical contribution is a lock-free mechanism for evaluating shared thunks that eliminates the major performance bottleneck in parallel evaluation of a lazy language. Our results are preliminary but promising: we ...</description></snippet><snippet id="FW14-e005-7152-08"><link cache="FW14-topics-docs/e005/7152_08.html" timestamp="2014-04-20 00:09:44">http://www.citeulike.org/group/504/article/342273</link><title>Haskell ready to dazzle the real world</title><description>Haskell has proved itself to be a suitable implementation language for large software projects. Nevertheless, surprisingly few graphical end-user applications have been written in Haskell. Based on our experience with the development of the Bayesian network toolbox Dazzle, we argue that the language is indeed very well suited for writing such applications. Popular language features, such as higher-order functions, laziness, and light syntax for data structures, turn out to hold their ground in a large interactive end-user application. Haskell, combined with ...</description></snippet><snippet id="FW14-e005-7152-09"><link cache="FW14-topics-docs/e005/7152_09.html" timestamp="2014-04-20 00:14:17">http://www.citeulike.org/user/msakai/article/342271</link><title>Darcs: distributed version management in Haskell</title><description>A common reaction from people who hear about darcs, the source control system I created, is that it sounds like a great tool, but it is a shame that it is written in Haskell. People think that because darcs is written in Haskell it will be a slow memory hog with very few contributors to the project. I will give a somewhat historical overview of my experiences with the Haskell language, libraries and tools.I will begin with a brief overview of ...</description></snippet><snippet id="FW14-e005-7152-10"><link cache="FW14-topics-docs/e005/7152_10.html" timestamp="2014-04-20 00:16:18">http://www.citeulike.org/user/RamuAnandakrishnan/article/332196</link><title>Eager Haskell: resource-bounded execution yields efficient iteration</title><description>The advantages of the Haskell programming language are rooted in its clean equational semantics. Those advantages evaporate as soon as programmers try to write simple iterative computations and discover that their code must be annotated with calls to seq in order to overcome space leaks introduced by lazy evaluation. The Eager Haskell compiler executes Haskell programs eagerly by default, i.e. , bindings and function arguments are evaluated before bodies. When resource bounds are exceeded, computation falls back and ...</description></snippet></snippets></search_results>