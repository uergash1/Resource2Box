id	content
GX016-50-3666937	"Dataplot                                                              Vol 1                                                              Auxillary Chapter                                         SVG     Name:            SVG          Type:            Output Device Command          Purpose:            Create SVG (Scalable Vector Graphics) format graphics files.          Description:            The ability to generate graphics for web based applications is     increasingly important.  The three most common formats for     web applications are:                        GIF          JPEG          PNG (Portable Network Graphics)                   Note that these are all bit mapped formats.            SVG (Scalable Vector Graphics) is an emerging graphics     format for web applications.  SVG is an XML (extensible     markup language) based format.  Note that XML is a meta     markup language, that is it is a langauge for defining      languages.  SVG is one specific implementation of an     XML language.  This is analogous to HTML being a specific     implementation of a SGML (Standard Generalized Markup     Language) language.  SVG is expected to develop into an     important format over the next several years.            SVG is a relatively new standard (as of 3/2002) and not     all browsers will support it.  Adobe provides a freely     downloadable plugin for Netscape and Internet Explorer on the     PC and Mac OSX.  Search for the ""SVG Viewer"" on the Adobe     web site (http://www.adobe.com).  Also, there are several     SVG viewers/browsers (e.g., XSMILES) under development.     Support for SVG graphics in web pages should grow rapidly     in the next few years.            SVG is a vector based rather than a bitmap based protocol.     Also, SVG is an ASCII file that contains a textual     description of the graph.  One of the primary advantages     of this approach is that web graphics can be easily edited     much the way the HTML files can be edited.  This can make     the maintenance of the graphics on a web site easier.            In addition to web applications, it is expected that     SVG will be supported by many graphics editing programs     (e.g., Photoshop, Corel Draw).         Syntax 1:            SVG            This form designates device 1 as an SVG graphics device,     which results in the SVG output being written to the     screen.  This syntax is not partiucularly useful since the     SVG needs to be saved in a file so that an external SVG viewer     can read it.          Syntax 2:            DEVICE <1/2/3> SVG            This form designates one of DATAPLOT's 3 devices (typically     device 2) as an SVG device.          Examples:            DEVICE 2 SVG       DEVICE 3 SVG            Note:            For SVG, it is often desirable to put each plot in a     separate file with a unique name.  This can     be accomplished with a sequence of commands like the following:                      SET IPL1NA  PLOT1.SVG           DEVICE 2 SVG              generate first plot           DEVICE 2 CLOSE           SET IPL1NA  PLOT2.SVG           DEVICE 2 SVG              generate second plot           DEVICE 2 CLOSE                    The SET IPL1NA command specifies the name of the file.  Note     that this name is currently converted to upper case.     This command should come before the DEVICE 2 SVG command.          Note:            The default image size is 600 pixels by 450 pixels.  You     can change the default size of the image by using the     DEVICE ... PICTURE POINTS command.  For example,                      SET IPL1NA  PLOT1.SVG           DEVICE 2 SVG           DEVICE 2 PICTURE POINTS  300 300              generate first plot           DEVICE 2 CLOSE                  Note:            Style sheets allow easier maintenance/editing by specifying     default attributes in an external style sheet file.  The     default Dataplot style sheet is ""dataplot.css"" and it is     stored in the Dataplot ""HELP"" sub-directory.           Currently, Dataplot supports the following class for     the background (this only sets the color, not the size):                     rect.background                  Currently, Dataplot supports the following classes for     lines:                     polyline.narrow-solid          polyline.medium-solid          polyline.wide-solid          polyline.extrawide-solid          polyline.narrow-dotted          polyline.medium-dotted          polyline.wide-dotted          polyline.extrawide-dotted          polyline.narrow-dash          polyline.medium-dash          polyline.wide-dash          polyline.extrawide-dash          polyline.narrow-dash2          polyline.medium-dash2          polyline.wide-dash2          polyline.extrawide-dash2          polyline.narrow-dash3          polyline.medium-dash3          polyline.wide-dash3          polyline.extrawide-dash3          polyline.narrow-dash4          polyline.medium-dash4          polyline.wide-dash4          polyline.extrawide-dash4          polyline.narrow-dash5          polyline.medium-dash5          polyline.wide-dash5          polyline.extrawide-dash5                    Currently, Dataplot supports the following classes for     text:                     text.left-horizontal          text.center-horizontal          text.right-horizontal                    Currently, no classes are supported for region fills.           As we develop more experience with SVG graphics, we may     expand the supported classes.           When using external style sheets, you modify the attributes     of the clases.  However, you do not edit which classes are     available (Dataplot generates the SVG file based on the above     classes.           Dataplot will check the value of certain attributes     (color for lines, color and size for text) when generating     the SVG file.  If these are not the default values, then     a local ""style"" option will be added for that element     to override the value in the style sheet.           To make your own style sheets, simply copy the default     file ""dataplot.css"" to a new file name and then edit that     file.  Use the SET SVG STYLE SHEET NAME command (see below)     to specify the location of the style sheet you wish to use     (this should be the location of the style sheet relative to     the location of the SVG file on your web pages).         Note:            The following SET commands apply to the SVG output.                     SET SVG COORDINATE SYSTEM  <PIXEL/PERCENT>            - specify whether coordinates are specified in              pixel units or percent untis.  Currently, only              pixel units are supported.  The PERCENT option is              reserved for possible future implementation.                      SET SVG FONT NAME <SERIF/SANS/MONOSPACE>            - specify the font name for hardware characters.              Generic names (i.e., supported on all SVG viewers)              are: serif, sans-serif, and monospace.  Specific              font names (e.g., arial) depend on what fonts are              installed on your local system.  Currently, only              the generic fonts are supported.  For specific              fonts, use style sheets and set the name in the              style sheet.  The default is sans-serif.         SET SVG FONT WEIGHT <NORMAL/BOLD>            - specify whether text is drawn as bold or normal.              The default is bold.         SET SVG FONT STYLE <NORMAL/ITALIC>            - specify whether text is drawn in an italic style              or a normal style.  The default is normal.                       SET SVG CAP STYLE <BUTT/ROUND/SQUARE/NONE>            - specify the cap style for line drawing.  The default              is butt.          SET SVG JOIN STYLE <MITER/ROUND/BEVEL/NONE>            - specify the join style for line draweing.  The default              is miter.                       SET SVG HARDWARE FILL SWITCH <NONZERO/EVENODD/SOFTWARE>            - by default, region fills are performed in hardware              using a ""non-zero"" rule.  You can also specify              that an ""evenodd"" rule be used.  In general, using              hardware region fill will have better performance.              However, hardware fills can occassionally have              unpredictable results.  In this case, you can              have Dataplot perform region fills in software              by specifing SOFTWARE.                       SET SVG STYLE SHEET <INTERNAL/EXTERNAL/NONE>            - specify whether the SVG graphics are generated              using style sheets (EXTERNAL) or not (NONE).  In              general, style sheets are most beneficial when              multiple graphics are being used on a web site.              SVG supports both external style sheets (i.e.,              stored in a separate file) or internal to the              SVG file.  Currently, Dataplot only supports              external style sheets.  The INTERNAL switch is              reserved for possible future implementation.              There is also an EXTERNAL USE and an EXTERNAL              CREATE option.  This is reserved for future use,              but it currently has no effect.          SET SVG STYLE SHEET NAME <file name>            - specify the name of the external file sheet              (up to 80 characters).  The default name is              ""dataplot.css"".          SET SVG FOREGROUND COLOR <color>            - specify the default foreground color when style              sheets are being used.  If a line or text color              does not match this foreground color, then Dataplot              inserts a ""style"" option that overrides the style              sheet value.  Note that the default color is              set independently in the style sheet file.  So              you may need to edit the style sheet as well.              Note:            Each ""page"" is assigned an ID using the "" "" element.     You can add your own translate, scale, and rotate options     to the SVG file to transform the full plot (this is an element     of the ""Scalable"" part of Scalable Vector Graphics).          Note:            Currently, Dataplot generates static plots in SVG format.     SVG supports advanced capabilities such as animation,     gradients, and Javascript scripting.  Support for at least     some of these capabilities may be added in future     implementations.  However, you can edit the SVG file     (either via an ASCII text editor or a graphics editing     program) to add such capabilities.          Default:            None          Synonyms:            None          Device Notes:               HARDWARE TEXT - The SVG device currently supports            hardware characters.  Available fonts may depend on what            fonts you have supported on your system.         COLOR - SVG supports the full range of 88 colors supported            by Dataplot.         HARDWARE FILL - Solid area fills are done in hardware.  You            can override this to generate them in software.         DASH PATTERNS - The following dash patterns are available:                            DASH  - 3 pixels on, 3 pixels off;                 DOT   - 1 pixel on, 1 pixels off;                 DASH2 - 9 pixels on, 5 pixels off                 DASH3 - 5 pixels on, 3 pixels off,                       9 pixel on, 2 pixel off;                  DASH4 - 9 pixels on, 3 pixels off,                       5 pixel on, 9 pixel off,                        3 pixel on, 5 pixel off;                  DASH5 - 5 pixels on, 2 pixels off;                         If you want to modify these patterns, it is recommended            that you use external style sheets.         LINE WIDTH - Thick lines are generated in hardware.         GRAPHICS INPUT - The CROSS-HAIR command is not supported            for this device.         The CHARACTER PIXEL option is supported on this device.         Related Commands:                                                   GD PNG/JPEG                                        = Direct graphical output to a file in PNG/JPEG format.                                                            POSTSCRIPT                                        = Direct graphical output to a Postscript device.                                                            HPGL                                        = Direct graphical output to an HPGL device.                                                            DEVICE                                        = Specify certain actions for the graphics output.                                        Applications:            Web Applications, Graphics Import Into Graphics Editing     Programs          Reference:            ""SVG Essentials"", David Eisenberg, O'Reilly, 2002.           ""Designing SVG Web Graphics"", Andrew Watt, New Riders, 2002.          Implementation Date:            2002/3          Program:            SET IPL1NA PLOT1.SVG       DEVICE 2 SVG      DEVICE 2 PICTURE POINTS 400 300       TITLE SAMPLE SVG PLOT       PLOT X**2 FOR X = 1 1 9       DEVICE 2 CLOSE       SET IPL1NA PLOT2.SVG       DEVICE 2 SVG       DEVICE 2 PICTURE POINTS 500 400       TITLE SECOND SAMPLE SVG PLOT       PLOT X**3 FOR X = 1 1 9       DEVICE 2 CLOSE                                                        Date created: 3/27/2002         Last updated: 4/4/2003         Please email comments on this WWW page to         alan.heckert@nist.gov ."
GX031-88-3550026	Next:   2 64  -2 10  + 1    Up:   Random Number Generators    Previous:   48-bit CRI Linear Congruential                61-bit Prime Modulus Linear Congruential Generator      This algorithm is slower than the generators using a power of two modulus, but produces a random number sequence free of short period patterns in the low order bits. A pattern does occur for this generator, however, and is described in [ 5 ]. The next value for the random state   x [ n ] is determined from the current value  x [ n  - 1] by:             x [ n ] =  a   x [ n  - 1]   ( mod p )     (6)      Where the multiplier,    a  = 437799614237992725, is hardwired into the algorithm and   p  is a Mersenne prime; that is, a prime that is of the form    p  = 2 m  - 1 where  m  is also a prime. For this generator  m  = 61, which is the largest value of m less than 64 for which 2 m  - 1 and  m  are primes.  The multiplier was again chosen to obtain maximal period of the generator,   2 61  -2   2.3  x  10 18 , for this algorithm.  This generator is the same as the default one-stream SPRNG pmlcg generator and was checked to insure that it satisfies the requirements for maximal period. The interface routines for this generator are declared as:  Rng_Type RngP61Seed( Rng_UInt32 i, Rng_UInt32 j );      Rng_Type RngP61Spawn( Rng_Type *x );      int iRngP61( Rng_Type *x );      double dRngP61( Rng_Type *x );      float fRngP61( Rng_Type *x );                                Next:   2 64  -2 10  + 1    Up:   Random Number Generators    Previous:   48-bit CRI Linear Congruential
GX019-81-13588789	"APREPRO Predefined Variables                               A few commonly used variables are predefined in           APREPRO . These are listed below. The default output format is specified          as a C language format string, see your C language documentation for more          information. The default format and comment variables are defined with          a leading underscore in their name so they can be redefined without generating          an error message.                                                              Predefined Variables                                    Name                       Value                       Description                                PI                       3.14159265358979323846                       p                                PI_2                       1.57079632679489661923                       p/2                                SQRT2                       1.41421356237309504880                                                      DEG                       57.2957795130823208768                       180  / p            degrees per radian                                RAD                       0.01745329251994329576                       p/180  radians          per degree                                E                       2.71828182845904523536                       base of natural logarithm                                GAMMA                       0.57721566490153286060                       euler-mascheroni constant 1                                PHI                       1.61803398874989484820                       golden ratio ( +          1)/2                                VERSION                       Varies, string value                       current version of CUBIT                                _ FORMAT                       ""%.10g""                       default output format                                _C_                       ""#""                       default comment character                                                                                   1 The euler-mascheroni constant is defined          as the limit of 1 + 1/2 + ... + 1/s - log(s) as s approaches infinity.                                                              Note that the output format is used to output          both integers and floating point numbers. Therefore, it should use the          %g format descriptor which will use either the decimal (%d), exponential          (%e), or float (%f) format, whichever is shorter, with insignificant zeros          suppressed. The table below illustrates the effect of different format          specifications on the output of the variable  PI  and the value 1.0          . See the documentation of your C compiler for more information. For most          cases, the default value is sufficient.                                                              Effect of Various Output Format          Specifications                                    Format                       PI Output                       1.0 Output                                %.10g                       3.141592654                       1                                %.10e                       3.1415926536e+00                       1.0000000000e+00                                %.10f                       3.1415926536                       1.0000000000                                %.10d                       1413754136                       0000000000                                                                                                            The comment character should be set to the character          that the program which will read the processed file uses as a comment          character. The default value of ""$"" is the comment character used by the          SEACAS codes at Sandia National Laboratories. The  -c  command line          option * automatically changes the value of the comment variable to match          the character specified on the command line."
GX029-87-4684231	"[   source navigation   ]   [   identifier search   ]   [   freetext search   ]   [   file search   ]   [   repository   ]         Software     Cross Reference            . / usatlas / fisyak / root.removed / postscript / src / TSVG.cxx             Version:      [   current   ]           File /home/lxr/source/current//usatlas/fisyak/root.removed/postscript/src/TSVG.cxx     1   // @(#)root/postscript:$Name:  $:$Id: TSVG.cxx,v 1.1.1.5 2003/01/20 18:13:15 fisyak Exp $     2   // Author: Olivier Couet     3       4   /*************************************************************************     5    * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *     6    * All rights reserved.                                                  *     7    *                                                                       *     8    * For the licensing terms see $ROOTSYS/LICENSE.                         *     9    * For the list of contributors see $ROOTSYS/README/CREDITS.             *    10    *************************************************************************/    11     12   //////////////////////////////////////////////////////////////////////////    13   //                                                                      //    14   // TSVG                                                                 //    15   //                                                                      //    16   // Graphics interface to SVG.                                           //    17   //                                                                      //    18   //////////////////////////////////////////////////////////////////////////    19      20  #ifdef  WIN32    21  #pragma  optimize ( """" ,off)   22  #endif   23     24  #include  <stdlib.h>> >   25  #include  <string.h>> >   26  #include  <ctype.h>> >   27     28  #include "" Riostream.h ""   29  #include "" TROOT.h ""   30  #include "" TColor.h ""   31  #include "" TVirtualPad.h ""   32  #include "" TPoints.h ""   33  #include "" TSVG.h ""   34  #include "" TStyle.h ""   35  #include "" TMath.h ""   36     37   ClassImp ( TSVG )   38     39   //______________________________________________________________________________    40   //Begin_Html    41   /*    42   <a href="" http://www.w3.org/Graphics/SVG/Overview.htm8""><b>SVG</b></a>  is a    43   language for describing two-dimensional graphics in XML. <b>SVG</b> allows for    44   three types of graphic objects: vector graphic shapes, images and text.    45   Graphical objects can be grouped, styled, transformed and composed into    46   previously rendered objects. The feature set includes nested transformations,    47   clipping paths, alpha masks, filter effects and template objects. <b>SVG</b>    48   drawings can be interactive and dynamic. Animations can be defined and    49   triggered either declaratively or via scripting.    50   <p>    51   The way to access <b>SVG</b> in <b>ROOT</b> (in my private version only) is the    52   following:    53   <PRE>    54      <A HREF=""html/TSVG.html"">TSVG</A> mysvg(&quot;myfile.svg&quot;)    55      object-&gt;Draw();    56      mysvg.Close();    57   </PRE>    58   The result is the ASCII file <tt>myfile.svg</tt>, it is best viewed with    59   Internet Explorer and you need the    60   <a href="" http://www.adobe.com/svg/viewer/install/main.html"">Adobe  <b>SVG</b>    61   Viewer</a>. To zoom using the Adobe <b>SVG</b> Viewer, position the mouse over    62   the area you want to zoom and click the right button. To define the zoom area,    63   use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.    64   By clicking with the right mouse button on the <b>SVG</b> graphics you will get    65   a pop-up menu giving other ways to interact with the image.    66   <p>    67   <b>SVG</b> files can be used directly in compressed mode to minimize the time    68   transfer over the network. Compressed <b>SVG</b> files should be created using    69   <tt>gzip</tt> on a normal ASCII <b>SVG</b> file and should then be renamed    70   using the file extension <tt>.svgz</tt>.    71   */    72   //End_Html    73      74   //______________________________________________________________________________    75   TSVG :: TSVG () :  TVirtualPS ()   76  {   77      // Default SVG constructor    78      79     fStream = 0;   80     fType   = 0;   81      gVirtualPS  =  this ;   82  }   83     84   //______________________________________________________________________________    85   TSVG :: TSVG ( const   char  * fname ,  Int_t  wtype) :  TVirtualPS ( fname , wtype)   86  {   87      // Initialize the SVG interface    88       //    89       //  fname : SVG file name    90       //  wtype : SVG workstation type. Not used in the SVG driver. But as TSVG    91       //          inherits from TVirtualPS it should be kept. Anyway it is not    92       //          necessary to specify this parameter at creation time because it    93       //          has a default value (which is ignore in the SVG case).    94      95     fStream = 0;   96      Open ( fname , wtype);   97  }   98     99   //______________________________________________________________________________   100   void   TSVG :: Open ( const   char  * fname ,  Int_t  wtype)  101  {  102      // Open a SVG file   103     104      if  (fStream) {  105         Warning ( ""Open"" ,  ""SVG file already open"" );  106         return ;  107     }  108    109     fType =  abs (wtype);  110     SetLineScale( gStyle ->GetLineScalePS());  111      gStyle -> GetPaperSize (fXsize, fYsize);  112      Float_t  xrange, yrange;  113      if  ( gPad ) {  114         Double_t  ww =  gPad -> GetWw ();  115         Double_t  wh =  gPad -> GetWh ();  116        ww *=  gPad ->GetWNDC();  117        wh *=  gPad ->GetHNDC();  118         Double_t   ratio  = wh/ww;  119        xrange = fXsize;  120        yrange = fXsize* ratio ;  121         if  (yrange > fYsize) { yrange = fYsize; xrange = yrange/ ratio ;}  122        fXsize = xrange; fYsize = yrange;  123     }  124    125      // Open OS file   126      fStream   =  new   ofstream ( fname , ios :: out );  127      if  (fStream == 0) {  128         printf ( ""ERROR in TSVG::Open: Cannot open file:%s\n"" , fname );  129         return ;  130     }  131    132      gVirtualPS  =  this ;  133    134      for  ( Int_t  i=0;i<512;i++) fBuffer[i] =  ' ' ;  135    136     fBoundingBox =  kFALSE ;  137    138     fRange       =  kFALSE ;  139    140      // Set a default range   141       Range (fXsize, fYsize);  142    143      NewPage ();  144  }  145    146   //______________________________________________________________________________   147   TSVG :: ~TSVG ()  148  {  149      // Default SVG destructor   150     151      Close ();  152  }  153    154   //______________________________________________________________________________   155   void   TSVG :: Close ( Option_t  *)  156  {  157      // Close a SVG file   158       if  (! gVirtualPS )  return ;  159      if  (!fStream)  return ;  160      if  ( gPad )  gPad -> Update ();  161      PrintStr ( ""</svg>@"" );  162    163      // Close file stream   164       if  (fStream) { fStream-> close ();  delete  fStream; fStream = 0;}  165    166      gVirtualPS  = 0;  167  }  168    169   //______________________________________________________________________________   170   void   TSVG ::On()  171  {  172      // Activate an already open SVG file   173     174      // fType is used to know if the SVG file is open. Unlike TPostScript, TSVG   175       // has no ""workstation type"". In fact there is only one SVG type.   176     177      if  (!fType) {  178         Error ( ""On"" ,  ""no SVG file open"" );  179         Off ();  180         return ;  181     }  182      gVirtualPS  =  this ;  183  }  184    185   //______________________________________________________________________________   186   void   TSVG :: Off ()  187  {  188      // Deactivate an already open SVG file   189     190      gVirtualPS  = 0;  191  }  192    193   //______________________________________________________________________________   194   void   TSVG :: DrawBox ( Double_t  x1,  Double_t  y1,  Double_t  x2,  Double_t   y2)  195  {  196      // Draw a Box   197     198      static   Double_t  x[4], y[4];  199      Int_t   ix1  =  XtoSVG (x1);  200      Int_t   ix2  =  XtoSVG (x2);  201      Int_t   iy1  =  YtoSVG (y1);  202      Int_t   iy2  =  YtoSVG (y2);  203      Int_t  fillis = fFillStyle/1000;  204      Int_t  fillsi = fFillStyle%1000;  205    206      if  (fillis == 3 || fillis == 2) {  207         if  (fillsi > 99) {  208           x[0] = x1;   y[0] = y1;  209           x[1] = x2;   y[1] = y1;  210           x[2] = x2;   y[2] = y2;  211           x[3] = x1;   y[3] = y2;  212            return ;  213        }  214         if  (fillsi > 0 && fillsi < 26) {  215           x[0] = x1;   y[0] = y1;  216           x[1] = x2;   y[1] = y1;  217           x[2] = x2;   y[2] = y2;  218           x[3] = x1;   y[3] = y2;  219            DrawPS (-4, &x[0], &y[0]);  220        }  221         if  (fillsi == -3) {  222            PrintFast (9, ""<rect x=\"""" );  223            WriteInteger ( ix1 , 0);  224            PrintFast (5, ""\"" y=\"""" );  225            WriteInteger ( iy2 , 0);  226            PrintFast (9, ""\"" width=\"""" );  227            WriteInteger ( ix2 - ix1 , 0);  228            PrintFast (10, ""\"" height=\"""" );  229            WriteInteger ( iy1 - iy2 , 0);  230            PrintFast (7, ""\"" fill="" );  231            SetColor (5);  232            PrintFast (2, ""/>"" );  233        }  234     }  235      if  (fillis == 1) {  236         PrintFast (9, ""<rect x=\"""" );  237         WriteInteger ( ix1 , 0);  238         PrintFast (5, ""\"" y=\"""" );  239         WriteInteger ( iy2 , 0);  240         PrintFast (9, ""\"" width=\"""" );  241         WriteInteger ( ix2 - ix1 , 0);  242         PrintFast (10, ""\"" height=\"""" );  243         WriteInteger ( iy1 - iy2 , 0);  244         PrintFast (7, ""\"" fill="" );  245         SetColor (fFillColor);  246         PrintFast (2, ""/>"" );  247     }  248      if  (fillis == 0) {  249         PrintFast (9, ""<rect x=\"""" );  250         WriteInteger ( ix1 , 0);  251         PrintFast (5, ""\"" y=\"""" );  252         WriteInteger ( iy2 , 0);  253         PrintFast (9, ""\"" width=\"""" );  254         WriteInteger ( ix2 - ix1 , 0);  255         PrintFast (10, ""\"" height=\"""" );  256         WriteInteger ( iy1 - iy2 , 0);  257         PrintFast (21, ""\"" fill=\""none\"" stroke="" );  258         SetColor (fLineColor);  259         PrintFast (2, ""/>"" );  260     }  261  }  262    263   //______________________________________________________________________________   264   void   TSVG :: DrawFrame ( Double_t  xl,  Double_t  yl,  Double_t  xt,  Double_t   yt,  265                               Int_t   mode ,  Int_t   border ,  Int_t  dark,  Int_t  light)  266  {  267      // Draw a Frame around a box   268       //   269       // mode = -1  the box looks as it is behind the screen   270       // mode =  1  the box looks as it is in front of the screen   271       // border is the border size in already pre-computed SVG units dark is the   272       // color for the dark part of the frame light is the color for the light   273       // part of the frame   274     275      static   Int_t  xps[7], yps[7];  276      Int_t  i, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  277    278      //- Draw top&left part of the box   279     280     xps[0] =  XtoSVG (xl);          yps[0] =  YtoSVG (yl);  281     xps[1] = xps[0] +  border ;     yps[1] = yps[0] -  border ;  282     xps[2] = xps[1];              yps[2] =  YtoSVG (yt) +  border ;  283     xps[3] =  XtoSVG (xt) -  border ; yps[3] = yps[2];  284     xps[4] =  XtoSVG (xt);          yps[4] =  YtoSVG (yt);  285     xps[5] = xps[0];              yps[5] = yps[4];  286     xps[6] = xps[0];              yps[6] = yps[0];  287    288     ixd0 = xps[0];  289     iyd0 = yps[0];  290      PrintFast (10, ""<path d=\""M"" );  291      WriteInteger (ixd0, 0);  292      PrintFast (1, "","" );  293      WriteInteger (iyd0, 0);  294    295      idx  = 0;  296     idy = 0;  297      for  (i=1; i<7; i++) {  298        ixdi = xps[i];  299        iydi = yps[i];  300        ix   = ixdi - ixd0;  301        iy   = iydi - iyd0;  302        ixd0 = ixdi;  303        iyd0 = iydi;  304         if ( ix && iy) {  305            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  306            if ( idy ) {  MovePS (0,idy); idy = 0; }  307            MovePS (ix,iy);  308            continue ;  309        }  310         if  ( ix ) {  311            if ( idy )  {  MovePS (0,idy); idy = 0; }  312            if ( ! idx  ) {  idx  = ix;  continue ;}  313            if ( ix* idx  > 0 ) {  314               idx  += ix;  315           }  else  {  316               MovePS ( idx ,0);  317               idx   = ix;  318           }  319            continue ;  320        }  321         if ( iy ) {  322            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  323            if ( !idy) { idy = iy;  continue ;}  324            if ( iy*idy > 0 ) {  325              idy += iy;  326           }  else  {  327               MovePS (0,idy);  328              idy  = iy;  329           }  330        }  331     }  332      if (  idx  )  MovePS ( idx ,0);  333      if ( idy )  MovePS (0,idy);  334      PrintFast (8, ""z\"" fill="" );  335      if  ( mode  == -1) {  336         SetColor (dark);  337     }  else  {  338         SetColor (light);  339     }  340      PrintFast (2, ""/>"" );  341    342      //- Draw bottom&right part of the box   343      xps[0] =  XtoSVG (xl);          yps[0] =  YtoSVG (yl);  344     xps[1] = xps[0] +  border ;     yps[1] = yps[0] -  border ;  345     xps[2] =  XtoSVG (xt) -  border ; yps[2] = yps[1];  346     xps[3] = xps[2];              yps[3] =  YtoSVG (yt) +  border ;  347     xps[4] =  XtoSVG (xt);          yps[4] =  YtoSVG (yt);  348     xps[5] = xps[4];              yps[5] = yps[0];  349     xps[6] = xps[0];              yps[6] = yps[0];  350    351     ixd0 = xps[0];  352     iyd0 = yps[0];  353      PrintFast (10, ""<path d=\""M"" );  354      WriteInteger (ixd0, 0);  355      PrintFast (1, "","" );  356      WriteInteger (iyd0, 0);  357    358      idx  = 0;  359     idy = 0;  360      for  (i=1;i<7;i++) {  361        ixdi = xps[i];  362        iydi = yps[i];  363        ix   = ixdi - ixd0;  364        iy   = iydi - iyd0;  365        ixd0 = ixdi;  366        iyd0 = iydi;  367         if ( ix && iy) {  368            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  369            if ( idy ) {  MovePS (0,idy); idy = 0; }  370            MovePS (ix,iy);  371            continue ;  372        }  373         if  ( ix ) {  374            if ( idy )  {  MovePS (0,idy); idy = 0; }  375            if ( ! idx  ) {  idx  = ix;  continue ;}  376            if ( ix* idx  > 0 ) {  377               idx  += ix;  378           }  else  {  379               MovePS ( idx ,0);  380               idx   = ix;  381           }  382            continue ;  383        }  384         if ( iy ) {  385            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  386            if ( !idy) { idy = iy;  continue ;}  387            if ( iy*idy > 0 ) {  388              idy += iy;  389           }  else  {  390               MovePS (0,idy);  391              idy  = iy;  392           }  393        }  394     }  395      if (  idx  )  MovePS ( idx ,0);  396      if ( idy )  MovePS (0,idy);  397      PrintFast (8, ""z\"" fill="" );  398      if  ( mode  == -1) {  399         SetColor (light);  400     }  else  {  401         SetColor (dark);  402     }  403      PrintFast (2, ""/>"" );  404  }  405    406   //______________________________________________________________________________   407   void   TSVG :: DrawPolyLine ( Int_t  nn,  TPoints  *xy)  408  {  409      // Draw a PolyLine   410       //   411       //  Draw a polyline through  the points  xy.   412       //  If NN=1 moves only to point x,y.   413       //  If NN=0 the x,y are  written  in the SVG        file   414       //     according to the current transformation.   415       //  If NN>0 the line is clipped as a line.   416       //  If NN<0 the line is clipped as a fill area.   417     418      Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  419    420      if  (nn > 0) {  421        n = nn;  422   ///     SetLineStyle(fLineStyle);   423   ///     SetLineWidth(fLineWidth);   424   ///     SetColor(Int_t(fLineColor));   425      }  else  {  426        n = -nn;  427   ///     SetLineStyle(1);   428   ///     SetLineWidth(1);   429   ///     SetColor(Int_t(fLineColor));   430      }  431    432     ixd0 =  XtoSVG (xy[0]. GetX ());  433     iyd0 =  YtoSVG (xy[0]. GetY ());  434   ///  WriteInteger(ixd0);   435   ///  WriteInteger(iyd0);   436       if ( n <= 1) {  437         if ( n == 0)  return ;  438   ///     PrintFast(2,"" m"");   439          return ;  440     }  441    442      PrintFast (2, "" m"" );  443      idx  = 0;  444     idy = 0;  445      for  ( Int_t  i=1;i<n;i++) {  446        ixdi =  XtoSVG (xy[i]. GetX ());  447        iydi =  YtoSVG (xy[i]. GetY ());  448        ix   = ixdi - ixd0;  449        iy   = iydi - iyd0;  450        ixd0 = ixdi;  451        iyd0 = iydi;  452         if ( ix && iy) {  453            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  454            if ( idy ) {  MovePS (0,idy); idy = 0; }  455            MovePS (ix,iy);  456            continue ;  457        }  458         if  ( ix ) {  459            if ( idy )  {  MovePS (0,idy); idy = 0; }  460            if ( ! idx  ) {  idx  = ix;  continue ;}  461            if ( ix* idx  > 0 ) {  462               idx  += ix;  463           }  else  {  464               MovePS ( idx ,0);  465               idx   = ix;  466           }  467            continue ;  468        }  469         if ( iy ) {  470            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  471            if ( !idy) { idy = iy;  continue ;}  472            if ( iy*idy > 0 ) {  473              idy += iy;  474           }  else  {  475               MovePS (0,idy);  476              idy  = iy;  477           }  478        }  479     }  480      if (  idx  )  MovePS ( idx ,0);  481      if ( idy )  MovePS (0,idy);  482    483      if  (nn > 0 ) {  484   ///     if (xy[0].GetX() == xy[n-1].GetX() && xy[0].GetY() == xy[n-1].GetY()) PrintFast(3,"" cl"");   485   ///     PrintFast(2,"" s"");   486      }  else  {  487   ///     PrintFast(2,"" f"");   488      }  489  }  490    491   //______________________________________________________________________________   492   void   TSVG :: DrawPolyLineNDC ( Int_t  nn,  TPoints  *xy)  493  {  494      // Draw a PolyLine in NDC space   495       //   496       //  Draw a polyline through  the points  xy.   497       //  If NN=1 moves only to point x,y.   498       //  If NN=0 the x,y are  written  in the SVG        file   499       //     according to the current transformation.   500       //  If NN>0 the line is clipped as a line.   501       //  If NN<0 the line is clipped as a fill area.   502     503      Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  504    505      if  (nn > 0) {  506        n = nn;  507   ///     SetLineStyle(fLineStyle);   508   ///     SetLineWidth(fLineWidth);   509   ///     SetColor(Int_t(fLineColor));   510      }  else  {  511        n = -nn;  512   ///     SetLineStyle(1);   513   ///     SetLineWidth(1);   514   ///     SetColor(Int_t(fLineColor));   515      }  516    517     ixd0 =  UtoSVG (xy[0]. GetX ());  518     iyd0 =  VtoSVG (xy[0]. GetY ());  519   ///  WriteInteger(ixd0);   520   ///  WriteInteger(iyd0);   521       if ( n <= 1) {  522         if ( n == 0)  return ;  523   ///     PrintFast(2,"" m"");   524          return ;  525     }  526    527   ///  PrintFast(2,"" m"");   528       idx  = 0;  529     idy = 0;  530      for  ( Int_t  i=1;i<n;i++) {  531        ixdi =  UtoSVG (xy[i]. GetX ());  532        iydi =  VtoSVG (xy[i]. GetY ());  533        ix   = ixdi - ixd0;  534        iy   = iydi - iyd0;  535        ixd0 = ixdi;  536        iyd0 = iydi;  537         if ( ix && iy) {  538            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  539            if ( idy ) {  MovePS (0,idy); idy = 0; }  540            MovePS (ix,iy);  541            continue ;  542        }  543         if  ( ix ) {  544            if ( idy )  {  MovePS (0,idy); idy = 0; }  545            if ( ! idx  ) {  idx  = ix;  continue ;}  546            if ( ix* idx  > 0 ) {  547               idx  += ix;  548           }  else  {  549               MovePS ( idx ,0);  550               idx   = ix;  551           }  552            continue ;  553        }  554         if ( iy ) {  555            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  556            if ( !idy) { idy = iy;  continue ;}  557            if ( iy*idy > 0 ) {  558              idy += iy;  559           }  else  {  560               MovePS (0,idy);  561              idy  = iy;  562           }  563        }  564     }  565      if (  idx  )  MovePS ( idx ,0);  566      if ( idy )  MovePS (0,idy);  567    568      if  (nn > 0 ) {  569         if  (xy[0]. GetX () == xy[n-1]. GetX () && xy[0]. GetY () == xy[n-1]. GetY ())  PrintFast (3, "" cl"" );  570   ///     PrintFast(2,"" s"");   571      }  else  {  572   ///     PrintFast(2,"" f"");   573      }  574  }  575    576   //______________________________________________________________________________   577   void   TSVG :: DrawPS ( Int_t  nn,  Double_t  *xw,  Double_t  *yw)  578  {  579      // This function defines a path with xw and yw and draw it according the   580       // value of nn:   581       //   582       //  If nn>0 a line is drawn.   583       //  If nn<0 a closed polygon is drawn.   584     585   ///   static Float_t dyhatch[24] = {.0075,.0075,.0075,.0075,.0075,.0075,.0075,.0075,   586   ///                                 .01  ,.01  ,.01  ,.01  ,.01  ,.01  ,.01  ,.01  ,   587   ///                                 .015 ,.015 ,.015 ,.015 ,.015 ,.015 ,.015 ,.015};   588   ///   static Float_t anglehatch[24] = {180, 90,135, 45,150, 30,120, 60,   589   ///                                    180, 90,135, 45,150, 30,120, 60,   590   ///                                    180, 90,135, 45,150, 30,120, 60};   591       Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy, fais, fasi;  592     fais = fasi = 0;  593    594      if  (nn > 0) {  595        n = nn;  596     }  else  {  597        n = -nn;  598        fais = fFillStyle/1000;  599        fasi = fFillStyle%1000;  600         if  (fais == 3 || fais == 2) {  601            if  (fasi > 100 && fasi <125) {  602   ///        DrawHatch(dyhatch[fasi-101],anglehatch[fasi-101], n, xw, yw);   603                return ;  604           }  605            if  (fasi > 0 && fasi < 26) {  606   ///        SetFillPatterns(fasi, Int_t(fFillColor));   607            }  608        }  609     }  610    611       if ( n <= 1) {  612          Error ( ""DrawPS"" ,  ""Two points are needed"" );  613          return ;  614      }  615    616      ixd0 =  XtoSVG (xw[0]);  617      iyd0 =  YtoSVG (yw[0]);  618    619       PrintFast (10, ""<path d=\""M"" );  620       WriteInteger (ixd0, 0);  621       PrintFast (1, "","" );  622       WriteInteger (iyd0, 0);  623    624       idx  = idy = 0;  625       for  ( Int_t  i=1;i<n;i++) {  626         ixdi =  XtoSVG (xw[i]);  627         iydi =  YtoSVG (yw[i]);  628         ix   = ixdi - ixd0;  629         iy   = iydi - iyd0;  630         ixd0 = ixdi;  631         iyd0 = iydi;  632          if ( ix && iy) {  633             if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  634             if ( idy ) {  MovePS (0,idy); idy = 0; }  635             MovePS (ix,iy);  636         }  else   if  ( ix ) {  637             if ( idy )  {  MovePS (0,idy); idy = 0;}  638             if ( ! idx  ) {  idx  = ix;}  639             else   if (  TMath :: Sign (ix, idx ) == ix )        idx  += ix;  640             else  {  MovePS ( idx ,0);   idx   = ix;}  641         }  else   if ( iy ) {  642             if (  idx  ) {  MovePS ( idx ,0);  idx  = 0;}  643             if ( !idy) { idy = iy;}  644             else   if (  TMath :: Sign (iy,idy) == iy)         idy += iy;  645             else  {  MovePS (0,idy);    idy  = iy;}  646         }  647      }  648       if  ( idx )  MovePS ( idx ,0);  649       if  (idy)  MovePS (0,idy);  650    651       if  (nn > 0 ) {  652          if  (xw[0] == xw[n-1] && yw[0] == yw[n-1])  PrintFast (1, ""z"" );  653          PrintFast (21, ""\"" fill=\""none\"" stroke="" );  654          SetColor (fLineColor);  655          if (fLineWidth > 1.) {  656             PrintFast (15, "" stroke-width=\"""" );  657             WriteInteger ( Int_t (fLineWidth), 0);  658             PrintFast (1, ""\"""" );  659         }  660          if  (fLineStyle == 2) {  661             PrintFast (23, "" stroke-dasharray=\""3,3\"""" );  662         }  else   if  (fLineStyle == 3) {  663             PrintFast (23, "" stroke-dasharray=\""1,4\"""" );  664         }  else   if  (fLineStyle == 4) {  665             PrintFast (27, "" stroke-dasharray=\""3,4,1,4\"""" );  666         }  667          PrintFast (2, ""/>"" );  668      }  else  {  669          PrintFast (8, ""z\"" fill="" );  670          if  (fais == 0) {  671             PrintFast (14, ""\""none\"" stroke="" );  672             SetColor (fFillColor);  673   ///      } else if (fais == 3 || fais == 2) {   674   ///        if (fasi > 0 && fasi < 26) {   675   ///           Put SVG patterns here   676          }  else  {  677             SetColor (fFillColor);  678         }  679          PrintFast (2, ""/>"" );  680      }  681  }  682    683   //______________________________________________________________________________   684   void   TSVG :: Initialize ()  685  {  686      // Initialize the SVG file. The main task of the function is to ouput the   687       // SVG header file which consist in <title>, <desc> and <defs>. The   688       // HeaderPS provided by the user program is written in the <defs> part.   689     690      // Title   691       PrintStr ( ""<title>@"" );  692      PrintStr ( GetName ());  693      PrintStr ( ""@"" );  694      PrintStr ( ""</title>@"" );  695    696      // Description   697       PrintStr ( ""<desc>@"" );  698      PrintFast (22, ""Creator: ROOT Version "" );  699      PrintStr ( gROOT ->GetVersion());  700      PrintStr ( ""@"" );  701      PrintFast (14, ""CreationDate: "" );  702      TDatime  t;  703      PrintStr (t. AsString ());  704      //Check a special header is defined in the current style   705       Int_t  nh =  strlen ( gStyle ->GetHeaderPS());  706      if  (nh) {  707         PrintFast (nh, gStyle ->GetHeaderPS());  708     }  709      PrintStr ( ""</desc>@"" );  710    711      // Definitions   712       PrintStr ( ""<defs>@"" );  713      PrintStr ( ""</defs>@"" );  714    715  }  716    717   //______________________________________________________________________________   718   void   TSVG :: MovePS ( Int_t  ix,  Int_t  iy)  719  {  720      // Move to a new position (ix, iy). The move is done in relative coordinates   721       // which allows to have short numbers which decrease the size of the file.   722       // This function use the full power of the SVG's paths by using the   723       // horizontal and vertical move whenever it is possible.   724     725      if  (ix != 0 && iy != 0)  {  726         PrintFast (1, ""l"" );  727         WriteInteger (ix, 0);  728         PrintFast (1, "","" );  729         WriteInteger (iy, 0);  730     }  else   if  (ix != 0)  {  731         PrintFast (1, ""h"" );  732         WriteInteger (ix, 0);  733     }  else   if  (iy != 0)  {  734         PrintFast (1, ""v"" );  735         WriteInteger (iy, 0);  736     }  737  }  738    739   //______________________________________________________________________________   740   void   TSVG :: NewPage ()  741  {  742      // Start the SVG page. This function initialize the pad conversion   743       // coefficients and ouput the <svg> directive which is close later in the   744       // the function Close.   745     746      // Compute pad conversion coefficients   747       if  ( gPad ) {  748         Double_t  ww   =  gPad -> GetWw ();  749         Double_t  wh   =  gPad -> GetWh ();  750        fYsize        = fXsize*wh/ww;  751     }  else  {  752        fYsize = 27;  753     }  754    755      // <svg> directive. It defines the viewBox.   756       if (!fBoundingBox) {  757         PrintStr ( ""@<svg viewBox=\""0 0"" );  758         WriteInteger (CMtoSVG(fXsize));  759        fYsizeSVG = CMtoSVG(fYsize);  760         WriteInteger (fYsizeSVG);  761         PrintStr ( ""\"" xmlns=\""http://www.w3.org/2000/svg\"">"" );  762         PrintStr ( ""@"" );  763         Initialize ();  764        fBoundingBox  =  kTRUE ;  765     }  766  }  767    768   //______________________________________________________________________________   769   void   TSVG :: Range ( Float_t   xsize ,  Float_t   ysize )  770  {  771      // Set the range for the paper in centimetres   772     773      Float_t  xps, yps, xncm, yncm, dxwn, dywn, xwkwn, ywkwn, xymax;  774    775     fXsize =  xsize ;  776     fYsize =  ysize ;  777    778     xps =  xsize ;  779     yps =  ysize ;  780    781      if (  xsize  <= xps &&  ysize  < yps) {  782         if  ( xps > yps ) xymax = xps;  783         else              xymax = yps;  784        xncm  =  xsize /xymax;  785        yncm  =  ysize /xymax;  786        dxwn  = ((xps/xymax)-xncm)/2;  787        dywn  = ((yps/xymax)-yncm)/2;  788     }  else  {  789         if  (xps/yps < 1) xwkwn = xps/yps;  790         else              xwkwn = 1;  791         if  (yps/xps < 1) ywkwn = yps/xps;  792         else              ywkwn = 1;  793    794         if  ( xsize  <  ysize )  {  795           xncm = ywkwn* xsize / ysize ;  796           yncm = ywkwn;  797           dxwn = (xwkwn-xncm)/2;  798           dywn = 0;  799            if ( dxwn < 0) {  800              xncm = xwkwn;  801              dxwn = 0;  802              yncm = xwkwn* ysize / xsize ;  803              dywn = (ywkwn-yncm)/2;  804           }  805        }  else  {  806           xncm = xwkwn;  807           yncm = xwkwn* ysize / xsize ;  808           dxwn = 0;  809           dywn = (ywkwn-yncm)/2;  810            if ( dywn < 0) {  811              yncm = ywkwn;  812              dywn = 0;  813              xncm = ywkwn* xsize / ysize ;  814              dxwn = (xwkwn-xncm)/2;  815           }  816        }  817     }  818     fRange =  kTRUE ;  819  }  820    821   //______________________________________________________________________________   822   void   TSVG :: SetFillColor (  Color_t   cindex  )  823  {  824      // Set color index for fill areas   825     826     fFillColor =  cindex ;  827      if  ( gStyle ->GetFillColor() <= 0)  cindex  = 0;  828  }  829    830   //______________________________________________________________________________   831   void   TSVG :: SetLineColor (  Color_t   cindex  )  832  {  833      // Set color index for lines   834     835     fLineColor =  cindex ;  836  }  837    838   //______________________________________________________________________________   839   void   TSVG :: SetLineStyle ( Style_t  linestyle)  840  {  841      // Change the line style   842       //   843       // linestyle = 2 dashed   844       //           = 3 dotted   845       //           = 4 dash-dotted   846       //           = else solid (1 in is used most of the time)   847     848     fLineStyle = linestyle;  849  }  850    851   //______________________________________________________________________________   852   void   TSVG :: SetLineWidth ( Width_t  linewidth)  853  {  854      // Set the lines width.   855     856     fLineWidth = linewidth;  857  }  858    859   //______________________________________________________________________________   860   void   TSVG :: SetMarkerColor (  Color_t   cindex  )  861  {  862      // Set color index for markers.   863     864     fMarkerColor =  cindex ;  865  }  866    867   //______________________________________________________________________________   868   void   TSVG :: SetColor ( Int_t   color )  869  {  870      // Set color with its color index   871     872      if  ( color  < 0)  color  = 0;  873      TColor  * col  =  gROOT -> GetColor ( color );  874      if  ( col ) {  875         SetColor ( col -> GetRed (),  col -> GetGreen (),  col -> GetBlue ());  876     }  else  {  877         SetColor (1., 1., 1.);  878     }  879  }  880    881   //______________________________________________________________________________   882   void   TSVG :: SetColor ( Float_t  r,  Float_t  g,  Float_t  b)  883  {  884      // Set color with its R G B components   885       //   886       //  r: % of red in [0,1]   887       //  g: % of green in [0,1]   888       //  b: % of blue in [0,1]   889     890      if  (r <= 0. && g <= 0. && b <= 0. ) {  891         PrintFast (7, ""\""black\"""" );  892     }  else   if  (r >= 1. && g >= 1. && b >= 1. ) {  893         PrintFast (7, ""\""white\"""" );  894     }  else  {  895         char   str [12];  896        sprintf( str , ""\""#%2.2x%2.2x%2.2x\"""" , Int_t (255.*r)  897                                          , Int_t (255.*g)  898                                          , Int_t (255.*b));  899         PrintStr ( str );  900     }  901  }  902    903   //______________________________________________________________________________   904   void   TSVG :: SetTextColor (  Color_t   cindex  )  905  {  906      // Set color index for text   907     908     fTextColor =  cindex ;  909  }  910    911   //______________________________________________________________________________   912   void   TSVG :: Text ( Double_t  xx,  Double_t  yy,  const   char  *chars)  913  {  914      // Draw text   915       //   916       // xx: x position of the text   917       // yy: y position of the text   918       // chars: text to be drawn   919     920      static   const   char  *fontFamily[] = {  921      ""Times"" ,  ""Times"" ,  ""Times"" ,  922      ""Helvetica"" ,  ""Helvetica"" ,  ""Helvetica"" ,  ""Helvetica"" ,  923      ""Courier"" ,  ""Courier"" ,  ""Courier"" ,  ""Courier"" ,  924      ""Symbol"" , ""Times"" ,  ""ZapfDingbats"" };  925    926      static   const   char  *fontWeight[] = {  927      ""normal"" ,  ""bold"" ,  ""bold"" ,  928      ""normal"" ,  ""normal"" ,  ""bold"" ,  ""bold"" ,  929      ""normal"" ,  ""normal"" ,  ""bold"" ,  ""bold"" ,  930      ""normal"" , ""normal"" ,  ""normal"" };  931    932      static   const   char  *fontStyle[] = {  933      ""italic"" ,  ""normal"" ,  ""italic"" ,  934      ""normal"" ,  ""oblique"" ,  ""normal"" ,  ""oblique"" ,  935      ""normal"" ,  ""oblique"" ,  ""normal"" ,  ""oblique"" ,  936      ""normal"" , ""normal"" ,  ""normal"" };  937    938      Int_t  ix    =  XtoSVG (xx);  939      Int_t  iy    =  YtoSVG (yy);  940      Int_t   txalh  = fTextAlign/10;  941      if  ( txalh  <1)  txalh  = 1;  if  ( txalh  > 3)  txalh  = 3;  942      Int_t   txalv  = fTextAlign%10;  943      if  ( txalv  <1)  txalv  = 1;  if  ( txalv  > 3)  txalv  = 3;  944    945      Double_t      wh = ( Double_t ) gPad -> XtoPixel ( gPad -> GetX2 ());  946      Double_t      hh = ( Double_t ) gPad -> YtoPixel ( gPad -> GetY1 ());  947      Float_t   fontrap  = 1.09;  //scale down compared to X11   948       Float_t   ftsize ;  949    950      Int_t   font   =  abs (fTextFont)/10;  951      Int_t  ifont =  font -1;  952      if  ( font  > 42 ||  font  < 1)  font  = 1;  953      if  (wh < hh) {  954         ftsize  = fTextSize*fXsize* gPad ->GetAbsWNDC();  955     }  else  {  956         ftsize  = fTextSize*fYsize* gPad ->GetAbsHNDC();  957     }  958    959      Int_t   fontsize  = CMtoSVG( ftsize / fontrap );  960      if (  fontsize  <= 0)  return ;  961    962      if  ( txalv  == 3) iy = iy+ fontsize ;  963      if  ( txalv  == 2) iy = iy+( fontsize /2);  964    965      if  (fTextAngle != 0.) {  966         PrintFast (21, ""<g transform=\""rotate("" );  967         WriteInteger (- Int_t (fTextAngle), 0);  968         PrintFast (1, "","" );  969         WriteInteger (ix, 0);  970         PrintFast (1, "","" );  971         WriteInteger (iy, 0);  972         PrintFast (3, "")\"">"" );  973     }  974    975      PrintFast (9, ""<text x=\"""" );  976      WriteInteger (ix, 0);  977      PrintFast (5, ""\"" y=\"""" );  978      WriteInteger (iy, 0);  979      PrintFast (1, ""\"""" );  980      if  ( txalh  == 2) {  981         PrintFast (21, "" text-anchor=\""middle\"""" );  982     }  else   if  ( txalh  == 3) {  983         PrintFast (18, "" text-anchor=\""end\"""" );  984     }  985      PrintFast (6, "" fill="" );  986      SetColor ( Int_t (fTextColor));  987      PrintFast (12, "" font-size=\"""" );  988      WriteInteger ( fontsize , 0);  989      PrintFast (15, ""\"" font-family=\"""" );  990      PrintStr (fontFamily[ifont]);  991      if  ( strcmp (fontWeight[ifont], ""normal"" )) {  992         PrintFast (15, ""\"" font-weight=\"""" );  993         PrintStr (fontWeight[ifont]);  994     }  995      if  ( strcmp (fontStyle[ifont], ""normal"" )) {  996         PrintFast (14, ""\"" font-style=\"""" );  997         PrintStr (fontStyle[ifont]);  998     }  999      PrintFast (2, ""\"">"" );  1000      if  ( font  == 12 && chars[0] >=  '\xA3'  && chars[0] <=  '\xF2' ) {  1001         char   str [8];  1002        sprintf( str , ""&#x%2.2x;"" , chars[0] & 255);  1003         PrintStr ( str );  1004     }  else  {  1005         PrintStr (chars);  1006     }  1007      PrintFast (7, ""</text>"" );  1008    1009      if  (fTextAngle != 0.)  PrintFast (4, ""</g>"" );  1010  }  1011    1012   //______________________________________________________________________________   1013   void   TSVG :: TextNDC ( Double_t  u,  Double_t  v,  const   char  *chars)  1014  {  1015      // Write a string of characters in NDC   1016     1017      Double_t  x =  gPad -> GetX1 () + u*( gPad -> GetX2 () -  gPad -> GetX1 ());  1018      Double_t  y =  gPad -> GetY1 () + v*( gPad -> GetY2 () -  gPad -> GetY1 ());  1019      Text (x, y, chars);  1020  }  1021    1022   //______________________________________________________________________________   1023   Int_t   TSVG :: UtoSVG ( Double_t  u)  1024  {  1025      // Convert U from NDC coordinate to SVG   1026     1027      Double_t  cm = fXsize*( gPad ->GetAbsXlowNDC() + u* gPad ->GetAbsWNDC());  1028      return   Int_t (0.5 + 72*cm/2.54);  1029  }  1030    1031   //______________________________________________________________________________   1032   Int_t   TSVG :: VtoSVG ( Double_t  v)  1033  {  1034      // Convert V from NDC coordinate to SVG   1035     1036      Double_t  cm = fYsize*( gPad ->GetAbsYlowNDC() + v* gPad ->GetAbsHNDC());  1037      return   Int_t (0.5 + 72*cm/2.54);  1038  }  1039    1040   //______________________________________________________________________________   1041   Int_t   TSVG :: XtoSVG ( Double_t  x)  1042  {  1043      // Convert X from world coordinate to SVG   1044     1045      Double_t  u = (x -  gPad -> GetX1 ())/( gPad -> GetX2 () -  gPad -> GetX1 ());  1046      return    UtoSVG (u);  1047  }  1048    1049   //______________________________________________________________________________   1050   Int_t   TSVG :: YtoSVG ( Double_t  y)  1051  {  1052      // Convert Y from world coordinate to SVG   1053     1054      Double_t  v = (y -  gPad -> GetY1 ())/( gPad -> GetY2 () -  gPad -> GetY1 ());  1055      return   fYsizeSVG- VtoSVG (v);  1056  }  1057    1058   //______________________________________________________________________________   1059   void   TSVG :: CellArrayBegin ( Int_t ,  Int_t ,  Double_t ,  Double_t ,  Double_t ,  1060                             Double_t )  1061  {  1062      Warning ( ""TSVG::CellArrayBegin"" ,  ""not yet implemented"" );  1063  }  1064    1065   //______________________________________________________________________________   1066   void   TSVG :: CellArrayFill ( Int_t ,  Int_t ,  Int_t )  1067  {  1068      Warning ( ""TSVG::CellArrayFill"" ,  ""not yet implemented"" );  1069  }  1070    1071   //______________________________________________________________________________   1072   void   TSVG :: CellArrayEnd ()  1073  {  1074      Warning ( ""TSVG::CellArrayEnd"" ,  ""not yet implemented"" );  1075  }  1076    1077   //______________________________________________________________________________   1078   void   TSVG :: DrawPolyMarker ( Int_t ,  Float_t  *,  Float_t  *)  1079  {  1080      Warning ( ""TSVG::DrawPolyMarker"" ,  ""not yet implemented"" );  1081  }  1082    1083   //______________________________________________________________________________   1084   void   TSVG :: DrawPolyMarker ( Int_t ,  Double_t  *,  Double_t  *)  1085  {  1086      Warning ( ""TSVG::DrawPolyMarker"" ,  ""not yet implemented"" );  1087  }  1088    1089   //______________________________________________________________________________   1090   void   TSVG :: DrawPS ( Int_t ,  Float_t  *,  Float_t  *)  1091  {  1092      Warning ( ""TSVG::DrawPS"" ,  ""not yet implemented"" );  1093  }  1094              [   source navigation   ]   [   identifier search   ]   [   freetext search   ]   [   file search   ]   [   repository   ]       This page was automatically generated by the   LXR engine . Visit the  LXR main site  for more information.   This version by  Torre Wenaus ."
GX251-66-7974031	"A Tec hnical Journal f or PDA De velop ers  PDA DEVELOPERS Volume 4.5  Sept/Oct 1996 $13.95 US  $14.95 Canada  Newton Internet Enabler (NIE) An easy-to-use client proto c lient The AP I Explained  The HP OmniGO 100 The definitive review A Compression Tool Compression Express Options App  Pilot Conduits Conduits The Definitive Guide  Plus Psion OPL Localization Informed Filler Review And the usual suspects   PDA Solutions Exhibition September 14, 1996  Inland Meeting & Exposition Center  Westmont, IL, 20 minutes from Chicago's O'Har e Airpor t  The PDA Solutions Exhibition is the only event where you can find out how to harness the new, exciting technology of PDAs and hand-held computers to boost your personal productivity and also implement a variety of corporate solutions. Come see the latest mobile assistants from Palm Computing, Psion, SONY, Apple Computer, Hewlett Packard, Motorola, Sharp and more.  Ke ynote Speaker  TM  Jeff Hawkins Vice President and Chief Technologist The Palm Computing Division of US Robotics Designer of the award-winning Palm Pilot and the Graffiti handwriting-recognition software.  Sponsors Psion, General Magic , Palm Computing, ARDIS, Apple , and HP.  Co-sponsors Geoworks, Pen Computing Magazine, In-Touch USA, Wright Strategies, and PDA Direct.  Conference Tracks  Getting the most out of your PDA  Psion, Palm Pilot, OmniGo, Newton, Magic Cap, HP Palmtops. Presented by leading experts in the field, including editors from Pen Computing Magazine.  Corporate solutions using hand-held mobile technologies, presented by key system integrators.  Vertical market applications using hand-held computers  Medical, Utilities, Financial Services, Global Positioning, Agriculture, and more.  Special topics, such as creating your own PDA-readable content, connecting to the Internet with PDAs, wireless Web access, and creating your own specialized applications programs for a PDA.  Cost The PDA Solutions Exhibition exhibits are open to the public at no charge. Registration for the full Solutions conference is $50 until September 8, $65 after that.  Exhibits 10,000 square feet full of PDA manufacturers, software vendors, wireless communications companies, systems integrators, and specialists in harnessing the power of hand-held computers. Come find out why PDAs are the most exciting segment of the computer industry.  Creative Digital Inc. 293 Corbett Avenue, San Francisco, CA 94114-1842 Call (415.621.4252), Fax (415.621.4922), E-mail (info@cdpubs.com), or Surf (http://www.cdpubs.com).   Contents  Regulars PDA News ..................................................... Steve Mann 2 New Technologies, Existing Carriers .... Andy Seybold 5 AT&T Wireless' Internet phone strategy.  Reviews Informed Filler for Newton ............... John Schettino 8 John raves about this high-quality forms product.  Newton User Interface Guidelines ........... Ken Knight 10 A review of one of Apple's first official Newton books.  The OmniGo 100 .......................................... Scott Sbihli 11 A hard-core Newton user tries a new device  and likes it!.  Features Getting Started Multi-Developer Magic Cap Projects ...... Bruce Tong 16 Tips and tricks for keeping your objects organized.  Express Option Modifier .............................. John Blue 19 An IZL program for changing OmniGo express options.  An OmniGo Compression Tool ....... Marcus Groeber 26 Psion OPL Localization .......................... Danile Pfund 17 A few simple steps to creating international Psion apps. Get maximum use out of your OminGo's limited RAM.  NIE Made Easy: The protoInetClient . Ray Rischpater 38 Making NIE-enabled Newton apps the easy way.  The NIE 1.0 API ...................................... John Schettino 41 John describes NIE's seamier side .  Extending Your Desktop With the Pilot .... Stu Slack 42 The definitive conduit-creation guide from the experts.  PDA Developers is copyright and trademarked by  Creative Digital Publishing Inc. 293 Corbet t Avenue 415.621.4252 info@cdpubs.com http://ww  San Francisco, C A 94114-1842  415.621.4922 (fax)  74774.50@compuserve.com w.cdpubs.c om  All rights reserved. All tr ademarks used in this maga zine are for editorial purposes only and to the benefit of the trademark owner, with no intention of infringing on that trademark. Editor and Publisher ............................................... Steve Mann Contributing Editors ..................................... John Sc hettino, ................ Brenda Holloway, Andy Seybold, Ray Rischp ater  PDA De velope rs (ISSN 1088-4149) is published bimonthly for $65 per year ($85 overseas) by Creative Digital Publishing, Inc., 293 Corbett Avenue, San Francisco, CA 94114-1842. Periodicals postage paid at San Francisco, CA. POSTMASTER: Send address changes to PDA De velopers, Creative Digital Publishing Inc., 293 Corbett Ave., San Francisco, CA 94114-1842. P DA DE VELOPER S  4.5  Sept/Oc t 1996  1   Regulars PDA News Steve Mann sem@cdpubs.com  browser that runs on the PocketNet Phone, and specifications for an HTML-like language called HDML for creating custom client applications that are compatible with the b rowser. For more information on Unwired Planet's technology, and their developer tools and services, check out http://www.uplanet.com. For more details on AT&T's announcements, see Andy Seybold's column on page 5.  U.S. Robotics Ships Pilot Development Tools In mid June, the Palm Computing subsidiar y of U.S. Robotics announced the availability of CodeWarrior for Pilot, a Pilot development environment based on Metrowerk's popular CodeWarrior 9.0 IDE. This first release runs only on Macintosh systems. Metrowerks has announced that CodeWarrior will b e available for Windows some time this fall. Priced at $299, CodeWarrior for Pilot does not include the full CodeWarrior suite of tools, but it does include a subscription for five releases of the environment, instead of CodeWarrior's usual three. In addition, Metrowerks is offering a special Pilot bundle, including CodeWarrior for Pilot, a Pilot 5000, and a debugger cable for $399, a savings of almost $300. For more information, contact Metrowerks at http:// www.metrowerks.com or 512.305.0400. Palm is also offering a similarly developer bundle, priced at $499, but it includes the Pilot conduit SDK, which requires Microsoft's Visual C++ 4.0. You can also buy the individual SDKs directly from Palm. Both the client and conduit SDKs are $99. For more information, contact U.S. Robotics at http://www.usr.com, devinfo@palm.com, 800.881.7256, 800.891.6342 ext. 203 (in Canada), or 408.848.5604.  PCS Deployment Gearing Up BellSouth Mobility, a subsidiar y of B ellSouth Corporation, announced on July 18 the deployment of PCS-1900 ser vices in North and South Carolina, and Eastern Tennessee. Using spectrum recently purchased during the FCC airwave auctions last year, BellSouth Mobility's offers three fixed-price monthly plans:  Personal ($26.95), including 45 call minutes, plus $.30 for each additional minute;  Performance ($44.95), including 120 call minutes, plus $.25 for each additional minute; and  Power ($89.95), including 360 cal l minutes, plus $.15 for each additional minute. Each plan includes a free first minute for incoming calls, no roaming charges, no peak/off-peak pricing differentials, voice mail, numeric paging, and call waiting, hold, and forwarding. A variety of lightweight BellSouth and Nokia handsets are available from BellSouth and selected retailers. Prices range from $125 to $200. For more information, contact BellSouth Mobility at 888.DCS.2001. PCS-1900 is a digital voice and data ser vice that is functionally, but not frequency-compatible with the GSM standard used in most parts of the world. It shouldn't be too long before it's possible to buy one handset that is both PCS and GSM compatible, and suitable for using throughout the world (assuming the carriers can build the infrastructure).  Psion Software PLC In July Psion announced the formation of a new corporate entity, Psion Software PLC. This new group's mission is to license its operating system and applications software. They w ill make available 16-bit EPOC< the operating system on their popular Psion 3a, and their upcoming EPOC/32, a port designed for 32-bit RISC processors. In related announcements, partners Advanced RISC Machines (ARM), Digital Semiconductor, and Cirrus Logic announced that EPOC/32 is being ported to ARM's StrongARM SA-110 chips (available from Digital Semiconductor) plus the new generation ARM7100, a socalled ""PDA on a chip."" Cirrus Logic is expected to provide a complete design solution, including an evaluation board, design database, and EPOC SDK. For more information, contact Psion Software PLC at +44.171.208.1800, or 415.373.3224, or Digital Semiconductor at http:// www.digital.com/info/semconductor.  Pac Bell Throw s Its Hat in the Ring Earlier this year, Pa cific Bell Mobile Services said it expects to deploy PCS-1900 services throughout its West Coast territories by early 1997. Their handsets will be built by Nokia and Ericcson and incorporate the GEOS operating system. In July, Phoenix Technologies PICO group announced PicoPAL, a software layer for personal communicators and Smart Phones running the GEOS operating system. Phoenix is a leading supplier of low-level OS components like ROM BIOSs, communications subsystems, and other system-level software products. Expect PicoPAL to be an integral part of the Pac Bell handsets when they become available.  General Magic After keeping quiet for a few months, General Magic burst forth with a deluge of announcements on June 25th. These announcements were designed to reveal the company's Internet, Web, and intranet strategies. They included the following:  General Magic has licensed Microsoft's Internet Explorer, and has signed up as an America Online developer. They expect to bundle an AOL client and IE in the forthcoming commercial release of Magic Cap for Windows, which will be some time in the second half of 1996.  The company announced the immediate availability of SoftModem, software that provides a robust set of data and fax modem functions on general-purpose microprocessors, independent of the operating systems. The 28.8 Kbps version of the software requires 64K RAM and 256K ROM. Licensing inquiries should be directed to Kendall Larsen at 408.774.4474.  Tabriz AgentWare and Tabriz Agent Tools, a deployment and developme nt environment for creating agent-based Internet solutions and services, is now available. Based on TeleScript, Tabriz includes persistence, mobile agent capabilities, built-in security, Java support, standard browser support, and a variety of other capabilities.  C TIA W ireless Apps Panel Finally, CTIA's Wireless Apps conference in Las Vegas (October 7-9, 1996) will feature a Smart Phone Executive Forum, hosted by Geoworks. The Forum w ill include two panel discussions: one on smart phone development architectures, a second on content and service aftermarkets for smart phones. For more information, contact CTIA at 202.785.0081.  AT&T Wireless Internet Phone Not to be outdone by a flurr y of Smart Phone announcements, AT&T Wireless Services in July announced the AT&T PocketNet Phone, an integrated cellular phone and ""wireless Internet appliance."" Costing about $500, and manufactured by PCSI of San Diego, this device uses CDPD services to provide text-only access to Internet services and a base set of business services like two-way messaging, airline and financial informat ion, spor ts scores, lo cal movie listings, and lottery results. In addition, corporate and independent Web developers can program the phone for remote wireless access to int ranets and custom twoway messaging applications using technology created by AT&T equity partner Unwired Planet. The technology includes a server that officiates between the wireless services and the wireline part of the Internet, a  2  P DA De velopers 4.5  Sept/Oct 1996    They announced the commercial availability of Presto!Links and Presto!Mail, Internet e-mail and web browsing solutions for Magic Cap devices. In a follow-up announcement on July 11, General Magic announced that Presto!Mail will be made available to all AT&T PersonaLink subscribers. AT&T intends to discontinue PersonaLink at the end of August.  Company Hewlett-Packard Apple Psion Sharp Sony Motorola Others Total  Percent 34% 18% 14% 12% 6% 4% 12% 100%  Units 175,000 92,500 72,000 61,500 31,000 20,500 61,500 514,000  A Newton-Only Store Down Under A new Newton-only store, Newton World, will b e opening shortly in Sydney, Australia. Newton World will have a retail storefront, but will also provide systems integration and software development services. In addition, they are aggressively putting together a distribution business that specializes in providing a full range of Newton hardware, software, and accessories to Newton resellers throughout Australia. For more information, or to discuss having Newton World handle your products, contact Newton World at +61.2.261.8685, +61.2.261.8689 (fax), or newtonworld@moreinfo.com.au.  Product Announcements F ormLogic 2.0 In mid June, Wright St rategies announced the third-quarter availability of FormLogic 2.0, the next generation of their mobile applications development environment. FormLogic 2.0 has three components: FLBuilder, FLServer, and FLEngine. FLBuilder uses a Visual Basic-like language to let developers create multi-page client applications, including communications links to corporate legacy systems. FLEngine executes the client application on a mobile device. Currently available for the Newton MessagePad, FLEngine will be available for other platforms. FLServer provides:  Transparent, real-time data exchange between mobile devices and enterprise data sources;  A transport-independent design that can be used with dial-up, LAN, TCP/IP, and wireless technologies;  Automatic software distribution capabilities and authenticationbased security; and  A complete administrative package based on a user/group model, including event logging, server configuration, and software component registration. Pricing varies, depending on installation size. Contact Wright Strategies at 619.551.6808 for more information.  A Newton-Only Store in Tokyo In mid July, Enfour, Inc. announced the opening of Japan's first Newton Only store, The Newton Shop, in the Ginza area of Tokyo. Announced at the same time that Apple debuted the Japanese version of the MessagePad 130, the Newton Shop carries a ful l line of Newton hardware and software, accessories, and offers a club credit card from Nippon Shimpan that provides Newton loss and damage insurance. The Newton Shop plans on positioning the Newton as a fashionable lifestyle accessory, not a toy for digital early adopters. The MessagePad 130 will b e bundled with a Japanese display and input solution from Enfour called UniFEP. It includes a Japaneselanguage user manual and a CD-ROM of related Windows and Mac software. In early August, Enfour announced the availability of HWCR, a kanji handwriting recognition package for the MessagePad 130. HWCR has full support for roman, hiragana, katakana, and most of the kanji alphabet. It also supports ink-text for delayed recognition. The Newton Shop can be reached at +81.3.5411.7738, +81.3.5474.8934 (fax), or richard@enfour.com.  AR DI S Wireless E-M ail for MessagePad 130 At MacWorld in Boston, ARDIS announced that River Run Software Group's Mail on the Run! electronic mail software now supports the Newton Messag ePad 130. Mail on the Run! provides access to indust rystandard Microsoft Mail and Lotus cc:Mail systems using the ARDIS wireless data network. NewtonSource, a retailer of Newton solutions, will b e offering a Mobile Mail bundle that includes ARDIS airtime, Mail on the Run!, a MessagePad 130, and a Motorola Personal Messenger 100D Wireless Modem Card. For more information contact NewtonSource at http:// www.newtonsource.com.  PDA Event World Market Strategies is sponsoring The Hand-Held and PDA Expo `96 on December 4-6 in San Mateo, CA. Billed as a ""strategic meeting of the minds designed to bring together customers and vendors to explore the functional asp ects of PDA technology,"" the Expo will focus on vertical markets, functional aspects of PDA technology, and corporate solutions. For more information contact World Market St rategies at 415.252.8008.  GEOS Developer Mailing List A new mailing list has been created specifically for the discussion of issues related to GEOS development. The list is not an official support forum from Geoworks, but it has the advantage of being accessible from any mail system that is capable of exchanging e-mail w ith the Internet. To subscribe to the list, send mail with any subject and the line ""subscribe geos-dev your@address.dom"" in the message body to ""majordomo@lifelike.com"" (on the same server, there is also an OmniGo list under the keyword ""ogo""). Alternatively, you can use ""subscribe geos-dev-digest"", which gives you all the contributions of a day in a single mail.  EnRoute i-net Also at MacWorld Boston, Netstrategy Software of Toronto announced EnRoute i-net, a commercial POP/SMTP Internet mail client for the Newton. In addition to supporting plain text messaging, EnRoute i-ne t also lets Newton users send Newton-native data like text, frames, books, and packages as MIME attachments. This provides seamless Newtonto-Newton and Newton-to-desktop transfers. Other features include scheduled connections, message filtering, group addressing , and a plugin architecture. Using Apple's recently released Newton Internet Enabler, EnRoute inet costs $69.95. Contact NetStrategy at 416.369.1996, 416.361.0451 (fax), or celso@netcom.ca for the closest retail outlet.  PDA Shipment Estimates Recently, as reported by NewtNews on the Internet, the Yankee Group estimated PDA unit shipments in the U.S. at about 514,000 units. They broke out the best sellers with these percentages:  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  3   W ireless Distributed Tr ansaction Systems In early August, ARDIS and Ta ctica Corp. announced Caprera, Tactica software that makes it possible to create distributed wireless transaction systems over the ARDIS data network. Caprera is programmable server software that gives client/server applications wireless access to corporate databases. Caprera is one of the first products to achieve ARDIS Level One certification. Tactica is now an authorized ARDIS Solution provider. The server is targeted at mobile and remote users of LAN-based, transaction-oriented applications such as field sales org anizations that must access customer data residing on a corporate le gacy system. It's appropriate for corporate developers and independent software vendors. For more information, contact Tactica at info@tactica.com or http://www.tactica.com.  IBM Global Uplink Update KABINDA, ZAIRE  In a move IBM offices are hailing as a major step in the company's ongoing worldwide telecommunications revolution, M'wana Ndeti, a member of Zaire's Bantu tribe, used an IBM global uplink network modem yesterday to cr ush a nut. Ndeti, who spent 20 minutes trying to open the nut by hand, easily cracked it open by smashing it repeatedly with the powerful modem. ""I could not crush the nut by myself,"" said the 47-year-old Ndeti, who added the savor y nut to a thick, peanut-based soup minutes later. ""With IBM's help, I was able to break it."" Ndeti discovered the nutbreaking, 28.8 V.34 modem yesterday, when IBM was shooting a commercial in his southwestern Zaire village. During a break in shooting, which shows African v illagers eagerly teleconferencing via computer with Japanese schoolchildren, Ndeti snuck onto the set and took the modem, which he b elieved would serve well as a ""smashing"" utensil. IBM officials were not surprised the longtime computer giant was able to provide Ndeti with practical solutions to his everyday problems. ""Our telecommunicat ions systems offer people all over the world global networking solutions that fit their specific needs,"" said Herbert Ross, IBM's director of marketing. ""Whether you're a nun cloistered in an Italian abbey or an Aborigine in Australia's Great Sandy Desert, IBM has the ideas to get you where you want to go today."" According to Ndeti, of the modem's many powerful features, most impressive was its hard plastic casing , which easily sustained several minutes of vigorous pounding against a large stone. ""I put the nut on a rock, and I hit it with the modem,"" Ndeti said. ""The modem did not break. It is a good modem."" Ndeti was so impressed with the modem that he purchase d a new, state-of- the-art IBM workstation, complete with a PowerPC 601 microprocessor, a quad-speed internal CD-ROM dr ive and three 16-bit Ethernet networking connectors. The tribesman has already made good use of the computer system, fashioning a g azelle trap out of its wires, a boat anchor out of the monitor, and a crude but effective weapon from its mouse. ""This is a good computer,"" said Ndeti, carving up a just-captured gazelle w ith the computer's flat, shar p internal processing device. ""I am using every part of it. I will cook this gazelle on the keyboard."" Hours later, Ndeti capped off his delicious gazelle dinner by smoking the computer's 200-page owner's manual. IBM spokespeople praised Ndeti's choice of computers. ""We are pleased that the Bantu people are turning to IBM for their business needs,"" said company CEO William Allaire. ""From Kansas City to Kinshasa, IBM is bringing the world closer together. Our cutting-edge technology is truly creating a global village."" Thanks for Stu Slack of The Windward Group for this contribution. Or iginal source unknown. Copyright 1996 by that original source. All rights reserved.  Psion Ex ternal Disk Drive In June, Purple Software announced the immediate availability of the Cyclone, a low-cost external disk drive for Psion hand-held computers, including the 3a and the WorkAbout. The Cyclone, which operates on five AA batteries or external power, includes Purple Software's File Manager software. It's advantages include:  It reads and writes standard PC-format floppy disks, making it possible to copy Psion software to floppy disks for backup purposes, and to transpor t data and programs to and from PC-based systems.  It's tightly integrated into the Psion environment. The disk appears as drive ""C:"", making it accessible anywhere you can access a Psion Flash SSD.  It makes it possible for developers to distribute their Psion software on floppy disk instead of Flash SSD, reducing their manufacturing costs. The Cyclone, which is available in almost 20 countries, retails for about $225. For more information, contact Purple Software at +44.171.387.7777 or purplesoft@cix.compulink.co.uk.  Sharp Zaurus Freeware ASM S DK In late July Palmware announced the impending release availability of a free SDK for developing Sharp Zaurus applications. PILI is a PC-based macro assembler that creates binaries for a virtual CPU interpreter. The binar y image is downloaded to the Zaurus for execution. Applications created with PILI cannot be commercially distributed, but they can be made available as freeware. Palmware is working on licensing details for commercial PILI-created applications. The PILI virtual CPU is a 32-bit architecture, with an 8K stack and 256 general-purpose registers. All registers can be used for all operations. Op codes include full arithmetic and bit operators, register manipulations, test, jumps, loops, and stack manipulations. There are macro-assembler library calls for more powerful functions like GUI operations, graphics, and basic input/output operations. For more information contact Palmware at 100014.1025@compuser ve.com.  In a move IBM offices are hailing as a major step in the company's ongoing worldwide telecommunications revolution, M'wana Ndeti, a member of Zaire's Bantu tribe, used an IBM global uplink network modem yesterday to crush a nut. 4 P DA De velopers 4.5  Sept/Oct 1996   New Technologies, Existing Carriers Andrew M. Se ybold  Wireless Internet Is Coming Most of the ar ticles you may read about the ""Wireless Internet"" and CDPD will feature AT&T Wireless as the lead player in this new combination of services. We have taken a different view of these announcements and our observations are as follows. The stor y begins with Unwired Planet, a company that was founded in 1994 as Libris. Its mission was, and is, to deliver an open platform for wireless Internet appliances. Unwired Planet's vision encompasses such devices as cellular phones and two-way pagers. On July 12, AT&T Wireless Services announced its ""Wireless Internet Appliance,"" the AT&T PocketNet Phone, and CDPD as the wireless data network of choice for these new phones. Unwired Planet announced its UP.Link platform and applications written in Unwired Planet's open language, Handheld Device Markup Language (HDML). Unwired Planet's UP.Link Browser is an HDML browser optimized for embedding into cellular phones and pagers. UP.Link is a middleware server that facilitates billing and optimizes communicat ions between wireline and wireless portions of the Internet. UP.Mail is a full-featured two-way paging service for the UP.Link platform.  Not To Be Confused with Web Browsing! Anyone who expects to find anything in this article about World Wide Web graphical image home page surfing with this software over a wireless network can stop reading! It is unfortunate that the word ""browser"" is used at all since ""browser"" has come to imply a graphics capability for the Web. Nor is it correct to discuss ""Web browsing,"" since the Unwired Planet software is about accessing specific information that resides on the Net or on other networks.  access their calendar, notes, and other information stored in the phone for recall. Which phone or system is best? We believe that the answer will depend upon the end-user community--who is using the device and for what pur pose--and it will depend upon users' perceptions of the availability of CDPD coverage as it is today and as it may be in the future. When the PocketNet Phone is w ithin range of a CDPD network, and the server side of the system has been set up to provide the types of information access required, we see it is a fast, efficient way to obtain timely and useful data in small doses. One of the most compelling demonstrations we saw was the ""find it"" capability of the system. We searched for a listing of movies close to our house. (This could just as easily have been food, lodging, gas stations, etc.) After entering our zip code, the system queried the Internet server and responded with a listing of four theaters within a short drive from our home. Scrolling through the listings provided additional information such as which movies were playing and their start times. Our first impression was that scrolling through a twenty-character by four-line screen would be a painful experience. However, when working with this type of information, it is easy to read, and moving forward and backward is a simple process to learn. Receiving e-mail is also easy, although we would not want to receive a document as large as a press release. It works well for short messaging. Composing messages takes some getting used to since each key on the keypad represents mult iple letters of the alphabet--2 is ABC, 3 is DEF, etc.--but it can be done. Since much of the ""intelligence"" of the system resides on servers and not on the phone, it is possible for menu-driven options and other shortcuts to be programmed to make it easier for the user to navigate within the system.  On the Other End The client/server model of compu ting is the key to the system. In this model, most of the intensive computing cycles are performed by the server, permitting the client to be the recipient of the information and not the engine behind obtaining it.  What This Really Is Phones and pagers that have been or will be enabled by Unwired Planet are not ""smart phones"" as we see them. Smart phones have a dedicated processor, an operating system, an onboard Personal Information Manager (PIM) for phone numbers and appointments, and some other bells and whistles. Phones that are enabled with Unwired Planet software become ""Information Terminals"" in the true sense of the term. They are not, at least in this generation, capable of storing large amounts of user data. AT&T does a credible job of explaining the differences between what has come to be known as a ""smart"" phone and what one market research firm has dubbed a ""Wireless Internet Terminal,"" or ""WIT."" Business Week insists on calling it an Internet appliance. AT&T's definition of what it has dubbed the ""PocketNet Phone"" includes the differences already mentioned as well as a price differential. PocketNet Phones w ill sell for around $500, while ""smart phones"" sell for between $1,000 and $2,000. The form factor also differs. Smart phones are bigger and bulkier than PocketNet Phones. The premise of the PocketNet Phone is that it is a voice phone into which a Net level of functionality has been integrated--such functionality being the ability to access computer information in a text format and display it on the same four or five-line by twenty-character screen used when making voice phone calls.  Multimedia/ Images  Bandwidth  It's the Network! Perhaps the best way to understand the difference between the two types of phones is to compare them when in and out of coverage. When both devices are within a coverage area, they can communicate over the network to send and receive data. When the PocketNet Phone is not within CDPD coverage, but is within AMPS coverage, it remains a voice phone but loses any and all ability to provide information. The PocketNet Phone can retain a smal l amount of information for future access, but it is not intended for use as a handheld personal information manager. On the other hand, anywhere a smart phone can communicate via voice, it can send and receive data. Of course, it will not be able to communicate when it is out of coverage, but users will still be able to  Text Figure 1 - AT&T's illustration of bandwidth vs. information format. An Internet-enabled phone is designed for text-based information. P DA DE VELOPER S  Information Format  4.5  Sept/Oc t 1996  5   The Unwired Planet model calls for a server between the c lient and the information ser ver. It is what UP refers to as a middleware server between the wireless Internet appliance and the server to be accessed. This middleware server provides several functions. In order of importance, to the network provider it is a real-time repository for transaction informat ion which becomes the input for any audit or billing system. (UP.Link supports multiple access control models--basic, premium, and pay-per-view.) It is also an interactive directory of available information and services, and it handles protocol translation and data compression functions to optimize the connection between the w ireline and wireless por tions of the network. The middleware server must be programmed to provide phone users with access to standard Internet sites. However, according to Unwired Planet, its Handheld Device Markup Language is a close cousin of HyperText Markup Language (HTML), the Internet programming language. Any programmer fluent in HTML should be able to quickly become fluent in HDML, and an application written in HDML will work over any UP-enabled wireless network and UP.Phones.   Access the latest airline travel information, such as flight arrival and departure times and airport weather and parking advisories, in any city. Automatically dial an airline reservation agent to arrange travel plans.  Obtain the latest ground-travel information, such as mass-transit schedules, fares, routes, for major cities.  C orpor ate Intr anet Applic ations  Use AT&T PocketNet Phone to check product inventory, price lists, order status, and deliver y schedules to close business in a fast, efficient manner while on the road. Select a company form or document and have it faxed to your customer for signature.  Stay up-to-date with company information and reduce your paper burden with quick a ccess to company bulletins or newsletters, directories, company meeting schedules, van pool schedules, and all network-resident corporate information. [Lunch menus on my cellular phone, hooray!]  Send urgent messages or scheduling information to remote workers such as photographers at the scene of breaking news. Reduce their equipment burden by sending the written information they need on a telephone rather than requiring them to carry a PC.  Track a package that's due to arrive from a major package carrier. Find out when it arrived at a central station, and when it will be delivered.  What AT&T Adds to the System AT&T is hoping that its new PocketNet Phones will help increase the acceptance and use of the CDPD network as it is today--an overlay of the analog cellular voice network. The AT&T announcement has sizzle, it has ""sex appeal,"" and anyone who tries one of these phones will initially be captivated by the speed and performance of the demos. AT&T is positioning PocketNet Phones for use with corporate intranets as well as with the Internet--a smart move on AT&T's part since we believe most use rs are initially more concerned about getting to their own corporate information than being able to find the closest movie theater. AT&T's press release provides insight into how it envisions these phones being used. Some of the applications discussed include:  Read and respond to your e-mail when a phone is more convenient than managing a laptop computer.  Access the latest financial news and recent stock quotations, find out the latest information about a particular company, then call a broker to initiate a transaction, all from the same phone, even when you're on the golf course or in a cab or restaurant.  Be on top of the latest weather conditions while on the road. Receive informat ion such as current conditions and travel advisories, temperature highs and lows, and five-day forecasts for most major destinations.  Look up names, phone numbers, and addresses for individuals and businesses wherever you go using a nationwide telephone directory.  Not A Very Compelling Story The above, w ith a minor editorial comment or two, is taken directly from the press material sent out by AT&T. Please remember that these phones display four lines of twenty characters each. It is difficult for us to keep this article upbeat when we read promotional material such as this. We want to keep it up beat because we believe that there is a ne ed for quick, easy access to information such as that provided by the Unwired Planet software system. We do not believe that wireless will have a one-size-fits-all device, just as it will not have a one-size-fits-all network. Unwired Planet has done a superb job of architecting a client/server model that provides information retrieval in devices that are not computer based. Further, UP understands the model of keeping the intensive computing at the server level, and has optimized the wireless data portion of its system for the best possible performance. We also believe that this model, when applied to short messaging in phones, pagers, and even over other two-way wireless networks has a realistic chance of becoming a successful standard. Our concerns lie with the marketing machine dr iven by AT&T's wireless division. Because this machine is a powerful one, with many creative folks driving  Figure 2 - HDML servers will be maintained by AT&T, net work providers, and corporate sites if desired.  6  P DA De velopers 4.5  Sept/Oct 1996   it, we are concerned that the tone of this announcement is one of hype that will set unrealistic expectations for the PocketNet Phone. AT&T's wireless division's similar marketing practices in the past have had a negative effect on the rate of acceptance of any and all forms of wireless data. If positioned properly, the PocketNet Phone should be an attractive option for many existing cell phone use rs. Kendra VanderMeulen, vice president and general manager of AT&T Wireless Ser vices, really hit the mark with her statement in the press release: ""The device makes a surgical strike into the Internet to extract the precise information you want, when you want it. The result: Individuals and organizations will exploit the true essence of the Internet--its core content--w ith speed and ease they've never experienced."" Yet in the balance of the p ress materials, AT&T appears to be positioning these devices to provide access to long documents and other such informat ion that will be painful to read on a four-line by twentycharacter screen. We hope that Ms. VanderMeulen's vision for the products is the one that sticks to the PR and advertising agencies' walls over the next few months.  Questions We do not question the technology. Unwired Planet has done a great job in providing the necessary tools to turn a voice phone into an information terminal. We do question whether the CDPD footprint is sufficiently robust at this stage in its deployme nt to satisfy PocketNet Phone users, and we wonder how long it w ill take before the enabling servers are installed by corporate MIS departments. We have no doubt that over time this technology will be important to certain segments of the market. Early adopters of these phones must have a clear understanding of the limitations they will face in coverage and in the amount of information that is practical to review on a PocketNet Phone. If they truly understand these limitations and sign up for the ser vice, they w ill most likely find it a great experience. Being able to access information on demand, within seconds, is a comp elling stor y.  The real issue is of how much value users will perceive these devices to be when they are out of a CDPD coverage area. Using CDPD for access, the sy stem's response t ime is impressive. If dial-up access over either analog or circuit-switched CDPD is required, we believe that the experience will be too painful for users to endure. While other CDPD service providers will be announcing agreements with Unwired Planet to provide services, at the time of this announcement, AT&T stands alone. AT&T presently covers sixteen areas with its own CDPD network and, with an ag reement from Ameritech, it can offer ser vice in six additional cities. AT&T states that it does not consider a market to be ""commercial"" until it has at least fifty p ercent of its cellular footprint CDPD-ready. As we go to press, AT&T claims to have 100-percent CDPD coverage in ten markets: Austin, Dallas, For t Lauderdale, Miami, Minneapolis, Pittsburg h, Portland, Salt Lake City, San Antonio, and Seattle. The other AT&T cities include Las Vegas, Minneapolis/St. Paul, New York/New Jersey, Oklahoma City, Sacramento, and Tulsa. According to the CDPD Forum's report card of the top fifty MSAs, forty markets offer at least core-level CDPD coverage, with most offering full coverage. A total of 57 of the top 100 markets have coverage. Conversely, 43 of the top 100 markets have no coverage. CDPD se rvice providers include AT&T Wireless, Bell Atlantic/Nynex, GTE, and Ameritech.  The Wireless Internet AT&T appears to be initiating a major push into wireless Internet activity. With the PocketNet Phone, it has a viable tool. If it keeps its marketing hype in check, AT&T should find an audience of users who will take to these phones and find them of value. However, if AT&T promises too much to too many, this new push will result in more unmet user expectations and yet another step back for wireless data. We hope for the good of all concerned (including the ""other"" wireless network providers) that AT&T will use this exciting new technology to grow its business and expand the overall perceived usefulness of wireless data.  1-2-3 Start Tracking  Bug Tracking the Macintosh Way  TestTrack is ready to use right out of the box-- simply install, add a few users, and start tracking. It's that easy.  ""I am managing over 300 bugs in four programs. Thank goodness I found your program!!! The next release will be organized."" Rick Shields, MedImage, Inc.  TestTrack is more than an easy-to-use bug tracking program--it's a powerful quality control tool for busy software developers:  er, Dear PDA Develop  Automate TestTrack automates the tedious and error-prone process of reporting and tracking bugs by hand. It also eliminates the need to create a custom solution using general purpose database tools such as 4DTM or FileMaker ProTM.  Communicate TestTrack links engineers, testers, managers, even tech writers together so no one falls out of the loop. Team members are notified automatically when defects are assigned to them, guaranteeing communication and ensuring efficient work flow.  Stay up to Date TestTrack lets any authorized user look up the current state of any defect at any time.  Analyze TestTrack makes reporting easy-- point, click, print and read. Customize reports to list what you want to see. Check the History Do you want to know who reported the most bugs, how many are still open, or how much time a user spent fixing bugs? This information and more is just a click or two away. How about a bug's history--who found, fixed, and verified it-- all of the details are available.  Filter out Noise Use TestTrack's powerful filtering feature to see only the information of interest to you. For example, create a filter to list only highpriority problems. Create another to list only feature requests for the next release.  you really have killer PDA app, do the next When you're developing oo? tools t time to build your Mac-based more of today's top and the tool more and Discover feature requests, o track their bugs, t developers are using stTrack. information--Te customer o om consultants t all PDA developers--fr Call Today-- for TestTrack is ideal e de velopers. ware and hardwar cial soft commer the Macintosh way! and start tracking To order 81 fax 513-683-17 513-683-6456 call om e-mail sales@seapine.c  Seapine Software, Inc. 1066 Seapine Ct. Maineville, Ohio 45039  For more information info@seapine.com http://www.seapine.com P DA DE VELOPER S  Seapine S S Software 4.5  Sept/Oc t 1996  7   Reviews Informed Filler for Newton John Schettino GTE Laborat ories, Inc. js12@gte.com Rating 3/4 out of 5 Pros Seamless desktop connectivity, powerful interface objects, large feature set. Cons Limited support for e-mail submission of records. Forms and records must be exchanged via direct connection. Price Informed Filler for Newton, including Informed Designer for Macintosh - $195 Informed Filler for Newton, including Informed Designer and Informed Manager for Macintosh - $390 Shana Corporation 9744 - 45th Avenue Edmonton, Alberta, Canada T6E 5C5 403.433.3690, 403.437.4381 (fax)  versions of the same form (for desktop and Newton) that are laid out differently but share fields. In this case you give each form the same identifier. Forms have a master page (things dr awn here appear on every page) and up to 99 body pages. Each page contains one or more objects that suppor t input. Each input object can also contain help text that the user can access while filling in the form. Newton forms can use the following objects: Fields are basic entr y boxes. They include text, number, date, time, telephone, and picture. For textual fields you can specify the font, size, style, and alignment. Check boxes These are standard Newton check boxes. The label is always to the right of the box, and is always displayed in 9-point Geneva. Radio buttons Radio Buttons are implemented for choice lists if the list of choices is small enough to display within the bounds of the object. If not, then the choice list is displayed as a pick list. The templates provided with the package provide pre-made radio button clusters for two to six choices. Tables Tables are multi-column and multi-row objects. Each row is edited via a detail view that is generated automatically by Informed Filler. The table may optionally include a title. Although you can define columns with different widths, they are displayed with equal widths on the Newton. The number of rows and columns is fixed in a table. Font, size, and style are not configurable for tables. Text Text is static text used for form labels. You have full control over the font, size, and style of the text. Graphics Graphics are not supported in Newton Filler, but are suppor ted in the Informe d Filler package. There is a powerful scripting system that you can use to add intelligence to a form's fields. Information can be extracted from other forms or from the owner informat ion of the Newton. A large suite of math, date, time, and string functions, plus basic conditionals, are provided. Some of these extended features are not supported, or are supported with restrictions, on the Newton. You use the portrait and landscape stationary files and drawing library to simplify creating forms correctly sized for a Newton. You select the desired orientation for the form by opening the corresponding stationar y file, then copy objects from the drawing library to quickly lay out the form. Editing Tool Bar Form Window Name from Newton Owner Information Current Date Current Time Town Pick List Table with two text fields and one pick list  Fields  I  f your business revolves around forms, the Informed suite of applications is for you. The Newton package consists of the Informed Filler for Newton application and a CD ROM containing the Macintosh-based Forms designer tool. A separate package, Informed Manager, is used to manage form definitions and filled-in forms on the Macintosh. The idea behind this product is that there are already thousands (if not millions) of forms used in all kinds of businesses. Insurance forms, invoices, orders, payme nts, requisitions, and so on. This suite of tools lets you define, on the Macintosh, complex forms with spreadsheet-style calculated fields. These forms are then downloaded to the Newton where they are filled in. Completed forms are uploaded back to the Macintosh for further processing .  Install The Newton package comes on a diskette and a CD ROM. You first install the Informed Designer package onto your Macintosh. A full installation uses about 25 MB of disk space. Then you install the Informed Filler for Newton diskette. This installs an updated version of Informed Designer on the Macintosh that contains Newton connection functions. It also installs example Newton-sized forms and some layout templates, and two Newton packages. To complete the suite, you instal l the Informed Manager software off the final diskette. Compounding this already long install process is the requirement that you reboot your Macintosh after each installer completes its job. 25 MB disk space and three reboots later, you're ready to install the form tool on the Newton. You install the packages on your Newton using the supplied package installer. The ""Informed Filler.pkg"" tool and the ""Filler Guide.pkg"" help book are each 185K.  Using Informed C reating F orms on the Macintosh Forms creation on a Macintosh is much simpler then forms creation on a Newton. Let's be honest: a large color or gray-scale monitor, full-sized keyboard, and mouse make laying out a form easy. On the Macintosh, you create forms using Informed Designer (two stationary files are included pre-sized to the MessagePad portrait and landscape orientations). Each form is assig ned a unique identifier for differentiating it from other f orms in the system. You can create two Figure 1 - Page 1 of an accident report. Form Layer/Page number  8  P DA De velopers 4.5  Sept/Oct 1996   Figures 1 and 2 show a completed two-page form as displayed by Informed Designer. The form has several input objects to let an officer gather details about the accident and the parties involved. Once finished, you install the form on the Newton. On the Newton you launch Informe d Filler f or Newton, Tap the form Tab, and then tap Receive. Transfer is done using a serial connection and is reasonably quick. This form took about 20 seconds to transfer.  Conclusions The Informed suite is a p owerful and flexible forms system. Informed for Newton supports multiple forms, excellent desktop connectivity, full Newton 2.0 user interface components, and routing features. The desktop suite of tools for creating forms and processing records is simple to use and quite powerful. This review only scratches the surface of its functionality. The scripting capabilities provide for form interactions, field validations, and very complex forms. Just about anything you can do with a desktop form can be reproduced in a Newton version. This tool could be greatly enhanced by supporting e-mail and wireless exchange of both new Form definitions and records. Even without these features this is a serious forms tool for Newton.  On the Newton When you start Informed Filler for Newton for the first time, it installs an example form. This is obviously a work-around, since you cannot delete all forms on the Newton. The default form is loaded and displayed. After downloading , Figure 3 shows page 1 of the Accident Report form filled out on the Newton. Entering information is simple. In addition to standard Newton pen input, the Filler also supports the external keyboard  the Tab key moves you through the form from left to right and top to bottom. By using pick lists, radio buttons, check boxes, and drawing fields, you can greatly reduce the amount of text entry required to complete a form. After creating one or more records, you can then upload them to Informed Manager for further processing. Tapping on the i displayed in a field's title (see Figure 3) opens a slip with the help text for that field. The Tab at the upper right-hand part of the screen is a form chooser. You can instal l a large number of forms on the Newton and quickly switch between them by tapping on this button. The Newton changes orientation to match the current Form. You can navigate to the next and previous records using the silkscreen arrows at the top of the screen. The Newton overview button displays an overview of all entered records. You can bulk-upload all unsent records from the overview.  Pages of Form Navigator  Form Chooser and Form Connection  i Indicates help text available Date and Time Pickers use Standard Newton 2.0 Date/Time Pickers  Town Pick List  On the Desktop To capture records back on the Macintosh you open the same form inside of Informed Manager. For my p olice report example, I created a combined form that places all the fields on one page (see Figure 4). As long as it has the same form identifier, Informed Manger accepts the data from the Newton in the new form. You then select the View, Receive From Newton... command and send the record form to Newton. Once uploaded, you can review, edit, and fur ther process the records in the Manager.  Record Navigation Route Actions include Print, Fax, Beam, Bail, About, Send to Destktop, Delete, and Clear  New Record  Figure 3 - Newton interface.  Newton Draw/Sketch Area  Figure 2 - Page 2 of the report.  Figure 4 - A completed form in the Manager. P DA DE VELOPER S  4.5  Sept/Oc t 1996  9   Newton User Interface Guidelines Ken Knight IA, Inc. knight@sphinx.biosci.wayne.edu Rating 1/2 (on a five-point scale) Pros A thoroug h set of guidelines for designing proper Newton user interfaces. Cons Coverage in some areas is not as complete as it could be. Some aspects of the user interface are still vague. Price $24.75 by Apple Computer, Inc. published Addison-Wesley Publishing Company, Inc. ISBN: 0-201-48838-8, Apple item T1986ZA 800.282.2732, 716.871.6555, 716.871.6511 (fax) 800.637.0029 (Canada)  Newton Software Interfaces The Newton's interface is still quite young . Whether it survives the test of time depends largely on how developers treat it. Apple's Newton User Interface Guidelines are meant to ensure that developer products follow the established Newton interface rules, while still allowing developers the freedom to expand the interface in new directions where appropriate. By using this book when designing a Newton program, you can guarantee that people who are comfortable w ith the Newton are also comfortable w ith your program. If you ignore what is presented in the book, you run the risk of losing customer support and creating headaches for yourself with unnecessary technical support and difficulty improving your product's usefulness over time. The Newton User Interface Guidelines cover a wide range of topics, including how and when to use certain Newton controls, view types, working with icons, data input and editing gestures, and more. Not only are issues of when to use an interface element examined, sometimes in great detail, but specific design considerations for the primar ily penbased Newton system are considered. For example, the guidelines recommend placing the primar y controls of an application at the bottom of its display, preventing the contents of a view from being unnecessarily obscured by a user's hand each time a primar y control is tapped. The book has some limitations. For example, the action button is dealt with in a cursor y fashion, which leaves unresolved whether it is acceptab le to extend the popup to include other action items besides ones with obvious communications aspects, duplications, and deletions. Is the action picker the right place to put actions to encrypt data or provide a set of filters for some type of dig ital processing? The answer to the former is probably yes, but the answer to the latter question, esp ecially if there are many processing options (say an application that does sound processing), is probably no. Another example involves using the status bar button versus an auxiliary button like those found in an outline in the Note Pad. Developers can reasonably infer that auxiliary buttons should only be used in specific cases, while status bar controls should be used if their functions are of a more general nature, but this is not actually stated in the book. While I have some complaints with the completeness of this reference, it's only the first edition and, like the Newton itself, will no doubt improve. Many ne w user interface issues have been raised with the introduction of PDAs. This book is a good place to start when building an interface for your software. Apple has not only authorized a printed edition of this tome, but has also placed DocViewer and Adobe Acrobat versions at their Newton developer web pages (http://devworld.apple.com/dev/newton/techinfo.html). These on-line versions are accessible to anyone who has Internet access. Although this book has some flaws, it should be read by e ver y Newton developer, from hobbyist to professional system integrator.  P  aying attention to interface design has a dramatic effect on the quality of any product. Consider for example the car. The place ment and use of the steering wheel, gas pedal, brakes, gauges, and clutch all fol low conventions that everyone understands. Imagine if every car model placed its controls in radically different pla ces, labeled them differently, and provided different responses for controls that are labeled the same. To say the least, driving would be more difficult and less enjoyable. On the other end of the spectrum, VCRs have user interfaces that people find intimidating and therefore tend not to use. Every VCR I've seen has different programming and setup me thods. Some are menubased and leave little room for interpretation. Others, though menubased, provide such a maze of options it's difficult to figure out how to create a program. There is no standardization. Directions are often confusing and leave a person wondering if their VCR is programmed correctly.  Software Interfaces  Computer programs fall somewhere in the middle of this spectrum. Some computer systems provide few standard user interface tools; others have considerably more. A well-designed user interface, especially one that follows the rules laid down by the computer system manufactures, attracts and keeps customers. One reason the Macintosh has done well over the years is that Apple created a powerful-yet-friendly interface and then provided developers with a set of guidelines to ensure that their programs use the interface to best advantage. A person using a Mac program expects certain things, such as the cut, copy, paste, and undo commands, to always operate the same way. Programs that do not follow the conventions for these commands, or omit them entirely, frustrate users. Contrast the situation on the Macintosh to that found in many Windows 3.x programs, which use many different conventions for similar tasks. Microsoft provided few guidelines for people to fol low. The user info@nsbasic.com www.nsbasic.co m experience suffers because of it. A good user interface must be consistent, provide Tel 416 264-5 clear and concise metho ds to accomplish tasks, and be Fax 416 264-5 flexible enoug h to allow for growth over time without sacrificing clarity. The Macintosh has managed this fairly well while other systems have had varying degrees of success. NS BASIC Corpora 77 Hill Crescen Toronto, Canada M 1J3  ... BASIC for the Newton NS BASIC is a complete implementation o which takes full advantage of the rich N e enviroment. Easy to use interactive envir develop and run your programs immediate Features         Lots of window objects Serial and IR Comms Indexed files Graphic and Scientific funct 240 page Handbook PC and Mac connectivity Callable from other applica Create your own packages  Requirements Any Newton 2.0 or 1.x device  $99. 0 plus 5.00 shipp  10  P DA De velopers 4.5  Sept/Oct 1996   The OmniGo 100 Scott Sbihli Procter & Gamble scotts6487@aol.com Rating (on a five-point scale) Pros Speed, Graffiti, price. Cons Some programs are not full-featured. Flimsy case. Price $349 (with 1 MB RAM), $49.95 (Bindery), $119.95 (Connectivity Kit) Hewlett-Packard 1000 N. E. Circle Blvd., Corvallis, OR 97330 541.715.2004, 800.443.1254, 541.715.5488 (fax)  icons which are single-click shortcuts to the built-in applications. One of the icons rotates the OmniGo's display 90 degrees letting you choose the device's orientation. The other half of the unit has a 67-key keypad that includes chicklet-style alphabetic, digit, punctuation, cursor control, navigation, and function keys. They're too small for touch typing, but any typist can enter data at a reasonable clip after a little practice. The right side of the keyboard sports a Type II PC Card slot. The left has a proprietary serial interface for connecting the OmniGo to a PC. My unit was the 1 MB version. It had around 410 KB free for my use. One characteristic of the OmniGo 100 I'm sure I dislike is its constant creaking. Like a 1984 Chrysler K car, this thing creaks and groans when you open it and hold it. Its case doesn't feel nearly as rugged as my Newton. I have no hard data to prove this, but if anyone is willing to lend me a Newton, an OmniGo, a pair of goggles, and a sledgehammer, I believe I could put together an experiment.  Consistency is Everything  P  erspective. The whole world is perspective (and reference points). Do you realize how poorly built a Chevette is if you've never driven or ridden in another car? I used to believe that Minute Maid frozen orange juice was the quintessential breakfast drink, until I stopped at a roadside stand in Orlando and had a huge glass of freshsqueezed orange juice for $1.00. Needless to say, my taste buds whimper each time I drink the frozen stuff. Going from the Newton to an OmniGo produced a similar experience. I'm not saying that the Newton is frozen OJ and the OmniGo fresh squeezed, but the Newton did g ive me a solid reference point, a perspective, for deciding which PDA features are most important. I've spent the last month living w ith an OmniGo and without my MessagePad 120. How did I fare?  The Form Factor Out of the box, the OmniGo 100 is decidedly smaller and lighter than the MessagePad 120. It's roughly the thickness and width of a Newton, but its length extends from the top of the Newton to the bottom of the Newton's screen. Unfortunately, the OmniGo is still a tight fit for a man's shirt pocket. The case is charcoal gray and feels slightly less sturdy than the Newton's tough shell. This PDA runs on two AA batteries and a single three-volt backup battery. An external power source isn't an option, unless HP's figured a way to run the unit on static electricity. The OmniGo opens like a paperback book with one half containing a 240 by 240 pixel, one-bit display (see Figure 1). The display opens all the way and folds back so the keyboard and screen are back to back. If you think the Newton has a cr amped screen, you're going to find the OmniGo positively tiny. On either side of the screen are permanent  The consistency of the OmniGo's application interfaces is impressive (see Figure 2). In the upper-left is the gadget for closing an application. In the upper-right, there are gadgets for scrolling up and down, for sw itching pages, or for switching pen mo des. There are five function keys in a tidy row at the bottom of the screen. You can either use the stylus to click a function-key button or press a corresponding key on the keyboard. These buttons are used within all OmniGo applications. They do things like start a new note, edit a database, or present a menu with a list of items. The utility button is in the lower-right corner of the screen. Depending on the currently running application, this button's menu controls application preferences, standard cut, copy, and paste functions, and print utilities. All of these design choices result in a PDA with a consistent interface between applications, and a reduced learning curve, where users spend less time figuring out each program. OmniGo printing is done using the unit's proprietary serial interface. All applications support printing through the utility menu. You set your default printer choice using a program's preferences menu. Choices includes LaserJet, InkJet, Epson 24 pin, IBM Proprinter 24 pin, and Canon BubbleJet printers. You can print both application-specific information and screen shots.  This PDA is Loaded OmniGo's standard list of software is imp ressive, giving it much more utility than the Newton out of the box. The OmniGo 100 uses a wellestablished operating system called GEOS. Graffiti, an excellent but overly-hyped set of handwriting-recognition algorithms, is integrated into GEOS. The OmniGo ROM includes an appointment book, a phone book, a note-taking program, a database, a new car, a program for jotting notes,  Figure 2 - The OmniGo's outstanding interface consistency. P DA DE VELOPER S  4.5  Sept/Oc t 1996  11   a financial program (Cash flows, amortization, and more), an HP 12C calculator emulator, a spreadsheet, a book reader, a world time program, a trip to the Caribbean, a stop watch program, and solitaire. (By the way, two things in the previous sentence you don't get with OmniGo; I included them to hold your attention.) Each of these applications does an average or better job at their task, but you may want to replace a few with third-party solutions. Documentation is also one of the OmniGo's strong points. The manual is a solid half-inch in thickness. If you own an HP calculator or printer, you know how copious the documentation that accompanies it is. The OmniGo is no exception. It's filled with screen shots and stepby-step instructions for using each program. Curiously the only thing missing is a set of OmniGo technical specification in the Appendices.  Gr affiti Graffiti has received many positive reviews. Originally designed to improve the Newton's handwriting recognition, Graffit i relies on your creating ea ch character the same way each time. Moreover, each character is created with a single stylus stroke. (For instance, the letter ""A"" is written with a stroke which lo oks like a carat (""^"").) Instead of having to recognize the first letter of the alphabet any number of ways in which a person can write it, Graffiti only works with one type of stroke. You would think Graffiti would do an excellent job recognizing handwriting. I had some significant problems getting the OmniGo to recognize certain characters. Graffiti supports the alphabet, numbers, punctuation, and other special keyboard characters, like """"and """". That's a lot of strokes; when different strokes have only minor variations, recognition can suffer. If you compare Graffiti's recognition to that of the original Newton recognition, Graffiti is a marked improvement. Graffiti is a modest improvement over the Newton's cur rent recognition algorithms, but I like the ability to write my characters any way I want. If you are willing to invest time in learning this alien-race alphabet, you can have recognition speeds far faster than the Newton.  ing appointments. You can set an alarm to remind you of an impending appointment. This alarm is flexible in one minute inter vals, with a fiveminute default One impressive feature that beats the Newton hands down is the OmniGo's week view. You can see all seven days of the week as well as twelve hours of the day. Each hour-long block with a scheduled event appears as a shaded block. The Newton attempts to show you information for each appointment  you can't get a very good overview of your week with the Newton. I much prefer seeing how busy I am during the whole week, even though I can't see exactly what things are scheduled. The to-do list shares numerous features with the Newton. Give the task a description, a start date, and a due date, and then set the priority. Unfortunately, the OmniGo treats the to-do list and schedule as separate items  you have to manually switch between their views. Another noticeable feature of the OmniGo's Appointment program is speed. (This applies to all OmniGo applications.) Switching between views is expedient, and editing appointments is quick. This feature is un-Newton-like and a pleasant surprise.  Phone Book Program The Phone Book shares some interface features with the Appointment Book. Unfortunately, the Phone Book is one of the OmniGo's weak points. The information it tracks includes a name, a ddress, home phone, work phone, fax number, company name, title, and the allinclusive ""Other"" category (see Figure 4). Phone Book is woefully inadequate given today's technological toys. Where are Cellular Phone, Pager, and School Phone? What about e-mail addresses? Even my mother has an e-mail account. These other contact points can't all be wedged into the ""Other"" categor y. With a Newton, you can add as many fields as you like and, more importantly, you can name the fields to suit your taste. I guess Hewlett Packard doesn't lie  it's a phone book and no more. Personally, I could never use it. I have too much information. Phone Book entries can be categorized and filed. Don't see a category that meets your needs? Make your own. I created a Volleybal l category to track all of the subs that I call. One nifty feature is the ability to choose the three Phone Book fields that the OmniGo displays. You can show Name, Address, and Home Phone (useful) or Fax, Title, and Category (not so useful). This feature is somewhat critical for the OmniGo since it only show three fields. The OmniGo lacks a business card or equivalent view that readily shows all of the data about a person. To switch between two listings, you must manually look at an entr y, page down to the second half of data, back out, and then select some one else.  Appointment Book/ To Do List The Appointment Book lets you to schedule your time and manage daily tasks (see Figure 3). At the top of the screen there are five tabs for five different appointment v iews. Appt displays daily appointments, ToDo shows daily tasks and Week, Month, and 4Month give different overviews of your schedule. The bottom of the screen also has five tabs for creating a new appointment, searching the database for an appointment, attaching a note to an appointment, showing today's agenda, and switching quickly to any day of the month. Appointment data includes a description of the meeting, and a star t and end time. Additionally you can make a me eting repeat at regular intervals including such odd times as every third 25th day of the month, or every other Wednesday. This give you great scheduling flexibility while saving time if you don't want to individually record oddly-repeat-  Note Sharing many qualities with an inexpensive word processor, the Note program supports justification, different type styles, two sizes of fonts,  Figure 3 - The Appointment Book shows a day's events.  Figure 4 - The Phone Book is one of OmniGo's major sore spots.  12  P DA De velopers 4.5  Sept/Oct 1996   digital ink, an eraser, and cut, copy, and paste. The screen is wide enough to show 28 columns with the larger f ont and 38 with the smaller (see Figure 5). Formal word processing is out, but it's very suitable for jotting d own small pieces of information. One of the OmniGo's most arresting features is speed and speed is what makes this applet valuable. If you know Graffit i, you should have no problems taking notes with reasonable alacrity. Pictures and diagrams require no processing after each shap e is drawn. If you click the Exit button in the upper-left corner of the Note's window, a Save dialog box appears. You can give your document a name and categorize it for future use. You are then sent back to the Note program's contents list to select a different note or create a new one.  Label Categor y Choice List Check Button  Static te Accepts Accepts Creates  xt for each record category selections from a user-defined set one choice from a pop-up list a non-mutually exclusive check box  Jot ter Jotter is an interesting program. It's similar to the Note application except that it holds exactl y one note of up to 20 pages. You can jot the note in text or digital ink for later recognition. Any page of the note may be ""stuck"" into another application. Not bad, but why do I need a separate application for small notes? Starting a note in the Note program isn't much of an inconvenience. While using Jotter I discovered an annoying limitation of the OmniGo. I was on vacation recently, playing cards with my parents. The OmniGo substituted as a pad of paper and pen for keeping score. After about two or three screens of ink, the PDA politely informed me that it had no more room for digital ink. I had very little data at that time.  The OmniGo vertical ly displays all of the fields you create. When you leave edit mode, you have to return to the database list, and select the newly created database to begin entering data. You can modify database records or the database structure at any time. The Database program is an interesting way to store user-defined data. It's a flat file database program, with no reporting capabilities, but I was able to make a more suitable version of the Phone Book application. In my version, I included all of the fields that the ROM-based Phone Book excludes. The Database program suffers the same display issues that the Phone program does: only three fields from a record can be displayed at a time (see Figure 6). Once again, my phone program is crippled, but this time from the screen size. Granted, I can define which fields I want displayed, but I certainly can't show name, address, phone, and fax at the same time. In combination with the OmniGo's Find feature, a business card view displaying all of the data from a record would be a valuable addition.  Financ e The Finance application included with the OmniGo includes a wealth of conversion and calculation utilities. To be honest, I don't know how to use some of them, and I'm sure that I probably won't need them on a daily basis, but here's a list:  Time Value of Money - Calculate loan amounts, payments, interest rate conversions, and amortizations.  Cash Flows - Useful for Internal Rate of Return (IRR), Net Present Value (NPV), Net Uniform Series (NUS), and Net Future Value (NFV).  Business Percentages - Calculate markup, margin, and percent changes.  Compound Interest - Determine investment appreciation.  Solver - Calculate the unknown value in an equation using an iterative process. It can also plot the result.  List Stats - Solve one and two-variable statistical models, fit a curve to data, forecast using ""what-if "" criteria, and graph data.  Conversion - Convert currency, length, volume, mass, area, and temperature. There are preferences for setting the notation of numbers: fixed point, engineering, or scientific, alo ng with the precision (see Figure 7).  Database When you think of databases, what do you think of? Oracle, dBase, gigabytes of data, volumes of documentation? Well this database's documentation is ten pages long. That should tell you something of its power. It also speaks volumes about how easy it is to use. To solve my problem of a grossly inadequate phone book program, I decided to use the Database program to create my own custom phone book. Starting the application displays a list of currently available databases, plus the number of records and the total byte count of the database. To make your personal database, either select New from the buttons at the bottom of the screen or choose Modify to alter an existing database. New brings up a blank screen with an Edit button at the bottom. Click on Edit to create a new field. Field choices include: Text Number Number +/Date Time Text Accepts only numbers Only numbers as well, but with arrows for incrementing/decrementing Date-formatted numbers Time-formatted numbers  Figure 5 - The Notepad organizes all notes in an alphabetized list.  Figure 6 - Create fl at file databases with the Database program. P DA DE VELOPER S  4.5  Sept/Oc t 1996  13   You can also set one of the calculations to the default start-up calculation. Finally, there is a setting for reporting ang les in either degrees, radians, or grads. One other interesting feature of the TVM, cash flow, stats, and solver calculations is the ability to save cases. You can input a set of data for a calculation, minus a piece of data you want to vary, and save it for later use. The OmniGo has an excellent set of financial utilities.  T he Ginsu Knives Included with all of the standard applications are three other programs: A calculator that is d ecidedly better than the one included with the Newton, a stop watch program, and a Solitaire game in case you are in a boring finance meeting. They're all fit programs, but I'd take the knives given a choice.  Conclusions Spreadsheets Spreadsheets. The g eneral, all-purpose, solves-everything, cures-anything application. You need one, OmniGo provides one. Spreadsheets can grow to a size of 64 rows by 64 columns (no Federal Budgets on this baby). However, other than the small sheet size, this application is extremely powerful  it's considerably more versatile and feature laden (sans graphing) than QuickFigure Pro, a third-par ty Newton spreadsheet. Here's a partial list of features:  Cells can contain labels, values, names, and functions. Names are particularly useful for creating formulas. Instead of using references such as ""C8"" or ""$D$3"", you can name a cell and use that name in a formula.  You can change the column width and align cell values left, right, and center.  You can insert and delete entire rows and columns.  Quickly entering data in a spreadsheet is cake. You can fill a row or column with a piece of data. You can also use a Fill Series command to load a range of cells with the days of the week, months, or numeric sequences.  Cell data can be protected to prevent accidental deletion or alteration.  You can also lock cells. In this case certain cells are shown permanently on-screen, while the user scrolls through the rest of the spreadsheet.  You can pre-d efine formulas and save them in a list for later insertion into a sheet.  There are almost 100 spreadsheet functions (see Figure 8). Besides the usual trig, stat, financial, and logical functions, there are cell informat ion, printing, and string manipulation functions. Cell information functions do things like count non-emp ty cells and check to see if a cell's contents are a number or a string. The printing functions return file names and the number of pages in a printed spreadsheet. The string functions do complex operations such as strip unprintable characters, convert strings to upper or lower case, and replace or repeat strings within a sheet. The OmniGo packs a wallop for its price. At less than half the cost a Newton MessagePad 130, but including most of the Newton's features, the OmniGo is a great buy. Unfortunately it isn't the quintessential PDA, but I don't think one exists yet. A number of the applications include features (such as the week overview in the Appointment Book) that the Newton just flat out misses. Speed is another plus for the OmniGo. It recognizes handwritten Graffiti characters as quickly as you can enter them. There is no lag. Launching applications is as quick. I find using the OmniGo enjoyable with this speed. It also makes me reluctant to go back to my MessagePad where I have to wait for everything to happen. I see that little light bulb at the top of the screen so much, I sometimes dream about it. My only hope is that Apple loses the squirrels and puts a real processor in the next Newton. The OmniGo does have some disadvantages. The phone book is abysmal considering the decade in which we live. As noted previously, if you take the time, you can construct a more suitable version w ith the database program. But why should I have to do that? HP made some physical design choices to save money. You have to decide if it's a good or bad thing. The OmniGo doesn't have an IR port. I don't miss it, but in the future when all desktop and laptop computers come standard with this features, I'll probably change my mind. The screen is smaller than Newton's and supports only one-bit graphics (unlike Magic Link), but I didn't buy this thing for image editing. The case's plastic feels cheap and the stylus broke the first week. Also, the OmniGo only runs on batteries  there is no power adapter port. Sound is limited to bleeps, blips, and bloops. You won't find any digital sound here (then again I'm not sure you really need it). All of this aside, OmniGo's $399 price is a steal for its features. If I were in the market for a PDA and price was a factor (isn't it always?) the additional $350 for a Newton isn't worth it. For org anizing your daily life, taking notes, and running mini-programs, the OmniGo is a superior product to Newton. If I get a pay raise next week or wake up one morning and realize I'm stuck in Bill Gates' body, I'd go for the Newton (Heck, maybe I'd buy Apple). It has a slightly more polished set of applications, an IR port, external power supply, and lots of shareware. The big question is: which company is going to introduce a next generation PDA with a bigger screen, faster processor and advanced built-in communications?  Figure 7 - OmniGo's strong suit is the Finance program.  Figure 8 - Each spreadsheet cell may contain a complex equation.  14  P DA De velopers 4.5  Sept/Oct 1996   Eessential OmniGo Accessories Scott Sbihli  Bookreader auto-detects all book format files on the OmniGo including the one you just installed. Happy Hypertexting.  Connectivity Pack Geoworks' Bindery 2.0 Digital Shakespeare. That's how you think of yourself. You wake up late at night w ith the plot of a most-excellent novel. Oh and by the way, you're a tree-hugger. So, how do you influence the masses with your symbolism, imagery, and philosophies without kil ling trees? You needn't look any farther than Geoworks' Bindery and its assorted utilities. The Bindery, Geoworks word processor, generates ""GPK"" files which can viewed on an OmniGo using the Bookreader. The Bookreader lets you to view multi-part files which contain text, graphics, and hyperlinks. Think of the Bookreader as a hypertext help program optimized to view long documents. It has facilities for scrolling through a long page, the ability to search for text, move forward and backward in a file, and show a history of pages you've viewed. Before I discuss the virtues of Bindery and related programs, I feel the need to vent slig htly about the environment in which Bindery r uns. It uses the GeoManager, which is essentially the Geoworks operating system. Granted, this OS is a nice piece of work. It has been well thought out and has an interface that is at least as good as Windows 3.1, if not more advanced in certain areas. My question is: WHY? Microsoft, Apple, and IBM pretty much own the whole OS market for PCs. Why do I need another OS for creating Bindery files? Why should I learn its interface? Geoworks should design the thing to run on Windows 95 and join the rest of the world. Bindery is a word processor not unlike the Windows 95 WordPad. It has all the basic features you'd expect in a word processor, plus some additional functions for handling graphics, setting up hyperlinks in documents, and designating graphics hot spots as hyperlinks. Import filters include Display Write, Microsoft Word, WordStar, WordPerfect, and RTF. Graphics themselves come from the other major application included with GeoManager, GeoDraw. GeoDraw can handle both vector-based and bit-mapped graphics. Outstanding features include object g rouping, multiple duplicating, skewing objects, gradient fills, splines, anchor points modification, Boolean draw modes, shading, and pattern fills. Import filters include BMP, CLP, GIF, PCX, and TIFF. GeoDraw is an excellent program. I just wish they would convert it to Windows or Mac. Once your tome is complete with graphics and hyperlinks, and it's been spell checked, you use the utility GEOS SDK Shipper to open your document and convert it into an OmniGo package. Finally, use the Installer application to transfer the package to the OmniGo. The No PDA is an island unto itself. It needs to be able to backup, restore, and exchange data with other computers. HP's Connectivity Pack for the OmniGo lets you do all that by connecting the OmniGo to a PC's serial port. The major options of this package are Hotsync, the Desktop PIM, export/impor t filters, and data restoration. The Connectivity Pack features are very similar to those available with the equivalent Newton software. Hotsync is the process of maintaining the same data on your PC as your OmniGo. The first time the Connectivity Pack is launched it asks you to do a Hotsync to get things going. The user's choice is either automatic or manual. Automatic Hotsyncs all of the data on the OmniGo and PC; manual lets you choose which files get synchronized. The Connectivity Pack uses time and date stamps to determine which files need to be in which place. Moreover, if a file is found in one place, but not the other, it is moved to the unit where it is missing. If a time and date stamp aren't sufficient for determining what to do (both PC and OmniGo have had their data altered), the Connectivity Pack goes so far as to compare individual records. Editing, creating, and deleting records w ith the Connectivity Pack is possible using the included PIM software. You may work with the records of the Appointment Book, Phone Book, and Notepad programs. Strangely all of the other applications are not directl y accessible or alterable w ithin the program. You can't look at, alter, or export spreadsheets, for example. Unfortunate. Nothing much needs to be said about export and import. Import interprets dBase, CSV, tab-delimited text, and the Phone Book, Notepad, and Appointme nt Book files of an HP 100LX or 200LX. If you import one of the first three types of files, the data can only be use d with the three supported applets in the Connectivity Pack and must be completely field-for-field compatible. Export filters include dBase, CSV, and tab-delimited text. The Connectivity Pack documentation is outstanding . Considering the relative simplicity of the utility, the manual is generous with descriptions, screen shots, and troublesho oting. It goes so far as to list the exact steps for removing the utility altogether. Kudos to the writers of the manual. The Connectivity Pack does its job and does it well. I hope a future release g ive users access to the other applications installed on the OmniGo and to third-party application data.  The Hand-held Systems Integrator Director y  100+ pages of profiles of systems integrators for all hand-held platforms, from low-end PDAs to high-end specialized terminals.  Extensive indices by platform, application area, and industry.  Separate sections for development tools and enabling technologies.  Hardware summaries of each of the popular hand-held devices.  Designed for anyone looking for hand-held solution providers or vertical market products.  A concise industry reference.  The Hand-held Systems Integrator Director y is updated twice a year. A single issue is $25 plus $5 shipping and handling ($7.50 outside North America). An annual subscription is $50/ $55 (includes shipping and handling). Major credit cards and US bank-drawn checks accepted. Call (415.621.4252), e-mail (hsid@cdpubs.com), fax (415.621.4922), or surf (www.cdpubs.com). P DA DE VELOPER S  4.5  Sept/Oc t 1996  15   Getting Started Multiple-Developer Magic Cap Projects Bruce Tong ZZTong@aol.com  I  t's not uncommon to see mult iple developers working on a sing le application in most segments of the computer industry. Application development for PDAs is typically different. Extensive class libraries and smaller applications with fewer requirements usually mean only one or two developers are needed. Unfortunately, because of this trend, the tools needed to support mult iple developers are usually an afterthought if they're even available. The good news for Magic Cap developers is that there are available tools. Even better, many of those tools are included on the CodeWarrior CDs or are freely available. What follows is a discussion of several issues surrounding multiple-developer efforts on Magic Cap applications.  One advantage of this approach occurs early on in the project  each scene can have its own entrance. This gets around the problem of being unable to develop deeply-nested scenes until the higher-level scenes are at least partially functional. However, this approach breaks down if one scene contains the majority of the functionality  you quickly get to the point where the small scenes are done and only one developer can work on the remaining scene. Another possible resource conflict emerges if several scenes have the same functionality. In this case, one developer locks many modules at once, preventing others from w riting code. One other thing to watch for when planning your module content is the hooks between the modules. For example, you might find it awkward to have view chains trailing back and forth from one ""Objects.Def "" file to another. Continuing on with the theme of org anizing the project by scene for example, you have to decide if ListViews are defined with the objects they summarize, or whether should they be grouped with the surrounding viewables in the scene in which the ListViews are presented. Either choice means b oth modules contain objects which refer to objects in the other module. A developer needs both modules to change this hook.  Images  Modules Large projects mean multiple definition and code modules. Multiple modules combined with multiple developers can lead to a configuration manageme nt nightmare that only a document control system can cleanly solve. There are several source code control solutions available for both the CodeWarrior Integrated Development Environment (CWIDE) and the Macintosh Programmer's Workshop (MPW). CodeManager can be purchased from Metrowerks, and Projector is included as an integral part of MPW.  N aming C onventions Small Magic Cap applications tend to place all of their object definitions in a single instance definition file named ""Objects.Def "". Of course, if you have multiple instance definition files, they must all have unique names. This is generally done by appending ""Objects.Def "" onto something descriptive. ""StudentObjects.Def "" and ""InstructorObjects.Def "" are both examples of this naming convention, which is also consistent with the way many of the MPW scripts are designed to work. If you use another naming convention, you'll find yourself fighting some of the MPW scripts and you'll have to modify any Makefile that MPW builds for you. By convention, class definition files end with a "".Def "" extension. This can be a little confusing at first since the instances definition files also end the same way. As with the instance file naming convention, the MPW scripts are designed with this convention in mind. You do not have to have a class definition file corresponding to each instance definition file, but you may find this helps keep things organized so you can intuitively know where each class is defined.  Images are central to the Magic Cap theme, and are easily converted by the Simulator into a form readily included in an object definition file. But these images tend to change over time and should be included in your document control solution. Unfortunately, applications such as SuperPaint don't know anything about source code control, and don't prevent developers from altering read-only designated PICT files. If you choose to use Projector, a handy trick for managing images is to copy them into a ResEdit file as a PICT resource. ResEdit warns developers if they're about to edit a file which Projector has marked as read-only. As an added bonus, ResEdit displays all of the PICT resources in a cataloglike fashion, so it's easy to locate the image you want.  Instance IDs It's a good idea to allocate blocks of instance IDs to each object definition file. This way developers do not have to check with each other when they need to create a new instance definition. Because a source code control system makes sure a module is being modified by one developer, they can safely create new objects within the allocated range. The MPW script ""GetUniqueInstanceID"" proves to be very valuable when a developer wants to create a new instance. In versions of the development environment prior to CodeWarrior 9, it returns the first unused ID g reater than the lowest used instance ID in the active file. As of CodeWarrior 9, this script searches through all ""Objects.Def "" files. If you plan to allocate ranges of IDs to each ""Objects.Def "" file, you may want to revert back to the old method. To do so, edit the script and change it to read: UnusedInstances ""{Active}"" -o > ""{Active}""  Module C ontent A significant challenge facing a development team involves deciding how the project's object definitions and code should be broken up over multiple modules. The goal is to organize the project into logical chunks and minimize resource conflicts. While there is no single best answer to this question, one possibility is to organize the project based on the application's scenes. In this case, each scene's object definitions are pla ced in a unique ""O bjects.Def "" file, and each scene's source code in its own "".c"" file.  This scr ipt calls an MPW tool named ""UnusedInstances"". This tool has several options which you can see by issuing this command while you're in the workshe et: UnusedInstances -h  Presently, the valid range for instance IDs is 1 - 9999. While this is plenty of IDs for even the largest of projects, choosing a range of values  A significant challenge facing a development team involves deciding how the project's object definitions and code should be broken up over multiple modules. 16 P DA De velopers 4.5  Sept/Oct 1996   for each instance definition module might be difficult if you're unsure how many objects you'll be creating in each module. To help manage these instance IDs, the ""Renumber"" MPW tool available at http:// www.spies.com/MagicCap/ is extremely valuable. Unfortunately, just like the Replace All option in the editor, changes to the instance IDs of any of your hooks aren't carried over into other definition files, so you have to manually change those references as well.  Psion OPL Localization Daniel Pfund pfund3@uni2a.unige.ch  Solid Code With multiple developers, it's less-likely any one developer knows ever ything about all aspects of the application. ""Intuition kills"" of bugs are less common, increasing the need for good diagnostics to be built into the application. A log file is a good way to accomplish this. It's also a good idea to write each method so it does its own parameters and derived values validation. As a project evolves, conditions change as to when and how methods are cal led. Moreover, while you may remember the last pla ce a specific ObjectID was validated, your co-workers are probably not as familiar with your code as you are. Consider the following code fragment which illustrates the use of important methods such as DirectID(), HasObject(), and Implements(), as well as how to put diagnostics into the log with DebugMessage(): /* Find the ObjectID of the current card */ currCard = DirectID( iCurrentCard ); /* Make sure the card exists */ if ( HasObject( currCard ) == false ) { DebugMessage((""myMethod()--currCard is bogus."")); PlaySound( iErrorSound ); return; } /* Make sure it's the type of card we want */ if ( Implements( currCard, myCard_ ) == false ) { DebugMessage((""myMethod()--currCard is not a myCard_"")); PlaySound( iErrorSound ); return; }  H  ave you ever wondered how you could distribute your p rograms to a wider audience? Apart from marketing and distribution problems, one key factor is program localization. Indeed, even though English is now the most common international language, you are simply not able to reach everyone with just an English program. If you've ever wondered how to localize your OPL programs without a hassle, read on. I cover all of the programming aspects you should be aware of. You'll see that it's extreme ly easy if you think about it from the star t.  Finding the Psion's Language First you to have to find out on which type of Psion (in a nationality sense) your program is running. This is the easy par t: Psion provides an operating system call that does just that. Here's some example code to show you how it works in OPL: i%=CALL($1B8B) /*GenGetLanguageCode*/ /* i% can take the following values: 00 01 02 03 04 05 06 07 08 09 10 11 */ Testing English - UK French - France German - Germany Spanish Italian Swedish Danish Norwegian Finnish English - USA French - Switzerland 12 13 14 15 16 17 18 19 20 21 22 23 German - Switzerland Portuguese Turkish Icelandic Russian Hungarian Dutch Flemish English - Australia English - New Zealand German - Austria French - Belgium  There is, of course, a price to pay for all this extra checking. Calls to each of these methods takes time and must go through the Dispatcher. Pre-processor directives to remove this code for a final build may be a nice compromise for applications which need to be optimized for execution speed. Another issue to watch is the use of indexicals. For example, in an application w ith several stacks of cards, the value of iCurrentCard may not always be a card from the stack with which you want to work. In this case, you need to locate the current card yourself. For example, change the first line of the above example to this: /* Find the ObjectID of the current card */ currCard = CurrentCard( myStackScene );  Finding the Psion's language is not everything; you should also let the user override their Psion's language. A lot of people have English Psions from UK because they are usually much less expensive than their local counterpart. Users can typically put up with the English programs. Although keyboard mapping was a problem some time ago, you can now use the excellent KbdMap shareware program to remap all your keys to whatever you choose. I let the user override the default by using an external file which contains the language code he or she wants to use. You can use other techniques, but this is a simple one. (All these examples come from my bank account tracking program called DPBank, which you can download from my home page or most other Psion FTP sites). Here's how the code above is expanded in my program: /* Attempt to find this file on any drive */ file$=fndfil$:("":\APP\DPBANK\LANGS.USR"") IF file$="""" /* File not found */ i%=CALL($1B8B) /*GenGetLanguageCode*/ IF i%<10 /*To make the lang$ string always a 2byte code*/ lang$=""0"" ENDIF lang$=lang$+GEN$(i%,2) /*If the user's Psion language is not yet supported */ IF NOT( LOC(""010208101123"",lang$) ) lang$=""01"" /*Default to UK*/ ENDIF /*Existing languages:  Conclusion It is possible to involve multiple developers simultaneously on a Magic Cap project. Useful tools exist and are readily available, although there is room for improvement. Successful coordination of the project depends primarily on two factors: project organization and developer discipline. Code and developer resource conflict issues are, for the most part, identical to those found in more traditional development efforts.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  17   01: UK 02: FRA 08: Norway 10: USA 11: CH ROM (->02) default to french if Suisse Romand 23: B FRA (->02) */ IF lang$=""11"" OR lang$=""23"" lang$=""02"" ENDIF ELSE /*Read User's choice*/ IOOPEN(i%,file$,$20) /*Open text file*/ IOREAD(i%,ADDR(lang$)+1,2) POKEB ADDR(lang$),2 /*Set LBC*/ IOCLOSE(i%) ENDIF  at means. I usually put the string's content in comments to the right of the line. For example: dINIT lang$:(29) /*""WARNING!""*/  This way it's very easy to maintain your program and even save space, since you can use the same string in several par ts of your program. You may also want to put some comments in the language file since your translator may not understand the exact context in which a sentence is used: words often have double meanings. Another important aspect is to always have the files up to date. I've had several problems when I changed, for example, the English file but forgot to update the French file. This is a real bug nest if you don't fully test your program in each language before each release.  The MENU Hotkeys Once you have the user's preferred language, you can either load an external OPO language file if your p rogram is big, or use it to vector into a specific language procedure (this requires that all languages are contained in one file, usually the same as the program). Of course, if you use an external file, you are responsible for checking for the file and taking appropriate measures if it doesn't exist. To add a final touch to each localization, it's a good idea to localize the Psion hotkeys for each action in your menu. This is a little more difficult than localizing standard strings since your main program cannot accommodate itself to various hotkeys dynamically. The trick around this is to use a hotkeys offset table: program the different menu actions in your local language and use a lookup table to vector into the appropriate action with the foreign languages. Sounds strange? Have a look at the code below: VECTOR LOC( lang$:(200),CHR$(key%) ) /*lookup table for Upper case hotkeys */ PROC lang$:(choice) VECTOR choice c1::,c2::,c3::,c4:: ENDV c1:: RETURN ""Hello!"" c2:: RETURN ""Goodbye"" c3:: RETURN ""Welcome back to DPBank"" c4:: RETURN ""Transaction:"" ENDP ua,ub,uc,ud,ue,uf,ug,uh,ui,uj,uk,ul,um un,uo,up,uq,ur,us,ut,uu,uv,uw,ux,uy,uz ENDV ua:: /*Auto descriptions maintenance*/ action for upper case ""A"" goes here ub:: /*Choice ""B"" from menu*/ put action here ...  Localizing Strings Once you have the appropriate language file loaded, it's simple to call the language procedure (I call it lang$:) with the number of the string you want it to return. For example:  Then, create the fol lowing lookup tables (lang$:(200) in the above example). For the original language, use ""abcdefghijklmnopqrstuvwxyz""  Notice the use of the VECTOR command. This command is highly efficient in OPL. It saves you a lot of precious space over a more traditional IF... ELSEIF... ELSEIF... ELSE... ENDIF sequence. Not convinced? Try to code the above with an IF statement and see how the two files differ in size. Of course, it isn't many bytes, but still I believe a byte counts a lot more on PDAs than on home PCs. You should strive to keep your program's memor y footprint low. The main advantag e to creating separate procedures for each language is that if you don't do the translations yourself, your external translator only ne eds to worry about one particular procedure. Also, he or she won't have to hunt through the whole program t rying to find strings to translate and risk missing some. Of course, the other advantage is that you only have one main program, and as a programmer you don't need to keep multiple copies of your source in various languages. The only drawback to this approach is the speed you lose because the OPL interpreter needs to load and unloa d the same procedure several times in a row (a dialog for example). If your program really comes to its knees, you can use some cache memory to attempt to speed it up. Although cache may seem very opportune, it's not a solution to everything. I've noticed that some programs run much faster with cache memory, but for others, it makes no difference. The only way to know is to t ry it with several cache sizes.  For another language, say French, use ""avcdm g i k eno frstuxpq ""  In the French version of the program, Psion-q for ""Quitter"" vectors into the same procedure as Psion-x for ""eXit"" in the English version because it takes the place of the ""x"" in the lookup table. I do a LOC using that string; LOC returns the position within the string, not the ASCII code for the located chara cter. It is a good idea to avoid using characters other than the normal 26 letters of the Roman alphabet. Numbers are bad  the French (for example) have to press the Shift key to get to the numbers and the case of the letter may influence your program's decisions. Ultimately, it's best to try the program directly on a foreign machine if you have access to one.  Conclusion In this article, I describe a simple but effective method for translating your OPL programs into other languages. As you can see, with a little programming effort, it's easy to translate a complete program in a few hours. All you need now are some translators.  Pr actic al C oding Tips When you create a fairly large program, you need to maintain it. When you look at the source, you'd like to know what the st ring you're looking  18  P DA De velopers 4.5  Sept/Oct 1996   Features Express Option Modifier John Blue jlblue@aol.com  I  n my ar ticle in the previous issue of PDA Developers, I talked about the Express Menu and described an IZL program to set up a cold OmniGo with a minimal Express Menu. The program was ver y static in that it provided only a predefined setup of my choosing. Once the program ran, the only way to modify the Express Options was to figure out which bits to flip on or off, convert the bits to a number, and edit the proper parameter line in the RAM-based ""NET.INI"" file. In this article I show how you can use IZL to help change the Express Menu's expressOptions parame ter within the [uiFeatures] section of the ""NET.INI"" file. I also point ou t some IZL features and quirks I ran into while developing the program.  Bits 15 through 11 are not used and should not b e set. What makes setting the expressOptions parameter cumbersome is that you must figure which bits to set, change the bit string to a decimal value, and place it in the correct spot within the ""NET.INI"" file. My IZL program, MINEXPME, helps manage all the details of the bit settings, converts them to a decimal value, and places the expressOptions parameter in the right place within ""NET.INI"". I use IZL to do the parameter setting because I have no other development system for the OmniGo. The only other way to create software is to use the GEOS SDK (which can require two PCs and wading through a CD that contains several megabytes of documentation). IZL, however, provides an on-board way to create programs to do things that are ""missing"" from the OmniGo.  Details of the Program. The main goal of the p rogram is to g rab the expressOptions parameter from the ""NET.INI"" file, display it in a usable form, provide a way for you to modify it, and put the new value back in the appropriate place. Before starting, I knew what I had to do to get the parameter to and from the file. I also knew what I needed to do to convert from a decimal value to a bit string representation and back. However, I did not know how I was going to present the parameter and let you modify it. A straightforward approa ch would have been to use a command line. This would entail asking questions as to what bits to set, getting the response, and pulling all the information together when finished. While this approa ch is doable, I picture having the ability to tap on any bit I want to modify at any time.  Too Many Parameters Within the ""NET.INI"" file there are many parameters that fall under a large number of section headers. Each of these parameters control some part of the GEOS operating system. The GEOS Software Development Kit (SDK) documentation lists 34 section headers or categories for the INI files. Listed under each category are many parameters defining the behavior for the category. Parameter values may be Booleans, numbers, strings, or lists. Further complicating things is that some numeric parame ter values are meaningful only if looked at as a bit-st ring representation. For example, the parameter expressOptions lists a number for its value; 11 of the number's 16 bits define the behavior for nine different Express Menu actions.  I Z L Objec ts IZL provides a way to present informat ion like parame ter bits as eventdriven objects; that's the underlying approach IZL takes as a language. All programs consist of controllable objects like buttons, frames, and labels. Button objects may have actions associated with them v ia functions. Other objects, like frames, have modifiers or properties that can be passed on to their children, which are also objects. For example, a frame can have modifiers like frame size, frame position, and frame child layout. IZL is not a full-blown, object-oriented language like Smalltalk, where all data types are objects and ever ything responds to messages sent to them. IZL limits its object orientation to interface construction and manipulation. It also lets you build hierarchies of interface objects for controlling one parent and affecting many children. In addition to interface objects, IZL has variables and functions (both built-in and user-defined) that you can use to control and respond to user events like pen taps. Variables can be strings, numbers, Booleans, and arrays of the basic types. You can also use arrays to control several similar IZL o bjects like buttons.  Express Menu Controlling Par ameters The Express Menu is controlled by one parameter (expressOptions) under the uiFeatures categor y and four parameters (floatingKeyboard, maxNumDirs, noSubMenus, and otherAppSubMenu) under the expressMenuControl category. For this article I concentrate on expressOptions. The expressOptions parameter is controlled by setting it to a value whose individual b its are on or off for a particular function. Below is a brief summary of the bits and their meaning. Read ""OmniGo Express Menu Setup"" in the July/August issue of PDA Developers for more detail on expressOptions and other Express Menu controlling parameters. Bit 10 = 1 Express Menu displays a list of the currently running applications. Bit 9 = 1 Express Menu displays all the applications in the ""\WORLD\DESK ACCESSORIES"" directory. Bit 8 = 1 Express Menu displays all the applications in the ""\WORLD"" director y. Bit 7 = 1 Express Menu displays a hierarchical list of the applications in sub-directories of the ""\WORLD"" directory. Bit 6 = 1 Express Menu displays a control panel area, for example, a link to the printer status window. Bit 5 = 1 Express Menu displays a list of DOS tasks accessible to the switcher. Bit 4 = 1 Express Menu displays a utilities panel. Bit 3 = 1 Express Menu displays an option to exit to DOS. Bits 2, 1, and 0 control the location of the Express Menu: 000 001 010 Display no Express Menu. Display the menu in upper left of the screen. Display the menu ""just below the bottom of the screen.""  But tons, Buttons, But tons The ability to create a series of buttons led me to design an interface with a button assigned to each bit. I created my interface first, experimenting with different approaches. The following is a result of the experimentation. While the code below is only an interface skeleton, doing no actual work, it does run. # Minimal Expert Mode Modifier interface skeleton variables; exp_bits = 11; expwrkstr = ""11111111111""; end; # Menu button setup menu_item menu_item menu_item menu_item save; display ""Save setup""; end; exp_reset; display ""Reset expressOptions""; end; about; Display ""About""; end; show_bits; Display expwrkstr; end;  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  19   # Interface frames frame userframe; hidden; vertical; hug_left; end; button params[exp_bits],userframe; display ""Parameter name""; end; frame aboutframe; hidden; vertical; center_h; center_v; char_size 30, 4; position 40,40; box; end; label info, aboutframe; display ""Minimal Express Option Modifier""; end; button about_ok, aboutframe; display ""Ok""; end; # frame for save file buttons frame saveframe; hidden; vertical; position 35, 40; box; end; label saving, saveframe; display ""Save expressOptions value?""; end; frame save_opts, saveframe; horizontal; end; button save_yes, save_opts; char_size 10,1; display "" Yes""; end; label filler, save_opts; display "" ""; end; button save_no, save_opts; char_size 10,1; display "" No""; end; # Frame & menu button functions function about; hide saveframe; hide userframe; show aboutframe; end; function about_ok; hide aboutframe; show userframe; end; function save; hide userframe; hide aboutframe; show saveframe; end; function save_no; hide saveframe; show userframe; end; function show_bits; hide aboutframe; hide saveframe; show userframe; end; function params; end; function exp_reset; call show_bits; end; function savexpopt; end; function save_yes; call savexpopt; hide saveframe; show userframe; end; function startup; show userframe; end;  This code allowed me to play with different layouts and frame sizes. I wouldn't say this is a perfect interface but it gets the job done. I'll leave the aesthetics to others to debate.  Walk Though the Fr ame Hier arc hy MINEXPME uses three interface frames. userframe contains the parameter bit control buttons. aboutframe contains the program title and an OK button. saveframe contains two children objects in a vertical layout: a label and a frame named save_opts. The save_opts fr ame is used to organize two buttons and a label in a horizontal layout. When the startup func tion is activated (startup is a special IZL function that is run before any user events are processed) it makes the userframe the active frame, displaying the parameter control buttons. Each button has a function with the same name. When a button is tapped, its function is run. Additionally, all the menu selections activate other functions.  Spec ial But ton C ase The par ameter buttons are a special case, because each of the eleven buttons activates the same function. The lines button params [exp_bits],userframe; display ""Parameter name""; end;  define an ar ray of buttons as children of the frame userframe. Each button is linked to the function params. This function figures out which button is tapped by looking at the special global IZL variable called invokersub. You can use invokersub to index mult iple arrays associated with a button. In this case, invokersub can have a value of zero to 10 (arrays are zero based). In the full program I link button zero to bit zero of the expressOptions parameter.  Hide and Show There are several functions that hide a frame while showing another. Since IZL is event driven, not hiding a frame while another frame is active can cause conflicts in code execution and make the interface look messy. Hiding a frame makes any child fr ames or buttons invisible and inaccessible. For example, if you tap the Save button, then the saveframe is displayed. If you decide to next tap the About button, the saveframe is hidden and the aboutframe is displayed. If this hide and show functionality is not put in the program, then the two frames are displayed simultaneously (see Figure 1).  Figure 1 - Overlapping frames.  20  P DA De velopers 4.5  Sept/Oct 1996   Difficult Interface Issue One of the difficulties I had to deal w ith creating this program was providing information before saving the expressOptions parameter to a file. I wanted to have the save_yes function display a message to a label area so you would know that something is happening while saving is selected (I felt this would be needed as saving takes longer than most people expect). I initially used a put statement to display a message in the filler area between the buttons. But nothing appeared when the program ran. Nothing appeared when I r an the program w ith the trace on either. This confused me, so I created a smaller example so I could concentrate on the actions involved. Here are two code examples that show some questionable actions by IZL (not doing what I would expect). # save interface skeleton number 1 menu_item save; display ""Save setup""; end; frame userframe; hidden; vertical; display ""user frame""; hug_left; end; frame saveframe; hidden; vertical; position 35, 40; box; end; label saving, saveframe; display ""Save expressOptions value?""; end; frame save_opts, saveframe; horizontal; end; button save_yes, save_opts; char_size 10,1; display "" Yes""; end; label filler, save_opts; display "" ""; end; button save_no, save_opts; char_size 10,1; display "" No""; end; function save; hide userframe; show saveframe; end; function save_no; hide saveframe; show userframe; end; variables; i = 0; end; function do_work; put filler, "" Working on stuff ""; i = 0; while i<30; i=i+1; end_while; put filler, "" Done working on stuff ""; end; function save_yes; call do_work; hide saveframe; show userframe; end; function startup; show userframe; end;  # save interface skeleton number 2 menu_item save; display ""Save setup""; end; frame userframe; hidden; vertical; display ""user frame""; hug_left; end; frame saveframe; hidden; vertical; position 35, 40; box; end; label saving, saveframe; display ""Save expressOptions value?""; end; frame save_opts, saveframe; horizontal; end; button save_yes, save_opts; char_size 10,1; display "" Yes""; end; label filler, save_opts; display "" ""; end; button save_no, save_opts; char_size 10,1; display "" No""; end; frame waitframe; hidden; vertical; position 35, 40; char_size 40, 4; box; end; label wait, waitframe; display ""Please wait""; end; function save; hide userframe; show saveframe; end; function save_no; hide saveframe; show userframe; end; variables; i = 0; end; function do_work; hide saveframe; show waitframe; i = 0; while i<30; i=i+1; end_while; hide waitframe; end;  The first example displays a basic userframe and one menu button to activate saveframe. I want to have saveframe have a message displayed after the save_yes button is tapped. However, the messages ("" Working on stuff "" and ""Done working on stuff "") do not get displayed. But, if you immediately re-select the save menu button again you see that the message ""Done working on stuff "" is now a part of the saveframe. This is confusing. Why does the filler message appear late? Does it require hiding the frame before any new things can be written? I decided to tr y another approach with another skeletal program: Figure 2 - The main window. P DA DE VELOPER S  4.5  Sept/Oc t 1996  21   function save_yes; call do_work; hide saveframe; show userframe; end; function startup; show userframe; end;  You must reboot the OmniGo by holding down the LEFTSHIFTON-NEXT keys at the same time in order for the changed expressOptions bits to take effect. Be sure to save the settings first. # Minimal Expert Mode Modifier  In this program I decided to hid e the saveframe while the work was being done. Unfortunately, this did not work either. It seems as if the frame control is running under a different processor thread than other code threads so that the work code gets executed, but the interface is not updated immediately, possibly delayed until a lower computing point (I am speculating here). Putting the tra ce on did not reveal any insight. At this time I still am tr ying to figure out how to make saveframe hide immediately when the ""Yes"" button is tapped. The above two samples indicate that something subtle is happening, and there is no clear explanation from the manuals to help. For the moment I decided to hold off on getting this part of the interface just right.  variables; # array of strings for on/off string values on_or_off[2] = ""off "", ""on ""; exp_bits=11; # number of parameters bits # variables for expressOptions exp_value exp_str = exp_found expwrkstr = 0; # expressOptions binary representation """"; # expressOptions bit string = FALSE(); # expressOptions found in NET.INI = """"; # working bit string  Instructions To use my final program, load in the source file. The program first reads the RAM based ""NET.INI"" (on the ""B:"" drive) file for the current value of expressOptions. Don't worry if the parameter does not exist in the ""NET.INI"" file  the program provide a default value of 0. The screen then displays all eleven bits as buttons with descriptors and the bit values (see Figure 2). Tapping on a button flips its value. The menu button at the bottom of the screen (the F2 button) contains four choices (see Figure 3): save the current bit setup, reset expressOptions to original settings, display some information about the program, and display the expressOptions bits as a binary string. ""Save setup"" displays another frame asking if it is OK to save the settings or cancel the saving p rocess. ""Reset expressOptions"" sets the expressOptions bits to the last values that were read in or saved. If you change some bits, save the settings, and change a few more, then decide to reset, you get the bits set from the last save and not from when the program started. The ""About"" command displays the program title with an OK button (see Figure 4). The last item, the bit representation of the expressOptions buttons, is some thing I used to help in debugging the program and decided to leave in. It demonstrates that even menu buttons can be written to after their initial creation (something I discovered by playing around with IZL  it's not mentioned in the manual). The program displays bits zero, one, and two individually even though all three together control the activation and placement of the Express Menu. I make them independently modifiable so you can experiment.  # display name of ini parameters plabnames[exp_bits]=""Express Menu Upper Left"", ""Exprees Menu Below Lower Left"", ""Bit 2 has no effect"", ""Show Exit to DOS"", ""Utilities Panel"", ""DOS Tasks List"", ""Control Panel Area"", ""Show World/Sub-Directory Apps"", ""Show World Directory Apps"", ""Show World/Desk Accessories Apps"", ""Show Running Apps""; ini_file = ""b:\geoworks\NET.INI""; # ini file to work on tmp_file = ""b:\geoworks\tmp.ini""; # temp working file i = 0; # scratch var str_len = 0; # string length end;  Figure 3 - The lone menu.  Figure 4 - The About window.  22  P DA De velopers 4.5  Sept/Oct 1996   # Menu button setup menu_item menu_item menu_item menu_item save; display ""Save setup""; end; exp_reset; display ""Reset expressOptions""; end; about; Display ""About""; end; show_bits; Display expwrkstr; end;  while i < exp_bits; put params[i], plabnames[i]&"" ""&on_or_off[VALUE(MID(expwrkstr,exp_bits-i-1,1))]; i = i + 1; end_while; put show_bits, expwrkstr; end; # # # # Handle selected parameter buttons note: IZL string LENGTH function is NOT zero based but IZL string MID function is.  # Interface frames frame userframe; hidden; vertical; hug_left; end; # # # # # # the array of the bit control buttons. Button x corrolates to bit x in the expressOptions value exp_str # & expwrkstr. This requires translation match. Strings are zero based accessed left to right (i.e.; the left most character is character number zero and the right most character is character number LENGTH(string)-1.  function params; # invoked when param button pressed # get value associated with object i = VALUE(MID(expwrkstr,exp_bits-invokersub-1,1)); # flip 0 to 1 or 1 to 0 # reflect new value i = (i + 1) % 2; # and store new value put invoker, plabnames[invokersub]&"" ""&on_or_off[i]; expwrkstr = LEFT(expwrkstr, exp_bits-invokersub-1) & STRING(i, 0) & RIGHT(expwrkstr, invokersub); put show_bits, expwrkstr; end; # # # # Reset the expressOptions values to those first read in on program start. If expressOptions has been saved then the old original value is gone.  button params[exp_bits],userframe; display "" ""; end; frame aboutframe; hidden; vertical; center_h; center_v; char_size 30, 4; position 40,40; box; end; label info, aboutframe; display ""Minimal Express Option Modifier""; end; button about_ok, aboutframe; display ""Ok""; end; frame saveframe; hidden; vertical; position 35, 40; box; end; label saving, saveframe; display ""Save expressOptions value?""; end; frame save_opts, saveframe; horizontal; end; button save_yes, save_opts; char_size 10,1; display "" Yes""; end; label filler, save_opts; display "" ""; end; button save_no, save_opts; char_size 10,1; display "" No""; end; # Frame & menu button functions function about; hide saveframe; hide userframe; show aboutframe; end; function about_ok; hide aboutframe; show userframe; end; function save; hide userframe; hide aboutframe; show saveframe; end; function save_no; hide saveframe; show userframe; end; # display parameter buttons' values and labels function show_bits; hide aboutframe; hide saveframe; show userframe; i=0; # zero based access to arrays  function exp_reset; expwrkstr = exp_str; call show_bits; end; # code to handle numeric conversions variables; digits = """"; # digits allowed in base digit_val = 0; # binary representation of single digit num_str = """"; # string representation of number num_value = 0; # binary representation of number index = 0; # pointer into num_str err_state = FALSE(); base = 0; # base of number end; # Convert string to a value # input parameters: # num_str = string needing conversion to a value. # digits = string of possible digits in num_str # base = base of num_str # out parameters: # num_value = value # err_state = TRUE() if there was a problem in function. # Code modified from HexCalc by Doug Taylor at the Ohio State University. function string2val; err_state = FALSE(); # remove control characters, make small case # characters upper case, & remove all leading # and trailing spaces.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  23   num_str = TRIM(UPPER(CLEAN(num_str))); num_value = 0; index = 0; while AND(index < LENGTH(num_str),err_state = FALSE()); if ISERR(FIND(MID(num_str,index,1),digits,0)); err_state = TRUE(); else; digit_val = FIND(MID(num_str,index,1),digits,0); if (32767 - digit_val)/base < num_value; err_state = TRUE(); else; num_value = (base * num_value) + digit_val; end_if; end_if; index = index + 1; end_while; end; # # # # # # # # # # # # Convert value to a string. . input parameters to the function: num_value = value needing conversion to a string digits = string of digit characters possible in num_str base = base of num_str err_state = error state from the string2val function. If using function independently from string2val then set err_state = FALSE() before calling. output parameters: num_str = string version of num_value Code modified from HexCalc by Doug Taylor at the Ohio State University.  function findvalue; found = FALSE(); open data_file, file_name; # open file get data_file, in_line; # grab a line # and start looping through file. while AND(bytesread <> 0, found=FALSE()); # parameter name not found on this line. if ISERR(FIND(param_str,in_line,0)); else; found = TRUE(); # parameter string found. Check for value. if ISERR(FIND(""="", in_line, 0)); # parameter string was not formed correctly # (no equal sign) so default the value to 0 value_str = ""0""; else; tmpval = LENGTH(in_line); tmpval2 = FIND(""="", in_line, 0); # grab the value from the middle of # the string, ignoring the # carriage return and a line feed at # the of the line. note that FIND is # zero based i.e.; the first character # is character zero value_str = MID (in_line, tmpval2+1, tmpval- tmpval2-3); end_if; end_if; get data_file, in_line; end_while; close data_file; end; # # # # # read RAM based NET.INI for expressOptions output parameters: exp_str = bit string representation of expressOptions exp_value = binary representation of expressOptions exp_found = TRUE() if expressOptions found  function val2string; num_str = """"; while AND(num_value > 0,err_state = FALSE()); digit_val = MOD(num_value,base); num_str = MID(digits,digit_val,1) & num_str; num_value = (num_value - digit_val) / base; end_while; end; # file handling variables variables; in_line = """"; # in file read line found = FALSE(); # flag signaling found parameter value param_str = """"; # parameter string to find value_str = """"; # value of parameter file_name = """"; # name of file tmpstr=""""; # tmp string tmpstr2=""""; # tmp string tmpstr3 = """"; # tmp str tmpval = 0; # tmp value tmpval2 = 0; # tmp value CrLf[2] = $13,10; # carriage return, line feed end; file data_file; end; # file object file data_file2; end; # file object # # # # # # # # # # This function tries to find a parameter string within a file & return its value. return input parameters: file_name = file to open for searching param_str = parameter value Output parameters: found = FALSE() if the param_str is not found, TRUE() if param_str if found value_str = the value of param_str  function getexpopt; param_str = ""expressOptions""; # Look for expressOptions file_name = ini_file; # open RAM based NET.INI call findvalue; exp_found = found; if found; # an expressOptions value is found num_str = value_str; digits = ""0123456789""; base = 10; call string2val; if err_state; # an error in string2val, default expressOptions exp_value = 0; # set to zero exp_str = ""00000000000""; # set to 11zero bits else; exp_value = num_value; digits = ""01""; base = 2; call val2string; exp_str = num_str; end_if;  24  P DA De velopers 4.5  Sept/Oct 1996   else; # not found in file, default expressOptions exp_value = 0; # set to zero exp_str = ""00000000000""; # set to eleven zero bits end_if; end; # save settings for expressOptions. function savexpopt; # convert expwrkstr to a value to write out num_str = expwrkstr; # setup for the call to string2val digits = ""01""; base = 2; call string2val; if err_state; # There was an error in conversion. # Default expressOptions to zero exp_value = 0; exp_str = ""00000000000""; expwrkstr = exp_str; else; # expressOptions working bit string converted ok. exp_value = num_value; exp_str = expwrkstr; end_if; # delete any previous tmpNET.INI files since # we want create a new one delete tmp_file; open data_file, ini_file; # open current NET.INI open data_file2, tmp_file; # open temp .ini file # start copy and check loop. get data_file, in_line; while bytesread <> 0; # was expressOptions originally found in ini file? if exp_found; if ISERR(FIND(""expressOptions"",in_line,0)); # expressOptions not found on this line put data_file2, in_line;. else; put data_file2, ""expressOptions = "" & STRING(exp_value, 0); put data_file2, CrLf; end_if; else; # not originally found so look for section header # under which to insert new expressOptions value # go ahead & write out the in_line put data_file2, in_line; if ISERR(FIND(""[uiFeatures]"",in_line,0)); # section header not found on this line else; # put in new expressOptions parameter # value after the section header put data_file2, ""expressOptions = "" & STRING(exp_value, 0); put data_file2, CrLf;  end_if; end_if; get data_file, in_line; # get the next line end_while; close data_file; close data_file2; delete ini_file; # remove old ini file copy tmp_file, ini_file; # put new ini in correct place delete tmp_file; # clean up # needs to be put in because of possible multiple saves # from one session. without it the save function puts # multiple copies of expressOptions line in the file exp_found = TRUE(); end; function save_yes; call savexpopt; hide saveframe; show userframe; end; function startup; show userframe; call getexpopt; # assign the bit value to the cooresponding buttons. # IZL string LENGTH function is NOT zero based but # IZL string MID function is.fill out the bit string # if it is less than exp_bits long exp_str=REPEAT(""0"",exp_bits-LENGTH(exp_str)) & exp_str; expwrkstr = exp_str; # setup working exp bit string call show_bits; # display the buttons with correct bit values end;  Strengths, Weaknesses and Assumptions For small utility programs, IZL works well for development on the OmniGo. For bigger programs, it is much easier to develop them on a machine with a bigger screen and keyboard. I started most of the code on the OmniGo, but for big edits I use my OmniBook 300 and download the programs to the OmniGo. I then use the OmniGo along with OgEdit by R.C. Schuler (schuler@usa.net) for debugging edits. IZL does not have the interface polish like programs developed with the GEOS SDK, but it has enoug h functions to create usable interfaces. It is slow when reading and writing the ""NET.INI"" file and can make you wonder if anything is happening. The fol lowing are some assumptions I used when creating this program:  The program does not control any Express Menu options outside the expressOptions parameter. It would be unwieldy to create an IZL program to modify all ""NET.INI"" parameters.  There is no file error checking  the program does not look at the special global IZL variable ERROR_CODE to check file opens and closes.  There can o nly be one expressOptions line in ""NET.INI"". Although I have used multiple expressOptions in the ""NET.INI"" file, with the second one se eming to take precedence, this program reads only the first occurrence within the file.  The ""NET.INI"" file must be on the B: drive. I also used a convention of capitalizing the built in IZL functions for readability. They don't have to be upper case.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  25   A Simple OmniGo File Compression Tool Marcus Groeber 100712.270@compuserve.com  press data stored in memory buffers as well as in files. While comp ressing memor y buffers is probably the method of choice for integrating compression into application data formats, other programs' files are probably best compressed from one file to another.  M  emor y is always a limiting factor on small devices like Hewlett Packard's OmniGo. While efficient data compression techniques are common practice on desktop machines, they are still not found in PDAs too often. Apart from the lack of CPU horsepower, one reason for this may be the problem of presenting compression functions to the user in a way that they can easily handle them. This ar ticle describes an attempt to simply solve this problem by using the OmniGo's b uilt-in resources as much as possible.  All Files Are Not Equal While experimenting w ith the compression library, I found that its performance both in compression ratio and speed is only slightly worse than PKZIP 1.1, which seems good enough for general purpose compression on small CPUs. That was the good news. Passing the handle of a source and destination file to the library and leaving all the work to the system routines also seemed easy at first, but it turns that there is more work involved if you want to handle any type of file. From a GEOS perspective, files fall into two groups: true GEOS files, which can have long names, tokens (indicating creator and file type), comments, and other extended attributes, and native DOS files, which are restricted to the set of attributes offered by DOS (date, time, and a few of flags). On the other hand, GEOS uses a plain D OS file system as a host  it must add a header to any true GEOS file to store the extended attributes. This header is part of the DOS content of the file, but the system does not treat it as part of the GEOS file content. Consequently, when opening the file w ith the GEOS FileOpen function, the header with all its vital information is not directly accessible, and is lost during compression. Thinking about it a bit, I realized that any standard GEOS filetransfer applications would have the same problem, but they somehow manage to transfer GEOS files including their headers. A little disassembly of the PCCOM library in the areas close to the FileOpen function revealed that the most significant bit of the FileAccessFlags record passed to FileOpen (which should not normally be set) contains an undocumented flag that, if set, forces the system to access the file in native mode. In other words, it treats the header as additional data in the beginning of the file. Together with the documented ability to create a file in nat ive DOS mode, I could now compress all files identically and look at them using the same methods as any DOS-based application. You should keep in mind that this flag is probably left undocumented for a good reason: accessing GEOS files in native mode can make an application dependent on the way GEOS files are stored in the host file system. It's not certain that every file system designed for GEOS will give you full access to all extended attributes through native files. (A file system can easily store additional attributes in a director y structure, where they belong, instead of in the file.)  Design Goals There is a design feature of the OmniGo that make implementing a compression program rather straightforward: its internal structure is fairly close to a typical PC with 576K of base memory and a little over 400K for a RAM disk with a standard DOS file system. On the other hand, most of the file system is hidden from the end user by restricting application data storage to a single directory (""\GEOWORKS\DOCUMENT""). Any new program is free to break this rule, but with the limited amount of free storage, this is not likely to become common practice. The basic idea behind the program is to let the user selectively compress and decompress individual data files created by other applications. Decisions about which files should be stored in compressed or expanded form are left entirely to the user. (In the application, I use the word ""Packing"" instead of ""Compression"" because it fits more easily underneath an icon and onto a menu button.) The application presents a simple two-box model similar to the one used by the standard Transfer application: the user interface consists of two identical file lists, one showing uncompressed files and one showing files that are archived in comp ressed form (see Figure 1). Two menu buttons, ""Pack"" and ""Unpack"", in the function bar at the lower edg e of the screen, move files from the upper to the lower list (where they are compressed) and vice versa (where they are uncomp ressed). There can only be either a compressed or an uncompressed version of a file.  Getting Started - Sleuthing When I started thinking about a simple data compression tool, I decided that it should use the compression functions already offered by the GEOS operating system. This way, I could avoid reimplementing one of the numerous LZ-some thing compression algorithms already available. Even though the SDK does not mention them, the presence of such functions is clearly indicated by a library called ""COMPRESS.GEO"" (its long name is ""PKware Comp ression Library""), which is part of every version of GEOS 2.x I have seen so far, including the one on the OmniGo. Since the SDK documentation is not very helpful as to the contents of this library, I began a process that most GEOS programmers sooner or later become familiar with: trying to piece together the bits of information that are available. Browsing over the contents of the ""\PCGEOS\INCLUDE"" subdirectory of the OmniGo SDK (always a good idea if the official documentation leaves you with questions), I came across two useful files: ""COMPRESS.H"", which defines the C interface to the comp ression library, and ""LDF\COMPRESS.LDF"", which is necessary to link the library to applications. These files first appeared in the OmniGo version of the SDK. Perhaps Geoworks plans to document the library in the future. Even though ""COMPRESS.H"" contains nothing but declarations, the names of arguments and option flags tell you most of what there is to know about using the library. The remaining pieces of the puzzle, like the interpretation of the return value, can be found in the ""COMPRESS.DEF"" file, which specifies the ESP (assembly language) interface of the library. Even if you're planning to write your application in GOC, it can sometimes be helpful to look at the "".DEF"" files because they are often quite thoroughly commented. From the various files I learned that the compress librar y can com-  Figure 1 - The compression tool main window.  26  P DA De velopers 4.5  Sept/Oct 1996   A Rose by Any Other Name To avoid having to deal with creating subdirectories to hold compressed versions of files, I decided to store the compressed files in the same director y and under the same name as their uncomp ressed originals, but marked with a special file t ype. That should ensure that other applications do not confuse them with their own files. There is one exception to this rule which is too common to be ignored: the database librar y that maintains ""DB"" files, which are used by most of the OmniGo's built-in applications. Unfortunately, this library doesn't care if a file is native. If it encounters a file with the name of the database it wants to open, it overwrites this file unconditionally if it does not contain a valid database file structure. The only way to avoid this is to add a distinctive suffix (""(p)"" for packed) to the compressed name of any file with a name that could indicate a DOS file. Having source and destination file in the same directory requires using an intermediary file name for one of the files during compression and decompression. It turns out that this is also useful for speeding up director y searches. For files with long names, GEOS relies on a special relationship between the DOS file name and the long GEOS name. By assigning the file a well-defined GEOS-style temporar y name before compressing it, the program can later unpack the file (whose header contains the temp orary name used prior to compression) into a DOS file with a suitable name, and then rename it to its proper name, leaving the task of finding a new name for the DOS file to the system. (I just have to make sure I use a temporary file name that yields identical DOS and GEOS names, so it can be applied to both file types without having to distinguish any further.) Storing the compressed file as a replacement for the original means that I ultimately have to delete the source file. This imposes a special responsibility on the error checking of the previous steps. If anything goes wrong that might indicate a failure, or if the size reported by the compression librar y appears to be inconsistent with the true file size, I abort the operation and try to restore everything to its original state.   HINT_FILE_SELECTOR_SHOW_FILE_SIZE makes sure that the lists show file sizes as well as their names and modification dates.  HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW set to four tells them to show no more than four files each, which means that both lists together fill the screen just nicely.  HINT_MINIMIZE_CHILD_SPACING makes the A-Z selection bar disappear, providing space for at least one additional file name. This last item is not mentioned in the SDK and has to be figured out by inspired guessing. ( This is another strong argument for a yet-to-bewritten GEOS visual UI designer.)  Fast Flicker-Free Files After implementing the file selectors, I noticed that every time a file was compressed or decompressing, the file lists updated their contents at least three times each. The reason was pretty clear: every change in the file system (for example, creating or deleting a file) causes the affected file selectors to rescan their directory and redraw themselves. Normally, this a good thing because it keeps the file lists current without requiring any work on my part. In this case, the result is annoying. The messag e MSG_GEN_FILE_SELECTOR_SUSPEND lo oked helpful. It's described as a message that keeps the file selector quiet during mult iple sequential changes. It took me a few days and a number of Swat sessions to figure out the correct way to deliver this message to make sure that the file selector is suspended during the deliver y of the change notifications:  Pass the SUSPEND message to the file selector using a direct @call before any file operation. This makes sure that updates are suspended before the program continues.  Perform the file operations.  @send the END_SUSPEND message to the file selector using the forceQueue option. This makes sure that it is placed into the message queue after all the notifications.  Making a Choice The first major task of the program is to present two lists of file names to the use r. Most of the functionality I need is already provided by the GEOS GenFileSelector object class, so the obvious solution is to arrange two file selectors in the application's main screen (a GenPrimary object), each picking a suitable selection of the files in the ""\DOCUMENT"" directory. The choice of selection rules for compressed files is straightforward. All compressed files are stored as GEOS files with my application's token specified as Creator. I simply use the attribute ATTR_GEN_FILE_SELECTOR_CREATOR_MATCH with the appropriate token to pick all the compressed files. The uncompressed selector is a bit trickier. It's supposed to display all the available files, with the exception of files stored in ROM. They can be excluded by showing only those files that have the FA_ARCHIVE attribute set. (The more obvious choice of excluding FA_READ_ONLY files y ields no v isible result.) In addition, compressed files should not appear in the uncompressed list. To do this, I need to exclude all the files having my creator token. This can't be done using predefined selection methods. In this case, the SDK is helpful: ""APPL\SDK_C\FSFILTER"" contains a complete sample for defining a custom filter function in C. This filter, which is called once for every file in the list, decides whether to include the current file in the list based on any criteria defined in the C code. Adapting this code is simple, althoug h the compiler complains about a ""Suspicious pointer conversion"" when passing the address of the callback function  the system hea der files incorrectly d eclare the function protot ype without the _pascal keyword, which is required to pass arguments in the correct order. To get maximum use out of the limited OmniGo screen space, I customize the selectors w ith a few more ATTRs and HINTs (ATTRs that may or may not be honored by the current user interface):  Preparing for Localization Since the OmniGo comes in versions for different countries, it would be nice to make this program easily adaptable to foreign languages. This is not too hard, keeping in mind the most important rule for writing translatable GEOS applications: ""Beware of string constants."" Using the ResEdit tool that comes with the SDK, any text stored in object resources can be edited even without having access to the source code. On the other hand, all hard-coded string constants are there to stay. This is not a problem for things like menu names or dialog box items, because their VisMonikers are stored in translatable form anyway. But it means that error messages and other language-dependant text parts have to be stored in chunks, which means they cannot be accessed directly using pointers without locking down their memory blocks first. Error messages are displayed in a routine named UserStandardDialogOptr(), which is specifically designed to take pointers to translatable resources rather than normal strings. To make it usable with routines like sprintf that take a C pointer, the blo ck it resides in is locked in memor y so that the chunk's address can be turned into a pointer using LMemDeref(). Don't forget to unlock the block again after using it.  The Wish List The complete source code for the main compression/decompression program is at the end of this article. In its current version, it's suitable for compressing databases and spreadsheets. There is still plenty of room for improvement.  The program can only deal with files in the ""DOCUMENT"" directory. It cannot handle files stored on SRAM cards.  A more compatible way of handling extended attributes would be to retrieve them using documented GEOS functions and to store them in a data block at the beginning of the compressed file.  Error checking could be further improved by running a checksum over the uncompressed file. P DA DE VELOPER S  4.5  Sept/Oc t 1996  27    When working with database files, there is nothing that prevents a user from creating a new (empty) copy of a database while another version is stored in compressed state. In such a situation, there is no way to look at the comp ressed version to see what it contains without removing the uncompressed file.  dLite  A Different Approach The fact that the OmniGo really is a DOS-based machine can also be exploited in a different way by using standard DOS file compression technology. One program that seems to be particularly suitable for the OmniGo is Rainer Schuetze's resident decompressor dLite, a $20 shareware program. The program, which has a memor y footprint of only about 12 K, provides completely transparent decompression, but it cannot compress files on the fly. In other words, files must be packed with a separate tool before downloading them to the OmniGo, and they lose their compression as soon as any data is written to them. This makes the program especially suited for compressing reference informat ion as well as program files (because dLite is operating in between DOS and GEOS, it can decompress files of any type). For example, the size of the CompuServe client for GEOS (normally more than 300K) can be halved using dLite, while keeping the decompression process completely invisible to the user. You can include the dLite startup command (""DLITE /I /F+"") in the ""AUTOEXEC.BAT"" file on the OmniGo's RAM disk. It is then loaded when you restart the OmniGo using Shift-On-Next. It should be possible to use other compression tools in a similar way. For debugging a setup of this kind, it can be quite useful to install an additional program (like OGTEXT or OGTMODE) to enable the text mode on the OmniGo to see any messages displayed during startup. The complete source code for CompTool, including the ""GP "" and ""MAK"" files can be found on the source code disk for this issue of PDA Developers. *********************************************************************** * PROJECT: CompTool * FILE: CompTool.goc * AUTHOR: Marcus Grber ***********************************************************************/ @include   #include   #include   #include   #define TEMPNAME ""COMPTOOL.000"" #define SUFFIX "" (p)"" /* Undocumented FileOpen flag forcing Geos files to open * as native files, for access to their file header: */ #define _FILE_FORCE_NATIVE 0x80 ************************************************************************** * Class & Message Definitions **************************************************************************/ @class CompToolProcessClass, GenProcessClass; @message void MSG_CTPROC_COMP_TRIGGER(); @message void MSG_CTPROC_DECOMP_TRIGGER(); @endc; @class @endc; CompToolFileSelectorClass, GenFileSelectorClass;  @start Interface; @object CompToolAppClass CompToolApp = { GI_visMoniker = @list{ @TextMoniker }; GI_comp = @CompToolPrimary; gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = @CompToolPrimary; } @object GenPrimaryClass CompToolPrimary = { GI_comp = @DataArea,@CompTrigger,@DecompTrigger; HINT_CENTER_CHILDREN_HORIZONTALLY; } @object GenInteractionClass DataArea = { GI_comp = @UnpackedSel,@PackedSel; HINT_ORIENT_CHILDREN_VERTICALLY; } @object CompToolFileSelectorClass UnpackedSel = { GI_visMoniker = ""Unpacked:""; GFSI_fileCriteria = FSFC_GEOS_NON_EXECUTABLES | FSFC_GEOS_EXECUTABLES | FSFC_NON_GEOS_FILES | FSFC_FILE_FILTER | FSFC_FILTER_IS_C; GFSI_attrs = FSA_HAS_FILE_LIST; ATTR_GEN_PATH_DATA = {SP_DOCUMENT,{"".""}}; ATTR_GEN_FILE_SELECTOR_FILE_ATTR = {FA_ARCHIVE, FA_SUBDIR | FA_HIDDEN | FA_SYSTEM | FA_READ_ONLY}; HINT_FILE_SELECTOR_SHOW_FILE_SIZE; HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW = 4; HINT_PLACE_MONIKER_ABOVE; HINT_MINIMIZE_CHILD_SPACING; } @object GenFileSelectorClass PackedSel = { GI_visMoniker = ""Packed:""; GFSI_fileCriteria = FSFC_GEOS_NON_EXECUTABLES; GFSI_attrs = FSA_HAS_FILE_LIST; ATTR_GEN_PATH_DATA = {SP_DOCUMENT,"".""}; ATTR_GEN_FILE_SELECTOR_CREATOR_MATCH = {{""CMPT""},16424}; HINT_FILE_SELECTOR_SHOW_FILE_SIZE; HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW = 4; HINT_PLACE_MONIKER_ABOVE; HINT_MINIMIZE_CHILD_SPACING; } @object GenTriggerClass CompTrigger = { GI_visMoniker = ""Pack""; GTI_destination = process; GTI_actionMsg = MSG_CTPROC_COMP_TRIGGER; HINT_SEEK_MENU_BAR; HINT_SEEK_SLOT = 0; } @object GenTriggerClass DecompTrigger = { GI_visMoniker = ""Unpack""; GTI_destination = process; GTI_actionMsg = MSG_CTPROC_DECOMP_TRIGGER; HINT_SEEK_MENU_BAR; HINT_SEEK_SLOT = 1; } @visMoniker TextMoniker = ""Compression Tool""; /* All program messages are stored in chunks, so the application can be translated without having to modify the source code: */  @class CompToolAppClass, GenApplicationClass; @endc; ************************************************************************** * UI Objects **************************************************************************/  28  P DA De velopers 4.5  Sept/Oct 1996   @chunk char textCompress[] = ""packed""; @chunk char textUncompress[] = ""unpacked""; @chunk char err0[] = ""File successfully \1.""; @chunk char err1[] = ""File to be \1 couldn't be opened or renamed.""; @chunk char err2[] = ""Destination file couldn't be created.""; @chunk char err3[] = ""No file selected to be \1.""; @chunk char err4[] = ""Error writing destination file. Memory full?""; @chunk char freeSpace[] = ""Unpacked: (%ldKb free)""; @end Interface; *********************************************************************** * Various routines and declarations ***********************************************************************/ const GeodeToken ourToken={{""CMPT""},16424}; const FileExtAttrDesc filterAttrs[] = {{ FEA_CREATOR, 0, sizeof(GeodeToken), NULL }, { FEA_END_OF_LIST, 0, 0, NULL}}; #define #define #define #define #define COMP_ERR_NONE COMP_ERR_SOURCE COMP_ERR_DEST COMP_ERR_NO_FILE COMP_ERR_WRITE 0 1 2 3 4  /* Close files */ FileClose(dst,FILE_NO_ERRORS); FileClose(src,FILE_NO_ERRORS); /* * * * * * This error checking not completely bullet-proof, but there seems to be no way of distinguishing between an error and destination size that is a multiple of 65536 when CompressDecompress() returns zero. In addition, a memory-full condition sometimes seems to go undetected. */  if(size==0 || (word)size!=ret) { FileDelete(dstName); /* remove invalid dest file */ FileRename(TEMPNAME,fname); /* undo renaming */ return COMP_ERR_WRITE; } /* Remove source file */ FileDelete(TEMPNAME); return COMP_ERR_NONE; } word DecompressFile(char *fname) { FileHandle src,dst; word ret; dword size; char dstName[FILE_LONGNAME_BUFFER_SIZE]; word len=strlen(fname); strcpy(dstName,fname); if(len>=4 && strcmp(dstName+len-4,SUFFIX)==0) dstName[len-4]=0; /* Open source file */ src = FileOpen(fname, FILE_ACCESS_R|FILE_DENY_W); if(!src) return COMP_ERR_SOURCE; /* Create destination file, fail if already exists */ dst = FileCreate(TEMPNAME, FCF_NATIVE|FILE_CREATE_ONLY|FILE_ACCESS_W|FILE_DENY_RW, FILE_ATTR_NORMAL); if(!dst) { FileClose(src,FILE_NO_ERRORS); FileRename(TEMPNAME,fname); return COMP_ERR_DEST; } /* Do all the work... */ ret = CompressDecompress( CLF_DECOMPRESS, src,NULL,0,dst,NULL ); size = FileSize(dst); /* size of destination file */ /* Close files */ FileClose(dst,FILE_NO_ERRORS); FileClose(src,FILE_NO_ERRORS); if(size==0||(word)size!=ret)/* see CompressFile() */ { FileDelete(TEMPNAME);/* remove invalid dest file */ return COMP_ERR_WRITE; } /* Remove source if same name as destination * (rename shouldn't fail). */ if(strcmp(fname,dstName)==0) FileDelete(fname);  const optr errorMsg[] = {@err0,@err1,@err2,@err3,@err4}; /* Pack/unpack a file in current working directory. The * resulting file is in the same place w/same name as * the original file: */ word CompressFile(char *fname) { FileHandle src,dst; word ret; dword size; char dstName[FILE_LONGNAME_BUFFER_SIZE]; strcpy(dstName,fname); if(strlen(dstName)<=12) strcat(dstName,SUFFIX); if(FileRename(fname,TEMPNAME)) return COMP_ERR_SOURCE; /* Open source file */ src = FileOpen(TEMPNAME, _FILE_FORCE_NATIVE|FILE_ACCESS_R|FILE_DENY_W); if(!src) return COMP_ERR_SOURCE; /* Create destination file, fail if already exists */ dst = FileCreate(dstName, FILE_CREATE_ONLY|FILE_ACCESS_W|FILE_DENY_RW, FILE_ATTR_NORMAL); if(!dst) { FileClose(src,FILE_NO_ERRORS); FileRename(TEMPNAME,fname); /* undo renaming */ return COMP_ERR_DEST; } FileSetHandleExtAttributes( dst,FEA_CREATOR,&ourToken,sizeof(ourToken)); /* Do all the work... */ ret = CompressDecompress( 0, src,NULL,0,dst,NULL ); size = FileSize(dst); /* size of destination file */  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  29   /* Rename destination file to its proper name. */ if(FileRename(TEMPNAME,dstName)) { if(strcmp(fname,dstName)!=0) FileDelete(TEMPNAME); return COMP_ERR_DEST; } /* Remove source if name is different from * destination . (This allows a graceful abort if * renaming fails because a file with * the original name already exists.) */ if(strcmp(fname,dstName)!=0) FileDelete(fname); return COMP_ERR_NONE; } /* Pack/unpack a file based on current selection in the UnpackedSel or PackedSel list: */ void ConvertAction(Boolean comp) { DiskHandle srcHandle; char srcPath[PATH_BUFFER_SIZE],*err; char fname[FILE_LONGNAME_BUFFER_SIZE]; dword ret; optr srcObj; /* * * * Suspend file selectors updates - @call makes sure that this message is delivered immediately, so it becomes effective before any notifications of file system changes arrive: */  PackedSel::MSG_GEN_FILE_SELECTOR_END_SUSPEND(); @send,forceQueue UnpackedSel::MSG_GEN_FILE_SELECTOR_END_SUSPEND(); } /* Update free space display for doc drive in moniker * of file selector showing names of unpacked files: */ void UpdateFreeSpace(void) { char buf[80]; dword free = DiskGetVolumeFreeSpace(SP_DOCUMENT); MemLock(OptrToHandle(@freeSpace)); sprintf(buf,LMemDeref(@freeSpace),free/1024); MemUnlock(OptrToHandle(@freeSpace)); @callUnpackedSel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT( buf, VUM_DELAYED_VIA_UI_QUEUE); } /* filter routine implements a kind of ""inverted * ATTR_GEN_FILE_SELECTOR_CREATOR_MATCH"", i.e. it * includes all files except those with ""our"" token: */ Boolean _pascal CompToolFilterRoutine(optr oself, FileEnumCallbackData *fecd, word frame) { GeodeToken *tok = FileEnumLocateAttr(fecd, FEA_CREATOR, NULL); return memcmp( tok,&ourToken,sizeof(GeodeToken))? FALSE:TRUE; } *********************************************************************** * Method definitions for object classes ***********************************************************************/ @classdecl CompToolProcessClass, neverSaved; @method CompToolProcessClass, MSG_CTPROC_COMP_TRIGGER { ConvertAction(TRUE); /* compress selected file */ UpdateFreeSpace(); /* show new free space */ } @method CompToolProcessClass, MSG_CTPROC_DECOMP_TRIGGER { ConvertAction(FALSE); /* decompress selected file */ UpdateFreeSpace(); /* show new free space */ } @classdecl CompToolAppClass; @method CompToolAppClass, MSG_META_GAINED_TARGET_EXCL { @callsuper(); /* better safe than sorry */ UpdateFreeSpace(); /* something may have changed */ } @classdecl CompToolFileSelectorClass; @method CompToolFileSelectorClass, MSG_GEN_FILE_SELECTOR_GET_FILTER_ROUTINE { /* This line causes ""Suspicious pointer conversion"" * with the OmniGo SDK, because the type of the * callback routine is incorrectly declared * without the ""_pascal"" keyword in gfselc.goh: */ static GenFileSelectorFilterRoutine *filterRoutine = CompToolFilterRoutine; /* see FSFILTER sample in SDK... */ filter->filterRoutine = filterRoutine; filter->filterAttrs = filterAttrs; }  @call PackedSel::MSG_GEN_FILE_SELECTOR_SUSPEND(); @call UnpackedSel::MSG_GEN_FILE_SELECTOR_SUSPEND(); srcObj = comp? @UnpackedSel:@PackedSel; ret = @call srcObj::MSG_GEN_FILE_SELECTOR_GET_SELECTION (fname); /* get current selection */ if( GFS_GET_ENTRY_FLAGS(ret) & GFSEF_NO_ENTRIES ) ret = COMP_ERR_NO_FILE; /* no file: abort */ else { @call srcObj::MSG_GEN_PATH_GET( srcPath,sizeof(srcPath)); srcHandle = @call srcObj::MSG_GEN_PATH_GET_DISK_HANDLE(); /* Set working directory to avoid path names... */ FileSetCurrentPath(srcHandle,srcPath); @call CompToolApp::MSG_GEN_APPLICATION_MARK_BUSY(); if(comp) ret = CompressFile(fname); else ret = DecompressFile(fname); @call CompToolApp:: MSG_GEN_APPLICATION_MARK_NOT_BUSY(); } UserStandardDialogOptr( 0, 0, 0, comp? @textCompress:@textUncompress, errorMsg[ret], ( (ret? CDT_ERROR:CDT_NOTIFICATION) << CDBF_DIALOG_TYPE_OFFSET)|(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET )); /* Make sure updates are resumed after all messages currently in queue (especially file system notifications) have been dealt with: */ @send,forceQueue  30  P DA De velopers 4.5  Sept/Oct 1996   NIE Made Easy: The protoInetClient Ray Rischpater AllPen Software, Inc. dove@allpen.com hile Newton has long had support for AppleTalk networks, TCP/IP support has been lacking. Fortunately, Apple has reversed this trend with the Newton Internet Enabler (NIE), giving the Newton access to the Internet and TCP/IP intranets. In this article, I review TCP/IP fundamentals and describe a proto you can use to speed the development of your NIE-capable applications.  W TCP/IP  during run time. These port numbers are often referred to as ephemeral ports, as they are short-lived. Applications may listen on ports, awaiting connections, or initiate a connection to a remote port. The former are called servers, the latter clients. There are application-sp ecific protocols used by these applications to carr y their data between client and server. These protocols include the Domain Name Service protocol (DNS), which I discuss shortly, along with protocols for mail (POP and SMTP), file transfer (FTP), and many others.  The Newton Internet Enabler The NIE, which requires Newton OS 2.0, is an implementation of a TCP stack, including TCP, UDP, and IP, along with SLIP and PPP protocols for serial and modem connections. In addition, the NIE also has:  A link layer manager, capable of conditioning a serial channel to accept a link by exchanging strings v ia an expect/response mechanism, and capable of shar ing the link with multiple applications;  A Domain Name Resolver (DNR), implementing the Domain Name Service for the conversion of symbolic host names to their IP addresses and the reverse;  A setup application to enter the details of connecting to an Internet Service Provider (ISP); and  An interface to TCP and UDP via NewtonScript endpoints. While not necessarily part of a traditional TCP/IP implementation, the first two items are found in most TCP/IP implementations. They make software development significantly easier. The link layer manager has an API of global functions for selecting an ISP, establishing a link, and releasing a link once the connection is complete. The API is asynchronous, so your application can do other tasks while a link is being created or destroyed. In addition, your application can receive status v ia a callback method which is called periodically during the course of an operation. The DNR is a bare-bones Domain Name Service client. It's capable of finding an IP address for a host name or the reverse, a mail server's IP address, or the name of a particular host. If you need more robust services for domain management, you need to write your own DNS client. Like the link layer manager, its operations are asynchronous. As part of the NIE, an Internet Setup application is included so that users can enter the details of establishing a connection w ith their ISP. The Internet Setup application is only required while a Newton is being set up to access a network (entering the required phone number, SLIP or PPP, any scr ipting necessary to connect with the service, and so forth). Once a Newton is set up, the Internet Setup application can be removed to recover the memory it uses. The fa ct that the NIE's interface to TCP/IP endpoints is v ia the standard protoBasicEndpoint makes using the endpoints extremely easy for programmers already proficient with Newton communicat ions programming. The NIE includes some text files which contain constant function declarations for various NIE endpoint.  Developed in the sixties, seventies, and early eighties, TCP/IP is the generic name for a suite of network protocols. TCP/IP quickly became the reference for other network protocols, and the de facto standard for what is now the Internet. The suite has been adopted worldwide, with implementations available for almost every operating system. TCP/IP takes its name from two of its most-used components, TCP and IP. The protocol is packet-based, with data being broken up into little packets before being sent and reassembled on the receiving end. TCP/IP is an open protocol, with public standards and public implementations. The TCP/IP protocols are organized as a stack of protocols, each protocol building on the functionalit y and features of the protocols below it (this is why you often hear implementations referred to as stacks). At the bottom of the stack is the physical layer, such as a serial or Ethernet cable, responsible for carrying the raw bits between devices. Above this is the link layer, responsible for the transport of datagrams across the physical layer. PPP and SLIP are link-layer protocols, encapsulat ing the higher-level protocols so they may be carried across a serial cable. PPP (the Point-to-Point Protocol) is a well-defined standard for encapsulating IP and other protocols for transport across circuitswitched links such as modems and serial cables from one point to another. SLIP, the Serial Line Internet Protocol, is essentially a simpler way to do the same thing, with far fewer f eatures than PPP. Above these layers is the first real protocol belonging to the stack, the Internet Protocol (IP). This protocol provides mult iplexing and demultiplexing of the protocols above IP, along with pa cket assembly and disassembly. Additionally, it provides addressing for all hosts on an Internet. Hosts are addressed using a thirty-two bit integer (commonly called the IP Address), divided up into eight-bit chunks separated by decimal points. Part of this number indicates a destination network, while the remainder indicates a destination host on the target network. The number of bits use d for each vary from site to site, so the entire IP address is always used to refer to a host. You never use the IP protocol directly, but use its features with both UDP and TCP. The remaining protocols rely upon IP to carry data. The first two, ICMP and IGMP, are used to control routing, connectivity, and groups of Internet hosts. More important us are TCP and UDP. UDP, the User Datagram Protocol, is the protocol closest to IP. A connectionless, unreliable protocol, each output operation produces exactly one UDP datagram, which in turn generates one IP datagram. While UDP does not provide guaranteed deliver y or a retry mechanism, it does provide a checksum on the data being sent, assuring that if data arrives at its destination it is free from errors. TCP, the Transmission Control Protocol, uses IP to carry a reliable byte stream between two Internet nodes. A connection-oriented protocol, it also provides the reliability one would expect in a byte stream, including checksums to ensure data integrity, retries for lost packets, and similar features. TCP is analogous to Apple's ADSP protocol in its characteristics, although the implementation is naturally different. TCP/IP uses sixteen-bit port numbers to multiplex connections and identify client applications. Some port numbers, used by servers, are fixed and referred to as well-known ports (for example, HTTP servers use port 80). Well-known ports, which range from one and 1023, are assigned by the Internet Assigned Numbers Authority. Other port numbers are dynamically assigned by the appropriate protocol stack  The protoInetClient protoInetClient is a simple proto designed to hide the details of the NIE and the protoBasicEndpoint in client applications. The interface to the protoInetClient is deceptively simple:  Include the text files provided with the NIE, and the protoInetClient file, in your project file.  Create a frame inheriting from the protoInetClient with slots indicating the type of transport (TCP or UDP), along with the destination port and address.  Call :Open() to establish the link and connect the endpoint. Pass a callback specification (identical to those detailed in the Communicat ions part of the Newton Programmer's Guide) whose completionScript is called when the connection is made.  Use the endpoint returned in your completionScript to perform the input and output required by your application. P DA DE 4.5  Sept/Oc t 1996  VELOPER S  31    When complete, call :Close() on the endpoint to close and destroy the endpoint and release the underlying link layer. The protoInetClient handles the link layer and DNR if required. Once the link is established, it instantiates, binds, and connects your endpoint, so that your application can focus on the TCP/IP communications as a whole. When complete, the proto disconnects, unbinds, and disposes of the endpoint, and releases the link on your application's behalf. When instantiating a protoInetClient, you need to provide informat ion in the following slots:  fTransport, which contains either kTCP or kUDP indicating whether the endpoint is to provide TCP or UDP services;  fDestinationAddress, either a string containing a remote host name, or an array of four integers indicating an IP address;  fDestinationPort, the destination port number;  fSourcePort, an optional source port number; and  fStatusProto, the proto for a status view to b e used in notifying users regarding the status of communicat ions.  if inAction='connect then begin gState:='linking; fStatusView:={ _proto: if fStatusProto then fStatusProto else GetLayout(""protoInetStatusTemplate"")}; InetGrabLink(nil, self, 'mGrabCb); end else gState:=nil; end;  Next, call InetGrabLink() to request the link indicated by the user. InetGrabLink() uses the same arguments as InetCon nectionSlip(). Unlike the latter function, however, the callback is invoked multiple times, and takes three arguments:  The link ID in use;  The cur rent status of the link as a status frame; and  An error code or nil if no error occurs. Acquiring a link can take a relat ively long period of time, as the device may have to dial a modem, execute a chat script to reach a PPP or SLIP stream, and then continue. Because of these potential delays, InetGrabLink() invokes a callback periodically to notify the user of the current progress in establishing the link. You need to create a status template for this callback to present to the user. The status slip can contain anything you find appropriate, as long as it inherits from the protoInetStatusTemplate supplied with the NIE. If you do not provide a status slip to the link layer manager, it generates one based on the protoInetStatusTemplate. In your callback, you can use the NIE function InetDisplayStatus() to keep the user appraised of status: mGrabCb:=func(inLinkID, inStat, inErr) begin fLinkID:=inLinkID; if inErr then begin :mNotifyError(""InetGrabLink"", inErr); gState:=nil; end else begin InetDisplayStatus(inLinkID, fStatusView, inStat); if inStat.linkStatus='connected then begin gState:='linked; InetDisplayStatus(inLinkID, fStatusView, nil); fStatusView:=Nil; /* DNS Stuff shown below goes here */ end; end; end  Connecting the protoInetClient C onnec ting the Link L ayer Before a TCP or UDP endpoint can be used, the link layer must be initialized and a link established: 1. Give the user an oppor tunity to select a link by calling InetOpenConnectionSlip(). 2. Call InetGrabLink() to request a link from the system. Pass a callback that is used to notify you of the stat us of the link establishment. In your callback, call InetDisplayStatus() to notify the user of this progress. 3. Once the link is established, use NIE endpoints like you would in any other application. Alternatively, use InetGetLinkStatus() to determine the current status of the link. 5. Call InetReleaseLink() to relinquish your link after disconnecting your endpoints. Recall that the link manager routines are all asynchronous. They all take a context and a method name (represented as a symbol) in addition to other arguments; the method is invoked when the call is complete. The InetConnectionSlip() method presents the user with a slip for selecting their ISP if no link is currently active. This slip allows them to select their current emp orium and indicate which ISP should be used. You pass three arguments to InetConnectionSlip():  The initial ID of the link to be offered (or nil to have the system select one for you);  A context frame to receive the callback message; and  A symbol representing the method to be invoked on the callback. Once the user makes a selection, the callback is invoked with a single argument. This argument may be either nil (indicating that the connection is to be aborted) or 'connect. If a link is active, the slip is not displayed, the existing link is used, and the callback is immediately invoked with the 'connect symbol. For example: Open:=func(inCallbackSpec) begin if gState then return; gState:='choosing; InetOpenConnectionSlip(nil, self, 'mConnectSlipCb); gCallbackSpecs:=Clone({}); gCallbackSpecs.fOpen:=inCallbackSpec; end; mConnectSlipCb:=func(inAction) begin  InetDisplayStatus() is like a Swiss Army knife  you can use it to do many things. Regardless of the result you desire, pass the current link ID, a reference to your status v iew, and a reference to the status frame your callback receives. The function shows or hides the status dialog and updates the status indicator with the text of the current status as indicated by the incoming arguments. Table 1 on the next page shows the relationship between the arguments to InetDisplayStatus() and the resulting actions taken.  32  P DA De velopers 4.5  Sept/Oct 1996   Determining a Remote Address If you're writing a general-purpose application, you probably need to know how to use the NIE's Domain Name Resolver. It uses DNS to convert human-readable host names such as ""CDPUBS.COM"" to its Internet address equivalent, a four-byte address. In addition to host name conversion, you can also find a mail server's name or address given a host name. The DNR also provides asynchronous processing. When issuing a request, you pass the data for your request along with a context frame and method identifier, and await your callback's invocation indicating the result of your query. You access the DNR functions using the following global functions:  DNSGetAddressFromName(), which converts a st ring host name to its IP equivalent;  DNSGetMailAddressFromName(), which finds the IP address for a mail server given a host name;  DNSGetMailServerFromName(), which returns the name of the mail server given a host name;  DNSGetNameFromAddress(), which returns a host name given the IP address; and  DNSCancelRequests(), which cancels all requests associated with a specific context frame. The first four functions each require three arguments: the key for the data to be retrieved, the client context, and a symbol denoting the callback. The cancellat ion function takes only a client context and callback symbol. All callba cks but the cancellation callback are invoked with a results array and result code. The results array contains an array of result frames, containing one or more of the following slots:  type, the result type (one of kDNSAddressType or kDNSDomainType);  resultDomainName, a string containing the result ing domain name; and  resultIPAddress, an array containing the four-byte IP address. The protoInetClient uses the DNR to determine the appropriate IP address from the incoming host name as needed using the following: ... if ClassOf(fDestinationAddress)='string then DNSGetAddressFromName( fDestinationAddress, self, 'mDNSResultCb); else begin fDestAddrAsArray=fDestinationAddress; :mInstantiateAndBind(); end; ...  mDNSResultCb:=func(inResultArr, inResultCode) begin local myAddrFrame; local myHandyAddresses:=Clone([]); if inResultCode then begin print(""DNS lookup failed due to "" && inResultCode); call gCallbackSpecs.fOpen with ( nil, nil, inResultCode); end else if Length(inResultArr)=0 then begin print(""DNS lookup failed - returned no addresses!""); call gCallbackSpecs.fOpen with (nil, nil, -8007); end else begin fDestAddrAsArray:=inResultArr[0].resultIPAddress; :mInstantiateAndBind(); end; end;  C onnec ting an Endpoint Once the link layer is established, your ap plication can use TCP or UDP endpoints. The interface to these endpoints is identical to the interface used with other kinds of endpoints: you indicate the type of endpoint desired via a service class option, set other appropriate options, and then instantiate, bind, and connect your endpoint. This endpoint started life in the method :mInstantiateAndBind(): mInstantiateAndBind:=func() begin gEndpoint :={ _proto: protoBasicEndpoint, _parent: self, gState: nil, ExceptionHandler:func(inExp) begin local myErr; if HasSlot(inExp, 'error) then myErr:= inExp.error; else if HasSlot(inExp.data, 'errorCode) then myErr:= inExp.data.errorCode; if myErr<>kCancellationException then :Notify(kNotifyAlert, kAppName, ""Something bad happened - "" & myErr); :mTearDown(self); end, EventHandler:func(inEvent) begin if inEvent.eventCode= kCommToolEventDisconnected then begin :Notify(kNotifyAlert, kAppName, ""The other side has disconnected."" & myErr); :mTearDown(self); end else print(""An event we didn't expect ("" & inEvent.eventCode & "") occurred.""); end, };  Second Argument (view template) nil Template of a status view A currently shown status template  Third Argument (status) nil Status frame (non-nil) nil  Results  Returns a reference to a default status view, and opens the view for you. Uses the template as the status view and and displays the status. The status view is closed and destroyed.  Table 1 - InetDisplayStatus () arguments and results.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  33   try myErr:=gEndpoint :Instantiate(gEndpoint, call kGetEndpointConfigOptions with (fLinkID, fTransport)); onexception |evt| do begin :mNotifyError(""Instantiate"", 0); return; end; if myErr then begin :mNotifyError(""Instantiate"", myErr); return; end; myEp.gState:='instantiated; local myPortOpt; if fTransport=kUDP then begin // Assign an ephmereal. Hope it's not used. if NOT fPort then fPort=Random(1024, 65535); myPortOpt:=call kINetBindOptions with (0, fPort); end; try myErr=gEndpoint:Bind( myPortOpt, { _parent: self, async: true, CompletionScript: mBindCb, } ); onexception |evt| do begin :mNotifyError(""Bind"", 0); :mTearDown(); return;  end; if myErr then begin :mNotifyError(""Bind"", myErr); :mTearDown(); return; end; end  The only surprises here are two constant compile-time functions used to generate the various arguments  kGetEndpointConfigOptions and kINetBindOptions. The NIE has several compile-time functions that aren't well documented in the NIE manual, but can make your life significantly easier. They are listed in Table 2 for your reference. kGetEndpointConfigOptions generates the three options necessary to select the NIE's C tool. The options are used to request the NIE via the 'inet option, specify the link to be used with the 'ilid option, and indicate the desired transport via the 'itsv option. kINetBindOptions specifies the local (source) port your application is using. Most standard Internet applications have a wellknown port, where client applications can find them. This port is listened to by servers; also, clients can specify that port as the destination port and use a randomly assigned port for their source port. If you're writing a client application, you probably don't need to specify the local port, unless you're using UDP. protoInetClient makes up a local port if you don't pick one for UDP endpoints, but you run the risk of col liding with another port in use by the NIE  the port assig nment algorithm I use isn't very robust. kINetBindOptions creates an 'ilpt option frame with the desired local port. Note that protoInetClient invokes Bind() asynchronously. When it's complete, notification is provided via the invocation of :mBindCb():  Function kNumtoHostAddr kHostAddrToNum kIsIPAddr  Arguments inAddrArr inAddrStr inAddrStr  Purpose Turns an address into a string in the form ""a.b.c.d"" Turns a string address in the form a.b.c.d to the four-byte IP address. Examines the incoming string and tries to see if it's an IP address in the form :a.b.c.d"". Right now it's not very robust, so use it with caution. Creates an options array for use when an NIE endpoint is instantiated. Creates an options array for use when an NIE endpoint is bound. Creates an options array for use when an NIE TCP endpoint is connected. Finds the error number associated with an exception. Looks up a string associated with the NIE error code indicated. Creates an options array for use with a UDP endpoint when data is to be output.  kGetEndpointConfigOptions kINetBindOptions kTCPConnectOptions kGetExceptionError kGetInetErrorStr kUDPPutBytesOptions  inLinkID inProtocol inLocalPort inUseDefaultPort inRemoteAddrArr inRemotePort inExp inErr inAddrArr inPort  Table 2 - NI E constant functions defined by include files.  34  P DA De velopers 4.5  Sept/Oct 1996   mBindCb:=func(inEp, inOpt, inRes) begin if inRes then begin :mTearDown(inEp); if inRes<>kCancellationException then :mNotifyError(inRes); end else begin inEp.gState:='bound; local myConnOpt; if fTransport=kTCP then myConnOpt:=call kTCPConnectOptions with (fDestAddrAsArray, fDestinationPort); try inEp:Connect(myConnOpt, { _parent: self, async: true, CompletionScript: mConnectCb, } ); onexception |evt| do begin :mNotifyError(""Bind"", 0); :mTearDown(); return; end; if myErr then begin :mNotifyError(""Bind"", myErr); :mTearDown(); return; end; end; end;  If you're using UDP, your arguments to Connect() are somewhat different. Rather than passing a destination port and socket, you pass nothing. Although the endpoint interface is a connection-oriented API, the UDP interface itself is connectionless. When using UDP, you can also pass the destination port and address to your endpoint's Output() me thod, so that one UDP endpoint can contact many UDP servers.  Input and Output with the NIE Get ting Input If you've worked with Newton communications before, using NIE should be easy. Your applications should post an input specification and wait for data to come to your application. For example, here's a primitive input specification for a Newton ""Telnet"" server which provides access to a NewtonScript interpreter over TCP: local myExcludeStr:=kUnicodeLF & kUnicodeBS; local myInputSpec:={ form: 'string, termination: {endSequence: unicodeCR}, inputScript: func(inEp, inData, inTerm, inOpt) begin local myCodeBlock, myResult; StrFilter(inData, myUnicodeLFStr, 'rejectAll); try myCodeBlock:=Compile(inData); onexception |evt| do :mOutput(""An error occurred compiling your code"" & kUnicodeCR & kUnicodeLF); try myResult:=SPrintObject(call myCodeBlock with ()); onexception |evt| do :mOutput(""An error occurred executing your code"" & kUnicodeCR & kUnicodeLF) if myResult then :mOutput(myResult & kUnicodeCR & kUnicodeLF); end, completionScript: func(inEp, inOpt, inRes) begin if inRes<>kCancellationException then begin print(""Input spec saw error "" & inRes); :mTearDown(inEp); end; end, }; gEndpoint:SetInputSpec(myInputSpec);  Note that I could use Listen() here if I want the application to sit on a local port waiting for an incoming request. Since the application is a client application, I use Connect() to connect the endpoint to the remote server, indicating the ser ver's destination address and port. The connection callback is about what you'd expect: mConnectCb:=func(inEp, inOpt, inRes) begin if inRes then begin :mTearDown(inEp); if inRes<>kCancellationException then :mNotifyError(inRes); end else begin inEp.gState:='connected; inEp.Close:=func() begin if kDebugOn then print(""Close""); :mTearDown(self); end; gCallbackSpecs.fOpen:?CompletionScript( inEp, nil, nil); end; end  At this point, control is passed to the application, and you can exchange data freely w ith the server you've contacted.  This code builds an input specification which looks for strings ending in carriage returns. When it receives one, it attemp ts to compile the string into NewtonScript code and execute that code, outputting the result with the output function I describe shortly. If you're learning Newton from a streams-based OS such as UNIX, you probably need a bit of background on input specifications. Rather than using tradit ional input streams, the Newton OS uses input sp ecifications, which describe the format of the information your application expects to receive. You build an input specification (or input spec for short) using data such as the class of the incoming data, its length or an array of possible termination characters which mark the end of an input operation, and how long the OS should wait for input or communications flags which denote the end of input. The spec is used by the Newton OS to wait f or input on your application's behalf while the application is running. Once the conditions are met, the program's InputScript is invoked to pass you the input. If the input spec is never satisfied, the P DA DE 4.5  Sept/Oc t 1996  VELOPER S  35   CompletionScript may be invoked to notify you of this condition. (This happens if you're expecting data in a window of time, or if the endpoint is closed while you're expecting input.) Your application can switch between active input specs by using the endpoint method SetInputSpec(), which sets the endpoint's input specification to a specific frame. Using mult iple input specifications makes writing state machines very easy. When planning a new application, take pains to be sure you develop a good state machine to represent input. The effort you put in during the design phase is repaid a thousand fold when your application's communications code is almost entirely an array of input specifications and their scripts. If you're new to working w ith state machines and communications, check out the Newton DTS sample CommsFSM, which has enough to get you started. Unfortunately, the input specification mechanism makes p orting code some what difficult, since many legacy applications hide their state machines behind a streams-oriented communications interface. If you're porting code, be prepared to have a good grasp of the underlying data protocol, and represent the protocol as a state machine using (possibly mult iple) input specifications. At all costs avoid the temptation of simulating a stream with an endpoint  it's overly expensive and you almost never need the true functionality of a byte stream. If you use UDP, you need to know the port from w hich your application receives its data. Also, odds are that you'll want to receive entire packets. Here's a simple example of how to do that: local myInputSpec:={ form: 'string, termination: {useEOP: true}, rcvFlags: kPacket, rcvOptions: { label: ""iuss"", type: 'option, opCode: opGetCurrent, result: nil, form: 'template, data: { arglist: [ [ 0,0,0,0 ], // Host address 0, // Host port ], typelist: [ 'struct, ['array, 'byte, 4], ], }, inputScript: func(inEp, inData, inTerm, inOpt) begin // Do something with the data end, completionScript: func(inEp, inOpt, inRes) begin if inRes<>-16005 then begin print(""Input spec saw error "" & inRes); :mTearDown(inEp); end; end, }; gEndpoint:SetInputSpec(myInputSpec);  As with all things, there's an exception in receiving data that you should know about. The TCP protocol supports the notion of expedited data, which is sent out-of-band at a higher priority than other data. When using a TCP endpoint, data sent with the expedited bit asserted isn't passed to your application via normal means. Rather, it's sent as an event to your endpoint's event handler. Here's a trivial example of an event handler: EventHandler:func(inEvent) begin if inEvent.eventCode=kCommToolEventDisconnected then begin :Notify(kNotifyAlert, kAppName, ""The other side has disconnected."" & myErr); :mTearDown(self); end else if inEvent.eventCode=kEventToolSpecific then print(""Expedited data! The byte was"" & inEvent.data); else print(""An event we didn't expect ("" & inEvent.eventCode & "") occurred.""); end,  Outputting Data Outputting data is no more difficult than it is with any other endpoint. You construct an object with your outgoing data and use the endpoint's Output() metho d to send the data: mOutput:=func(inStr) begin try local myErr:=gEndpoint:Output(inStr, nil, nil); onexception |evt| do begin :Notify(kNotifyAlert, kAppName, ""Something bad happened on Output - "" & myErr); :mTearDown(); end; if myErr then begin :Notify(kNotifyAlert, kAppName, ""Something bad happened on Output - "" & myErr); :mTearDown(gEndpoint); end; end;  When calling Output() you can also specify an ar ray of options and an output specification frame. For example, when you send UDP packets, you need to include the kPacket and kEOF flags in the sendFlags slot of your output specification, specify a destination address and port, and use one cal l to Output() to send your entire packet: try gEndpoint:Output(""Hello world!"", call kUDPPutBytesOptions with ( fDestAddrAsArray, fDestinationPort), { async: nil, sendFlags: kPacket+kEOF, }); onexception |evt| do /* Traditional error handling here! */  The inOpt argument to the inputScript contains the options array w ith the sender's IP address and port, which you can use to resp ond to the sender. Note that the termination specification indicates that Newton should be looking for the end-of-packet identifier, and the receive flags indicate that you expect an entire packet.  As another example, consider sending expedited data over TCP. You need to send each byte independently and use the expedited option:  36  P DA De velopers 4.5  Sept/Oct 1996   local myOpt:={ label: ""iexp"", type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { argList: [ 15, // expiditedData byte ], typelist: [ 'struct, 'byte, ], }, } try gEndpoint:Output("""", myOpt, nil); onexception |evt| do /* Traditional error handling here! */  mDisconnectCb:=func(inEp, inOpt, inRes) begin try inEp:Unbind({ _parent: self, async:true, completionScript:func(inEp, inOpt, inRes) begin :mUnbindCb(inEp, inOpt, inRes); end; } ); onexception |evt| do nil; end; /* and the other callbacks look similar...*/  Tearing Down and Cleaning Up C losing the Endpoint When a user calls the Close() method of an endpoint created by the protoInetClient, the endpoint is disconnected, unbound, disposed, and the link layer manager releases the link in use. NIE endpoint teardown is accomplished in a manner identical to that of other endpoints: /* Endpoint's Close() method calls :mTearDown(self) */ mTearDown:=func(inEp) begin if inEp.gState=nil then begin print(""We do nothing.""); end else if inEp.gState='instantiated then begin :mUnBindCb(inEp, inOpt, inErr); end else if inEp.gState='bound then begin :mDisconnectCb(inEp, inOpt, inErr); end else if inEp.gState='listening then begin inEp:Cancel( { async: true, completionScript:func(inEp, inOpt, inErr) :mDisconnectCb(inEp, inOpt, inErr) }); end else if inEp.gState='connected then begin inEp:mDisconnect(); end else if kDebugOn then print( ""Endpoint is already closing!""); end  Two things are worth noting here. First of all, there is an internal state variable to determine the current operation. It's best if you merge your application's communications state machine with the state machine you developed for handling input when you wrote your protocol engine. It makes the code clearer to readers, and easier to maintain. Secondly (and this may seem a bit odd), be sure you wrap the endpoint's teardown metho ds in exception handlers. Your endpoint may be torn down after some thing bad has already happened to an open connection. In addition, it prevents uncaught exceptions from scaring your users.  Releasing the Link Since the link layer manager tracks link usage using reference counts, it's imperative that you release the link when you're done using an endpoint. The Newton keeps the link active as long as other applications may be using a NIE endpoint, and then shuts down the link itself. (It's also a good idea to release the link if your application has a period of inactivity  running a modem can cause a large battery drain.) Releasing the link is simple; call InetReleaseLink() with the same arguments you called InetGrabLink(): mUnbindCb:=func(inEp, inOpt, inErr) begin local i; try inEp:Dispose(); onexception |evt| do nil; gState:='stopping; InetReleaseLink(fLinkID, self, 'mReleaseCb); end; mReleaseCB:=func(inLinkID, inStat, inErr) begin if inErr then begin :mNotifyError(""InetReleaseLink"", inErr); gState:=nil; gEndpoints:=nil; gCallbackSpecs.fStop:?CompletionScript( self, nil, inErr); gCallbackSpecs:=nil; end else begin if inStat.linkStatus='idle then begin InetDisplayStatus(inLinkID, fStatusView, nil); gState:=nil; gEndpoints:=nil; gCallbackSpecs.fClose:?CompletionScript( nil, nil, nil); end; end; end P DA DE VELOPER S  4.5  Sept/Oc t 1996  37   InetReleaseLink() requires three arguments  the link ID, a reference to a status v iew if appropriate, and what to put into the status view (or nil to conceal it entirely). Be sure your application has the same number of InetGrabLink()and InetReleaseLink() calls. It's embarrassing to leave the link open, or clo bber it for another application.  The NIE 1.0 API John Schettino GTE Laboratories, Inc. js12@gte.com  Some Thoughts On Software Quality & Support When developing your application, you're going to need to do testing. There are a few areas with the NIE where testing is more important than you might think:  Be sure you  Test all exce  Verify your application product, so issues. check all b oundary conditions. ption and event handlers. software with multiple servers (or clients, if your is a server), ISPs, and modems if it's a commercial you can warn your customers about compatibility  N  When developing an intranet application, consider yourself lucky. You're working w ith an application in a comparatively known space. If you're developing an application for the Internet, however, make sure you schedule what may seem like an inordinate amount of testing time. The Internet is one big distributed system. You'll see a lot of failures you don't expect. Unfortunately, not all of them will be yours: I can think of a few late nights I've spent tracing failures which turned out to be routing, not application failures. Support for applications using the NIE is another area you need to be prepared for. Although the NIE provides one of the best environments for setting up ISPs I've ever seen, it's by no means clear to all users. You're likely to receive calls about modems and ISPs you've never heard of, along with questions like ""Will it work with my shell account?"". The Internet is probab ly a new thing to many of your users. You need to be prepared to make their initial experience with it as pleasant and painless as possible.  ewton has been on the Internet in one form or another for a few years now. Getting connected usually entails baroque UNIX shell dial-ups followed by Telnet sessions. While this method works (as is evident in both the LunaSuite and GoFetch transports), the user setup is difficult and the connection tenuous at best. The Newton Internet Enabler (NIE) provides a direct network connect between the Newton and an Internet Service Provider (ISP) using either PPP or SLIP dial-up protocols. Once connected, you have a direct connection to the net as a first-class computing device. You can open sockets to as many addresses and ports as you like, accept and send UDP packets, and even listen for connections. In this article I present an overview of the NIE API and show how you can use the NetTest sample application to quickly write an NIEenabled application.  NIE API The NIE consists of three distinct components: the Inet tool, the Link Controller, and Domain Name Service. The Inet tool, which provides the majority of the actual socket communications capabilities neatly disguised as our old friend a communications endpoint, is at the top layer. Once you've connected you can (for the most part) think of a TCP/IP socket as a very reliable serial endpoint connection. Bravo. Above that (meaning you need to deal with this before getting connected) is the Link Controller. This is where you initiate and drop connections to the Net. Finally, there are several functions to translate Internet name-based addresses (such as ""WWW.YAHOO.COM"") into an actual IP address (four numbers separated by p eriods, as in 205.216.146.70).  Link C ontroller  Get ting C onnec ted  Putting It All Together If you're new to Newton communications programming, this article is probably a bit overwhelming. On the other hand, if you've been developing Newton applications with communications for a while, there shouldn't be all that much new material. The important points you should remember when writing an Internet-enabled application are:  The NIE endpoints are exactl y like any other child of protoBasicEndpoint.  The NIE provides global functions for link layer establishment and teardown.  The NIE provides global functions for Domain Name Resolution.  The NIE's APIs are all asynchronous. If you keep these points firmly in hand, you can't go too far astray. If you're new to Newton development, it's b est to develop a few communicating applications before you start that killer application. Like many things, Newton software development (and understanding the communications APIs in particular) gets easier with practice. Regardless of your background, the NIE is something that Newton developers have been waiting for. It's now up to us to help bring the promise of the Newton OS to the Internet. The source code f or NIE Ray's proto can be found on the source code disk for this issue of PDA Developers.  The first thing the Newton must do to use Internet services is to get wired in to the net. Once this is done, the Newton is just another node on the net with an IP address. The Link Controller initiates and destroys this link. There are thirteen functions relating to the Link Controller, but only three do the most common tasks. The first step in the connection process is to let the user review and modify their configuration options. The InetOpenConnectionSlip() function presents a standard NIE connection slip to the user and calls a supplied cal lback once it is dismissed: InetOpenConnectionSlip (link, context, callback)  Further Reading Apple Computer, Inc. 1995. Ne wton Programmers Guide: Communications. Apple Computer, Inc. Cupertino, CA. Apple Computer, Inc. 1995. Newton Internet Enabler. Apple Computer, Inc. Cupertino, CA. Stevens, W. Richard. 1994. TCP/IP Illustrated. 3 volumes. AddisonWesley Publishing, Menlo Park, CA.  If the Newton is already connected it does not open the slip, it just calls the callback method. The function itself returns nil if the Newton is already connected, or the open slip view if it is not. The link ID is supplied in link. This ID can either be nil, to use the default user-specified ID, or the value returned by InetAdd NewLinkEntry() (you almost always use the default). The context and callback parameters are usually your application's frame, and a symbol for the method defined in that frame. The callback method is called with three parame ters (link, status, and error) once the connection slip is dismissed. The link parameter is the same as used in the InetOpenConnectionSlip() call. The status parameter is a frame containing a single slot named linkStatus. If the value of linkStatus is 'connect then you should proceed with the connection. The error parameter is either nil for success or an error code indicating the error condition. Assuming that the user wants to proceed with the connection, the next step is to g rab a link by calling InetGrabLink: InetGrabLink (link, context, callback)  38  P DA De velopers 4.5  Sept/Oct 1996   This is where your Newton gets plugged into the Internet. As in the previous function, you can call InetGrabLink even if your Newton is already connected, in which case it just calls the callback with a 'connected value in the linkStatus slot of the status frame. callback is called at several points in the connection process, so that you can provide feedback (and a means of canceling the operation) to the use r. The actual connection can take several seconds. The status usually proceeds through the fol lowing steps: 'idle 'initializing 'connecting 'login 'connected link not established initial setup preceding a connection dialing up the ISP connected to ISP, executing login script link made and ready to use  The next step is to use the Bind() endpoint method to bind that endpoint to a local TCP/IP address and port. When making an outgoing connection, this can be a dynamically-allocated local port. These options get a local port: [{ label: ""ilpt"", // set the local port type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { arglist: [0, true, ], typelist: [ 'struct,'short,'boolean, ],},},]  During this connection process you can use InetDisplayStatus()to display the connection progress. This function can use a view of your own design (based on a protoStatusTemplate) or it can create a floating slip containing a text display area and a stop button for you. Once the status is 'connected, you can use the link to create one or more sockets. When you're done with the link you use InetReleaseLink() to drop the link: InetReleaseLink (link, context, callback)  Finally, you're ready to connect to the TCP/IP service. These services reside at known IP addresses and ports. For example, to bind to the Yahoo web server you'd use ""WWW.YAHOO.COM"" at port 80. You use the DNS service to convert that address into the needed numbers. Use the Connect() endpoint method to make the connection, supplying these options: [{ label: ""itrs"", type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { arglist: [addr1, addr2, addr3, addr4, portNo], typelist: [ 'struct, 'byte, 'byte, 'byte, 'byte, 'short,],},},];  Based on the user preferences this may or may not actually disconnect the Newton from the Internet. It's important to note that the context supplied here should be the same as that used in the InetGrabLink() call.  Using a Soc ket When They C all it an Endpoint The NIE uses standard Newton endpoints to establish the actual Internet connections. This is both a very cool thing and a bit confusing for those of us with UNIX socket programming backgrounds. Depending on the type of connection you're making (TCP or UDP) and if you're initiating the connection or waiting for a connection, you've got more or less work to do. Let's look a the simple case of making an outgoing TCP connection. You use the familiar Instatiate() method on your endpoint, supplying the following options: [ { label: ""inet"", type: 'service, opCode: opSetRequired, result: nil, }, { label: ""ilid"", type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { arglist: [ link, ], typelist: [ 'struct, ulong, ],},}, { label: ""itsv"", type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { arglist: [ protocol, ], typelist: [ 'struct, 'ulong, ],},},]  addr1..addr4 and portNo values correspond to the four segments of the target Internet address and the port number to connect to. Once this connection is established you send and receive information over the endpoint as usual. To disconnect an endpoint you use the standard Disconnect(), Unbind(), and Dispose() methods.  Domain N ame Service How do you find the know the host name (80 for HTTP). This functions, but by far FromName(): actual IP address for your service? Usually you (""WWW.YAHOO.COM"") and the port number is where the DNS comes in. There are four DNS the one you use most is DNSGetAddress-  DNSGetAddressFromName (hostname, context, callback)  hostname is the host name you're looking up, context and callback are used for the callback as in the Link Controller. The callback func tion takes two par ameters. The first is an array of fr ames containing addresses that can be used for the host name. The second is the result code or nil for no error. A typical callback function just extracts the desired address: func(results, error) begin if error or length(results) < 1 then begin // handle error return; end; // save the resolved address hostIpAddr := results[0].resultIPAddress; end;  The v alue in hostIpAddr is an array of four numbers, corresponding to the IP address f or the host.  The ""inet"" option identifies this as an Internet endpoint, ""ilid"" specifies the link ID, and the ""itsv"" option identifies the protocol to use. The protocol is 1 for TCP and 2 for UDP.  A Brief Word From our Sponsor You have total control over how your NIE-enabled application does things, but there are a few very useful tools that you should look at before you begin coding everything from scratch. I'm talking about the ""Developer Goodies"" portion of the NIE distribution. P DA DE VELOPER S  4.5  Sept/Oc t 1996  39   The FSM proto has been expanded to support NIE, and is also an excellent source of example code showing how the various func tions are used. NetTest is a fully functioning application that you can use to hack your way to an NIE application in short order. There are also some serious memory limitations when using the NIE. On a MessagePad 120 you can expect to just barely get one endpoint connected with all instal led packages and extensions. You should also avoid attempting to use any of the DNS functions with an active endpoint.  This handler collects messages and appends then to the SmartString until a message containing ""End"" is received. Once that happens the entire message is processed in the method named processISPMessage(). This hand ler also strips out blank lines.  A Simple Protocol This issue's source code disk includes a custom application that uses simple commands to manipulate a telephony application that can make calls, conference calls, select an active call, and generally act like a PBX. The Newton application sends messages to initiate these actions, and receives status messages from the UNIX application indicating the current call status. It uses these messages to draw a visual representation of the current calls that the user can manipulate to merge calls, break conferences, and so on. The protocol is summarized below:  Building an NIE Application Quickly NetTest is a sample application that creates an endpoint connection (either TCP or UDP) to any host and port. Once connected you can enter in some text and send it through the endpoint. Any incoming text is displayed in a text window. You can hack this application to quickly implement many text-based NIE applications. I used it to quickly implement an application that uses a TCP endpoint to communicate with a custom UNIX application. NetTest implements all of the necessary goodies to get you connected. Once connected, you can send text messages and process incoming messages by modify ing just a few key methods. Two slots are used for outgoing and incoming text.  New ton C lient Messages Here are the messages that can be sent from the Newton client to the UNIX server: Dial   Drop   Merge     Split   Select   Transfer     Place a call to   Hang up the call using   Merge calls represented by   and   Split the call represented by   from its conference Make the call represented by   the active call, put others on hold Transfer the call in   to   End the session  Sending Messages To send a message using the NetTest project, simply place the desired text string into the slot named fDataStream, then call :Msend(). A CR and LF are appended to the message and then it is sent out the connected endpoint.  Processing Inc oming Messages Incoming messages are placed into a SmartString in the slot named fReceiveBuffer. As each message is received a method named MPutDataInReceivedArea() is called with the string. All you need to do is modify this method to examine the string to see what was received. Here's my modified handler: func(str) begin // fill up THE buffer until protocol-specific string // is reached. For us the is the word ""End"" if not call kViewIsOpenFunc with (fAppBase) then return; if fReceiveBuffer = nil then :MResetReceiveBuffer(); // is it the end-of-message line? // if so, don't add to the buffer, just process it if StrEqual(str, """" & UnicodeCR) then return; if StrEqual(str, ""End"" & UnicodeCR) then begin SmartStop(fReceiveBuffer, fReceiveBufferLen); self:processISPMessage(); end else begin // append this line to the current message buffer if fReceiveBufferLen < kMaxReceiveBufferSize then fReceiveBufferLen := SmartConcat( fReceiveBuffer,fReceiveBufferLen,str); else begin if not fBufFullNotified then begin :MNotify(""Receive buffer overflow.""); fBufFullNotified := true; end; end; end; end  Bye  U N I X Server Messages This is the current call state, as a flattened graph. State Active Call   id   Name ... End  There are zero or more lines of the form: id   Name  If   is not zero, then the next lines specify the group. This indicates that a new call has become the active call. Select Active Call   End  This indicates a client message was not processed: Error End  When the user performs some action that requires sending one of the client messages, the text is placed into the fDataStream slot and then :MSend() is called. When messages are received from the Unix server, processISPMessage() is called to process them once the ""End"" text is received. Here's the processISPMessage() handler:  40  P DA De velopers 4.5  Sept/Oct 1996   func() begin local myAccessor, theMessageHdr, theWords, aWord, activeCall; // tokenize the data by line myAccessor := StrTokenize(fReceiveBuffer, $\n); // get first line theMessageHdr := call myAccessor with (); :MPutDataInStatusArea(""Message: "" & theMessageHdr); if BeginsWith(theMessageHdr,""State"") then begin phoneDisplay:updateState(myAccessor); end; else if BeginsWith(theMessageHdr, ""Select"") then begin // Next line says which call is active theMessageHdr := call myAccessor with (); theWords := StrTokenize(theMessageHdr, $ ); call theWords with (); // discard word 1 activeCall := floor(StringToNumber(call theWords with ())); if activeCall > 0 then buttonArea:InitClusterValue(activeCall); else buttonArea:InitClusterValue(nil); end; else if BeginsWith(theMessageHdr, ""Error"") then nil; // some illegal request was made :MResetReceiveBuffer(); RefreshViews(); end  I use the very powerful StrTokenize() function to parse the SmartString into lines and words. The first line of the message is tested to see which of the server messages was received. If it was the ""Select"" message, the entire message is handed to phoneDisplay:updateState(), which updates the client display. Also, the id of the selected call is extracted and an appropriate radio button is enabled. If an ""Error"" message is received, it's simply discarded. Once the message is processed, the NetTest method :MReset ReceiveBuffer() is called to clear the received text buffer for the next message. This application (at least the communications portion) was implemented in a matter of hours by building on top of NetTest. Many UNIX TCP/IP services such as NNTP (net news), SMTP/POP (e-mail), and HTTP (world wide web) use similar text-based protocols. NetTest could be used to implement basic applications that work with these servers, or (as I did here) to implement custom client applications for the Newton.  Snowboard on the Internet NIE gives Newton the capability to play on the Internet. How it will play remains to be seen. I've used it to make a custom application (this is where Newton and NIE can really shine). You can use a Newton as one heck of a nice Internet appliance if you do all of the interface on the Newton and just send simple text messages to a UNIX, Mac, or NTbased server sitting on the Internet. The complexit y of TCP/IP programming is hidden pretty well by the NIE. Although there are a lot of functions, you can use the sample applications or the FSM protos to build the tedious connection/tear down code and really focus your efforts on the application itself. Fun times ahead.  Figure 2 - The Pilot Inventory application.  Figure 1 - Inventory on the PC - the main form. P DA DE VELOPER S  4.5  Sept/Oc t 1996  41   Extending Your Desktop With the Pilot Stu Slack The Windward Group slack@wwg.com  U.S.       Robotics markets its Pilot as a desktop extension, letting you take information from your p ersonal or office computer with you wherever you go. There are many p otential applications for this device, including:   Reads the Windows Registry and finds all the conduits listed in the Pilot Desktop section,  Enumerates the databases on the Pilot and creates a list of databases that reside on the Pilot, and  Determines which databases on the Pilot have a corresponding conduit. If there are databases without conduits, these are put into the list of databases to be backed up using the backup conduit. After HotSync builds its internal list of conduits (including all the standard Pilot application's conduits, backup conduit, install conduit, and third-party conduits), it's ready to start the synchronization process. For each conduit in turn, HotSync loads the conduit in memor y, choreographs the synchronization process, and then unloads the conduit.  A car dealer's vehicle database, Inventor y control, Golf score cards, A data-monitoring device, or A time-tracking tool.  C onduit Responsibilities A conduit's responsibilities during synchronization really depend on your requirements. Your sync logic can be simple or very complex. Minimally, a conduit that s upports record-level synchronization must:  Open both databases for modify access;  Determine which records are added, deleted, or modified on both platforms and use this information to perform the synchronization;  Convert data between local and remote formats (for example, resolving byte-format differences between Intel and Motorola microprocessors  the Pilot uses a Motorola microprocessor);  Create and/or delete local and remote records; and  Write information to the Sync Log, if appropriate. This log file collects useful information such as record counts and detailed descriptions of what was synched. To facilitate synchronization, the Pilot and PC databases both need information about the record operations since the last sync. During synchronization, the conduit compares each Pilot record against the corresponding PC record and decides how to proceed with this information. See the ""Synchronization Algorithm"" section of the Palm OS Conduit De velope r's Guide for a description of the possible synchronization cases and actions you should take.  One common aspect of all these applications is the ability to change data while in the field, and then merge those changes with the information on your desktop machine, preferably without losing any of the changes in the process. This intelligent merg ing of separate databases is referred to as synchronization. One of the Pilot's notable features is its one-touch synchronization, using the HotSync application. U.S. Robotics' HotSync application provides a uniform method for transferring information between the desktop and the Pilot. However, HotSync doesn't know anything about the data it moves. Rather, HotSync relies on conduits to do the dirty work. A conduit is a Windows DLL that you build to interface your application to the Pilot. It's responsible for reading and writing both the local (PC) and remote (Pilot) databases, and for doing any data transformations or field valuemappings required to accurately move data between the two systems. HotSync provides a number of services that help your conduit perform these tasks. Once you decide to create an application that extends your desktop in this way, there are many implications. These issues relate to data manageme nt in your desktop application and your Pilot application, as well as in your conduit. In this article I look at all of these issues, demonstrate how to write a Pilot application (in particular, the database manageme nt logic), and how to write a related conduit.  Example Application Pilot Conduits Synchronization is the process of merging two databases: one on a PC and one on a Pilot. The HotSync application manages this process, and calls on conduits to perform the actual data manipulation for each database that is synchronized. There is one conduit for each unique pair of PC and Pilot applications. Synchronization operations differ based on the type of usage you expect for your application. For example, if you have data that is going to change in only one place at a time (that is, the data changes on the PC or on the Pilot, but not on both at the same time), then you can synchronize using a simple file-copy approach. Such a conduit is fairly trivial. If, on the other hand, you expect data to change on both systems between synchronization operations, then you need to provide recordlevel synchronization, and you need to keep track of changes on a record-by-record basis. The Palm OS provides tools for you to do this in your Pilot application. It's up to you to maintain appropriate information in your desktop database. In order to illustrate the issues I discuss in this ar ticle, I have written a simple inventory control application. You can use this application in two ways: to provide price and availability information to a customer, and to field check and update the actual inventor y against what's in the database. In order to keep this application straightforward, I make two simplifying assumptions: the chara cter data is all stored in fixed-length fields, and the application does not support categories. The entire inventory application has three parts:  The PC application, shown in Figure 1;  The matching Pilot application, shown in Figure 2; and  The conduit. Both the PC and Pilot applications intentionally have similar user interface and data formats. The same group of users use both the desktop and the Pilot application. By making the interfaces and functions similar, they are not confused when they move from system to system.  The ABCs of HotSync When you press the HotSync button on the Pilot's cradle, an interrupt is generated which takes the Pilot out of sleep mode and into HotSync initiation mode. The Pilot then sends wake-up packets at two-second intervals until the HotSync application on the desktop acknowledges the Pilot's wake-up call, or until a time-out occurs. When the HotSync application recognizes the wake-up packet, the initiation process starts. HotSync does the following before it starts the synchronization process:  PC Applic ation The PC application (see Figure 1) is a dialog-based MFC application that lets you add, delete, and update records. Althoug h I don't talk in detail about the code, I refer to it when discussing the conduit and its logic to determine which records to synchronize.  Pilot Applic ation I wrote the Pilot application (see Figure 2) in C using CodeWarrior for Pilot (also referred to as the Pilot SDK) available from U.S. Robotics.  42  P DA De velopers 4.5  Sept/Oct 1996   The UI design is similar to the PC application, but the internals are completely different. I describe this application in more detail because it demonstrates some of the data management techniques that are important when developing Pilot applications.  Pilot Data Management The Pilot Data Manager, the Pilot's equivalent of a file system, is an integral part of the Palm OS. It maintains records on the Pilot in noncontiguous, non-volatile memory, relieving you of the burden of keeping track of record positions in memory. The Data Manager keeps track of records using record IDs that are assigned by the operating system. Every record on a Pilot has a unique record ID. The record ID is ver y important to the synchronizat ion process: it's used to identify matching records on the PC and Pilot. Databases are divided into two parts (se e Figure 3): the database header and the record information. The database header contains general information about the database, such as database name and number of records in the database. The database record info area contains a row for each record. Each row has four fields: Record ID The unique ID assigned by the Pilot Data Manager when the record is created. Cat The category that the record belongs to. My inventory control application does not implement categorized records, but this field can be used for a note-taking application, for example, to classify the notes into specific groups. The Pilot has built-in operating system suppor t for these categories. Attr The attributes of the record, set by you or by the Data Manager. The standard att ributes are Modified, Deleted, Archived, and New. Your PC database should have a matching field, so that your conduit can determine the status o f corresponding records, and take the appropriate action during synchronization. LocalID This is the local ID of the memory chunk allocated for the record. Local IDs lets the Data Manager store records anywhere on the memor y card. When accessing the record, the Data Manager does a simple offset calculation to obtain the record's handle, which it uses to access the record. There are two ways to open a database. You can use the Data Manager's DmOpenDatabaseByTypeCreator or DmOpenDatabase functions. I used the first function because Inventory stores all  of its data in a single database, tied to my application's creator ID. With more than one database, I have to use the DmOpenDatabase function, which uses a Database ID to identify the database to open. You can find the Database ID by calling DmFindDatabase. When you delete a record using the DmDeleteRecord function, the Data Manager doesn't actually delete the record. Instead, it marks the record Deleted using the appropriate record attribute. As a result, your conduit can identify records that are to be deleted from one database or the other. For more details about the specifics of the Data Manager, see ""The Data Manager"" in the Pilot SDK documentation.  Inventory's Database In order to demonstrate working with the Data Manager, I include two important functions from the Pilot application here: NewRecord, which creates new records, and DeleteRecord, which deletes a record from the Pilot database. The NewRecord function allo cates a new database record using DmNewRecord. Since I use only fixed-length fields, I can just use the size of the InvItem structure as the size of a new record. I then lock the returned handle to get a pointer to the new record. /************************************************** * NewRecord **************************************************/ Boolean NewRecord(DmOpenRef dbRef, InvItemPtr pSrcItem, UInt *index) { int size = 0; ULong offset; VoidHand hRecord; InvItemPtr pInvItem; Boolean bRes = true; // Allocate a new data chunk. hRecord = DmNewRecord( dbRef, index, (ULong)sizeof(InvItem) ); if( !hRecord ) { FrmAlert (DeviceFullAlert); return false; } pInvItem = MemHandleLock( hRecord ); // Write the record's contents if( pInvItem ) { offset = 0; DmStrCopy( pInvItem, 0, pSrcItem->m_szItem ); offset += MAX_ITEM; DmStrCopy( pInvItem, offset, pSrcItem->m_szDesc ); offset += MAX_DESC; DmWrite( pInvItem, offset, &pSrcItem->m_nStock, sizeof(int) ); offset += sizeof(int); DmWrite( pInvItem, offset, &pSrcItem->m_dPrice, sizeof(double) ); MemPtrUnlock( pInvItem ); // The ""dirty"" flag is set in DmReleaseRecord DmReleaseRecord( dbRef, *index, true ); } else bRes = false; return bRes; }  Figure 3 - A typical Pilot database l ayout. P DA DE VELOPER S  4.5  Sept/Oc t 1996  43   To write to database memory, you must use Data Manager functions like DmStrCopy and DmWrite. To use these functions, you must maintain an offset from the start of your record to write the data. As you can see, after I call DmStrCopy, I increment the offset by the number of bytes written. After unlocking the record, I use DmReleaseRecord to set the record's dirty flag. When deleting records in a Pilot application that has a sister application on the desktop, you do not want to physically delete records when the user presses the delete key. Instead, you should mark the record for deletion using DmDeleteRecord. Once you delete the record, it's gone from the user's view, but still in the database until the next sync operation. The following code fragment shows how to delete a record from a Pilot database. /************************************************** * DeleteRecord **************************************************/ DeleteRecord( int nRec ) { VoidHand hRec; hRec = DmQueryRecord( InventoryDB, CurrentRec ); if( hRec ) DmDeleteRecord( InventoryDB, CurrentRec ); }  access individual records. This structure enables the SyncManager to access any record, regardless of its layout. It is up to you to interpret the record's contents when using a record-oriented cal l. struct CRawRecordInfo { BYTE m_FileHandle; // From OpenDatabase() DWORD m_RecId; // Record ID WORD m_RecIndex; // Index of record BYTE m_Attribs; // Attributes short m_CatId; // Category int m_ConduitId; // Conduit ID DWORD m_RecSize; // Max records size WORD m_TotalBytes; // Num bytes read/written BYTE * m_pBytes; // Data };  You should always use the DmQueryRecord function and check the returned handle before calling any other Data Manager function. Deleted records return a NULL hRec. Note that there is a Data Manager function, DmRemoveRecord, that removes a record completely from a Pilot database, rather than marking it for deletion as discussed here.  The m_pBytes member variable is a pointer to the raw bytes in the record. The SyncManager sends this data to your conduit's conversion routine during synchronizat ion. The m_FileHandle is the database handle; it must be set to the value returned by SyncOpenDB. See the Conduit SDK for a more detailed description of this structure and its use. You can scan a database for modified records by calling the SyncManager's SyncReadNextModifiedRecord function. SyncManager uses the ""dirty"" bit in each record's attribute field to determine which records have been mo dified. You are responsible for maintaining the dirty bit in your Pilot application. Set it when you modify a record and clear it after you perform a sync.  C onduit Entry P oints Your conduit must export several C entry point functions so the HotSync application can retrieve information from your conduit and initiate the synchronization process. The list ing below shows the minimum conduit interface needed to get started. // InvCond.cpp : Defines the conduit init routines #include #include #include #include #include #include ""stdafx.h"" ""resource.h""   ""SyncMgr.h"" ""InvDll.h"" ""InvCond.h""  Writing Your Conduit A conduit is a Microsoft MFC Extension DLL that is loaded by the HotSync application when needed. To create a conduit, you need the Conduit SDK, available from US Robotics, and Microsoft Visual C++ (version 4.0 or b etter). The best way to create your DLL is to use the MFC AppWizard. Start by selecting File/New from MSVC, then select Project Workspace from the New dialog. Next, select MFC AppWizard (DLL), fill in the project name and select the Create button. This brings you to the MFC AppWizard dialog (see Figure 4). Under the question ""What type of DLL would you like to create?"" select MFC Extension DLL, then click the finish button. MSVC creates a skeleton DLL from which you can build your conduit.  The SyncM anager DLL The SyncManager DLL provides services that let your conduit set up and do a synchronization. It establishes and maintains the data pipeline between the PC and Pilot and handles database and record operations on the Pilot. The SyncManager provides three main categories of services: session-oriented, file-oriented, and record-oriented. The session-oriented services provide routines for initializing memor y and resources for use by your conduit during the sync process. You must call SyncRegisterConduit before calling any other SyncManager functions, and clean up using the SyncUnRegisterConduit function after your conduit is finished. The file-oriented services provide an API for Pilot database operations such as open, close, create, and delete databases. There are also functions for getting information from a database, such as the database's application information blo ck (AppInfo) which stores application-specific information in the database. The SyncOpenDB call opens a database on the Pilot and returns the database's file handle. You must use this handle when accessing Pilot records using the SyncManager's record-oriented services. The SyncManager's record-oriented services, such as reading, writing, and deleting records, provide the interface for working w ith database contents. These functions use a CRawRecordInfo structure to  Figure 4 - The MFC AppWizard Dialog  44  P DA De velopers 4.5  Sept/Oct 1996   #ifdef _DEBUG #define new DEBUG_NEW #undef THIS_FILE static char THIS_FILE[] = __FILE__; #endif static AFX_EXTENSION_MODULE InvCondDLL = { NULL, NULL }; HINSTANCE myInst; /***************************************** * DllMain *****************************************/ extern ""C"" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) { if (dwReason == DLL_PROCESS_ATTACH) { // Extension DLL one-time initialization AfxInitExtensionModule(InvCondDLL, hInstance); myInst = hInstance; // Insert this DLL into the resource chain new CDynLinkLibrary(InvCondDLL); } else if (dwReason == DLL_PROCESS_DETACH) { // Cleanup the DLL! AfxTermExtensionModule( InvCondDLL ); } return 1; // ok } /***************************************** * OpenConduit *****************************************/ ExportFunc long OpenConduit(PROGRESSFN pFn, CSyncProperties& rProps) { long retval = -1; if (pFn) { CInvConduit* pConduit; pConduit = new CInvConduit(pFn, rProps ); if (pConduit) { retval = pConduit->StartSync(); delete pConduit; } } return(retval); } /***************************************** * GetConduitName *****************************************/ ExportFunc long GetConduitName(char* pszName, WORD nLen) { long retval = -1; if (::LoadString(myInst, IDS_COND_NAME, pszName, nLen)) retval = 0; return retval; } /***************************************** * GetConduitVersion *****************************************/ ExportFunc DWORD GetConduitVersion() { return 0x00000101; }  The first function in the listing is DllMain, the main function that is called when the DLL is loaded by the system. If there are any application initialization tasks that need to be performed, do them here when the DLL_PROCESS_ATTACH flag is set in the dwReason parameter. Similarly, perform application cleanup tasks when the DLL_PRO-CESS_DETACH flag is set.  Informational Func tions Your conduit must expor t two functions that allow the SyncManager to interrogate your conduit during startup processing:  GetConduitName - This function lets the SyncManager obtain your conduit's name. HotSync uses this name in its progress dialog, for example.  GetConduitVersion - This function lets the SyncManager get version information from your conduit. HotSync queries each conduit for its version number, and does not loa d the conduit if it gets an incorrect version number. This lets HotSync manage enhancements to the HotSync application and conduits. Once HotSync loads your conduit's DLL into memory and determines that it's the correct version, it invokes your conduit by calling its OpenConduit entr y point.  The OpenC onduit Func tion HotSync calls OpenConduit in order to start the actual synchronization. HotSync passes two par ameters to this function. The first parameter, PROGRESSFN, is a pointer to a progress function. This function is reserved for future use. The second parameter identifies a CSyncProperties st ructure. This important structure contains informat ion, such as the local and remote database names, that you need when synching. class CSyncProperties { public: eSyncTypes m_SyncType; // Fast/Slow char m_PathName[BIG_PATH]; // Full path char m_LocalName[BIG_PATH]; // File name char m_UserName[BIG_PATH]; // User char* m_RemoteName[DB_NAMELEN]; // Remote DB names CDbList* m_RemoteDbList[DB_NAMELEN]; // Remote DB list int m_ nRemoteCount; // Num Remote DBs CSyncLog* m_pSyncLog; // sync log DWORD m_Creator; // Creator ID WORD m_CardNo; // DB's card num DWORD m_DbType; // DB Type (DATA) DWORD m_AppInfoSize; // convenience DWORD m_SortInfoSize; // convenience eFirstSync m_FirstDevice; // Dev first sync eConnType m_Connection; // Transfer medium }; ExportFunc long OpenConduit(PROGRESSFN pFn, CSyncProperties& rProps) { long retval = -1; if (pFn) { CInvConduit* pConduit; pConduit = new CInvConduit(pFn, rProps ); if (pConduit) { retval = pConduit->StartSync(); delete pConduit; } } return(retval); } P DA DE VELOPER S  4.5  Sept/Oc t 1996  45   In my Inventory example, OpenConduit instantiates a CInvConduit object which also takes the progress function pointer and CSyncProperties reference. I implement all the conduit synchronization code in this object only to isolate the synchronization code from the rest. (You can w rite the whole sync logic in C func tions that are cal led directly from OpenConduit.) After instantiating the conduit object, I call StartSync and the real action begins. When StartSync returns, Inventory is done with its part of the HotSync and the SyncManager destroys the conduit object.  Implementation of the Inventory Conduit Figure 6 shows the relationships between the Inventory conduit's classes and the local and remote databases. The conduit accesses the remote database, called InvDB, using SyncManager functions. The CommandServer is a DLL loaded by HotSync; it provides communications services such as reading physical records over the serial connection between the Pilot and the PC, to the SyncManager. The Inventor y conduit contains classes and their supporting members. The base class, called Cconduit, is responsible for setting up and controlling the synchronization and implementing common functions such as byte conversion routines. The derived class, CInv-Conduit, contains the interfaces that are needed to deal with inventoryspecific tasks such as reading and writing inventory records. class CConduit { public: CConduit( PROGRESSFN fFn, CSyncProperties &rProps ); // Public access CString &GetName() {return m_csName;} void SetName( const char *szName ) { m_csName = szName; } // Overridables virtual long StartSync(); virtual long ObtainLocalTable() {return CONDERR_BAD_LOCAL_TABLES; } virtual long ObtainRemoteTable() { return CONDERR_BAD_REMOTE_TABLES; } virtual void UpdateLocalTable() {}; // Support one or more of these sync types: virtual long DoFastSync(){return CONDERR_UNSUP_TYPE;} virtual long DoSlowSync(){return CONDERR_UNSUP_TYPE;} virtual long DoPilotToPCSync(){return CONDERR_UNSUP_TYPE;} virtual long DoPCToPilotSync(){return CONDERR_UNSUP_TYPE;}  The Window s Registry In order f or HotSync to call your conduit, you must have a properlyformatted entry in the Windows Registry (see Figure 5). All third-par ty conduits need to be included in the registry under the ""HKEY_CURRENT_USER/Software/Palm Computing/Pilot Desktop"" tree. HotSync looks for your conduit in the ""ApplicationN key"", where ""N"" is a consecutive non-negative number. When installing your conduit, you must find the last ""ApplicationN"" entr y and include yours after the last entry you find. In Figure 5 the Inventor y conduit is under the ""Application0"" key since there are no other third-party conduits installed. It is important that the ""Creator"" field contains your Pilot application database's creator ID. HotSync uses this creator ID to match-up your conduit to your Pilot database. If your Pilot database and the Creator ID don't match, HotSync assumes that the Pilot database should be included in the list of databases to be backed up using the backup conduit. On the Pilot, you set the creator ID when you create the database using the DmCreateDB function. The ""Priority"" entry determines the order in which the conduit is loaded. Using this field, you can affect the order in which HotSync executes the conduits. This is handy, for example, if you need to ensure that the Datebook conduit is executed before your conduit. ""Priority"" ranges from 0, the highest priority, to 4, the lowest. The default is 2. Note that more than one conduit can have the same priority value. The other Registry entries are fully described in the Palm OS Conduit SDK documentation.  Figure 5 - The Pilot Tree of the Windows Registry.  Figure 6 - Context diagram for Inventory conduit.  46  P DA De velopers 4.5  Sept/Oct 1996   protected: BOOL IsCommsError( long lErr ); void WriteByteStream( BYTE *pbDest, const char *pStr, int &iPos ); [... More ...] int ReadByteStream( char *pDest, const BYTE *pbSrc ); [... More ...] // Protected Variables PROGRESSFN m_pfnProgress; CSyncProperties &m_rSyncProps; BYTE m_hRemoteDB; fstream m_File; private: CString m_csName; };  case ePCtoHH: retval = DoPCToPilotSync(); break; case eHHtoPC: retval = DoPilotToPCSync(); break; } // Reset all status flags on the Remote size. SyncResetSyncFlags( m_hRemoteDB ); if (!IsCommsError(retval)) SyncCloseDB(m_hRemoteDB); // Update the local table UpdateLocalTable(); if (retval) syncFinishCode = slSyncAborted; // Notify the log that a sync has ended if (m_rSyncProps.m_pSyncLog) m_rSyncProps.m_pSyncLog->AddEntry( m_csName, syncFinishCode); if (!IsCommsError(retval)) SyncUnRegisterConduit(conduitHandle); return(retval);  Start Your S ync The CConduit::StartSync function is responsible for setting up and doing the sync. It first tells the SyncManager DLL, by calling the SyncRegisterConduit function, that it plans to talk to the Pilot. I instruct the SyncManager to append a ""Sync Started"" message to the Sync Log. You can use the log file to display other messages pertinent to the HotSync, such as start and end messages and failure messages if something goes awry. Since CInvConduit is derived from CConduit, it needs to override many of the functions called by StartSync. long CConduit::StartSync() { long retval; CONDHANDLE conduitHandle = (CONDHANDLE)0; Activity syncFinishCode = slSyncFinished; // Register this conduit with SyncMgr.DLL for // communication to HH if (retval = SyncRegisterConduit(conduitHandle)) return(retval); // Notify the log that a sync is about to begin if (m_rSyncProps.m_pSyncLog) m_rSyncProps.m_pSyncLog->AddEntry( m_csName, slSyncStarted); // Open the Remote Database retval = ObtainRemoteTable(); if( retval != CONDERR_NONE ) return retval; // Open PC tables and load local records && local // categories. retval = ObtainLocalTable(); if( retval != CONDERR_NONE ) return retval; // Synchronize the records - depends on the sync type // Note: Not all need to be supported. switch( m_rSyncProps.m_SyncType ) { case eFast: retval = DoFastSync(); break; case eSlow: retval = DoSlowSync(); break; }  Next, the conduit must open the local and remote databases. The local database is a simple linked list of CInventoryRec structures which are maintained by the CRecordList class. The OpenLocalTable function reads all of the local records into memory. I do this in order to minimize the duration of the synchronization session, thereby conserving Pilot battery life. long CInvConduit::ObtainLocalTable() { long retval = CONDERR_NONE; CString dataFile(m_rSyncProps.m_PathName); dataFile += m_rSyncProps.m_LocalName; m_File.open( dataFile, ios::binary|ios::in ); if( m_File.is_open() ) m_listRecs.ReadFromDisk( m_File ); else retval = CONDERR_BAD_LOCAL_TABLES; m_File.close(); return retval; }  The ObtainRemoteTable function opens the remote database on the Pilot, using SyncOpenDB. If the remote database does not exist (like when synching for the first time without previously running Inventory), I create a database using SyncCreateDB. You should use the information contained in the SyncProperties structure passed into your DLL to set information, such as the creator ID in the CDbCreateDB st ructure passed to SyncCre ateDB. Once the database has been successfully created, I store the file handle in the conduit's m_hRemoteDB member variable.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  47   long CInvConduit::ObtainRemoteTable() { long retval = CONDERR_BAD_REMOTE_TABLES; // Call into SyncManager.DLL to open Remote DB retval = SyncOpenDB( m_rSyncProps.m_RemoteName[0], 0, m_hRemoteDB); // Create the remote database if it's not there if (retval == SYNCERR_FILE_NOT_FOUND && m_rSyncProps.m_SyncType != eHHtoPC) { CDbCreateDB dbInfo; memset(&dbInfo, 0, sizeof(dbInfo)); dbInfo.m_Creator = m_rSyncProps.m_Creator; dbInfo.m_Flags = eRecord; dbInfo.m_CardNo = ( (BYTE)m_rSyncProps.m_CardNo; dbInfo.m_Type = m_rSyncProps.m_DbType; strcat( dbInfo.m_Name, m_rSyncProps.m_RemoteName[0]); if (!(retval = SyncCreateDB(dbInfo))) m_hRemoteDB = dbInfo.m_FileHandle; } return(retval); }  // Normal termination when EOF on Pilot is // encountered. Anything else is error to return. if( err && err!=SYNCERR_FILE_NOT_FOUND ) lRet = err; else { wireRec.m_FileHandle = m_hRemoteDB; // Now go through all modified records (new/delete) // on the local side and perform actions to the // remote side. for( inx=0; inx m_wStatus&fldStatusDELETE) == fldStatusDELETE ) DeleteRecs( *pLocalRec, inx, TRUE ); // Else if new record, add to remote side else if( (pLocalRec-> m_wStatus&fldStatusADD)== fldStatusADD ) { ConvertRec( wireRec, *pLocalRec ); err = SyncWriteRec( wireRec ); if( err == SYNCERR_NONE ) { pLocalRec->m_nRecId = wireRec.m_RecId; pLocalRec->SetStatus(fldStatusNONE); } else { lRet = err; break; } } } } } // Done - cleanup if( wireRec.m_TotalBytes > 0 && wireRec.m_pBytes ) delete [] wireRec.m_pBytes; // Purge all remote deleted records SyncPurgeDeletedRecs( m_hRemoteDB ); // Purge all local deleted records m_listRecs.PurgeDeletedRecs(); return lRet; }  Once I open (or create) the local and remote databases, I call DoFastSync in order to synchronize the two databases. The base CConduit class determines which virtual function to call by checking the SyncProperties m_SyncType member. This field indicates the type of sync: slow, fast, or overwrite. See the Palm OS Conduit SDK documentation for a complete explanation of each sync type. Here, I implemented only the fast sync logic. long CInvConduit::DoFastSync() { long err = SYNCERR_NONE; long lRet = SYNCERR_NONE; WORD wRecCnt; // Get number of recs in remote DB SyncGetDBRecordCount( m_hRemoteDB, wRecCnt ); CRawRecordInfo wireRec; CInventoryRec remoteRec; // Setup the record for retrieving record over wire memset(&wireRec, 0, sizeof(wireRec)); wireRec.m_FileHandle = m_hRemoteDB; // remote handle wireRec.m_RecId = 0; // Record ID wireRec.m_RecIndex = 0; wireRec.m_pBytes = (BYTE *)new char [sizeof(CInventoryRec)]; wireRec.m_TotalBytes = sizeof(remoteRec); // Loop over all the records on the Remote side and // perform the synchronization logic on each one. int inx = 0; while(err == SYNCERR_NONE) { if( (err = SyncReadNextModifiedRec(wireRec) ) != SYNCERR_NONE ) break; ConvertRec( remoteRec, wireRec ); PerformPilotToPCRecSync( remoteRec ); }  This function takes a two-step approach to synchronizing the records. First, the conduit iterates over all the remote records and acts on them, then iterates over the local records to do the same. While iterating over the records on the local or remote side, you may encounter deleted records. Be careful how you implement the record deletion function to avoid changing record indexes while in the iteration loop. I avoid this problem by marking records for deletion (instead of physically deleting them), then performing cleanup after the iteration is complete. SyncPurgeDeletedRecs purges records marked for deletion on the remote database, and m_listRecs.PurgeDeletedRecs does the same on the local database.  48  P DA De velopers 4.5  Sept/Oct 1996   When iterating over the records on the remote side, the conduit reads each record using SyncReadNextModifiedRec. The ConvertRec function reformats each record so that it can be recognized by the PC. For the remote records, I call PerformPilotToPCRecSync, which adds and deletes records on the local side as appropriate. void CInvConduit::PerformPilotToPCRecSync ( CInventoryRec &rRemoteRec ) { int nIndex; // Try to find the remote record BOOL bExists = m_listRecs.FindRecById( RemoteRec.m_nRecId, nIndex ); // If doesn't exist, then add it - but don't want to // add deleted recs. if( !bExists && (rRemoteRec.m_wStatus&fldStatusDELETE) != fldStatusDELETE ) { m_listRecs.AddRec( rRemoteRec ); } else { // If exists but remote rec marked for deletion, // then delete from local and remote sides. if( (rRemoteRec.m_wStatus&fldStatusDELETE) == fldStatusDELETE ) { DeleteRecs( rRemoteRec, nIndex ); }}}  ConvertRec does these tasks for the Inventory conduit. // Convert record REMOTE-->LOCAL void CInvConduit::ConvertRec( CInventoryRec &rDestRec, CRawRecordInfo &rWireRec ) { // Set record id rDestRec.m_nRecId = rWireRec.m_RecId; // Set the status for the record rDestRec.SetStatus(fldStatusNONE); if (rWireRec.m_Attribs & DELETE_BIT) // Delete flag rDestRec.SetStatus(fldStatusDELETE); else if (rWireRec.m_Attribs & DIRTY_BIT) rDestRec.SetStatus(fldStatusUPDATE); // If remote rec is not marked as deleted, then // convert the rest of record if( !(rWireRec.m_Attribs&DELETE_BIT) ) { const BYTE *pBuff = (const BYTE *) rWireRec.m_pBytes; int nPos = 0; WORD wUnits; double dPrice; // Use a utility function to read the ""stream"" // into the inventory record. pBuff += ReadByteStream( rDestRec.m_szName, pBuff, MAX_NAME_LEN ); pBuff += ReadByteStream( rDestRec.m_szDesc, pBuff, MAX_DESC_LEN ); pBuff += ReadByteStream( wUnits, pBuff ); rDestRec.m_nUnits = wUnits; *(double *)&dPrice = *pBuff; rDestRec.m_dPrice = dPrice; } } // Convert record LOCAL-->REMOTE void CInvConduit::ConvertRec( CRawRecordInfo &rWireRec, CInventoryRec &rSrcRec ) { BYTE *pBuff = (BYTE *)rWireRec.m_pBytes; int nPos = 0; WriteByteStream( pBuff, rSrcRec.m_szName, MAX_NAME_LEN, nPos ); WriteByteStream( pBuff, rSrcRec.m_szDesc, MAX_DESC_LEN, nPos ); WriteByteStream( pBuff,(WORD)rSrcRec.m_nUnits,nPos); *(double *)&pBuff[nPos] = rSrcRec.m_dPrice; }  If I find a record in the Pilot database that does not exist in the local database (and it's not mar ked deleted), I need to add the record to the local database using m_listRecs.AddRec. Similarly, records marked as Deleted on the Pilot need to be deleted from the PC. The DeleteRecs function does this. // Marks records for deletion on remote and local sides. void CInvConduit::DeleteRecs( CInventoryRec &rRec, int nIndex, BOOL bDelRemote ) { long err; CRawRecordInfo rawRecInfo; memset(&rawRecInfo, 0, sizeof(rawRecInfo)); rawRecInfo.m_FileHandle = m_hRemoteDB; rawRecInfo.m_RecId = rRec.m_nRecId; // Delete from local database m_listRecs.MarkDeletedAtIndex( nIndex ); // Should I mark remote record for deletion also? if( bDelRemote ) err = SyncDeleteRec( rawRecInfo ); }  Conclusion While Pilot applications merit a lot of attention, they are only truly useful when married to an appropriate desktop application. You can effect that marriage by creating a custom conduit that synchronizes the data between your Pilot and PC applications. As the Pilot becomes more prevalent in the market, there will be more and more opportunities to develop truly connected applications that extend the user's desktop into the field. Using the information in this article, coupled with the Palm OS Conduit SDK, you are now equipped to take advantage of those opportunities. The source code for Stu's sample Pilot application and conduit can be found on the source code disk for this issue o f PDA Developers. P DA DE 4.5  Sept/Oc t 1996  The second iteration loop is very similar to the first, except it iterates over all records on the local size and adds and deletes records on the remote side as appropriate. An important part of synchronization is the conversion between the raw record stream coming off the wire (and contained in CRawRec-ordInfo) into a record recognized by the conduit (CInventory-Rec). There are generally three types of conversions that you may need to support, depending on the data types in your records:  Byte swapping between Intel and Motorola formats,  Date conversions, and  Adding or removing carriage returns in strings.  VELOPER S  49   ONE-STOP PDA DEVELOPER SHOPPING The Magazine  PDA DEVELOPE  RSTM  PDA D  EVE LOP ER S  Source Code Disk  PDA Developers provides in-depth technical information about developing PDA software, focusing on Newton, Psion, GEOS, Magic Cap, and Hewlett Packard devices. Each issue includes news and announcements, programming tips and techniques, product reviews and previews, and programs with in-depth developer descriptions. For all technical levels. North America: $65. Overseas: $85. No shipping and handling. Ultimate New ton Debugger  Each issue of the PDA Developers source code disk includes the text of each ar ticle, the source code for each program in the issue, plus developer-oriented freeware, shareware, and goodies. For subscribers that receive just the disks, we include a Common Ground image of the printed issue. Available in Mac and Windows versions. $50 with a printed subscription. North America: $65. Overseas: $80. No shipping and handling.  V  IEW FRAM ETM  PDA Developers CD The cross-platform CD-ROM contains the slides from most of the presentations from the PDA Developers East `95 and PDA Developers West `96 conferences. Keynotes by industry pioneers and leaders, plus PDF-formatted versions of the GEOS 2.1 SDK documentation, the Magic Cap 1.5 developer docs, and much more. Essential for PDA developers. Cross-platform CD: $40. PDA Developers subscribers: $30.  ViewFrame is a Newton-resident debugger and browser that lets you do things you can't even do with the Inspector. Browse an application's complete object space, examining and modifying almost all objects in that space in multiple formats. See more things, more clearly and easily, than you can with the Inspector, without tying up the serial port. New version 1.2. Mac or Windows disk: $90. PDA Developers subscribers: $80. Ma c/New ton IR  GizmoBeam  TM  Mic roWaveTM  DOS/Newton I R  GizmoBeam is a device driver for beaming between Mac programs and Newtons. It includes Think C and Metrowerks sample source and detailed documentation. Requires knowledge of Macintosh Device Manager and Serial Device Drivers, plus CE-IR2, 3, or 4 hardware. Distribution licenses extra. Mac 5-user SDK: $200. PDA Developers subscr ibers: $175.  MicroWave is a linkable library for beaming between Newtons and D OS-based hardware. It includes a C header file, Microsoft and Borland libraries, three samples with full source code, and documentation. Requires CE-IR2, 3, or 4 hardware. Distribution licenses extra. DOS 5-user SDK: $200. PDA Developers subscribers: $175.  Prices are for a sing le-seat S DK and a five-user distribution license.  R agoutTM (Ragu')  The Ultimate Soup Utilit y Designed for Newton developers, consultants, and power users, Ragout lets you:  Create, delete, copy, and move soups.  Add and remove soup indices.  Create, delete, copy, move, view, and edit soup entries, and change slot data types at any depth. Mac or Windows disk: $55. PDA  Create multiple copies of an entry for sizing soups.  Move to the first and last entries, forward and backward one or N entries, go to a specific tagged entry, or search for an entry by index value.  Fax and print soup information and entry details, and beam soup entries. Developers subscribers: $50.  Shipping and handling - $7.50 in North Americ a, $12.50 elsewhere. CA residents add 8.5% sales tax. We accept major credit cards and US bank-drawn checks. Sorry, no POs.  Creative Digital Inc. 293 Corbett Avenue SanFrancisco, CA 94114 http://www.cdpubs.com   All Dog, no Fleas. cdi@cdpubs.com  74774.50@compuserve.com  415.621.4252 415.621.4922 (fax)   PDA Developers North September 11-13, 1996  Inland Meeting & Exposition Center  Westmont, IL, 20 minutes from Chicago's O'Har e Airpor t  Ke ynote Speakers Charles Davies , Technical Director, The Psion Group. Har el Kodesh, General Manager, Microsoft's Consumer Appliance Group. Grov er Right , Vice President, Geow orks. Kheng Jo-Khaw , General Manager, HP APCD. J anne Jormalainen , Engineering Director, Nokia. Steve Schr amm , Vice President & GM, General Magic . Gar y Gebhar dt , Channel Strategy Manager, ARDIS.  Sponsors Psion, General Magic, U.S. Robotics/Palm Computing, ARDIS, Apple Computer, Hewlett-Packard.  Co-sponsors Geoworks, Pen Computing Magazine, InTouch USA, Wright Strategies, and PDA Direct.  TM  Half-Day Introductor y Programming Courses Psion, Magic Cap, Pilot, GEOS, Newton, PenRight!, and FormLogic .  Conference Tracks The Companies The Technologies The key platform manufacturers summarize their products, markets, and future directions. Lead engineers from the platform creators summarize their key technologies, operating system advantages, and how they expect their technologies to evolve in the near future. Real Programmers Developers and system integrators talk about their products, the business of software development, and the technical and business challenges they face. Wireless Representatives from the major wireless product and service providers talk about their products and services and how developers can incorporate them into PDA products. Advanced Topics Speech recognition, smart phones, future CPU architectures, and lots more. Tools All kinds of tools  for developers, system integrators, and technically-savvy end users.  Cost $450 until Sept 8, $500 after that. Includes breakfast and lunch all three days. Includes full registration f or PDA Solutions Exhibition on Saturday, September, 14, 1996.  Exhibits 8000 square feet, with ridiculously low exhibitor rates. Contact us for details.  If You Are At All Serious About Hand-held Computing, You Can't Afford Not To Attend PDA Developers North. Creative Digital Inc . 293 Corbett Avenue, San Francisco, CA 94114-1842 Call (415.621.4252), Fax (415.621.4922), E-mail ( info@cdpubs.com), or Surf (http://www.cdpubs.com)."
GX040-04-1919175	"Grace User's Guide (for Grace-5.1.7)    by the Grace Team 16.03.2002      This document explains the usage of    Grace , a WYSIWYG 2D plotting tool for numerical data.       1.   Introduction      1.1   What is Grace?   1.2   Copyright statement       2.   Installation guide      2.1   Installing from sources   2.2   Binary installation   2.3   Alternative packaging schemes (RPM, ...)       3.   Getting started      3.1   General concepts   3.2   Invocation   3.3   Customization       4.   Guide to the graphical user interface      4.1   GUI controls   4.2   The main window   4.3   File menu    4.4   Edit menu    4.5   Data menu    4.6   Plot menu    4.7   View menu    4.8   Window menu    4.9   Help menu        5.   Command interpreter       5.1   General notes   5.2   Definitions   5.3   Variables   5.4   Numerical operators and functions   5.5   Procedures   5.6   Device parameters   5.7   Flow control   5.8   Declarations   5.9   Graph properties   5.10   Set properties       6.   Advanced topics      6.1   Fonts   6.2   Interaction with other applications   6.3   FFTW tuning   6.4   DL modules        7.   References      7.1   Typesetting   7.2   Device-specific limitations   7.3   Device-specific settings   7.4   Dates in Grace    7.5   Xmgr to Grace migration guide        1.   Introduction      1.1   What is Grace?        Grace is a WYSIWYG tool to make two-dimensional plots of numerical data. It runs under various (if not all) flavors of Unix with X11 and M*tif (LessTif or Motif). It also runs under VMS, OS/2, and Windows (95/98/NT/2000). Its capabilities are roughly similar to GUI-based programs like Sigmaplot or Microcal Origin plus script-based tools like Gnuplot or Genplot. Its strength lies in the fact that it combines the convenience of a graphical user interface with the power of a scripting language which enables it to do sophisticated calculations or perform automated tasks.   Grace is derived from Xmgr (a.k.a. ACE/gr), originally written by Paul Turner.   From version number 4.00, the development was taken over by a team of volunteers under the coordination of Evgeny Stambulchik. You can get the newest information about Grace and download the latest version at the   Grace home page .   When its copyright was changed to GPL, the name was changed to Grace, which stands for ``GRaphing, Advanced Computation and Exploration of data'' or ``Grace Revamps ACE/gr''. The first version of Grace available is named 5.0.0, while the last public version of Xmgr has the version number 4.1.2.   Paul still maintains and develops a non-public version of Xmgr for internal use.    1.2   Copyright statement             Copyright (©) 1991-1995 Paul J Turner, Portland, OR Copyright (©) 1996-2002 Grace Development Team  Maintained by Evgeny Stambulchik                            All Rights Reserved  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.         For certain libraries required to build Grace (which are therefore even included in a suitable version) there may be different Copyright/License statements. Though their License may by chance match the one used for Grace, the Grace Copyright holders can not influence or change them.         Package   License   cephes library   Free   T1lib   LGPL   Xbae   BSD-like   Tab Widget   BSD-like            Licenses               2.   Installation guide         2.1   Installing from sources               Configuration         Requirements. Grace usually compiles out of the box in a regular Unix-like environment. You need an ANSI C compiler (gcc is just fine), the X11R5 or above libraries and headers, and an implementaion of the M*tif API, version 1.2 or above. If you want to compile your own changes to certain parts of Grace, you will need a parser generator ( yacc  or, better,  bison ).    Extra libraries. Some features will be available only if additional libraries are installed. Those are:     The JPEG backend needs the IJG's (  JPEG library ), version 6.x.    The PNG backend needs the (  libpng ) library (version 0.96 or above).    The PDF driver requires the PDFlib library of Thomas Merz to be installed, which is available  here , version 3.02 or above.    If your computer has the FFTW library installed when Grace is compiled, Grace will link itself to this, and drop all conventional FFT's and DFT's. All transforms will be routed through this package. Note that there is then no difference between pushing the ""FFT"" button and the ""DFT"" button, except that FFT will complain if the length isn't a power of 2, and DFT will not.  For more information on this package, see the   FFTW Home page . In short, this package allows one to do non-power-of-2 length FFT's along with the normal ones.  It seems to work very efficiently for any set length which factors into 2^a 3^b 5^c 7^d for integer a, b, c, d. The great feature here is that set lengths which are powers of 10 (e.g. 1000, 10000) and integer multiples of these (500, 2000, 2500, 5000, etc.) can be computed with no significant penalty (maybe 20%) over power-of-2 transforms. Very often, real datasets come in these sizes, and not in powers of 2.    In order to read/write sets in the NetCDF data format, you will also need the   NetCDF libraries .        Decide whether you want to compile in a separate place (thus leaving the source tree pristine). You most probably would want it if compiling Grace for more than one OS and keeping the sources in a central shared (e.g. via NFS) location. If you don't need it, skip the rest of this paragraph and go right to the next step. Otherwise, assuming the sources are in  /usr/local/src/grace-x.y.z  and the compilation will be performed in  /tmp/grace-obj , do the following:    % mkdir /tmp/grace-obj   % cd /tmp/grace-obj   % /usr/local/src/grace-x.y.z/ac-tools/shtool mkshadow \     /usr/local/src/grace-x.y.z .                         The  configure  shell script attempts to guess correct values for various system-dependent variables used during compilation. It uses those values to create  Make.conf  in the top directory of the package. It also create  config.h  file containing system-dependent definitions. Finally, it creates a shell script  config.status  that you can run in the future to recreate the current configuration, a file  config.cache  that saves the results of its tests to speed up reconfiguring, and a file  config.log  containing compiler output (useful mainly for debugging  configure ). If at some point  config.cache  contains results you don't want to keep, you may remove or edit it.    Run  ./configure --help  to get list of additional switches specific to Grace    Run  ./configure <options> . Just an example:    % ./configure --enable-grace-home=/opt/grace      --with-extra-incpath=/usr/local/include:/opt/include \     --with-extra-ldpath=/usr/local/lib:/opt/lib --prefix=/usr                      would use  /usr/local/include  and  /opt/include  in addition to the default include path and  /usr/local/lib  and  /opt/lib  in addition to the default ld path. As well, all stuff would be put under the /opt/grace directory and soft links made to  /usr/bin ,  /usr/lib  and  /usr/include .  Note : If you change one of the  --with-extra-incpath  or  --with-extra-ldpath  options from one run of configure to another, remember to delete the  config.cache  file!!!          Compilation     Issue  make   If something goes wrong, try to see if the problem has been described already in the  Grace FAQ  (in the  doc  directory).          Testing           make tests   This will give you a slide show demonstrating some nice features of Grace.          Installation      make install     make links   The later (optional) step will make soft links from some files under the Grace home directory to the system-wide default locations (can be changed by the  --prefix  option during the configuration, see above).              2.2   Binary installation               Getting pre-built packages    Installation    Running tests        2.3   Alternative packaging schemes (RPM, ...)           Not written yet...     3.   Getting started        For a jump-in start, you can browse the demos (""Help/Examples"" menu tree). These are ordinary Grace projects, so you can play with them and modify them. Also, read the   Tutorial .   O.k. Here's a VERY quick introduction:     Start the GUI version: xmgrace (return).    Select/check the output medium and canvas size in File/Device Setup.    If needed, set the graph size ('Viewport' in Plot/Graph Appearance).    Load your data with Data/Import/ASCII. 'Load as': 'Single set' for two-column ASCII data, 'Block data' for multi-column ASCII data.    Adjust the scales, axis labels and tick marks in Plot/Axis properties. Acknowledge all changes with 'Apply'.    Adjust lines, symbols, legends in Plot/Set appearance.    Adjust titles, plot frame and legend display in Plot/Graph Appearance.    Data can be manipulated in Data/Transformations. To shift a data set by 20 to the left, e.g., in 'Evaluate Expression' select the same set on the left and the right, and say Formula: y=y-20. As you'll probably notice, Grace can do MUCH more than that. Explore at your leisure.    When you like your plot, select File/Print. That's it!        3.1   General concepts             Project files              A project file contains all information necessary to restore a plot created by Grace, as well as some of preferences. Each plot is represented on a single page, but may have an unlimited number of graphs.You create a project file of your current graph with File/Save,Save as.     Parameter files              A parameter file contains the detailed settings of your project. It can be used to transfer these settings to a different plot/project. You generate a parameter file with File/Save menu entry selected from the ""Plot/Graph appearance popup"". You can load the settings contained in a parameter file with File/Open.     Input File formats              Grace understands several input files formats. The most basic one is ASCII text files containing space and comma separated columns of data. The data fields can be either numeric (Fortran 'd' and 'D' exponent markers are supported) or alphanumeric (with or without quotes). Several calendar date formats are recognized automatically and you can specify your own reference for numeric dates formats. Grace also has a command language (see   command interpreter ), you can include commands in data files using lines having ""@"" as their first non-blank character. Depending on configuration, Grace can also read NetCDF files (see   configuration ).     Graphs              A graph consists of (every element is optional): a graph frame, axes, a title and a subtitle, a number of sets and additional annotative objects (time stamp string, text strings, lines, boxes and ellipses).   The graph type can be any of:        XY Graph    XY Chart    Polar Graph    Fixed Graph    Pie chart         Datasets              A dataset is a collection of points with x and y coordinates, up to four optional data values (which, depending on the set type, can be displayed as error bars or like) and one optional character string.     Sets              A set is a way of representing datasets. It consists of a pointer to a dataset plus a collection of parameters describing the visual appearance of the data (like color, line dash pattern etc).   The set type can be any of the following:          Set type   # of num. cols   Description   XY   2   An X-Y scatter and/or line plot, plus (optionally) an annotated value   XYDX   3   Same as XY, but with error bars (either one- or two-sided) along X axis   XYDY   3   Same as XYDX, but error bars are along Y axis   XYDXDX   4   Same as XYDX, but left and right error bars are defined separately   XYDYDY   4   Same as XYDXDX, but error bars are along Y axis   XYDXDY   4   Same as XY, but with X and Y error bars (either one- or two-sided)   XYDXDXDYDY   6   Same as XYDXDY, but left/right and upper/lower error bars are defined separately   BAR   2   Same as XY, but vertical bars are used instead of symbols   BARDY   3   Same as BAR, but with error bars (either one- or two-sided) along Y axis   BARDYDY   4   Same as BARDY, but lower and upper error bars are defined separately   XYHILO   5   Hi/Low/Open/Close plot   XYZ   3   Same as XY; makes no sense unless the annotated value is Z   XYR   3   X, Y, Radius. Only allowed in Fixed graphs   XYSIZE   3   Same as XY, but symbol size is variable   XYCOLOR   3   X, Y, color index (of the symbol fill)  XYCOLPAT   4   X, Y, color index, pattern index (currently used for Pie charts only)   XYVMAP   4   Vector map   XYBOXPLOT   6   Box plot (X, median, upper/lower limit, upper/lower whisker)                 Set types                   Not all set types, however, can be plotted on any graph type. The following table summarizes it:          Set type   XY Graph   XY Chart   Fixed   Polar   Pie   XY   +   +   +   +   +   XYDX   +   -   +   -   -   XYDY   +   +   +   -   -   XYDXDX   +   -   +   -   -   XYDYDY   +   +   +   -   -   XYDXDY   +   -   +   -   -   XYDXDXDYDY   +   -   +   -   -   BAR   +   +   +   -   -   BARDY   -   +   -   -   -   BARDYDY   -   +   -   -   -   XYHILO   +   -   -   -   -   XYZ   +   -   +   +   -   XYR   -   -   +   -   -   XYSIZE   +   +   +   +   -   XYCOLOR   +   +   +   +   +   XYCOLPAT   -   -   -   -   +   XYVMAP   +   -   +   -   -   XYBOXPLOT   +   -   -   -   -                 Graph/Set type connection                    Regions              Regions are sections of the graph defined by the interior or exterior of a polygon, or a half plane defined by a line. Regions are used to restrict data transformations to a geometric area occupied by region.     Real Time Input              Real Time Input refers to the ability Grace has to be fed in real time by an external program. The Grace process spawned by the driver program is a full featured Grace process: the user can interact using the GUI at the same time the program sends data and commands. The process will adapt itself to the incoming data rate.     Hotlinks              Hotlinks are sources containing varying data. Grace can be instructed a file or a pipe is a hotlink in which case it will provide specific commands to refresh the data on a mouse click (a later version will probably allow automatic refresh).     Devices            Grace allows the user to choose between several output devices to produce its graphics. The current list of supported devices is:        X11    PostScript (level 1 and level 2)    EPS (encapsulated PostScript)    Metafile (which is Grace format, used at the moment mostly for debugging purposes)    MIF (Maker Interchange Format used by FrameMaker)    SVG (Scalable Vector Graphics, a language for describing two-dimensional vector and mixed vector/raster graphics in XML)    PDF (depends on extra libraries, see   configuration )    PNM (portable anymap file format)    JPEG (depends on extra libraries, see   configuration )    PNG (depends on extra libraries, see   configuration )        Note that Grace no longer supports GIF due to the copyright policy of Unisys. Grace can also be instructed to launch conversion programs automatically based on file name. As an example you can produce MIF (FrameMaker Interchange Format) or Java applets using pstoedit, or almost any image format using the netpbm suite (see the   FAQ ).     Magic path            In many cases, when Grace needs to access a file given with a relative  pathname , it searches for the file along the following path:  ./pathname:./.grace/pathname:~/.grace/pathname:$GRACE_HOME/pathname     Dynamic modules            Grace can access external functions present in either system or third-party shared libraries or modules specially compiled for use with it. The term dynamic refers to the possibility Grace has to open the library at run time to find the code of the external function, there is no need to recompile Grace itself (the functions already compiled in Grace are ""statically linked"").     Coordinate frames             There are two types of coordinates in Grace: the  world coordinates  and the  viewport coordinates . Points of data sets are defined in the world coordinates. The viewport coordinates correspond to the image of the plot drawn on the canvas (or printed on, say, PS output page). The transformation converting the world coordinates into the viewport ones is determined by both the graph type and the axis scaling.   Actually, there is yet another level in the hierarchy of coordinates - the  device coordinates . However, you (as a user of Grace) should not worry about the latter. The mapping between the viewport coordinates and the device coordinates is always set in such a way that the origin of the viewport corresponds to the left bottom corner of the device page, the smallest of the device dimensions corresponds to one unit in the viewport coordinates. Oh, and the most important thing about the viewport -> device transformation is that it is homotetic, i.e. a square is guaranteed to remain a square, not a rectangle, a circle remains a circle (not an ellipse) etc.   3.2   Invocation            Operational mode             With respect to the user interface, there are three modes of operation that Grace can be invoked in. The full-featured GUI-based version is called  xmgrace . A batch-printing version is called  gracebat . A command-line interface mode is called  grace . Usually, a single executable is called in all cases, with two of the three files being (symbolic) links to a ""real"" one.    Command line options                 -autoscale  x|y|xy   Override any parameter file settings     -barebones  Turn off all toolbars     -batch  batch_file   Execute batch_file on start up     -block  block_data   Assume data file is block data     -bxy  x:y:etc.   Form a set from the current block data set using the current set type from columns given in the argument     -datehint  iso|european|us|days|seconds|nohint   Set the hint for dates analysis     -dpipe  descriptor   Read data from descriptor (anonymous pipe) on startup     -fixed  width   height   Set canvas size fixed to width*height     -free  Use free page layout     -graph  graph_number   Set the current graph number     -graphtype  graph_type   Set the type of the current graph     -hardcopy  No interactive session, just print and quit     -hdevice  hardcopy_device_name   Set default hardcopy device     -install  Install private colormap     -legend  load   Turn the graph legend on     -log  x|y|xy   Set the axis scaling of the current graph to logarithmic     -mono  Run Grace in monochrome mode (affects the display only)     -netcdf  file   Assume data  file  is in netCDF format. This option is present only if the netCDF support was compiled in     -netcdfxy  X_var   Y_var   If -netcdf was used previously, read from the netCDF file  X_var   Y_var  variables and create a set. If  X_var  name is ""null"" then load the index of Y to X. This option is present only if the netCDF support was compiled in       -noask  Assume the answer is yes to all requests - if the operation would overwrite a file, Grace will do so without prompting     -noinstall  Don't use private colormap     -noprint  In batch mode, do not print     -nosigcatch  Don't catch signals     -npipe  file   Read data from named pipe on startup     -nxy  nxy_file   Assume data file is in X Y1 Y2 Y3 ... format     -param  parameter_file   Load parameters from parameter_file to the current graph     -pexec  parameter_string   Interpret string as a parameter setting     -pipe  Read data from stdin on startup     -printfile  file  Save print output to file     -remove  Remove data file after read     -results  results_file   Write results of some data manipulations to results_file     -rvideo  Exchange the color indices for black and white     -saveall  save_file   Save all graphs to save_file     -seed  seed_value   Integer seed for random number generator     -source  disk|pipe   Source type of next data file     -timer  delay   Set allowed time slice for real time inputs to delay ms     -timestamp  Add timestamp to plot     -settype  xy|xydx|...   Set the type of the next data file     -version  Show the program version     -viewport  xmin ymin xmax ymax   Set the viewport for the current graph     -wd  directory   Set the working directory     -world  xmin ymin xmax ymax   Set the world coordinates for the current graph     -usage|-help  This message         3.3   Customization            Environment variables                GRACE_HOME  Set the location of Grace. This will be where help files, auxiliary programs, and examples are located. If you are unable to find the location of this directory, contact your system administrator.       GRACE_PRINT_CMD  Print command. If the variable is defined but is an empty string, ""Print to file"" will be selected as default.       GRACE_EDITOR  The editor used for manual editing of dataset values.       GRACE_HELPVIEWER  The HTML viewer for on-line browsing of help documents       GRACE_FFTW_WISDOM_FILE and GRACE_FFTW_RAM_WISDOM  These flags control behavior of the FFTW planner (see  FFTW tuning  for detailed info)            Init file          Upon start-up, Grace loads its init file,  gracerc . The file is searched for in the magic path (see  magic path ); once found, the rest of the path is ignored. It's recommended that in the  gracerc  file, one doesn't use statements which are part of a project file - such defaults, if needed, should be set in the default template (see   default template ).     Default template          Whenever a new project is started, Grace loads the default template,  templates/Default.agr . The file is searched for in the magic path (see    magic path ); once found, the rest of the path is ignored. It's recommended that in the default template, one doesn't use statements which are NOT part of a project file - such defaults, if needed, should be set in the  gracerc  (see   init file ).    X resources           The following Grace-specific X resource settings are supported:        XMgrace.invertDraw  Use GXinvert rather than GXxor for rubber-band lines. If the rubber-banding for zooms and lines, etc. doesn't appear on the canvas, set this resource to yes.      XMgrace.allowDoubleClick  When Yes, allow double clicks on the canvas to bring up various popups depending on  the location of the pointer when the double click occurs.      XMgrace.toolBar  Enables button toolbar      XMgrace.statusBar  Enables status bar      XMgrace.locatorBar  Enables locator bar          It is also possible to customize menus by assigning key accelerators to any item.   You'll need to derive the item's X resource name from the respective menu label, which is easily done following these rules:     All non-alphanumeric characters are skipped    Start with lower case; each new word (if any) continues from the capital letter    Add the item's type to the end - ""Menu"" for pulldown menus, ""Button"" for menu buttons.       For example, in order to make Grace popup the Non-linear curve fitting by pressing Control+F, you would add the following two lines   XMgrace*transformationsMenu.nonLinearCurveFittingButton.acceleratorText: Ctrl+F  XMgrace*transformationsMenu.nonLinearCurveFittingButton.accelerator: Ctrl<Key>f    to your  .Xresources  file (the file which is read when an X session starts; it could be  .Xdefaults ,  .Xsession  or some other file - ask your system administrator when in doubt).    Similarly, it may be desirable to alter default filename patterns of file selection dialogs. The recipe for the dialog's name is like for menu buttons outlined above, with ""Button"" being replaced with ""FSB"". E.g., to list all files in the ""Open project"" dialog (""File/Open...""), set the following resource:   XMgrace*openProjectFSB.pattern: *      4.   Guide to the graphical user interface        4.1   GUI controls          This section describes interface controls - basic building blocks, used in many popups.    File selection dialogs           Whenever the user is expected to provide a filename, either for reading in or writing some data, a file selection dialog is popped up. In addition to the standard entries (the directory and file lists and the filter entry), there is a pulldown menu for quick directory change to predefined locations (the current working directory, user's home directory and the file system root). Also, a ""Set as cwd"" button is there which allows to set any directory as you navigate through the directory tree as the current working directory (cwd). Once defined, it can be used in any other file selection dialog to switch to that directory quickly.     List selectors           Various selectors are available in several popups. They all display lists of objects (graphs, sets, ...) and can be used to perform simple operations on these objects (copying, deleting, ...). The operations are available from a popup menu that appears when pressing mouse button 3 on them. Depending on the required functionality, they may allow multiple choices or not. The following shortcuts are enabled (if the result of an action would contradict the list's selection policy, this would be ignored):     Ctrl+a select all    Ctrl+u unselect all    Ctrl+i invert selection         Graph selector             The operations that can be performed on graphs through the graph selector's popup menu are:     focus to    hide    show    duplicate    kill    swap    create new     All this operations are not available in every instance of the selector. For example in the ""read sets"" popup only one graph can be selected at a time, and the swap operation is disabled.   Double-clicking on a list entry will switch the focus to that graph.     Set selector             The operations that can be performed on sets through the set selector's popup menu are:     hide    show    bring to front    send to back    duplicate    kill    kill data    swap    edit     in spreadsheet (see  Spreadsheet data set editor )    in text editor        create new     by formula    in spreadsheet (see  Spreadsheet data set editor )    in text editor    from block data        pack all sets    selector operations     view set comments    show data-less    show hidden    select all    unselect all    invert selection    update           Double-clicking on a list entry will open the spreadsheet editor (see   Spreadsheet data set editor ) on the set data.      4.2   The main window             The canvas           Canvas hotkeys             When the pointer focus is on the canvas (where the graph is drawn), there are some shortcuts to activate several actions. They are:        Ctrl <Key>A: Autoscale the current graph    Ctrl <Key>D: Delete an object    Ctrl <Key>L: Move current graph legend    Ctrl <Key>M: Move an object    Ctrl <Key>T: Place timestamp    Ctrl <Key>U: Refresh hotlinks    Ctrl <Key>V: Set the viewport with mouse    Ctrl <Key>Z: Zoom    Ctrl Alt <Key>L: Draw a line    Ctrl Alt <Key>B: Draw a box    Ctrl Alt <Key>E: Draw an ellipse    Ctrl Alt <Key>T: Write a text string         Clicks and double clicks            A single click inside a graph switches focus to that graph. This is the default policy, but it can be changed from the ""Edit/Preferences"" popup.   Double clicking on parts of the canvas will invoke certain actions or raise some popups:        on a focus marker: move selected viewport corner     on an axis:  ""Plot/Axis properties"" popup    on a set:    ""Plot/Set appearance"" popup    on a legend: ""Plot/Graph appearance"" popup    on a (sub)title: ""Plot/Graph appearance"" popup    on an object (box, line, ...): a popup for editing properties of that object       The double clicking actions can be enabled/disabled from the ""Edit/Preferences"" popup.     Toolbar buttons          Along the left-hand side of the canvas (if shown) is the ToolBar. It is armed with several buttons to provide quick and easy access to the more commonly used Grace functions.           Draw : This will redraw the canvas and sets. Useful if ""Auto Redraw"" has been deselected in the Edit|Preferences dialog or after executing commands directly from the Window|Commands interpreter.          Lens : A zoom lens.  Click on the lens, then select the area of interest on the graph with the ""rubber band"".  The region enclosed by the rubber band will fill the entire graph.         AS : AutoScale.  Autoscales the graph to contain all data points of all visible (not hidden) sets.        Z/z :  Zoom in/out by 5%. The zoom percentage can be set in the Edit/Preferences dialog.     Arrows :  Scroll active graph by 5% in the arrow's direction.  The scroll percentage can be set in the Edit/Preferences dialog.        AutoT : AutoTick Axes.  This will find the optimum number of major and minor tick marks for both axes.     AutoO : Autoscale On set.  Click the  AutoO  button, then click on the graph near the set you wish to use for determining the autoscale boundaries of the graph.       ZX,ZY : Zoom along an axis.  These buttons work like the zoom lens above but are restricted to a single axis.      AX,AY : Autoscale one axis only.  The following buttons deal with the graph stack and there is a good example under Help/Examples/General Intro/World Stack.       Pu/Po : Push and pop the current world settings to/from the graph stack. When popping, makes the new stack top current.     PZ : Push before Zooming.  Functions as the zoom lens, but first pushes the current world settings to the stack.       Cy : Cycles through the stack settings of the active graph.  Each graph may have up to twenty layers on the stack.               Exit : Pretty obvious, eh?           4.3   File menu          The file menu contains all entries related to the input/output features of Grace.     New           Reset the state of Grace as if it had just started (one empty graph ranging from 0 to 1 along both axes). If some work has been done and not yet saved, a warning popup is displayed to allow canceling the operation.     Open           Open an existing   project file . A popup is displayed that allow to browse the file system.     Save           Save the current work in a project file, using the name that was used for the last open or save. If no name has been set (i.e., if the project has been created from scratch) act as   save as .     Save as           Save the current work in a project file with a new name. A popup allows to browse the file system and set the name, the format to use for saving data points (the default value is ""%16.8g""), and a textual description of the project. A warning is displayed if a file with the same name already exists.     Revert to saved           Abandon all modifications performed on the project since the last save. A confirmation popup is fired to allow the user canceling the operation.     Print setup           Set the properties of the printing device. Each device has its own set of specific options (see   Device-specific       settings ). According to the device, the output can be sent either directly to a printer or directed to a file. The global settings available for all devices are the sizing parameters. The size of the graph is fixed. Changing the 'Page' settings changes the size of the canvas underneath the graph. Switching between portrait and landscape rotates the canvas. Make sure the canvas size is large enough to hold your graph. Otherwise you get a 'Printout truncated' warning. If your canvas size cannot easily be changed because, for example, you want to print on letter size paper, you need to adjust the size of your graph ('Viewport' in Plot/Graph Appearance).     Print           Print the project using the current printer settings     Exit           Exit from Grace. If some work has been done and not saved, a warning popup will be displayed to allow the user to cancel the operation.      4.4   Edit menu            Data sets           Using the data set popup, you can view the properties of datasets. This include its type, length, associated comment and some statistics (min, max, mean, standard deviation). A horizontal scrollbar at the bottom allows to get the two last properties, they are not displayed by default. Also note that if you find some columns are too narrow to show all significant digits, you can drag the vertical rules using Shift+Button 2.   Using the menu on the top of this dialog, you can manipulate existing sets or add new ones. Among the most important entries in the menu, are options to create or modify a set using the spreadsheet data set editor (see   Spreadsheet data set editor ).     Spreadsheet data set editor            The dialog presents an editable matrix of numbers, corresponding to the data set being edited. The set type (and hence, the number of data columns) can be changed using the ""Type:"" selector. Clicking on a column label pops up a dialog allowing to adjust the column formatting. Clicking on the row labels toggles the respective row state (selected/unselected). The selected rows can be deleted via the dialog's ""Edit"" menu. Another entry in this menu lets you add a row; the place of the new row is determined by the row containing a cell with the keyboard focus on. As well, just typing in an empty cell will add one or several rows (filling the intermediate rows with zeros).   To resize columns, drag the vertical rules using Shift+Button 2.    Set operations           The set operations popup allows you to interact with sets as a whole. If you want to operate on the data ordering of the sets, you should use the   data set operations  popup from the Data menu. The popup allows you to select a source (one set within one graph) and a destination and perform some action upon them (copy, move, swap). This popup also give you a quick access to several graph and set selectors if you want to perform some other operation like hiding a graph or creating a new set from block data.     Arrange graphs           This entry fires up a popup to lay out several graphs in a regular grid given by  M  rows and  N  columns.    The graph selector at the top allows one to select a number of graphs the arrangement will operate on. If the number of selected graphs isn't equal to  M  times  N ,  new graphs may be created or extra graphs killed if needed. These options are  controlled by the respective checkboxes below the graph selector.   The order in which the matrix is filled in with the graphs can be selected (first horizontally then vertically or vise versa, with either of them inverted). Additionaly, one may choose to fill the matrix in the snake-like manner (adjacent ""strokes"" are anti-parallel).   The rest of the controls of the dialog window deal with the matrix spacing: left/right/top/bottom page offsets (in the viewport coordinates) and  relative  inter-cell distances, vertical and horizontal. Next to each of the vertical/horizontal spacing spinboxes, a ""Pack"" checkbox is found. Enabling it effectively sets the respective inter-cell distance to zero and alter axis tickmark settings such that only bottom/left-most tickmarks are visible.   If you don't want the regular layout this arrangement gives you, you can change it afterwards using the mouse (select a graph and double click on the focus marker, see   clicks and double clicks ).     Overlay graphs           You can overlay a graph on top of another one. The main use of this feature is to plot several curves using different scales on the same (apparently) graph. The main difficulty is to be sure you operate on the graph you want at all times (you can hide one for a moment if this becomes too difficult).     Autoscale           Using this entry, you can autoscale one graph or all graphs according to the specified sets only. This is useful if you need either to have truly comparable graphs despite every one contains data of different ranges, or if you want to focus your attention on one set only while it is displayed with other data in a complex graph.     Regions menu             Status              This small popup only displays the current state (type and whether it is active or not) of the existing regions.     Define              You can define a new region (or redefine an existing one), the allowed region types are:        Inside polygon    Outside polygon    Above line    Below line    Left of line    Right of line    In horizontal range    In vertical range    Out of horizontal range    Out of vertical range       A region can be either linked to the current graph only or to all graphs.     Clear              This kills a region.     Report on              This popup reports you which sets or points are inside or outside of a region.     Hot links           You can link a set to a file or a pipe using this feature. Once a link has been established, you can update it (i.e., read data again) by clicking on the update button. If you have specified a command (using Grace language) in the corresponding text field of the popup, it will be executed after each update. Note that you can use several commands separated by ';' characters.   Currently, only simple XY sets can be used for hotlinks.     Set locator fixed point           After having selected this menu entry, you can select a point on a graph that will be used as the origin of the locator display (just below the menu bar). The fixed point is taken into account only when the display type of the locator is set to [DX,DY].     Clear locator fixed point           This entry is provided to remove a fixed point set before and use the default again: point [0, 0].     Locator props           The locator props popup allows you to customize the display of the locator, mainly its type and the format and precision of the display. You can use all the formats that are allowed in the graphs scales.     Preferences           The preferences popup allows you to set miscellaneous properties of your Grace session, such as GUI behavior, cursor type, date reading hint and reference date used for calendar conversions.      4.5   Data menu            Data set operations           This popup gathers all operations that are related to the ordering of data points inside a set or between sets. If you want to operate on the sets as a whole, you should use the   set operations  popup from the Edit menu. You can sort according to any coordinate (X, Y, DX, ...) in ascending or descending order, reverse the order of the points, join several sets into one, split one set into several others of equal lengths, or drop a range of points from a set. The   set selector  of the popup shows the number of points in each set in square brackets like this: G0.S0[63], the points are numbered from 0 to n-1.     Transformations menu           The transformations sub-menu gives you access to all data-mining features of Grace.     Evaluate expression              Using evaluate expression allows you to create a set by applying an explicit formula to another set, or to parts of another set if you use regions restrictions.   All the classical mathematical functions are available (cos, sin, but also lgamma, j1, erf, ...). As usual all trigonometric functions use radians by default but you can specify a unit if you prefer to say cos (x rad) or sin (3 * y deg). For the full list of available numerical functions and operators, see  Operators and functions .   In the formula, you can use X, Y, Y1, ..., Y4 to denote any coordinate you like from the source set. An implicit loop will be used around your formula so if you say:                x = x - 4966.5                  you will shift all points of your set 4966.5 units to the left.   You can use more than one set in the same formula, like this:                y = y - 0.653 * sin (x deg) + s2.y                  which means you use both X and Y from the source set but also the Y coordinate of set 2. Beware that the loop is a simple loop over the indices, all the sets you use in such an hybrid expression should therefore have the same number of points and point i of one set should really be related to point i of the other set. If your sets do not follow these requirements, you should first homogenize them using  interpolation .     Histograms              The histograms popup allows you to compute either standard or cumulative histograms from the Y coordinates of your data. Optionally, the histograms can be normalized to 1 (hence producing a PDF (Probability Distribution Function).   The bins can be either a linear mesh defined by its min, max, and length values, or a mesh formed by abscissas of another set (in which case abscissas of the set must form a strictly monotonic array).     Fourier transforms              This popup is devoted to direct and inverse Fourier transforms. The default is to perform a direct transform on unfiltered data and to produce a set with the index as abscissa and magnitude as ordinate. You can filter the input data window through triangular, Hanning, Welch, Hamming, Blackman and Parzen filters. You can load magnitude, phase or coefficients and use either index, frequency or period as abscissas. You can choose between direct and inverse Fourier transforms. If you specify real input data, X is assumed to be equally spaced and ignored; if you specify complex input data X is taken as the real part and Y as the imaginary part.   If Grace was configured with the FFTW library (see   configuration ), then the DFT and FFT buttons really perform the same transform (so there is no speed-up in using FFT in this case). If you want Grace can to use FFTW  wisdom  files, you should set several   environment variables  to name them.     Running averages              The running average popup allows you to compute some values on a sliding window over your data. You choose both the value you need (average, median, minimum, maximum, standard deviation) and the length of the window and perform the operation. You can restrict the operation to the points belonging to (or outside of) a region.     Differences              The differences popup is used to compute approximations of the first derivative of a function with finite differences. The only choice (apart from the source set of course) is the type of differences to use: forward, backward or centered.     Seasonal differences              The seasonal differences popup is used to subtract data from a period to data of the preceding period (namely y[i] - y[i + period]). Beware that the period is entered in terms of index in the set and not in terms of abscissa!     Integration              The integration popup is used to compute the integral of a set and optionally to load it. The numerical value of the integral is shown in the text field after computation. Selecting ""cumulative sum"" in the choice item will create and load a new set with the integral and compute the end value, selecting ""sum only"" will only compute the end value.     Interpolation/Splines              This popup is used to interpolate a set on an array of alternative X coordinates. This is mainly used before performing some complex operations between two sets with the   evaluate          expression  popup.   The sampling array can be either a linear mesh defined by its min, max, and length values, or a mesh formed by abscissas of another set.    Several interpolation methods can be used: linear, spline or Akima spline.   Note that if the sampling mesh is not entirely within the source set X bounds, evaluation at the points beyond the bounds will be performed using interpolation parameters from the first (or the last) segment of the source set, which can be considered a primitive extrapolation. This behaviour can be disabled by checking the ""Strict"" option on the popup.   The abscissas of the set being interpolated must form a strictly monotonic array.     Regression              The regression popup can be used to fit a set against polynomials or some specific functions (y=A*x^B, y=A*exp(B*x), y=A+B*ln(x) and y=1/(A+Bx)) for which a simple transformation of input data can be used to apply linear regression formulas.   You can load either the fitted values, the residuals or the function itself. Choosing to load fitted values or residuals leads to a set of the same length and abscissas as the initial set. Choosing to load the function is almost similar to load the fitted values except that you choose yourself the boundaries and the number of points. This can be used for example to draw the curve outside of the data sample range or to produce an evenly spaced set from an irregular one.     Non-linear fit              The non linear fit popup can be used for functions outside of the simple regression methods scope. With this popup you provide the expression yourself using a0, a1, ..., a9 to denote the fit parameters (as an example you can say y = a0 * cos (a1 * x + a2)). You specify a tolerance, starting values and optional bounds and run several steps before loading the results.   The fit characteristics (number of parameters, formula, ...) can be saved in a file and retrieved as needed using the file menu of the popup.   In the ""Advanced"" tab, you can additionally apply a restriction to the set(s) to be fitted (thus ignoring points not satisfying the criteria), use one of preset weighting schemes or define your own, and choose whether to load the fitted values, the residuals or the function itself. Choosing to load fitted values or residuals leads to a set of the same length and abscissas as the initial set. Choosing to load the function is almost similar to load the fitted values except that you choose yourself the boundaries and the number of points. This can be used for example to draw the curve outside of the data sample range or to produce an evenly spaced set from an irregular one.     Correlation/covariance              This popup can be used to compute autocorrelation of one set or cross correlation between two sets. You only select the set (or sets) and specify the maximum lag. A check box allows one to evaluate covariance instead of correlation.     Digital filter              You can use a set as a weight to filter another set. Only the Y part and the length of the weighting set are important, the X part is ignored.     Linear convolution              The convolution popup is used to ... convolve two sets. You only select the sets and apply.     Geometric transforms              You can rotate, scale or translate sets using the geometric transformations popup. You specify the characteristics of each transform and the application order.     Sample points              This popup provides two sampling methods. The first one is to choose a starting point and a step, the second one is to select only the points that satisfy a boolean expression you specify.     Prune data              This popup is devoted to reducing huge sets (and then saving both computation time and disk space).   The interpolation method can be applied only to ordered sets: it is based on the assumption that if a real point and an interpolation based on neighboring points are closer than a specified threshold, then the point is redundant and can be eliminated.   The geometric methods (circle, ellipse, rectangle) can be applied to any set, they test each point in turn and keep only those that are not in the neighborhood of previous points.      Feature extraction           Given a set of curves in a graph, extract a feature from each curve and use the values of the feature to provide the Y values for a new curve.         Feature   Description   Y minimum   Minimum Y value of set   Y maximum   Maximum Y value of set   Y average   Average Y value of set   Y std. dev.   Standard deviation of Y values   Y median   Median Y value   X minimum   Minimum X value of set   X maximum   Maximum X value of set   X average   Average X value of set   X std. dev.   Standard deviation of X values   X median   Median X value   Frequency   Perform DFT (FFT if set length a power of 2) to find largest frequency component   Period   Inverse of above   Zero crossing   Time of the first zero crossing, + or - going   Rise time   Assume curve starts at the minimum and rises to the maximum, get time to go from 10% to 90% of rise. For single exponential curves, this is 2.2*time constant   Fall time   Assume curve starts at the maximum and drops to the minimum, get time to go from 90% to 10% of fall   Slope   Perform linear regression to obtain slope   Y intercept   Perform linear regression to obtain Y-intercept   Set length   Number of data points in set   Half maximal width   Assume curve starts from the minimum, rises to the maximum and drops to the minimum again. Determine the time for which the curve is elevated more than 50% of the maximum rise.   Barycenter X   Barycenter along X axis   Barycenter Y   Barycenter along Y axis   X (Y max)   X of Maximum Y   Y (X max)   Y of Maximum X   integral   cumulative sum                   Extractable features               Import menu             ASCII              Read new sets of data in a graph. A   graph selector  is used to specify the graph where the data should go (except when reading block data, which are copied to graphs later on).   Reading as ""Single set"" means that if the source contains only one column of numeric data, one set will be created using the indices (from 1 to the total number of points) as abscissas and read values as ordinates and that if the source contains more than one column of data, the first two numeric columns will be used. Reading as ""NXY"" means that the first numeric column will provide the abscissas and all remaining columns will provide the ordinates of several sets. Reading as ""Block data"" means all column will be read and stored and that another popup will allow to select the abscissas and ordinates at will. It should be noted that block data are stored as long as you do not override them by a new read. You can still retrieve data from a block long after having closed all popups, using the   set          selector .   The set type can be one of the predefined set presentation types (see   sets ).   The data source can be selected as ""Disk"" or ""Pipe"". In the first case the text in the ""Selection"" field is considered to be a file name (it can be automatically set by the file selector at the top of the popup). In the latter case the text is considered to be a command which is executed and should produce the data on its standard output. On systems that allows is, the command can be a complete sequence of programs glued together with pipes.   If the source contains date fields, they should be automatically detected. Several formats are recognized (see appendix   dates in grace ). Calendar dates are converted to numerical dates upon reading.   The ""Autoscale on read"" menu controls whether, upon reading in new sets, which axes of the graph should be autoscaled.     NetCDF              This entry exists only if Grace has been compiled with support for the NetCDF data format (see   configuration ).     Export menu             ASCII              Save data sets in a file. A   set          selector  is used to specify the set to be saved. The format to use for saving data points can be specified (the default value is ""%16.8g""). A warning is displayed if a file with the same name already exists.       4.6   Plot menu            Plot appearance           The plot appearance popup let you set the time stamp properties and the background color of the page. The color is used outside of graphs and also on graphs were no specific background color is set. The time stamp is updated every time the project is modified.     Graph appearance           The graph appearance popup can be displayed from both the plot menu and by double-clicking on a legend, title, or subtitle of a graph (see   Clicks and double clicks ). The graph selector at the top allows to choose the graph you want to operate on, it also allows certain common actions through its popup menu (see  graph selector ). Most of the actions can also be performed using the ""Edit"" menu available from the popup menubar. The main tab includes the properties you will need more often (title for example), and other tabs are used to fine tune some less frequently used options (fonts, sizes, colors, placements).   If you need special characters or special formatting in your title or subtitle, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!   You can save graph appearance parameters or retrieve settings previously saved via the ""File"" menu of this popup. In the ""Save parameters"" dialog, you can choose to save settings either for the current graph only or for all graphs.      Set appearance           The set appearance popup can be displayed from both the plot menu and by double-clicking anywhere in a graph (see   Clicks and double clicks ). The set selector at the top allows to choose the set you want to operate on, it also allows certain common actions through its popup menu (see  set selector ). The main tab gathers the properties you will need more often (line and symbol properties or legend string for example), and other tabs are used to fine tune some less frequently used options (drop lines, fill properties, annotated values and error bars properties for example).   You should note that despite the legend string related to  one  set is entered in the set appearance popup, this is not sufficient to display it. Displaying  all  legends is a graph level decision, so the toggle is in the main tab of the   graph appearance  popup.   If you need special characters or special formatting in your legend, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!     Axis properties           The axis properties popup can be displayed from both the ""Plot"" menu and by double-clicking exactly on an axis (see   Clicks and double clicks ). The pulldown menu at the top allows to select the axis you want to operate on. The ""Active"" toggle globally activates or deactivates the axis (all GUI elements are insensitive for deactivated axes). The start and stop fields depict the displayed range. Three types of scales are available: linear, logarithmic or reciprocal, and you can invert the axis (which normally increases from left to right and from bottom to top).  The main tab includes the properties you will need more often (axis label, tick spacing and format for example), and other tabs are used to fine tune some less frequently used options (fonts, sizes, colors, placements, stagger, grid lines, special ticks, ...).   If you need special characters or special formatting in your label, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!   Once you have set the options as you want, you can apply them. One useful feature is that you can set several axes at once with the bottom pulldown menu (current axis, all axes current graph, current axis all graphs, all axes all graphs). Beware that you always apply the properties of all tabs, not only the selected one.      4.7   View menu            Show locator bar           This toggle item shows or hides the locator below the menu bar.     Show status bar           This toggle item shows or hides the status string below the canvas.     Show tool bar           This toggle item shows or hides the tool bar at the left of the canvas.     Page setup           Set the properties of the display device. It is the same dialog as in   Print setup .     Redraw           This menu item triggers a redrawing of the canvas.     Update all           This menu item causes an update of all GUI controls. Usually, everything is updated automatically, unless one makes modifications by entering commands in the   Command  tool.       4.8   Window menu             Commands           Command driven version of the interface to Grace. Here, commands are typed at the ""Command:"" text item and executed when <Return> is pressed. The command will be parsed and executed, and the command line is placed in the history list. Items in the history list can be recalled by simply clicking on them with the left mouse button. For a reference on the Grace command interpreter, see   Command interpreter .    Point tracking           Not written yet...    Drawing objects           Not written yet...    Font tool           Not written yet...    Console           The console window displays errors and results of some numerical operations, e.g. nonlinear fit (see   Non-linear fit ). The window is popped up automatically whenever an error occurs or new result messages appear. This can be altered by checking the ""Options/Popup only on errors"" option.     4.9   Help menu            On context           Click on any element of the interface to get context-sensitive help on it. Only partially implemented at the moment.    User's guide           Browse the Grace user's guide.    Tutorial           Browse the Grace tutorial.    FAQ           Frequently Asked Questions with answers.    Changes           The list of changes during the Grace development.    Examples           The whole tree of submenus each loading a sample plot.    Comments           Use this to send your suggestions or bug reports.    License terms           Grace licensing terms will be displayed (GPL version 2).    About           A popup with basic info on the software, including some configuration details. More details can be found when running Grace with the ""-version"" command line flag.     5.   Command interpreter          5.1   General notes          The interpreter parses its input in a line-by-line manner. There may be several statements per line, separated by semicolon ( ; ). The maximal line length is 4 kbytes (hardcoded). The parser is case-insensitive and ignores lines beginning with the "" # "" sign.   5.2   Definitions               Name   Description   Examples   expr  Any numeric expression  1.5 + sin(2)   iexpr  Any expression that evaluates to an integer  25, 0.1 + 1.9, PI/asin(1)   nexpr  Non-negative iexpr  2 - 1   indx  Non-negative iexpr      qstr  Quoted string  ""a string""   vexpr  Vector expression  ""2*x""                         Basic types                  Expression   Description   Types   Example   GRAPH[ id ]  graph  id   indx  id   GRAPH[0]   G nn   graph  nn   nn : 0-99  G0                         Graph selections                  Expression   Description   Types   Example    graph .SETS[ id ]  set  id  in graph  graph indx  id , graphsel  graph   GRAPH[0].SETS[1]    graph .S nn   set  nn  in graph  graph nn : 0-99, graphsel  graph   G0.S1   SET[ id ]  set  id  in the current graph indx  id   SET[1]   S nn   set  nn  in the current graph nn : 0-99  S1   S   the last allocated set in the current graph -  S    S$  the active set in the current graph -  S$                         Set selections                  Expression   Description   Types   Example   R n   region  n   n : 0-4  R0                         Region selections                  Expression   Description   Types   Example   COLOR  ""colorname""   a mapped color  colorname   -  COLOR ""red""   COLOR  id   a mapped color with ID  id   nexpr  id   COLOR 2                         Color selections                  Expression   Description   Types   Example   PATTERN  id   pattern with ID  id   nexpr  id   PATTERN 1                         Pattern selections                  Expression   Description   Types   Example   X  the first column  -  X   Y  the second column  -  Y   Y n   ( n  + 2)-th column  n  = 0 - 4  Y3                         Data column selections             Not finished yet...   5.3   Variables                Variable   Description   datacolumn   data column of current set   set.datacolumn   data column of set   vvar   user-defined array   vvariable [i:j]   segment of a vector variable (elements from i-th to j-th inclusive, i <= j)                         Vector variables                    Variable   Description   vvariable[i]   i-th element of a vector variable   var   user-defined variable                         Scalar variables                 5.4   Numerical operators and functions           In numerical expressions, the infix format is used. Arguments of both operators and functions can be either scalars or vector arrays.          Operator   Description   +   addition   -   substraction   *   multiplication   /   division   %   modulus   ^   raising to power                         Arithmetic operators                    Operator   Description   AND or &&   logical AND   OR or ||   logical OR   NOT or !   logical NOT                         Logical operators                    Operator   Description   EQ or ==   equal   NE or !=   not equal   LT or <   less than   LE or <=   less than or equal   GT or >   greater than   GE or >=   greater than or equal                         Comparison operators                    Function   Description   abs(x)   absolute value   acos(x)   arccosine   acosh(x)   hyperbolic arccosine   asin(x)   arcsine   asinh(x)   hyperbolic arcsine   atan(x)   arctangent   atan2(y,x)   arc tangent of two variables   atanh(x)   hyperbolic arctangent   ceil(x)   greatest integer function   cos(x)   cosine   cosh(x)   hyperbolic cosine   exp(x)   e^x   fac(n)   factorial function, n!   floor(x)   least integer function   irand(n)   random integer less than n   ln(x)   natural log   log10(x)   log base 10   log2(x)   base 2 logarithm of x   maxof(x,y)   returns greater of x and y   mesh(n)   mesh array (0 ... n - 1)   mesh(x1, x2, n)   mesh array of n equally spaced points between x1 and x2 inclusive   minof(x,y)   returns lesser of x and y   mod(x,y)   mod function (also x % y)   pi   the PI constant   rand   pseudo random number distributed uniformly on (0.0,1.0)   rand(n)   array of n random numbers   rint(x)   round to closest integer   sin(x)   sine function   sinh(x)   hyperbolic sine   sqr(x)   x^2   sqrt(x)   x^0.5   tan(x)   tangent function   tanh(x)   hyperbolic tangent                         Functions                  Function   Description   chdtr(df, x)   chi-square distribution   chdtrc(v, x)   complemented Chi-square distribution   chdtri(df, y)   inverse of complemented Chi-square distribution   erf(x)   error function   erfc(x)   complement of error function   fdtr(df1, df2, x)   F distribution function   fdtrc(x)   complemented F distribution   fdtri(x)   inverse of complemented F distribution   gdtr(a, b, x)   gamma distribution function   gdtrc(a, b, x)   complemented gamma distribution function   ndtr(x)   Normal distribution function   ndtri(x)   inverse of Normal distribution function   norm(x)   gaussian density function   pdtr(k, m)   Poisson distribution   pdtrc(k, m)   complemented Poisson distribution   pdtri(k, y)   inverse Poisson distribution   rnorm(xbar,s)   pseudo random number distributed N(xbar,s)   stdtr(k, t)   Student's t distribution   stdtri(k, p)   functional inverse of Student's t distribution                         Statistical functions                  Function   Description   ai(x), bi(x)   Airy functions (two independent solutions of the differential equation  y''(x) = xy )   beta(x)   beta function   chi(x)   hyperbolic cosine integral   ci(x)   cosine integral   dawsn(x)   Dawson's integral   ellie(phi, m)   incomplete elliptic integral of the second kind   ellik(phi, m)   incomplete elliptic integral of the first kind   ellpe(m)   complete elliptic integral of the second kind   ellpk(m)   complete elliptic integral of the first kind   expn(n, x)   exponential integral   fresnlc(x)   cosine Fresnel integral   fresnls(x)   sine Fresnel integral   gamma(x)   gamma function   hyp2f1(a, b, c, x)   Gauss hyper-geometric function   hyperg(a, b, x)   confluent hyper-geometric function   i0e(x)   modified Bessel function of order zero, exponentially scaled   i1e(x)   modified Bessel function of order one, exponentially scaled   igam(a, x)   incomplete gamma integral   igamc(a, x)   complemented incomplete gamma integral   igami(a, p)   inverse of complemented incomplete gamma integral   incbet(a, b, x)   incomplete beta integral   incbi(a, b, y)   Inverse of incomplete beta integral   iv(v, x)   modified Bessel function of order v   jv(v, x)   Bessel function of order v   k0e(x)   modified Bessel function, third kind, order zero, exponentially scaled   k1e(x)   modified Bessel function, third kind, order one, exponentially scaled   kn(n, x)   modified Bessel function, third kind, integer order   lbeta(x)   natural log of |beta(x)|   lgamma(x)   log of gamma function   psi(x)   psi (digamma) function   rgamma(x)   reciprocal gamma function   shi(x)   hyperbolic sine integral   si(x)   sine integral   spence(x)   dilogarithm   struve(v, x)   Struve function   yv(v, x)   Bessel function of order v   zeta(x, q)   Riemann zeta function of two arguments   zetac(x)   Riemann zeta function                         Special math functions                    Function   Description   MIN(x)   min value of array x   MAX(x)   max value of array x   AVG(x)   average of array x   SD(x)   standard deviation of array x   SUM(x)   sum of all elements of array x                         Aggregate functions                   5.5   Procedures          Methods of directly manipulating the data corresponding to the Data|Transformation menu are described in table  transformations  .         Statement   Description   Types   Example   INTERPOLATE (set, mesh, method, strict)  interpolate  set  on a sampling  mesh  using  method .  strict  flag controls whether result should be bound within the source set  vexpr  mesh ,  method : one of LINEAR, SPLINE, and ASPLINE, onoff  strict   INTERPOLATE (S0, S1.X, ASPLINE, OFF)   HISTOGRAM (set, bins, cumulative, normalize)  calculate histogram of  set  on defined  bins .  cumulative  and  normalize  flags control whether to calculate cumulative and normalized (aka PDF) histograms, respectively. Data points are placed at upper limit of the bin  vexpr  bins , onoff  cumulative , onoff  normalize   HISTOGRAM (S0, MESH(0, 1, 11), OFF, ON)   XCOR (set1, set2, maxlag, covar)  calculate cross-correlation (or -covariance if the  covar  flag is set) of  set1  with  set2  with maximum lag  maxlag .  nexpr  maxlag , onoff  covar   XCOR (S0, S0, 50, OFF)   RESTRICT (set, restriction)  filter  set  according to logical  restriction . The original set will be overwritten  vexpr  restriction   RESTRICT (S0, x < 0)   RESTRICT (set, region, negate)  filter  set  by keeping only points lying inside/outside  region . The original set will be overwritten  onoff  negate RESTRICT (S0, x < 0)                         Transformations             Not finished yet...   5.6   Device parameters          For producing ""hard copy"", several parameters can be set via the command interpreter.  They are summarized in table   Device parameters .        Command   Description   PAGE SIZE xdim, ydim   set page dimensions (in pp) of all devices   PAGE RESIZE xdim, ydim   same as above plus rescale the current plot accordingly   DEVICE  ""devname""  PAGE SIZE xdim, ydim   set page dimensions (in pp) of device  devname    DEVICE  ""devname""  DPI dpi   set device's dpi (dots per pixel)   DEVICE  ""devname""  FONT onoff   enable/disable usage of built-in fonts for device  devname    DEVICE  ""devname""  FONT ANTIALIASING onoff   enable/disable font aliasing for device  devname    DEVICE  ""devname""  OP  ""options""    set device specific options (see   Device-specific settings )   HARDCOPY DEVICE  ""devname""    set device  devname  as current hardcopy device   PRINT TO  ""filename""    set print output to  filename  (but do not print)   PRINT TO DEVICE   set print output to hardcopy device (but do not print)                         Device parameters              5.7   Flow control               Statement   Description   Types   Example   PRINT  execute print job     PRINT   SLEEP  n   sleep for  n  seconds  expr  n   SLEEP(3)   EXIT( status )  cause normal program termination with exit status  status   iexpr  status   EXIT(0)   EXIT  cause normal program termination; same as EXIT(0)     EXIT   HELP  url   open a HTML document pointed to by  url   qstr  url   HELP ""doc/FAQ.html""   HELP  open User's Guide     HELP                         Flow control             5.8   Declarations          User-defined variables are set and used according to the syntax described in table   User variables .        Statement   Description   Types   Example   DEFINE  var   define new scalar variable  var      DEFINE myvar   DEFINE  vvar []  define new vector variable  vvar  of zero length     DEFINE myvvar[]   DEFINE  vvar [ n ]  define new vector variable  vvar  of length  n   nexpr  n   DEFINE myvvar[10]   CLEAR  var   undefine new variable  var  and deallocate associated storage     CLEAR myvar    vvar  LENGTH  n   reallocate vector variable  vvar   nexpr  n   myvvar LENGTH 25                         User variables             Not finished yet...   5.9   Graph properties        We divide the commands pertaining to the properties and appearance of graphs into those which directly manipulate the graphs and those that  affect the appearance of graph elements---the parameters that can appear in a Grace project file.   Command operations        General graph creation/annihilation and control commands appear in table   Graph operations .        Statement   Description   Types   Example   FOCUS  graph    Makes  graph  current and unhides it if necessary  graphsel  graph    FOCUS G0   KILL  graph    Kills  graph    graphsel  graph    KILL G0   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap )  Arrange existing graphs (or add extra if needed) to form an  nrows  by  ncols  matrix, leaving  offset  at each page edge with  hgap  and  vgap  relative horizontal and vertical spacings  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap   ARRANGE(2, 2, 0.1, 0.15, 0.2)   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap ,  hvinv ,  hinv ,  vinv )  Same as above, plus additional  hvinv ,  hinv , and  vinv  flags allowing to alter the order of the matrix filling  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap , onoff  hvinv ,  hinv ,  vinv   ARRANGE(2, 2, 0.1, 0.15, 0.2, ON, OFF, ON)   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap ,  hvinv ,  hinv ,  vinv ,  snake )  Same as above, plus additional  snake  flag allowing to fill the matrix in a snake-like fashion  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap , onoff  hvinv ,  hinv ,  vinv ,  snake   ARRANGE(2, 2, 0.1, 0.15, 0.2, ON, OFF, ON, ON)                         Graph operations             Parameter settings        Setting the active graph and its type is accomplished with the commands found in table   Graph selection parameters .        Statement   Description   Types   Example   WITH  graph    Makes  graph  current  graphsel  graph    WITH G0   TYPE  type    Sets  type  of current graph  graphtype  type   TYPE XY    graph  onoff  (De)Activates selected  graph    graphsel  graph , onoff   G0 ON    graph  HIDDEN onoff   Hides selected  graph    graphsel  graph , onoff   G1 HIDDEN TRUE    graph  TYPE  type    Sets  type  of  graph   graphsel  graph , graphtype  type    G0 TYPE XYDY                         Graph selection parameters             The axis range and scale of the current graph as well as its  location on the plot viewport are set with the commands listed in table  Axis parameters .     Statement   Description   Types   Example   WORLD XMIN  xmin    Sets minimum value of current graph's x axis to  xmin   expr  xmin    WORLD XMIN -10   WORLD XMAX  xmax    Sets maximum value of current graph's x axis to  xmin   expr  xmax    WORLD XMAX 22.5   WORLD YMIN  ymin    Sets minimum value of current graph's y axis to  ymin   expr  ymin    WORLD YMIN 0   WORLD YMAX  ymax    Sets maximum value of current graph's y axis to  ymax   expr  ymax    WORLD YMAX 1e4   VIEW XMIN  xmin    Sets left edge of current graph at x= xmin  in the viewport  expr  xmin  VIEW XMIN .2   VIEW XMAX  xmax    Sets right edge of current graph at x= xmax  in the viewport  expr  xmax  VIEW XMAX 1.0   VIEW YMIN  ymin    Sets bottom edge of current graph at y= ymin  in the viewport  expr  ymin  VIEW YMIN .25   VIEW YMAX  ymax    Sets top edge of current graph at y= ymax  in the viewport  expr  ymax  VIEW YMAX .75   XAXES SCALE  type    Set scaling of the x axes to  type   type : one of NORMAL, LOGARITHMIC, or RECIPROCAL   XAXES SCALE NORMAL   YAXES SCALE  type    Set scaling of the y axes to  type   type : one of NORMAL, LOGARITHMIC, or RECIPROCAL   YAXES SCALE LOGARITHMIC   XAXES INVERT onoff   If ON, draws xmin to xmax from right to left  onoff   XAXES INVERT OFF   YAXES INVERT onoff   If ON, draws ymin to ymax from top to bottom  onoff   YAXES INVERT OFF   AUTOSCALE ONREAD  type    Set automatic scaling on read according to  type   type : one of NONE, XAXES, YAXES, XYAXES   AUTOSCALE ONREAD NONE                         Axis parameters             The commands to set the appearance and textual content of titles and legends are given in table   Titles and legends .        Statement   Description   Types   Example   TITLE  title    Sets the title of current graph  qstr  title    TITLE ""Foo""   TITLE FONT  font    Selects font of title string  fontsel  font    TITLE FONT 1   TITLE SIZE  size    Sets size of title string  expr  size    TITLE SIZE 1.5   TITLE COLOR  color    Sets color of title string  colorsel  color    TITLE COLOR 1   SUBTITLE  subtitle    Sets the subtitle of current graph  qstr  subtitle    SUBTITLE ""Bar""   SUBTITLE FONT  font    Selects font of subtitle string  fontsel  font    SUBTITLE FONT ""Times-Italic""   SUBTITLE SIZE  size    Sets size of subtitle string  expr  size    SUBTITLE SIZE .60   SUBTITLE COLOR  color    Sets color of subtitle string  colorsel  color    SUBTITLE COLOR ""blue""   LEGEND onoff   Toggle legend display  onoff   LEGEND ON   LEGEND LOCTYPE  type    Posistion legend in  type  coordinates  type : either WORLD or VIEW   LEGEND LOCTYPE WORLD   LEGEND  xloc, yloc    Set location of legend box (upper left corner)  expr  xloc, yloc    LEGEND .5,.75   LEGEND FONT  font  Set legend font type  fontsel  font    LEGEND FONT ""Helvetica""   LEGEND CHAR SIZE  size    Sets size of legend label characters (1 is normal) expr  size    LEGEND CHAR SIZE .30   LEGEND  color  Set color of legend text  colorsel  color    LEGEND COLOR 1   LEGEND VGAP  gap    Sets vertical gap between legend entries  nexpr  gap    LEGEND VGAP 1   LEGEND HGAP  gap    Sets horizontal gap between symbol and description  nexpr  gap    LEGEND HGAP 4   LEGEND LENGTH  length  Sets  length  of legend nexpr  length    LEGEND LENGTH 5   LEGEND INVERT onoff   Determines relationship between order of sets and order of legend labels  onoff   LEGEND INVERT true   LEGEND BOX onoff   Determines if the legend bounding box is drawn  onoff   LEGEND BOX off   LEGEND BOX COLOR  color    Sets color of legend bounding box   colorsel  color   LEGEND BOX COLOR 1  LEGEND BOX PATTERN  pattern  Sets pattern of legend bounding box   patternsel  pattern   LEGEND BOX PATTERN 2  LEGEND BOX LINESTYLE  style  Sets line style of bounding box  nexpr  style   LEGEND BOX LINESTYLE 1   LEGEND BOX LINEWIDTH  width  Sets line width of bounding box nexpr  width   LEGEND BOX LINEWIDTH 2   LEGEND BOX FILL onoff   Determines if the legend bounding box is filled  onoff   LEGEND BOX FILL false   LEGEND BOX FILL COLOR  color    Sets color of legend box fill   colorsel  color   LEGEND BOX COLOR 3   LEGEND BOX FILL  pattern  Sets pattern of legend box fill  patternsel  pattern   LEGEND BOX FILL PATTERN 1                        Titles and legends             Not finished yet...   5.10   Set properties          Again, as with the graphs, we separate those parser commands that manipulate the data in a set from the commands that determine parameters---elements that are saved in a project file.    Commands        Operations for set I/O are summarized in table   Set input, output,  and creation .  (Note that this is incomplete  and only lists  input  commands at the moment.)        Statement   Description   Types   Example   READ  file    Reads  file  as a single set  qstr  file    READ ""foo.dat""   READ  settype   file    Reads  file  into a single set of type  settype   xytype  settype , qstr  file    READ xydy ""bar.dat""   READ NXY  file    Reads  file  as NXY data  qstr  file    READ NXY ""gad.dat""   READ BLOCK  file    Reads  file  as block data  qstr  file    READ BLOCK ""zooks.dat""   BLOCK  settype   columns    Forms a data set of type  settype  using  columns  from current block data file.  xytype  settype , qstr  columns    BLOCK xydxdy ""0:2:1:3""                         Set input, output,  and creation             The parser commands analogous to the Data|Data set operations dialogue can be found in table   Set operations .      Statement   Description   Types   Example   COPY  src  TO  dest    Copies  src  to  dest setsel  src,dest    COPY S0 TO S1   MOVE  src  TO  dest    Moves  src  to  dest   setsel  src,dest    MOVE G0.S0 TO G1.S0   SWAP  src  AND  dest    Interchanges  src  and  dest   setsel  src,dest    SWAP G0.S0 AND G0.S1   KILL  set    Kills  set    setsel  set    KILL G0.S0                         Set operations             Not Finished yet...    Parameter settings        Not written yet...    6.   Advanced topics           6.1   Fonts          For all devices, Grace uses Type1 fonts. Both PFA (ASCII) and PFB (binary) formats can be used.    Font configuration          The file responsible for the font configurations of Grace is  fonts/FontDataBase . The first line contains a positive integer specifying the number of fonts declared in that file. All remaining lines contain declarations of one font each, composed out of three fields:     Font name. The name will appear in the font selector controls. Also, backend devices that has built-in fonts, will be given the name as a font identifier.    Font fall-back. Grace will try to use this in case the real font is not found.    Font filename. The file with the font outline data.       Here is the default  FontDataBase  file:      14 Times-Roman             Times-Roman             n021003l.pfb Times-Italic            Times-Italic            n021023l.pfb Times-Bold              Times-Bold              n021004l.pfb Times-BoldItalic        Times-BoldItalic        n021024l.pfb Helvetica               Helvetica               n019003l.pfb Helvetica-Oblique       Helvetica-Oblique       n019023l.pfb Helvetica-Bold          Helvetica-Bold          n019004l.pfb Helvetica-BoldOblique   Helvetica-BoldOblique   n019024l.pfb Courier                 Courier                 n022003l.pfb Courier-Oblique         Courier-Oblique         n022023l.pfb Courier-Bold            Courier-Bold            n022004l.pfb Courier-BoldOblique     Courier-BoldOblique     n022024l.pfb Symbol                  Symbol                  s050000l.pfb ZapfDingbats            ZapfDingbats            d050000l.pfb                   Font data files        For text rastering, three types of files are used.      .pfa -/ .pfb -files: These contain the character outline descriptions. The files are assumed to be in the  fonts/type1  directory; these are the filenames specified in the  FontDataBase  configuration file.     .afm -files: These contain high-precision font metric descriptions as well as some extra information, such as kerning and ligature information for a particular font. It is assumed that the filename of a font metric file has same basename as the respective font outline file, but with the  .afm  extension; the metric files are expected to be found in the  fonts/type1  directory, too.     .enc -files: These contain encoding arrays in a special but simple form. They are only needed if someone wants to load a special encoding to re-encode a font. Their place is  fonts/enc        Custom fonts          It is possible to use custom fonts with Grace. One mostly needs to use extra fonts for the purpose of localization. For many European languages, the standard fonts supplied with Grace should contain all the characters needed, but encoding may have to be adjusted. This is done by putting a  Default.enc  file with proper encoding scheme into the  fonts/enc  directory. Grace comes with a few encoding files in the directory; more can be easily found on the Internet. (If the  Default.enc  file doesn't exist, the IsoLatin1 encoding will be used). Notice that for fonts having an encoding scheme in themselves (such as the Symbol font, and many nationalized fonts) the default encoding is ignored.   If you do need to use extra fonts, you should modify the  FontDataBase  file accordingly, obeying its format. However, if you are going to exchange Grace project files with other people who do not have the extra fonts configured, an important thing is to define reasonable fall-back font names.   For example, let us assume I use Hebrew fonts, and the configuration file has lines like these:          ... Courier-Hebrew              Courier                 courh___.pfa Courier-Hebrew-Oblique      Courier-Oblique         courho__.pfa     ...               My colleague, who lives in Russia, uses Cyrillic fonts with Grace configured like this:          ... Cronix-Courier              Courier                 croxc.pfb Cronix-Courier-Oblique      Courier-Oblique         croxco.pfb     ...               The font mapping information (Font name <-> Font fall-back) is stored in the Grace project files. Provided that all the localized fonts have English characters in the lower part of the ASCII table unmodified, I can send my friend files (with no Hebrew characters, of course) and be sure they render correctly on his computer.   Thus, with properly configured national fonts, you can make localized annotations for plots intended for internal use of your institution, while being able to exchange files with colleagues from abroad. People who ever tried to do this with MS Office applications should appreciate the flexibility :-).    6.2   Interaction with other applications            Using pipes            Using grace_np library          The grace_np library is a set of compiled functions that allows you to launch and drive a Grace subprocess from your C or Fortran application. Functions are provided to start the subprocess, to send it commands or data, to stop it or detach from it.        Function   Arguments   Description   int GraceOpenVA   (char * exe , int  buf_size , ...)  launch a Grace executable  exe  and open a communication channel with it using  buf_size  bytes for data buffering. The remaining NULL-terminated list of options is command line arguments passed to the Grace process   int GraceOpen   (int  buf_size )  equivalent to GraceOpenVA(""xmgrace"", buf_size, ""-noask"", NULL)   int GraceIsOpen   (void)   test if a Grace subprocess is currently connected   int GraceClose   (void)   close the communication channel and exit the Grace subprocess   int GraceClosePipe   (void)   close the communication channel and leave the Grace subprocess alone   int GraceFlush   (void)   flush all the data remaining in the buffer   int GracePrintf   (const char*  format , ...)  format a command and send it to the Grace subprocess   int GraceCommand   (const char*  cmd )  send an already formated command to the Grace subprocess   GraceErrorFunctionType GraceRegisterErrorFunction  (GraceErrorFunctionType  f )  register a user function  f  to display library errors                 grace_np library C functions.                  Function   Arguments   Description   integer GraceOpenF   (integer  buf_size )  launch a Grace subprocess and open a communication channel with it   integer GraceIsOpenF   (void)   test if a Grace subprocess is currently connected   integer GraceCloseF   (void)   close the communication channel and exit the Grace subprocess   integer GraceClosePipeF   (void)   close the communication channel and leave the Grace subprocess alone   integer GraceFlushF   (void)   flush all the data remaining in the buffer   integer GraceCommandF   (character*(*)  cmd )  send an already formatted command to the Grace subprocess   GraceFortranFunctionType GraceRegisterErrorFunctionF  (GraceFortranFunctionType  f )  register a user function  f  to display library errors                 grace_np library F77 functions.               There is no fortran equivalent for the GracePrintf function, you should format all the data and commands yourself before sending them with GraceCommandF.   The Grace subprocess listen for the commands you send and interpret them as if they were given in a batch file. You can send any command you like (redraw, autoscale, ...). If you want to send data, you should include them in a command like ""g0.s0 point 3.5, 4.2"".   Apart from the fact it monitors the data sent via an anonymous pipe, the Grace subprocess is a normal process. You can interact with it through the GUI. Note that no error can be sent back to the parent process. If your application send erroneous commands, an error popup will be displayed by the subprocess.   If you exit the subprocess while the parent process is still using it, the broken pipe will be detected. An error code will be returned to every further call to the library (but you can still start a new process if you want to manage this situation).   Here is an example use of the library, you will find this program in the distribution.         #include <stdlib.h> #include <stdio.h> #include <unistd.h> #include <grace_np.h>  #ifndef EXIT_SUCCESS #  define EXIT_SUCCESS 0 #endif  #ifndef EXIT_FAILURE #  define EXIT_FAILURE -1 #endif  void my_error_function(const char *msg) {     fprintf(stderr, ""library message: \""%s\""\n"", msg); }  int main(int argc, char* argv[]) {     int i;      GraceRegisterErrorFunction(my_error_function);      /* Start Grace with a buffer size of 2048 and open the pipe */     if (GraceOpen(2048) == -1) {         fprintf(stderr, ""Can't run Grace. \n"");         exit(EXIT_FAILURE);     }          /* Send some initialization commands to Grace */     GracePrintf(""world xmax 100"");     GracePrintf(""world ymax 10000"");     GracePrintf(""xaxis tick major 20"");     GracePrintf(""xaxis tick minor 10"");     GracePrintf(""yaxis tick major 2000"");     GracePrintf(""yaxis tick minor 1000"");     GracePrintf(""s0 on"");     GracePrintf(""s0 symbol 1"");     GracePrintf(""s0 symbol size 0.3"");     GracePrintf(""s0 symbol fill pattern 1"");     GracePrintf(""s1 on"");     GracePrintf(""s1 symbol 1"");     GracePrintf(""s1 symbol size 0.3"");     GracePrintf(""s1 symbol fill pattern 1"");      /* Display sample data */     for (i = 1; i <= 100 && GraceIsOpen(); i++) {         GracePrintf(""g0.s0 point %d, %d"", i, i);         GracePrintf(""g0.s1 point %d, %d"", i, i * i);         /* Update the Grace display after every ten steps */         if (i % 10 == 0) {             GracePrintf(""redraw"");             /* Wait a second, just to simulate some time needed for                calculations. Your real application shouldn't wait. */             sleep(1);         }     }      if (GraceIsOpen()) {         /* Tell Grace to save the data */         GracePrintf(""saveall \""sample.agr\"""");          /* Flush the output buffer and close Grace */         GraceClose();          /* We are done */         exit(EXIT_SUCCESS);     } else {         exit(EXIT_FAILURE);     } }             6.3   FFTW tuning          When the FFTW capabilities are compiled in, Grace looks at two environment variables to decide what to do with the FFTW 'wisdom' capabilities.  First, a quick summary of what this is. The FFTW package is capable of adaptively determining the most efficient factorization of a set to give the fastest computation.  It can store these factorizations as 'wisdom', so that if a transform of a given size is to be repeated, it is does not have to re-adapt.  The good news is that this seems to work very well.  The bad news is that, the first time a transform of a given size is computed, if it is not a sub-multiple of one already known, it takes a LONG time (seconds to minutes).   The first environment variable is GRACE_FFTW_WISDOM_FILE. If this is set to the name of a file which can be read and written (e.g., $HOME/.grace_fftw_wisdom) then Grace will automatically create this file (if needed) and maintain it. If the file is read-only, it will be read, but not updated with new wisdom. If the symbol GRACE_FFTW_WISDOM_FILE either doesn't exist, or evaluates to an empty string, Grace will drop the use of wisdom, and will use the fftw estimator (FFTW_ESTIMATE flag sent to the planner) to guess a good factorization, instead of adaptively determining it.   The second variable is GRACE_FFTW_RAM_WISDOM. If this variable is defined to be non-zero, and GRACE_FFTW_WISDOM_FILE variable is not defined (or is an empty string), Grace will use wisdom internally, but maintain no persistent cache of it. This will result in very slow execution times the first time a transform is executed after Grace is started, but very fast repeats. I am not sure why anyone would want to use wisdom without writing it to disk, but if you do, you can use this flag to enable it.       6.4   DL modules           Grace can access external functions present in either system or third-party shared libraries or modules specially compiled for use with Grace.    Function types        One must make sure, however, that the external function is of one of supported by Grace types:     Grace type   Description   f_of_i   a function of 1  int  variable   f_of_d   a function of 1  double  variable   f_of_nn   a function of 2  int  parameters   f_of_nd   a function of 1  int  parameter and 1  double  variable   f_of_dd   a function of 2  double  variables   f_of_nnd   a function of 2  int  parameters and 1  double  variable   f_of_ppd   a function of 2  double  parameters and 1  double  variable   f_of_pppd   a function of 3  double  parameters and 1  double  variable                                     Grace types for external functions             The return values of functions are assumed to be of the  double  type.   Note, that there is no difference from the point of view of function prototype between parameters and variables; the difference is in the way Grace treats them - an attempt to use a vector expression as a parameter argument will result in a parse error.   Let us consider few examples.    Examples           Caution: the examples provided below (paths and compiler flags) are valid for Linux/ELF with gcc. On other operating systems, you may need to refer to compiler/linker manuals or ask a guru.    Example 1           Suppose I want to use function  pow(x,y)  from the Un*x math library (libm). Of course, you can use the ""^"" operator defined in the Grace language, but here, for the sake of example, we want to access the function directly.   The command to make it accessible by Grace is   USE ""pow"" TYPE f_of_dd FROM ""/usr/lib/libm.so""      Try to plot y = pow(x,2) and y = x^2 graphs (using, for example, ""create new -> Formula"" from any   set        selector ) and compare.    Example 2           Now, let us try to write a function ourselves. We will define function  my_function  which simply returns its (second) argument multiplied by integer parameter transferred as the first argument.   In a text editor, type in the following C code and save it as ""my_func.c"":                double my_function (int n, double x)        {            double retval;            retval = (double) n * x;            return (retval);        }                  OK, now compile it:                $gcc -c -fPIC my_func.c        $gcc -shared my_func.o -o /tmp/my_func.so                  (You may strip it to save some disk space):                $strip /tmp/my_func.so                  That's all! Ready to make it visible to Grace as ""myf"" - we are too lazy to type the very long string ""my_function"" many times.      USE ""my_function"" TYPE f_of_nd FROM ""/tmp/my_func.so"" ALIAS ""myf""        Example 3           A more serious example. There is a special third-party library available on your system which includes a very important for you yet very difficult-to-program from the scratch function that you want to use with Grace.  But, the function prototype is NOT one of any predefined   types .  The solution is to write a simple function wrapper. Here is how:   Suppose, the name of the library is ""special_lib"" and the function you are interested in is called ""special_func"" and according to the library manual, should be accessed as  void special_func(double *input, double *output, int parameter) . The wrapper would look like this:                double my_wrapper(int n, double x)        {            extern void special_func(double *x, double *y, int n);            double retval;            (void) special_func(&x, &retval, n);            return (retval);        }                  Compile it:                $gcc -c -fPIC my_wrap.c        $gcc -shared my_wrap.o -o /tmp/my_wrap.so -lspecial_lib -lblas        $strip /tmp/my_wrap.so                  Note that I added  -lblas  assuming that the special_lib library uses some functions from the BLAS. Generally, you have to add  all  libraries which your module depends on (and all libraries those libraries rely upon etc.), as if you wanted to compile a plain executable.   Fine, make Grace aware of the new function      USE ""my_wrapper"" TYPE f_of_nd FROM ""/tmp/my_wrap.so"" ALIAS ""special_func""      so we can use it with its original name.    Example 4           An example of using Fortran modules.   Here we will try to achieve the same functionality as in Example 2, but with the help of F77.                DOUBLE PRECISION FUNCTION MYFUNC (N, X)        IMPLICIT NONE        INTEGER N        DOUBLE PRECISION X C        MYFUNC = N * X C        RETURN        END                  As opposite to C, there is no way to call such a function from Grace directly - the problem is that in Fortran all arguments to a function (or subroutine) are passed by reference. So, we need a wrapper:                double myfunc_wrapper(int n, double x)        {            extern double myfunc_(int *, double *);            double retval;            retval = myfunc_(&n, &x);            return (retval);        }                  Note that most of f77 compilers by default add underscore to the function names and convert all names to the lower case, hence I refer to the Fortran function  MYFUNC  from my C wrapper as  myfunc_ , but in your case it can be different!   Let us compile the whole stuff:                $g77 -c -fPIC myfunc.f        $gcc -c -fPIC myfunc_wrap.c        $gcc -shared myfunc.o myfunc_wrap.o -o /tmp/myfunc.so -lf2c -lm        $strip /tmp/myfunc.so                  And finally, inform Grace about this new function:      USE ""myfunc_wrapper"" TYPE f_of_nd FROM ""/tmp/myfunc.so"" ALIAS ""myfunc""       Operating system issues              OS/2              In general the method outlined in the examples above can be used on OS/2, too. However you have to create a DLL (Dynamic Link Library) which is a bit more tricky on OS/2 than on most Un*x systems. Since Grace was ported by using EMX we also use it to create the examples; however other development environments should work as well (ensure to use the _System calling convention!). We refer to Example 2 only. Example 1 might demonstrate that DLLs can have their entry points (i.e. exported functions) callable via ordinals only, so you might not know how to access a specific function without some research. First compile the source from Example 2 to ""my_func.obj""      gcc -Zomf -Zmt -c my_func.c -o my_func.obj      Then you need to create a linker definition file ""my_func.def"" which contains some basic info about the DLL and declares the exported functions.                  LIBRARY my_func INITINSTANCE TERMINSTANCE          CODE LOADONCALL          DATA LOADONCALL MULTIPLE NONSHARED          DESCRIPTION 'This is a test DLL: my_func.dll'          EXPORTS          my_function                    (don't forget about the 8 characters limit on the DLL name!). Finally link the DLL:      gcc my_func.obj my_func.def -o my_func.dll -Zdll -Zno-rte -Zmt -Zomf      (check out the EMX documentation about the compiler/linker flags used here!) To use this new library function within Grace you may either put the DLL in the LIBPATH and use the short form:      USE ""my_function"" TYPE f_of_nd FROM ""my_func"" ALIAS ""myf""      or put it in an arbitrary path which you need to specify explicitly then:      USE ""my_function"" TYPE f_of_nd FROM ""e:/foo/my_func.dll"" ALIAS ""myf""      (as for most system-APIs you may use the Un*x-like forward slashs within the path!)    7.   References           7.1   Typesetting          Grace permits quite complex typesetting on a per string basis. Any string displayed (titles, legends, tick marks,...) may contain special control codes to display subscripts, change fonts within the string etc.         Control code   Description   \f{x}   switch to font named ""x""   \f{n}   switch to font number n   \f{}   return to original font   \R{x}   switch to color named ""x""   \R{n}   switch to color number n   \R{}   return to original color   \#{x}   treat ""x"" (must be of even length) as list of hexadecimal char codes   \t{xx xy yx yy}   apply transformation matrix   \t{}   reset transformation matrix   \z{x}   zoom x times   \z{}   return to original zoom   \r{x}   rotate by x degrees   \l{x}   slant by factor x   \v{x}   shift vertically by x   \v{}   return to unshifted baseline   \V{x}   shift baseline by x   \V{}   reset baseline   \h{x}   horizontal shift by x   \n   new line   \u   begin underline   \U   stop underline   \o   begin overline   \O   stop overline   \Fk   enable kerning   \FK   disable kerning   \Fl   enable ligatures   \FL   disable ligatures   \m{n}   mark current position as n   \M{n}   return to saved position n   \dl   LtoR substring direction   \dr   RtoL substring direction   \dL   LtoR text advancing   \dR   RtoL text advancing   \x   switch to Symbol font (same as \f{Symbol})   \+   increase size (same as \z{1.19} ; 1.19 = sqrt(sqrt(2)))   \-   decrease size (same as \z{0.84} ; 0.84 = 1/sqrt(sqrt(2)))   \s   begin subscripting (same as \v{-0.4}\z{0.71})   \S   begin superscripting (same as \v{0.6}\z{0.71})   \T{xx xy yx yy}   same as \t{}\t{xx xy yx yy}   \Z{x}   absolute zoom x times (same as \z{}\z{x})   \q   make font oblique (same as \l{0.25})   \Q   undo oblique (same as \l{-0.25})   \N   return to normal style (same as \v{}\t{})   \\   print \   \n   switch to font number n (0-9) (deprecated)   \c   begin using upper 128 characters of set (deprecated)   \C   stop using upper 128 characters of set (deprecated)                                     Control codes.              Example:   F\sX\N(\xe\f{}) = sin(\xe\f{})\#{b7}e\S-X\N\#{b7}cos(\xe\f{})    prints roughly                           -x        F (e) = sin(e)·e  ·cos(e)         x                using string's initial font and e prints as epsilon from the Symbol font.   NOTE: Characters from the upper half of the char table can be entered directly from the keyboard, using appropriate  xmodmap(1)  settings, or with the help of the font tool (""Window/Font tool"").       7.2   Device-specific limitations           Grace can output plots using several device backends. The list of available devices can be seen (among other stuff) by specifying the ""-version"" command line switch.     X11, PostScript and EPS are full-featured devices    Raster drivers (PNM/JPEG/PNG):     only even-odd fill rule is supported    patterned lines are not implemented        PDF driver:     patterned fills are not implemented    bitmapped text strings are not transparent        MIF driver: the driver is a brand new one and still in beta test     some of patterned fills not implemented    bitmapped text strings not implemented        SVG driver: the driver is a brand new one and still in beta test     patterned fills not implemented    bitmapped text strings not implemented                7.3   Device-specific settings           Some of the output devices accept several configuration options. You can set the options by passing a respective string to the interpreter using the ""DEVICE  ""devname""  OP  ""options"" "" command (see  Device parameters ). A few options can be passed in one command, separated by commas.          Command   Description   grayscale   set grayscale output   color   set color output   level1   use only PS Level 1 subset of commands   level2   use also PS Level 2 commands if needed   docdata:7bit   the document data is 7bit clean   docdata:8bit   the document data is 8bit clean   docdata:binary   the document data may be binary   xoffset: x    set page offset in X direction  x  pp   yoffset: y    set page offset in Y direction  y  pp   mediafeed:auto   default input tray   mediafeed:match   select input with media matching page dimensions   mediafeed:manual   manual media feed   hwresolution:on   set hardware resolution   hwresolution:off   do not set hardware resolution                   PostScript driver options                    Command   Description   grayscale   set grayscale output   color   set color output   level1   use only PS Level 1 subset of commands   level2   use also PS Level 2 commands if needed   bbox:tight   enable ""tight"" bounding box   bbox:page   bounding box coincides with page dimensions                   EPS driver options                    Command   Description   PDF1.2   set compatibility mode to PDF-1.2   PDF1.3   set compatibility mode to PDF-1.3   compression:value   set compression level (0 - 9)                   PDF driver options                    Command   Description   format:pbm   output in PBM format   format:pgm   output in PGM format   format:ppm   output in PPM format   rawbits:on   ""rawbits"" (binary) output   rawbits:off   ASCII output                   PNM driver options                    Command   Description   grayscale   set grayscale output   color   set color output   optimize:on/off   enable/disable optimization   quality:value   set compression quality (0 - 100)   smoothing:value   set smoothing (0 - 100)   baseline:on/off   do/don't force baseline output   progressive:on/off   do/don't output in progressive format   dct:ifast   use fast integer DCT method   dct:islow   use slow integer DCT method   dct:float   use floating-point DCT method                   JPEG driver options                    Command   Description   interlaced:on   make interlaced image   interlaced:off   don't make interlaced image   transparent:on   produce transparent image   transparent:off   don't produce transparent image   compression:value   set compression level (0 - 9)                   PNG driver options                   7.4   Dates in Grace           We use two calendars in Grace: the one that was established in 532 by Denys and lasted until 1582, and the one that was created by Luigi Lilio (Alyosius Lilius) and Christoph Klau (Christophorus Clavius) for pope Gregorius XIII. Both use the same months (they were introduced under emperor Augustus, a few years after Julian calendar introduction, both Julius and Augustus were honored by a month being named after each one).   The leap years occurred regularly in Denys's calendar: once every four years, there is no year 0 in this calendar (the leap year -1 was just before year 1). This calendar was not compliant with earth motion and the dates were slowly shifting with regard to astronomical events.   This was corrected in 1582 by introducing Gregorian calendar. First a ten days shift was introduced to reset correct dates (Thursday October the 4th was followed by Friday October the 15th). The rules for leap years were also changed: three leap years are removed every four centuries. These years are those that are multiple of 100 but not multiple of 400: 1700, 1800, and 1900 were not leap years, but 1600 and 2000 were (will be) leap years.   We still use Gregorian calendar today, but we now have several time scales for increased accuracy. The International Atomic Time (TAI) is a linear scale: the best scale to use for scientific reference. The Coordinated Universal Time (UTC, often confused with Greenwich Mean Time) is a legal time that is almost synchronized with earth motion. However, since the earth is slightly slowing down, leap seconds are introduced from time to time in UTC (about one second every 18 months). UTC is not a continuous scale ! When a leap second is introduced by International Earth Rotation Service, this is published in advance and the legal time sequence is as follows: 23:59:59 followed one second later by 23:59:60 followed one second later by 00:00:00. At the time of this writing (1999-01-05) the difference between TAI and UTC was 32 seconds, and the last leap second was introduced in 1998-12-31.   These calendars allow to represent any date from the mist of the past to the fog of the future, but they are not convenient for computation. Another time scale is possible: counting only the days from a reference. Such a time scale was introduced by Joseph-Juste Scaliger (Josephus Justus Scaliger) in 1583. He decided to use ""-4713-01-01T12:00:00"" as a reference date because it was at the same time a Monday, first of January of a leap year, there was an exact number of 19 years Meton cycle between this date and year 1 (for Easter computation), and it was at the beginning of a 15 years  Roman indiction  cycle. The day number counted from this reference is traditionally called  Julian day , but it has really nothing to do with the Julian calendar.   Grace stores dates internally as reals numbers counted from a reference date. The default reference date is the one chosen by Scaliger, it is a classical reference for astronomical events. It can modified for a single session using the   Edit->Preferences  popup of the GUI. If you often work with a specific reference date you can set it for every sessions with a REFERENCE DATE command in your configuration file (see   Default template ).   The following date formats are supported (hour, minutes and seconds are always optional):       iso8601  : 1999-12-31T23:59:59.999   european : 31/12/1999 23:59:59.999 or 31/12/99 23:59:59.999   us       : 12/31/1999 23:59:59.999 or 12/31/99 23:59:59.999   Julian   : 123456.789       One should be aware that Grace does not allow to put a space in one data column as spaces are used to separate fields. You should always use another separator (:/.- or better T) between date and time in data files. The GUI, the batch language and the command line flags do not have this limitation, you can use spaces there without any problem. The T separator comes from the ISO8601 standard. Grace support its use also in european and us formats.   You can also provide a hint about the format (""ISO8601"", ""european"", ""us"") using the -datehint command line flag or the ref name=""Edit->Preferences"" id=""preferences""> popup of the GUI. The formats are tried in the following order: first the hint given by the user, then iso, european and us (there is no ambiguity between calendar formats and numerical formats and therefore no order is specified for them). The separators between various fields can be any characters in the set: "" :/.-T"" (one or more spaces act as one separator, other characters can not be repeated, the T separator is allowed only between date and time, mainly for iso8601), so the string ""1999-12 31:23/59"" is allowed (but not recommended).  The '-' character is used both as a separator (it is traditionally used in iso8601 format) and as the unary minus (for dates in the far past or for numerical dates). By default years are left untouched, so 99 is a date far away in the past. This behavior can be changed with the   Edit->preferences  popup, or with the  DATE WRAP on  and  DATE WRAP YEAR year  commands. Suppose for example that the wrap year is chosen as 1950, if the year is between 0 and 99 and is written with two or less digits, it is mapped to the present era as follows:   range [00 ; 49] is mapped to [2000 ; 2049]   range [50 ; 99] is mapped to [1950 ; 1999]   with a wrap year set to 1970, the mapping would have been:   range [00 ; 69] is mapped to [2000 ; 2069]   range [70 ; 99] is mapped to [1970 ; 1999]   this is reasonably Y2K compliant and is consistent with current use.  Specifying year 1 is still possible using more than two digits as follows: ""0001-03-04"" is unambiguously March the 4th, year 1. The inverse transform is applied for dates written by Grace, for example as tick labels. Using two digits only for years is not recommended, we introduce a  wrap year + 100  bug here so this feature should be removed at some point in the future ...   The date scanner can be used either for Denys's and Gregorian calendars. Inexistent dates are detected, they include year 0, dates between 1582-10-05 and 1582-10-14, February 29th of non leap years, months below 1 or above 12, ...  the scanner does not take into account leap seconds: you can think it works only in International Atomic Time (TAI) and not in Coordinated Unified Time (UTC). If you find yourself in a situation were you need UTC, a very precise scale, and should take into account leap seconds ... you should convert your data yourself (for example using International Atomic Time). But if you bother with that you probably already know what to do.     7.5   Xmgr to Grace migration guide           This is a very brief guide describing problems and workarounds for reading in project files saved with Xmgr. You should read the docs or just play with Grace to test new features and controls.        Grace must be explicitly told the version number of the software used to create a file. You can manually put ""@version VERSIONID"" string at the beginning of the file. The VERSIONID is built as MAJOR_REV*10000 + MINOR_REV*100 + PATCHLEVEL; so 40101 corresponds to xmgr-4.1.1. Projects saved with Xmgr-4.1.2 do NOT need the above, since they already have the version string in them. If you have no idea what version of Xmgr your file was created with, try some. In most cases, 40102 would do the trick.      The above relates to the ASCII projects only. The old binary projects (saved with xmgr-4.0.*) are not automatically converted anymore. An input filter must be defined to make the conversion work on-the-fly. Add the following line to  /.gracerc or the system-wide $GRACE_HOME/gracerc resource file: DEFINE IFILTER ""grconvert %s -"" MAGIC ""00000031"" See docs for more info on the I/O filters.      Documentation on the script language is severely lacking still.      Grace is WYSIWYG. Xmgr was not. Many changes required to achieve the WYSIWYG'ness led to the situation when graphs with objects carefully aligned under Xmgr may not look so under Grace. Grace tries its best to compensate for the differences, but sometimes you may have to adjust such graphs manually.      A lot of symbol types (all except *real* symbols) are removed. ""Location *"" types can be replaced (with much higher comfort) by A(nnotating)values. ""Impulse *"", ""Histogram *"" and ""Stair steps *"" effects can be achieved using the connecting line parameters (Type, Drop lines). ""Dot"" symbol is removed as well; use the filled circle symbol of the zero size with no outline to get the same effect.      Default page layout switched from free (allowing to resize canvas with mouse) to fixed. For the old behavior, put ""PAGE LAYOUT FREE"" in the Grace resource file or use the ""-free"" command line switch.  The use of the ""free"" page layout is in general deprecated, though.       System (shell) variables GR_* renamed to GRACE_*      Smith plots don't work now. They'll be put back soon."
GX230-67-13156712	"SAND92-2291 Unlimited Release Printed December 1992 Updated March 17, 1997  Distribution Category UC-705  APREPRO: An Algebraic Preprocessor for Parameterizing Finite Element Analyses Gregory D. Sjaardema Solid and Structural Mechanics Department Sandia National Laboratories Albuquerque, New Mexico 87185  Abstract Aprepro is an algebraic preprocessor that reads a file containing both general text and algebraic, string, or conditional expressions. It interprets the expressions and outputs them to the output file along with the general text. The syntax used in Aprepro is such that all expressions between the delimiters { and } are evaluated and all other text is simply echoed to the output file. Aprepro contains several mathematical functions, string functions, and flow control constructs. In addition, functions are included that, with some additional files, implement a units conversion system and a material database lookup system. Aprepro was written primarily to simplify the preparation of parameterized input files for finite element analyses at Sandia National Laboratories; however, it can process any text file that does not use the characters { }.   Intentionally Left Blank  4   Contents 1 Introduction ........................................................................................................ 2 Syntax .................................................................................................................. 3 Operators ............................................................................................................ 3.1 Arithmetic Operators .................................................................................... 3.2 Assignment Operators ................................................................................... 3.3 Relational Operators ..................................................................................... 3.4 Boolean Operators ........................................................................................ 3.5 String Operators ............................................................................................ 4 Predefined Variables .......................................................................................... 5 Functions ............................................................................................................. 5.1 Mathematical Functions ................................................................................ 5.2 String Functions ............................................................................................ 5.3 Additional Functions ..................................................................................... 6 Units Conversion System ................................................................................... 6.1 Introduction ................................................................................................... 6.2 Units Conversion Implementation ................................................................ 6.3 Usage ............................................................................................................. 6.4 Additional Comments ................................................................................... 7 Material Database Access System .................................................................... 7.1 Overview of the MATS System .................................................................... 7.2 Implementation of the Material Database Access Routines ......................... 7.3 Code Template Files: .................................................................................... 7.4 Material Files: ............................................................................................... 7.5 Additional Comments ................................................................................... 8 Error, Warning, and Informational Messages ................................................ 9 Examples ............................................................................................................. 9.1 Mesh Generation Input File .......................................................................... 9.2 Macro Examples ........................................................................................... 9.3 Command Line Variable Assignment ........................................................... 9.4 Loop Example ............................................................................................... 9.5 Units and Material Database Access Example ............................................. 10 References ........................................................................................................... A Execution ............................................................................................................. B Unit System Defined Variables ......................................................................... 7 9 13 13 14 14 14 15 17 19 19 21 22 25 25 26 28 30 33 33 35 35 37 38 41 43 43 44 44 45 45 49 51 53  5   Tables Table Table Table Table Table Table Table Table Table Table 1. 2. 3. 4. 5. 6. 7. 8: 9: 10: Arithmetic Operators ...........................................................................13 Assignment Operators..........................................................................14 Relational Operators ............................................................................14 Logical Operators.................................................................................15 Predefined Variables ............................................................................17 Effect of various output format specifications .....................................17 Mathematical Functions .......................................................................19 Units Systems and Corresponding Output Format--Metric .................25 Units Systems and Corresponding Output Format--English ...............26 Defined Units Variables.......................................................................53  Figures Figure 1. Schematic of Proposed MATS Database System ................................34  6   1 Introduction Aprepro is an algebraic preprocessor that reads a file containing both general text and algebraic expressions. It echoes the general text to the output file, along with the results of the algebraic expressions. The syntax used in Aprepro is such that all expressions between the delimiters { and } are evaluated and all other text is simply echoed to the output file. For example, if the following lines are input to Aprepro $ Rad = {Rad = 12.0} Point 1 {x1 = Rad * sind(30.)} Point 2 {x1 + 10.0} {y1} {y1 = Rad * cosd(30.)}  The output would look like: $ Rad = 12 Point 1 Point 2 6 16 10.39230485 10.39230485  In this example, the algebraic expressions are specified by surrounding them with { and }, and the functions sind() and cosd() calculate the sine and cosine of an angle given in degrees. Aprepro has been used extensively in the past two years to prepare parameterized files for finite element analyses using the Sandia National Laboratories SEACAS system1. The recent addition of the units conversion capability and the material database access routines have greatly increased the usability of Aprepro. Aprepro can also be used for non-finite element applications such as a powerful calculator and a general text processor for any file that does not use the delimiters { and }. Aprepro is written in the C language. The BISON2 and FLEX3 programs are used to generate the parsing and lexical analysis subroutines, respectively. The initial implementation of Aprepro was based on the mfcalc example in the BISON manual. Aprepro has been ported to several UNIX systems including Hewlett Packard HP-UX, Cray Research Unicos, Sun Microsystems SunOS, Tenon MachTen, Digital Equipment Ultrix; and to non-UNIX systems including VAX VMS, Macintosh, and Amiga. The         remainder of this document is organized as follows: Section 2 documents the syntax recognized by Aprepro, Sections 3, 4, and 5 describe the operators, predefined variables, and functions, Section 6 describes the units conversion system, Section 7 describes the material database support routines, Section 8 describes the error messages output from Aprepro, and Section 9 presents some examples of Aprepro usage. Appendix A documents the command line options for Aprepro, and Appendix B lists the defined units abbreviations.  7   Intentionally Left Blank  8   2 Syntax Aprepro is in one of two states while it is processing an input file, either echoing or parsing. In the echoing state, Aprepro echoes every character that it reads to the output file. If it reads the character {, it enters the parsing state. In the parsing state, Aprepro reads characters from the input file and identifies the characters as tokens which can be function names, variables, numbers, operators, or delimiters. When Aprepro encounters the character }, it tries to interpret the tokens as an algebraic, string, or conditional expression; if it is successful, it prints the value to the output file; if it cannot evaluate the expression, it prints the message: Aprepro: ERR: parse error (filename, line line#)  to the terminal* and prints the value 0 to the output file. The rules that Aprepro uses when identifying functions, variables, numbers, operators, delimiters, and expressions are described below:  Functions: Function names are sequences of letters and digits and underscores (_) that begin with a letter. The function's arguments are enclosed in parentheses. For example, in the line atan2(a,1.0), atan2 is the function name, and a and 1.0 are the arguments. See section 5 on page 19 for a list of the available functions and their arguments.  Variables: A variable is a name that references a numeric or string value. A variable is defined by giving it a name and assigning it a value. For example, the expression a = 1.0 defines the variable a with the numeric value 1.0; the expression b= ""A string"" defines the variable b with the value ""A string"". Variable names are sequences of letters, digits, and underscores (_) that begin with either a letter or an underscore. Variable names cannot match any function name and they are case-sensitive, that is, abc_de and AbC_dE are two distinct variable names. A few variables are predefined, these are listed in section 4 on page 17. Any variable that is not defined is equal to 0. A warning message is output to the terminal if an undefined variable is used, or if a previously defined variable is redefined.  Numbers: Numbers can be integers like 1234, decimal numbers like 1.234, or in scientific notation like 1.234E-26. All numbers are stored internally as floating point numbers.  Strings: Strings are sequences of numbers, characters, and symbols that are delimited by either single quotes ('this is a string') or double quotes (""this is another string""). Strings that are delimited by one type of quote can include * Error messages are printed to standard error. On UNIX systems they can be redirected to a file using your shells redirection syntax. See the man page for your shell for more information.  If the variable name begins with an underscore, no warning is output when the variable is redefined. Warnings can be turned off with the -W or +warning option.  9   the other type of quote. For example, {'This is a valid ""string""'}. Strings delimited by single quotes can span multiple lines; strings delimited by double quotes must terminate on a single line or a parsing error message will be issued.  Operators: Operators are any of the symbols defined in section 3 on page 13. Examples are + (addition), - (subtraction), * (multiplication), / (division), = (assignment), and ^ (exponentiation)  Delimiters: The delimiters recognized by Aprepro are: the comma (,) which separates arguments in function lists, the left curly brace ({) which begins an expression, the right curly brace (}) which ends an expression, the left parenthesis ( which begins a function argument list, the right parenthesis ) which ends a function argument list, the single quote (') which delimits a multi-line string, and the double quote ("") which delimits a single-line string.  Expressions: An expression consists of any combination of numeric and string constants, variables, operators, and functions. Four types of expressions are recognized in Aprepro: algebraic, string, relational, and conditional.  Algebraic Expressions: Almost any valid FORTRAN or C algebraic expression can be recognized and evaluated by Aprepro. An expression of the form a=b+10/ 37.5 will evaluate the expression on the right-hand-side of the equals sign, print the value to the output file, and assign the value to the variable a. An expression of the form b+10/37.5 will evaluate the expression and print the value to the output file. If you want to assign a value to a variable without printing the result, the expression must be inside an ECHO(ON|OFF) block (see page 23). Variables can also be set on the command line prior to reading any input files using the 'var=val' syntax. An example of this usage is given in section 9.2 on page 44. Only a single expression is allowed within the { } delimiters. For example, {x = sqrt(y^2 + sin(z))}, {x=y=z}, and {x=y} {a=z} are valid expressions, but {x=y a=z} is invalid because it contains two expressions within a single set of delimiters.  String Expressions: Aprepro has very limited string support. The only supported operations are assigning a variable equal to a string (a = ""This is a string"") or a function that returns a string, and concatenating two strings into another string (a = ""Hello"" // "" "" // ""World"").  Relational Expressions: Relational expressions are expressions that return the result of comparing two expressions. A relational expression is either true or false. Relational expressions can only be used on the left-hand side of a conditional expression. A relational expression is simply two expressions of any kind separated by a relational operator (See ""Relational Operators"" on page 14.)  Conditional Expressions: Aprepro recognizes a conditional expression of the form: relational_expression ? true_exp : false_exp  where relational_expression can be any valid relational expression, and true_exp  10   and false_exp are two algebraic expressions. If the relational expression is true, then the result of true_exp is returned, otherwise the result of false_exp is returned. For example, if the following command were entered: a = (sind(20.0) > cosd(20.0) ? 1 : -1)  then, a would be assigned the value -1 since the relational expression to the left of the question mark is false. Both true_exp and false_exp are always evaluated prior to evaluating the relational expression. Therefore, you should not write an equation such as sind(20.0*a)>cosd(20.0*a) ? a=sind(20.0) : a=cosd(20.0)  since the value of a can change during the evaluation of the expression. Instead, this equation should be written as: a = (sind(20.0*a)>cosd(20.0*a) ? sind(20.0) : cosd(20.0))  11   12   3 Operators The operators recognized by Aprepro are listed below. The letters a and b can represent variables, numbers, functions, or expressions unless otherwise noted. The tables below also list the precedence and associativity of the operators. Precedence defines the order in which operations should be performed. For example, in the expression: 3*4+6/2  the multiplications and divisions are performed first, followed by the addition because multiplication and division have higher precedence than addition. The precedence is listed from 1 to 14 with 1 being the lowest precedence and 14 being the highest. Associativity defines which side of the expressions should be simplified first. For example the expression: 3 + 4 + 5 would be evaluated as (3 + 4) + 5 for left associativity, the expression a = b / c would be evaluated as a = (b / c) for right associativity.  3.1 Arithmetic Operators Arithmetic operators combine two or more algebraic expressions into a single algebraic expression. These have obvious meanings except for the pre- and post- increment and Table 1. Syntax a+b a-b a*b, a~b a/b a^b, a**b a%b ++a, a++ --a, a--  Arithmetic Operators Description Addition Subtraction Multiplication Division Exponentiation. Modulus, (remainder) Pre- and Post-increment a Pre- and Post-decrement a. Precedence 9 9 10 10 12 10 13 13 Associativity left left left left right left left left  decrement operators. The pre-increment and pre-decrement operators first increment or decrement the value of the variable and then return the value. For example, if a = 1, then b=++a will set both b and a equal to 2. The post-increment and post-decrement operators first return the value of the variable and then increment or decrement the variable. For example, if a = 1, then b=a++ will set b equal to 1 and a equal to 2. The modulus operator % calculates the integer remainder. That is both expressions are truncated an integer value and then the remainder calculated. See the fmod function in section 5.1 on page 19 for the  13   calculation of the floating point remainder. The tilde character ~ is used as a synonym for multiplication to improve the aesthetics of the unit conversion system (see section 6 on page 25). It is more natural for some users to type 12~metre than 12*metre.  3.2 Assignment Operators Assignment operators combine a variable and an algebraic expression into a single algebraic expression, and also set the variable equal to the algebraic expression. Only variables can be specified on the left-hand-side of the equal sign. Table 2. Syntax a=b a+=b a-=b a*=b a/=b a^=b a**=b  Assignment Operators Description The value of 'a' is set equal to 'b' The value of `a` is set equal to a + b The value of `a` is set equal to a - b The value of `a` is set equal to a * b The value of `a` is set equal to a / b The value of `a` is set equal to a b  Precedence 1 2 2 3 3 4 4  Associativity right right right right right right right  The value of `a` is set equal to a b  3.3 Relational Operators Relational operators combine two algebraic expressions into a single relational expression. Relational expressions and operators can only be used before the question mark (?) in a conditional expression. Table 3. Syntax a b a <= b a >= b a == b a != b  Relational Operators Description true if `a` is less than `b` true if `a` is greater than `b` true if `a` is less than or equal to `b` true if `a` is greater than or equal to `b` true if `a` is equal to `b` true if `a` is not equal to `b` Precedence 8 8 8 8 8 8 Associativity left left left left left left  3.4 Boolean Operators Boolean operators combine one or more relational expressions into a single relational expression. If la and lb are two relational expressions, then:  14   Table 4. Syntax la || lb la && lb !la  Logical Operators Description true if either `la` or `lb` are true. true if both `la` and `lb` are true. true if `la` is false. Precedence 6 7 11 Associativity left left left  3.5 String Operators The only supported string operator at this time is string concatenation which is denoted by //. If a = ""Hello"" and b = ""World"", then: c = a // "" "" // b  sets c equal to ""Hello World"". Concatenation has precedence 14 and left associativity.  15   16   4 Predefined Variables A few commonly used variables are predefined in Aprepro. These are listed below. The default output format is specified as a C language format string, see your C language documentation for more information. The default format and comment variables are defined with a leading underscore in their name so they can be redefined without generating an error message. Table 5. Name PI PI_2 SQRT2 DEG RAD E GAMMA PHI VERSION _FORMAT _C_ 1  Predefined Variables Value 3.14159265358979323846 1.57079632679489661923 1.41421356237309504880 57.2957795130823208768 0.01745329251994329576 2.71828182845904523536 0.57721566490153286060 1.61803398874989484820 Varies, string value ""%.10g"" ""$"" Description  /2 2 180 /  degrees per radian  / 180 radians per degree base of natural logarithm euler-mascheroni constant1 golden ratio ( 5 + 1 ) / 2 current version of Aprepro default output format default comment character  1 1 The euler-mascheroni constant is defined as the limit of 1 + -- + ... + --  log s as s s 2 approaches infinity.  Note that the output format is used to output both integers and floating point numbers. Therefore, it should use the %g format descriptor which will use either the decimal (%d), exponential (%e), or float (%f) format, whichever is shorter, with insignificant zeros suppressed. The table below illustrates the effect of different format specifications on the output of the variable PI and the value 1.0 . See the documentation of your C compiler for more information. For most cases, the default value is sufficient. Table 6. Format %.10g %.10e %.10f  Effect of various output format specifications PI Output 3.141592654 3.1415926536e+00 3.1415926536 1.0 Output 1 1.0000000000e+00 1.0000000000  17   Table 6. Format %.10d  Effect of various output format specifications PI Output 1413754136 1.0 Output 0000000000  The comment character should be set to the character that the program which will read the processed file uses as a comment character. The default value of ""$"" is the comment character used by the SEACAS codes at Sandia National Laboratories. The -c command line option* automatically changes the value of the comment variable to match the character specified on the command line.  * See appendix A on page 51.  18   5 Functions Several mathematical and string functions are implemented in Aprepro. To cause a function to be used, you enter the name of the function followed by a list of zero or more arguments in parentheses. For example sqrt(min(a,b*3))  uses the two functions sqrt() and min(). The arguments a and b*3 are passed to min(). The result is then passed as an argument to sqrt(). The functions in Aprepro are listed below along with the number of arguments and a short description of their effect.  5.1 Mathematical Functions The following mathematical functions are available in Aprepro. Table 7. Syntax abs(x) acos(x) acosd(x) acosh(x) asin(x) asind(x) asinh(x) atan(x) atan2(y,x) atan2d(x) atand(y,x) atanh(x) ceil(x) cos(x) cosd(x) cosh(x) d2r(x) dim(x,y) dist(x1,y1, x2,y2)  Mathematical Functions Description Calculates the absolute value of x. x Calculates the inverse cosine of x, returns radians Calculates the inverse cosine of x, returns degrees Calculates the inverse hyperbolic cosine of x Calculates the inverse sine of x, returns radians Calculates the inverse sine of x, returns degrees Calculates the inverse hyperbolic sine of x Calculates the inverse tangent of x, returns radians Calculates the inverse tangent of y/x, returns radians Calculates the inverse tangent of x, returns degrees Calculates the inverse tangent of y/x, returns degrees Calculates the inverse hyperbolic tangent of x Calculates the smallest integer not less than x Calculate the cosine of x, with x in radians Calculate the cosine of x, with x in degrees Calculates the hyperbolic cosine of x Converts degrees to radians. Calculates x - min(x,y). Calculates ( ( x1  x2 ) + ( y1  y2 ) ) 2 2  19   Table 7. Syntax exp(x) floor(x)  Mathematical Functions Description Calculates e (Exponential) Calculates the largest integer not greater than x. Calculates the floating-point remainder of x/y. Calculates x 2 + y 2 Calculates the integer part of x truncated toward 0. Calculates log (  ( x ) ) Calculates the natural (base e) logarithm of x. Calculates log(1+x) Calculates the base 10 logarithm of x. Calculates the maximum of x and y. Calculates the minimum of x and y. Calculates r  cos ( a ) , a is in degrees Calculates r  sin ( a ) , a is in degrees Converts radians to degrees. Calculates a random number between xl and xh. Calculates x  sgn ( y ) Calculates the sine of x, with x in radians. Calculates the sine of x, with x in degrees. Calculates the hyperbolic sine of x Calculates the square root of x. Calculates the tangent of x, with x in radians. Calculates the tangent of x, with x in radians. Calculates the hyperbolic tangent of x. Calculates the julian day corresponding to mm/dd/yy. Calculates the julian day corresponding to mm/dd/yy at hh:mm:ss i j Calculates the angle between the vector x 1 ^ + y 1 ^ and x 2 ^ + y 2 ^ . returns radians. i j i j Calculates the angle between the vector x 1 ^ + y 1 ^ and x 2 ^ + y 2 ^ . returns degrees. i j x  fmod(x,y) hypot(x,y) int(x), [x] lgamma(x) ln(x), log(x) logp1(x) log10(x) max(x,y) min(x,y) polarX(r,a) polarY(r,a) r2d(x) rand(xl,xh) sign(x,y) sin(x) sind(x) sinh(x) sqrt(x) tan(x) tand(x) tanh(x) julday(mm, dd, yy) juldayhms(mm, dd, yy, hh, mm, ss) Vangle(x1,y1, Vangled(x1,y1, x2,y2) x2,y2)  20   5.2 String Functions A few useful string functions are available: tolower(svar) toupper(svar) tostring(x) execute(svar) Translates all uppercase characters in svar to lowercase. It modifies svar and returns the resulting string. Translates all lowercase character in svar to uppercase. It modifies svar and returns the resulting string. Returns a string representation of the numerical varaible x. The variable x is unchanged. svar is parsed and executed as if it were a line read from the input file. For example, if svar = ""b=sqrt(25.0)"", then {execute(svar)} returns the value 5 and sets b = 5. The expression svar is enclosed in delimiters prior to being executed and it must be a valid expression or an error message will be printed. Similar to execute(svar), except that svar is not enclosed in delimiters prior to being executed. For example, if svar = ""Point {1+5} {sqrt(5)} {sqrt(6)}"", then {rescan(svar)} would print: Point 6 2.236067977 2.449489743. The difference between execute(sv1) and rescan(sv2) is that sv1 must be a valid expression, but sv2 can contain zero or more expressions. Returns a string containing the value of the environment variable svar. If the environment variable is not defined, an empty string is returned. Returns a string containing the nth word of svar. The words are separated by one or more of the characters in the string variable del Returns the number of words in svar. Words are separated by one or more of the characters in the string variable del Returns a double-precision floating-point number equal to the value represented by the character string pointed to by svar. Outputs the string svar to stderr and then terminates the code with an error exit status.  rescan(svar)  getenv(svar) get_word(n,svar,del) word_count(svar,del) strtod(svar) error(svar)  The following example shows the use of some of the string functions. The lines beginning with the string ""Output>"" show the output from Aprepro resulting from entering the previous line. {t1 = ""ATAN2""} {t2 = ""(0, -1)""} Output> ATAN2 (0, -1) {t3 = tolower(t1//t2)} Output> atan2(0, -1) ...The variable t3 is equal to the string atan2(0, -1) {execute(t3)} Output> 3.141592654 ...The result is the same as executing {atan2(0, -1)}  21   This is admittedly a very contrived example; however, it does illustrate the workings of several of the functions. In the first example, an expression is constructed by concatenating two strings together and converting the resulting string to lowercase. This string is then executed and simply prints the result of evaluating the expression. The following example uses the rescan function to illustrate a basic macro capability in Aprepro. The example calculates the coordinates of eleven points (Point1 ... Point11) equally spaced about the circumference of a 180 degree arc of radius 10. {ECHO(OFF)}{num = 0} {rad = 10} {nintv = 10} {nloop = nintv + 1} {line = 'Define {""Point""//tostring(++num)}, {polarX(rad, (num1) * 180/nintv)} {polarY(rad, (num-1)*180/nintv)}'} {ECHO(ON)} {loop(nloop)} {rescan(line)} {endloop}  Output: Define Define Define Define Define Define Define Define Define Define Define Point1, Point2, Point3, Point4, Point5, Point6, Point7, Point8, Point9, Point10, Point11, 10 0 9.510565163 3.090169944 8.090169944 5.877852523 5.877852523 8.090169944 3.090169944 9.510565163 6.123233765e-16 10 -3.090169944 9.510565163 -5.877852523 8.090169944 -8.090169944 5.877852523 -9.510565163 3.090169944 -10 1.224646753e-15  Note the use of the ECHO(OFF|ON) block* to suppress output during the initialization phase, and the loop construct to automatically repeat the rescan line. The variable num is converted to a string after it is incremented and then concatenated to build the name of the point. In the definition of the variable line, single quotes are first used since this is a multi-line string; double quotes are then used to embed another string within the first string. To modify this example to calculate the coordinates of 101 points rather than eleven, the only change necessary would be to set {nintv=100}.  5.3 Additional Functions  File Inclusion: Aprepro can read input from multiple files using the include() and cinclude() functions. If a line of the form: {include(""filename"")} {include(string_variable)}  is read, Aprepro will open and begin reading from the file filename. A string variable can be used as the argument instead of a literal string value. When the end * Described in section 5.3 on page 22  Described in section 5.3 on page 22  22   of the file is reached, it will be closed and Aprepro will continue reading from the previous file. The difference between include and cinclude is that if filename does not exist, include will terminate Aprepro with a fatal error, but cinclude will just write a warning message and continue with the current file. The cinclude function can be thought of as a conditional include, that is, include the file if it exists. Multiple include files are allowed and an included file can also include additional files. Approximately 16 levels of file inclusion can be used. This option can be used to set variables globally in several files. For example, if two or more input files share common points or dimensions, those dimensions can be set in one file that is included in the other files. If ECHO(OFF) is in effect during in an included file, ECHO(ON) will automatically be executed at the end of the file.  Conditionals: Portions of an input file can be conditionally processed through the use of the {Ifdef(variable)} or {Ifndef(variable)} constructs. The syntax is: {Ifdef(variable)} ...Lines processed if 'variable' {Else} ...Lines processed if 'variable' {Endif} {Ifndef(variable)} ...Lines processed if 'variable' {Else} ...Lines processed if 'variable' {Endif} is not equal to 0 is equal to 0 or undefined  is equal to 0 or undefined is not equal to 0  The {Else} is optional. Note that if variable is undefined, its value is equal to zero. Ifdef constructs can be nested up to approximately 16 levels. A warning message will be printed if improper nesting is detected. {Ifdef(variable)}, {Ifndef(variable)}, {Else}, and {Endif} are the only text parsed on a line. Text following these on the same line is ignored.  Loops: Repeated processing of a group of lines can be controlled with the {loop(control)}, {endloop} commands. The syntax is: {loop(variable)} ...Process these lines 'variable' times {endloop}  Loops can be nested. A numerical variable or constant must be specified as the loop control specifier. You cannot use an algebraic expression such as {loop(3+5)}.  ECHO: The printing of lines to the output file can be controlled through the use of the {ECHO(OFF)} and {ECHO(ON)} commands. The syntax is: {ECHO(OFF)}  23   ...These lines will be processed, but not printed to output {ECHO(ON)} ...These lines will be both processed and printed to output. ECHO will automatically be turned on at the end of an included file. The commands ECHO and NOECHO are synonyms for ECHO(ON) and ECHO(OFF).   VERBATIM: The printing of all lines to the output file without processing can be controlled through the use of the {VERBATIM(ON)} {VERBATIM(OFF)} command. The syntax is: {VERBATIM(ON)} ...These lines will be printed to output, but not processed {VERBATIM(OFF)} ...These lines will be printed to output and processed  NOTE: there is a major difference between the ECHO/NOECHO commands, the Ifdef/Endif commands, and the VERBATIM(ON|OFF) commands: ECHO(ON|OFF) Ifdef/Endif VERBATIM(ON|OFF) Lines processed, but not printed if ECHO(OFF) Lines not processed or printed if in Ifndef block Lines not processed, but are printed   Output File Specification: The output function can be used to change the file to which Aprepro is outputting the processed data. The syntax is: output(""filename""), where filename is the name of the new output file. A string variable can be used as the function argument.The previous output file is closed. An error message is written and the code terminates if the file cannot be opened.  24   6 Units Conversion System Although great effort has been expended to ensure that the units conversion system is accurate and consistent, the author does not make any warranty expressed or implied, or assume any liability or responsibility for the use of this software. If any errors are discovered in this software, please contact the author.  6.1 Introduction The units conversion system in Aprepro is implemented as a set of files that define several variables that are abbreviations for unit quantities. For example, if the output format for the current unit system was inches, the variable foot would have the value 12. Therefore, an expression such as 8*foot would be equal to 96 which is the number of inches in 8 feet*. Files have been defined for seven consistent units systems including four metric based systems: si, cgs, cgs-ev, and shock; and three english-based systems: in-lbf-s, ft-lbf-s, and ft-lbm-s. The output units for these unit systems are shown in Table 8 (metric) and Table 9 (english). A list of the defined units abbreviations is given in Table 10. In addition to the definition of the conversion factors, several string variables are also defined which describe the output format of the current units system. For example, the string variable dout defines the output format for density units. For the in-lbf-sec units system, dout = ""lbf-sec^2/in^4"" which is the output format for densities in this system. The string variables can be used to document the Aprepro output. The string variable names are listed in the last column of Table 8 and Table 9. Table 8: Units Systems and Corresponding Output Format--Metric Quantity Length Mass Time Temp. Velocity Accel. Force Volume Density si metre kilogram second kelvin metre/sec metre/sec^2 newton metre^3 kg/m^3 cgs centimetre gram second kelvin cm/sec cm/sec^2 dyne cm^3 g/cc cgs-ev centimetre gram second eV cm/sec cm/sec^2 dyne cm^3 g/cc shock centimetre gram micro-sec kelvin cm/usec cm/usec^2 g-cm/usec^2 cm^3 g/cc string lout mout tout Tout vout aout fout Vout dout  * This can also be written as 8~foot since the symbol ~ has been defined to be the multiplication operator.  25   Table 8: Units Systems and Corresponding Output Format--Metric Quantity Energy Power Pressure joule watt pascal si erg erg/sec dyne/cm^2 cgs cgs-ev erg erg/sec dyne/cm^2 shock g-cm^2/usec^3 g-cm^2/usec^4 Mbar string eout Pout pout  Table 9: Units Systems and Corresponding Output Format--English Quantity Length Mass Time Temp. Velocity Accel. Force Volume Density Energy Power Pressure in-lbf-s inch lbf-sec^2/in second rankine inch/sec inch/sec^2 pound-force inch^3 lbf-sec^2/in^4 inch-lbf inch-lbf/sec lbf/in^2 ft-lbf-s foot slug second rankine foot/sec foot/sec^2 pound-force foot^3 slug/ft^3 foot-lbf foot-lbf/sec lbf/ft^2 ft-lbm-s foot pound-mass second rankine foot/sec foot/sec^2 poundal foot^3 lbm/ft^3 ft-poundal ft-poundal/sec poundal/ft^2 string lout mout tout Tout vout aout fout Vout dout eout Pout pout  The units definitions are accessed through the Units function in Aprepro: {Units(""unit_system"")}  where unit_system is one of the strings listed in the first row of the previous two tables. This will search the standard locations on your system for the correct files to include.  6.2 Units Conversion Implementation The units conversion system in Aprepro is implemented simply as a set of files that are selectively included by a function call in Aprepro. There are two types of files used. The first file type is a header file which defines the base units (metre, second, kg, radian, and kelvin) in terms of the desired output formats, and the output format string variables (lout, mout, ...). There is a different header file for each unit system. The in-lbf-s header file is shown below as an example: {_C_} This is the in-lbf-s units file: inch, sec, lbf  26   {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_}  Outputs: Time: Length: Accel: Mass: Force: Velocity: Volume: Density: Energy: Power: Pressure: Temp: Angular: 1 1 1 1 1 meter second kg kelvin radian = = = = =  {tout {lout {aout {mout {fout {vout {Vout {dout {eout {Pout {pout {Tout {Aout {m = {sec {kg = {degK {rad  = = = = = = = = = = = = =  ""second""} ""inch""} ""in/sec^2""} ""lbf-sec^2/in""} ""lbf""} ""in/sec""} ""in^3""} ""lbf-sec^2/in^4""} ""inch-lbf""} ""inch-lbf / sec""} ""psi""} ""degR""} ""radian""}  1 / 2.54e-2} {lout} = 1} {tout} 1/4.5359237e-1/(9.806650*m/sec^2)} {mout} = 1.8} {Tout} = 1} {Aout}  Note that this file defines the output units string variables at the top of the file and then defines the base units in terms of the output units at the bottom of the file. This is the only file that must be created to implement a new units system. The name of the header file matches the name of the units system and it must be all lowercase. The second file is called the conversion file. different units in terms of the base units. This new unit abbreviation to the system unless a the files must be modified. A short excerpt of {_C_}{_C_}{_C_} {_C_} 1 Meter= {_C_} 1 cm = {_C_} 1 mm = {_C_} 1 um = {_C_} 1 km = {_C_} 1 foot = {_C_} 1 mile = {_C_} 1 yard = {_C_} 1 inch = {_C_} 1 mil =  This file contains the equations defining the is the only file that must be changed to add a new base unit is added, in which case all of this file is shown below:  Length (L) {meter = metre = m} {lout} {cm = centimeter = centimetre {mm = millimeter = millimetre {um = micrometer = micrometre {km = kilometer = kilometre = {ft = foot = .3048 * m} {lout} {mi = mile = ft * 5280} {lout} {yd = yard = ft * 3} {lout} {in = inch = ft / 12} {lout} {mil = inch / 1000} {lout}  = m / 100} = m / 1000} = m / 1e6} 1000 * m}  {lout} {lout} {lout} {lout}  This segment is the portion of the conversion file which defines the length conversions. The expression {_C_} at the beginning of each line of the header and conversion files is a string variable that is given the current value of the comment character. In this way, the files can be written in a generic format that can be used as input for several codes. Each expression in the file defines a unit abbreviation in terms of a previously defined unit. For example, the third line of the file defines the abbreviations cm, centimeter, and centimetre in terms of the metre which is a base unit. The eighth line of the file defines the abbreviations mile and mi in terms of the foot which is earlier defined in terms of the meter. For ease of  27   verification of the units files, they are written in such a way that the output is somewhat self-explanatory, for example, if the SI system is being used, the above lines would result in the following output: $$$ $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 Length (L) Meter cm mm um km foot mile yard inch mil = = = = = = = = = = 1 meter 0.01 meter 0.001 meter 1e-06 meter 1000 meter 0.3048 meter 1609.344 meter 0.9144 meter 0.0254 meter 2.54e-05 meter  which is more understandable than if a bunch of numbers were output. The conversion expressions in this file were obtained from References 6, 7, 8, and 9. When Aprepro processes the function call {Units(""unit_system"")}, it first searches for the requested header file (which has the same name as the unit system) in the directories defined by the environment variable MATSPATH or the default location if MATSPATH is not defined. The first matching file is used. It then searches for the conversion file in the same directories. Units files other than those currently supported can be used by modifying the environment variable MATSPATH. For example the following C-shell command will cause Aprepro to first search the current directory, then your mats subdirectory, and finally the default units directory for the specified units system files: setenv MATSPATH "".:~/:/usr/local/eng_sci/mats""  The units files must be in a directory called units under the directories specified in the MATSPATH environment variable*. Therefore, it is possible to have a personal copy of a header file to define a new unit system and still use the global conversion file. The units conversion files are in the SEACAS1 code management system which is maintained by CVS10. CVS maintains a complete change log and the history of previous changes so that traceability is maintained.  6.3 Usage The following example illustrates the basic usage of the units conversion utility in Aprepro. $ Aprepro Units Utility Example $ {ECHO(OFF)} ...Turn off echoing of the conversion factors $ {Units(""shock"")} ...Select the shock units system $ NOTE: Dimensions - {lout}, {mout}, {dout}, {pout}  * This is done so that the entire system (units conversion and material database access routines) can use a single environment variable.  28   ...This will document what quantities are used in the file after it is run through Aprepro $ {len1 = 10.0 * inch} ...Define a length in an english unit (inches) $ {len2 = 12.0~inch} ... ~ is synonym for * (multiplication) Material 1, Elastic Youngs Modulus = Yield Stress = ...Define the density and End Point 100 {0.0} Point 110 {len1} Point 120 {len1} Point 130 {0.0} Plastic, {1890~kgpm3} $ {dout} {28.3e6~psi} {30~ksi} material parameters in whatever units they are available {0.0} {0.0} {len2} {len1}  The output from this example input file is: $ Aprepro ($Revision: 1.36 $) Fri Oct 23 13:32:42 1992 ...QA header written by Aprepro $ Aprepro Units Utility Example $ NOTE: Dimensions - cm, gram, g/cc, Mbar ...The documentation of what quantities this file uses $ 25.4 $ 30.48 Material 1, Elastic Plastic, 1.89 $ g/cc Youngs Modulus = 1.951216314 Yield Stress = 0.002068427188 ...All material parameters are now in consistent units End Point 100 0 0 Point 110 25.4 0 Point 120 25.4 30.48 Point 130 0 25.4 ...Lengths have all been converted to centimetres  The same input file can be used to output in SI units simply by changing Units command from shock to si. The output in SI units is: $ Aprepro ($Revision: 1.36 $) Fri Oct 23 13:33:22 1992 $ Aprepro Units Utility Example $ NOTE: Dimensions - meter, kilogram, kg/m^3, Pa ...Quantities are now output in standard SI units $ $ 0.254 $ 0.3048 Material 1, Elastic Youngs Modulus = Yield Stress = End Point 100 0 0 Point 110 0.254 Plastic, 1890 $ kg/m^3 1.951216314e+11 206842718.8  0  29   Point 120 0.254 0.3048 Point 130 0 0.254 ...Lengths have all been converted to metres  6.4 Additional Comments A few additional comments and warnings on the use of the units system are detailed below.  Omitting the {ECHO(OFF)} line prior to the {Units(""unit_system"")} function will print out the contents of the units header and conversion files. Each line in the output will be preceded by the current comment character which is $ by default. A few lines from the in-lbf-s units file are shown below: $ Aprepro ($Revision: 1.36 $) Fri Oct 23 13:35:02 1992 $ This is the in-lbf-s units file: inch, sec, lbf $ Outputs: $ Time: second $ Length: inch $ Accel: in/sec^2 $ Mass: lbf-sec^2/in $ Force: lbf $ Velocity: in/sec $ Volume: in^3 $ Density: lbf-sec^2/in^4 $ Energy: inch-lbf $ Power: inch-lbf / sec $ Pressure: psi $ Temp: degR $ Angular: radian $ $ 1 meter = 39.37007874 inch $ 1 second = 1 second $ 1 kg = 0.005710147155 lbf-sec^2/in $ 1 kelvin = 1.8 degR $ 1 radian = 1 radian ..... $$$ Acceleration (L/T^2) $ Grav. Accel. = 386.0885827 in/sec^2 $ $$$ Force (ML/T^2) $ 1 Newton = 0.2248089431 lbf $ 1 dyne = 2.248089431e-06 lbf $ 1 lbf = 1 lbf $ 1 kip = 1000 lbf ......  The comment character can be changed by invoking Aprepro with the -c option. For example aprepro -c# input_file output_file will change the comment character at the beginning of the lines to #. (See Appendix A on page 51 for a de-  scription of the command options.)  The temperature conversions are only valid for relative temperatures, for example, 100~degC is equal to 180~degF, not 212~degF.  30    Since several variables are defined in the units system, it is possible to redefine one of the variable names in your input file. If the Aprepro warning messages are turned off, you will not be notified of the variable redefinition and erroneous results may occur. Therefore, you should not turn off Aprepro warning messages while using the units system, and you should investigate all redefined variable messages to ensure that you are getting the results you expect.  31   32   7 Material Database Access System The material database access system has been implemented in Aprepro to facilitate the inclusion of material property data in finite element input data files. It consists of a few functions in Aprepro and a specified directory structure of files that contain material property data for each material in the system and template files for each material model in each analysis code. The template files format the data from the material property files into the correct format for the analysis codes. The material database access system is part of a larger material database system called MATS which is being developed at Sandia National Laboratories, New Mexico.  7.1 Overview of the MATS System MATS is a series of programs and datafiles which provides the analyst with a simple method  for retrieving material data from a database and inserting it into an input file for an analysis. The basic MATS system consists of the algebraic preprocessing code Aprepro, a set of template files for each material model in each analysis code, and a set of material database files for each material of interest. The full-featured MATS system would also include a database processor which would take raw test data and/or data from other sources, and provide the user with tools to process the data. After the user is satisfied with the fit of the data to the constitutive model that will be used, the data would be written to a datafile that could be used by the basic MATS system. Figure 1. shows a schematic representation of the proposed MATS system. It consists of three major sections:  Database Preprocessor: The database processor would be a tool which would take the raw test data and convert it into the correct format for the MATS database. Note that for nonlinear materials, this is not a simple conversion that can be performed automatically. The database processor should provide a highly interactive environment including tools such as multiple curve fitting options, filtering capabilities, options to work with portions of curves, curve editing capabilities, etc.  Material: The material datafiles would be stored in this section. Each major material group (for example, steel, aluminum, foam) would be a separate subdirectory under this section. These subdirectories would contain material files for each supported material of this type. For example, the aluminum subdirectory would have a material file for 6061-T6 aluminum which would contain the material data used in structural and thermal analysis codes. For example, yield stress, density, thermal conductivity, and specific heat.  Code: Code template files (which will be described later) would be stored in this section. Each supported code would have a separate subdirectory under this section. These subdirectories would contain a template file for each constitutive model supported by the analysis code. For example, the PRONTO2D subdirectory  33   would have templates for the Elastic, Elastic/Plastic, Johnson-Cook, Low Density Foam, and other constitutive models. Material data would be written into the database using the database processor, a simple text editor, or a stand-alone program written specifically for that function. Although the schematic only shows a single database structure, MATS will be written to search in several user-defined locations for the database information. This will allow userspecific, group-specific, and global databases to be developed. If an analyst develops personal datafiles for certain materials, MATS can be instructed to first look for the data in the personal datafiles. If it is found, that data will be used, if it is not found, MATS will continue to search all databases specified by the user until the data is found, or all of the specified databases have been searched.  DataBase Processor  Commercial Data Raw Test Data Steel 4340 6061 T6 1-5 lb 304 Generic 40-50 lb  MATS Material  Aluminum Foam  PRONTO  Elastic Material 1 EPDATA  Elas/Plas Material 2 EOS  Code  COYOTE CTH  Figure 1.  Schematic of Proposed MATS Database System  The remainder of this section will concentrate on the Aprepro interface routines to the material database system. Documentation of the overall MATS system will be published as soon as the system is developed and implemented.  34   7.2 Implementation of the Material Database Access Routines The material database routines are accessed from within Aprepro using a command of the form: {Material(mat_id, ""Mat_Type"", ""Mat_Name"", ""Model_Type"", ""Code"")} This accesses the material database for the specific material Mat_Name which is a Mat_Type material and formats it in a form suitable for the Model_Type constitutive model in the code Code. For example, to use OFHC Copper with the Johnson-Cook constitutive model11 in the PRONTO2D Code, the command would be: {Material(10,""Copper"",""OFHC Copper"",""Johnson-Cook"",""Pronto2d"")}  All strings are converted to lowercase so that the user only has to worry about the correct spelling. Aprepro manipulates this line into four commands which load the correct material database file and the correct template file. The example command produces a command which has the effect of: {_material_model = ""johnson_cook""} {include($MATS/material/copper/ofhc_copper)} {include($MATS/code/pronto2d/johnson-cook)} {material_model = "" ""}  where $MATS is a symbolic variable that points to the The symbolic variable can specify multiple locations are to permit private databases to be searched prior to or database. The mechanism for doing this is to define the list of colon separated directories. For example,  location of the material database. searched in a user-specified order instead of searching the default MATS environment variable as a  setenv MATS ~/mats:/department/mats:/global/mats  In many analyses, the analyst may want to modify some of the material properties specified in the material database file. For example, only a portion of a material may be explicitly modeled and therefore, the density of the modeled portion must be increased to maintain the correct mass of the body. In this case, the following commands would be used: {Material(mat_id, ""Mat_Type"", ""Mat_Name"", ""Model_Type"", ""DEFER"")} {Density = 20000 * kg/m^3} $ User-specified density {Material(mat_id, ""DEFER"", ""Mat_Name"", ""Model_Type"", ""Code"")}  This sequence of commands is manipulated into a series of commands which have the effect of first processing the material definition file, then allowing the user to modify any of the material parameters, and then formatting the data as specified in the template file for the specified code.  7.3 Code Template Files: Each code, or ""code family"", has its own set of template files which extract and format the information in the material database into a code-readable format. For example, prototype  35   template files for use in PRONTO and SANTOS are shown below for the Elastic and Johnson Cook material models. Material {_matid}, Elastic, {_Density} Youngs Modulus = {_Youngs_Modulus} Poissons Ratio = {_Poissons_Ratio} End {_C_} {dout} {_C_} {pout} {_C_} (no-dimen)  Material {_matid}, Johnson Cook, {_Density} {_C_} {dout} Youngs Modulus = {_Youngs_Modulus} {_C_} {pout} Poissons Ratio = {_Poissons_Ratio} {_C_} (no-dimen) Yield Stress = {_Yield_Stress} {_C_} {pout} Hardening Constant = {_Hardening_Constant} {_C_} {pout} Hardening Exponent = {_Hardening_Exponent} {_C_} (no-dimen) RhoCv = {_RhoCv} {_C_} {pout}/{Tout} Rate Constant = {_Rate_Constant} {_C_} (no-dimen) Thermal Exponent = {_Thermal_Exponent} {_C_} (no-dimen) Ref Temperature = {_Reference_Temperature}{_C_} {Tout} Melt Temperature = {_Melt_Temperature} {_C_} {Tout} End  The variable names (enclosed in {}) are defined with leading underscores to reduce the redefined variable warning messages which would occur for multiple uses of the material command in a single Aprepro execution. If a new, or modified, constitutive model is developed, we do not have to develop an entire new branch of the material database tree. Instead, only a new template file is created and, possibly, a few constants added to the material database. For example, if the Johnson-Cook damage model is implemented, the template file could look like: Material {matid}, JC Damage, {Density} Youngs Modulus = {Youngs_Modulus} Poissons Ratio = {Poissons_Ratio} Yield Stress = {Yield_Stress} Hardening Constant = {Hardening_Constant} Hardening Exponent = {Hardening_Exponent} RhoCV = {RhoCv} $ OR: {Density * Cv} ? Rate Constant = {Rate_Constant} Thermal Exponent = {Thermal_Exponent} Ref Temperature = {Reference_Temperature} Melt Temperature = {Melt_Temperature} D1 = {D1}, D2 = {D2}, D3 = {D3}, D4 = {D4}, D5 = {D5} End  where the name in the first line of the template has been changed and the 5 constants at the end of the template have been added. These constants would then need to be added to the material files.  36   7.4 Material Files: A prototype material database file is shown below. Note that the file can be divided into several sections delineating the Physical, Mechanical, and Thermal properties, for example. $ {ECHO(OFF)} Material Data File for Material -- {Material = ""OFHC Copper""} ...NOTE: These data are for example only, DO NOT USE ------ Physical Properties {_Density = 8960 *kg / m^3} ------ Mechanical Properties {_Youngs_Modulus = E = 124 * GPa} {_Poissons_Ratio = nu = 0.34} {_Shear_Modulus = E/2/(1+nu)} {_Bulk_Modulus = E/3/(1-2*nu)} {_Yield_Stress = 450000 * psi} ------ Thermal Properties {_Conductivity = k = 386 * W / m / degK} {_Specific_Heat = Cp = 383 * J / kg / degK} {_Diffusivity = k / Density / Cp} {_Volume_Expansion = 5.0e-5 / degK} {_Melt_Temperature = 1356 * degK} ------- Johnson Cook Specific Properties {_t = (_material_model==""johnson_cook"" || _material_model==""jc_damage"")?1:0} {ifdef(_t)} {_Yield_Stress = 90 * MPa} {_Hardening_Constant = 292 * MPa} {_Hardening_Exponent = 0.31} ...Several other constants {endif} -------- Temperature_Dependent_Material Model Specific Properties (_t = (_material_model == ""ep_temperature_dependent"")?1:0} {ifdef(_t)} {C1 = ""<< >>"" {C2 = ""<< >>"" ...The above two lines will output the message << > to the output file if they are referenced {endif} ...Other Models and Information  The material template files can have place holders for all of the information needed for the currently existing material models; if the information does not exist, the constant is set to output a warning message to the user of the information. See for example the entry for the constants C1 and C2 in the ep_temperature_dependent material block. Many of the materials that are typically used in analyses have properties that vary depending on the temperature and/or strain rates expected in the analysis. This can be handled in a way similar to that shown in the following example which illustrates temperature-dependent material properties: {NOECHO}  37   {range1 = (temp > {range2 = (temp > {range3 = (temp > {range4 = (temp > {ECHO} {ifdef(range1)} {_Linear_Expansion {endif} {ifdef(range2)} {_Linear_Expansion {endif} {ifdef(range3)} {_Linear_Expansion {endif} {ifdef(range4)} {_Linear_Expansion {endif}  0 100 200 300  && && && &&  temp temp temp temp  <= <= <= <=  100 200 300 400  ) ) ) )  ? ? ? ?  1 1 1 1  : : : :  0} 0} 0} 0}  = 1.0e-9 / degK}  = 2.0e-9 / degK}  = 3.0e-9 / degK}  = 4.0e-9 / degK}  In this example, the Linear Expansion Coefficient is set to a different value according to the expected temperature in the analysis*.  7.5 Additional Comments The material database access routines are somewhat experimental at this time. They have primarily been implemented to provide an experimental testbed for implementing the MATS material database system. It is expected that the basic functionality documented in this report will remain stable; however, additional functions may be added if the need arises. The following list provides some additional information relating to the material database access routines specifically, and to the MATS system in general.  Material property data is not and will not be distributed with Aprepro. It is the end users responsibility to provide this data in the form required by Aprepro if the database access functionality is desired. The primary reason for doing this is that the analyst should not treat this function as a black box in which appropriate material data automagically appear as the result of a simple command. Rather, it should be treated as a means of efficiently accessing (and converting to the correct units) the data that the analyst has previously collected and verified.  A units conversion system (see section 6 on page 25) must be specified prior to accessing any data in the material database.  The material database access routines do not verify the consistency of the material database. Procedures are needed to determine whether the data in the material databases are consistent. For example, is Poissons Ratio less than 0.5? Are the units set correctly?, etc.? This should be a separate program so that data can be entered using different programs and then checked for consistency.  *The mechanism for doing this is not very clean and will probably be changed in the future. This example is used just to show the concept.  38    Since several references may be used within a single material file and similar references will be used in several material files, there should be a reference list that will cross reference an abbreviation in the material file to the full bibliographical citation for the reference. A typical reference in a material file could look like: $ {Yield_Stress = 145e3*psi} $ Ref: GRJ:9  which would signify that the data were found on page 9 in the document GRJ which is an abbreviation for some report reference list.  39   40   8 Error, Warning, and Informational Messages Several error, warning, and informational messages will be printed by Aprepro if certain conditions are encountered during the parsing of an input file. The messages are of the form: Aprepro: Type: Message (file, line line#)  Where Type is ERR for an error message, WARN for a warning message, or INFO for an informational message; Message is an explanation of the problem, file is the filename being processed at the time of the message, and line# is the number of the line within that file. Error messages are always output, Warning messages are output by default and can be turned off by using the -W or +warning command option, and Informational messages are turned off by default and can be turned on by using the -M or +message command option. (See section A on page 51.)  Error Messages  Aprepro: ERR: parse error (file, line line#) An unrecognized or illformed expression has been entered. Parsing of the file continues following this expression.  Aprepro: ERR: Can't open 'file': No such file or directory The  file specified in the include command cannot be found or does not exist. Aprepro will terminate processing following this error message.  Aprepro: ERR: Can't open 'file': Permission denied The file specified  in the include or output command could not be opened due to insufficient permission. Aprepro will terminate processing following this error message.  Aprepro: ERR: Improperly Nested ifdef/ifndef statements (file, line line#) An invalid ifdef/ifndef block has been detected. Typically this is caused by an extra endif or else statement.  Aprepro: ERR:  An expression tried to divide by zero. The expression is given the value of the dividend and parsing continues. Zero divisor (file, line line#)   Aprepro: ERR: Units File not found The units system specified in the Units  command could not be found. This could be due to a misspelling of the units system name, or an incorrectly installed units system.  Aprepro: ERR: unit file found, no conversion file  The units system  has been incorrectly installed or is not available.  Aprepro: ERR: Error locating material model  The specified material  model datafile could not be found.  Aprepro: ERR: function (file, line line#) DOMAIN error: Argument out of domain The arithmetic function function has been passed an invalid  41   argument. For example, the above error would be printed for each of the expressions: {sqrt(-1.0)} {log(0.0)} {asin(1.1)}  since the arguments are out of the valid domain for the function. The value returned by the function following an error is system-dependent. See the function's man page on your system for more information.  Warning Messages  Aprepro: WARN: Undefined variable 'variable' (file, line line#) A variable is used in an expression before it has been defined. The variable is set equal to zero or the null string ("""") and parsing continues.  Aprepro: WARN: Variable 'variable' redefined (file, line line#) A previously defined variable is being set equal to a new value.  Informational Messages  Aprepro: INFO: Included File: 'filename' (file, line line#) The file filename is being included at line line# of file file. This message will also be printed during the execution of a loop block since temporary files are used to implement the looping function, and during the execution of the units conversion and material database access routines.  42   9 Examples 9.1 Mesh Generation Input File The first example shown in this section is the point definition portion of an input file for a mesh generation code. First, the locations of the arc center points 1, 2, and 5 are specified. Then, the radius of each arc is defined ({Rad1}, {Rad2}, and {Rad5}). Note that the lines are started with a dollar sign, which is a comment character to the mesh generation code. Following this, the locations of points 10, 20, 30, 40, and 50 are defined in algebraic terms. Then, the points for the inner wall are defined simply by subtracting the wall thickness from the radius values. Title Example for Aprepro $ Center Points Point 1 {x1 = 6.31952E+01} {y1 = 7.57774E+01} Point 2 {x2 = 0.00000E+00} {y2 = -3.55000E+01} Point 5 {x5 = 0.00000E+00} {y5 = 3.62966E+01} $ Wth = {Wth = 3.0} ...Wall thickness $ Rad5 = {Rad5 = 207.00} $ Rad2 = {Rad2 = 203.2236} $ Rad1 = {Rad1 = Rad2 - dist(x1,y1; x2,y2)} $ Angle between Points 2 and 1: {Th12 = atan2d((y1-y2),(x1-x2))} Point 10 0.00 {y5 - Rad5} Point 20 {x20 = x1+Rad1} {y5-sqrt(Rad5^2-x20^2)} Point 30 {x20} {y1} Point 40 {x1+Rad1*cosd(Th12)} {y1+Rad1*sind(Th12)} Point 50 0.00 {y2 + Rad2} $ Inner Wall (3 mm thick) $ {Rad5 -= Wth} $ {Rad2 -= Wth} $ {Rad1 -= Wth} ...Rad1, Rad2, and Rad5 are reduced by the wall thickness Point 110 0.00 {y5 - Rad5} Point 120 {x20 = x1+Rad1} {y5-sqrt(Rad5^2-x20^2)} Point 130 {x20} {y1} Point 140 {x1+Rad1*cosd(Th12)} {y1+Rad1*sind(Th12)} Point 150 0.00 {y2 + Rad2}  The output obtained from processing the above input file by Aprepro is shown below. Title Example $ Center Point Point Point $ Rad5 = $ Rad2 = $ Rad1 = $ Angle for Aprepro Points 1 63.1952 2 0 5 0 207 203.2236 75.2537088 between Points 2 and 1:  75.7774 -35.5 36.2966  60.40745947  43   Point 10 0.00 Point 20 138.4489088 Point 30 138.4489088 Point 40 100.3576382 Point 50 0.00 $ Inner Wall (3 mm thick) $ 204 $ 200.2236 $ 72.2537088 Point 110 0.00 Point 120 135.4489088 Point 130 135.4489088 Point 140 98.87615226 Point 150 0.00  -170.7034 -117.5893956 75.7774 141.214957 167.7236  -167.7034 -116.2471416 75.7774 138.6062794 164.7236  9.2 Macro Examples Aprepro can also be used as a simple macro definition program. For example, a mesh input file may have many lines with the same number of intervals. If those lines are defined using a variable name for the number of intervals, then preprocessing the file with Aprepro will set all of the intervals to the same value, and simply changing one value will change them all. The following input file fragment illustrates this $ {intA line 10 line 20 line 30 line 40 = 11} str 10 str 20 str 30 str 40 {intB 20 0 30 0 40 0 10 0 = int(intA / 2)} {intA} {intB} {intA} {intB}  Which when processed looks like: $ 11 line line line line 5 10 20 30 40 str str str str 10 20 30 40 20 30 40 10 0 0 0 0 11 5 11 5  9.3 Command Line Variable Assignment This example illustrates the use of assigning variables on the command line. While generating a complicated 2D or 3D mesh, it is often necessary to reposition the mesh using GREPOS. If the following file called shift.grp is created: Offset X {xshift} Y {yshift} Exit  then, the mesh can be repositioned simply by typing: Aprepro xshift=100.0 yshift=-200.0 shift.grp temp.grp Grepos input.mesh output.mesh temp.grp  44   9.4 Loop Example This example illustrates the use of the loop construct to print a table of sines and cosines from 0 to 90 degrees in 5 degree increments. Input: $ Test looping - print sin, cos from 0 to 90 by 5 {angle = -5} {Loop(19)} {angle += 5} {sind(angle)} {cosd(angle)} {EndLoop}  Output: $ -5 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 Test looping - print sin, cos from 0 to 90 by 5 0 0.08715574275 0.1736481777 0.2588190451 0.3420201433 0.4226182617 0.5 0.5735764364 0.6427876097 0.7071067812 0.7660444431 0.8191520443 0.8660254038 0.906307787 0.9396926208 0.9659258263 0.984807753 0.9961946981 1 1 0.9961946981 0.984807753 0.9659258263 0.9396926208 0.906307787 0.8660254038 0.8191520443 0.7660444431 0.7071067812 0.6427876097 0.5735764364 0.5 0.4226182617 0.3420201433 0.2588190451 0.1736481777 0.08715574275 6.123233765e-17  9.5 Units and Material Database Access Example This example illustrates the use of the units system and the material database access routines. The material data shown in this example are for illustrative purposes only and may not represent actual material data. This example also illustrates the use of the ifdef blocks to control processing of selected lines. This file was used as an input file for two analyses in which the mesh for one analysis was a subset of the other analysis. Materials 15 and 16 only appeared in the larger analysis and there were a few changes in boundary condition numbering between the two analyses. The example is annotated to explain some of the constructs used. Note that all of the dimensions in the file have unit identifiers so the unit system of the analysis can be changed simply by picking a new unit system in the Units() command. {ECHO(OFF)}{Units(""si"")} ...Specify the Units system Title Units and Material Database Access Example $ {InitVel = -sqrt(2.0 * ga * 500~foot)}  45   ...Velocity is for a 500 foot drop$ $ {Code = ""Pronto3D""} $ {ConstitModel = ""JC Damage""} ...The constitutive model used for all of the materials can now be changed simply by changing this line. $ $ NOTE: dimensions - {lout}, {mout}, {dout}, {pout} ...Echo the output units types to document processed file $ $ {den_17 = (3.125~lbm) / (2.758e-4~metre^3)} $ {den_18 = (1.000~lbm) / (8.747e-5~metre^3)} ...The densities of materials 17 and 18 are modified to get the correct mass for the model $ Control Information: Termination Time {ttime = 1.0~millisecond} Plot Time {ttime / 20} Output Time {ttime / 200} Write Restart {ttime / 10} ...Want 20 plot steps, 200 output steps, and 10 restart steps written during the analysis $ Boundary Conditions: No Displacement Y 10 {ifdef(LARGE_MODEL)} Rigid Surface 1600 {-1.85206e-1~meter} 0.0 0.0,1.0 0.0 0.0 Rigid Surface 1601 {-1.85206e-1~meter} 0.0 0.0,1.0 0.0 0.0 Rigid Surface 1602 {-1.85206e-1~meter} 0.0 0.0,1.0 0.0 0.0 {else} Rigid Surface 400 {-1.56e-1~meter} 0.0 0.0,1.0 0.0 0.0 Rigid Surface 410 {-1.56e-1~meter} 0.0 0.0,1.0 0.0 0.0 Rigid Surface 602 {-1.56e-1~meter} 0.0 0.0,1.0 0.0 0.0 {endif} ...Numbering of boundary conditions changes depending on which mesh is used in the analysis. LARGE_MODEL is defined when full analysis is run. Initial Velocity Material 5 {InitVel} Initial Velocity Material 6 {InitVel} Initial Velocity Material 8 {InitVel} Initial Velocity Material 9 {InitVel} Initial Velocity Material 10 {InitVel} {ifdef(LARGE_MODEL)} Initial Velocity Material 15 {InitVel} Initial Velocity Material 16 {InitVel} {endif} ...Materials 15 and 16 only appear in the large model Initial Velocity Material 17 {InitVel} Initial Velocity Material 18 {InitVel} ...All of the material parameters are defined below. {Material( 5, ""Aluminum"", ""6061-T6"", ConstitModel, Code)} {Material( 6, ""HE"", ""PBX-9502"",ConstitModel, Code)} {Material( 8, ""Aluminum"", ""6061-T6"", ConstitModel, Code)} {Material( 9, ""Plastic"", ""Lexan"", ConstitModel, Code)} {Material(10, ""Aluminum"", ""6061-T6"", ConstitModel, Code)} {ifdef(NOT_DEFINED)} {Material(15, ""Steel"", ""13-8 H1100"", ConstitModel, Code)} {Material(16, ""Aluminum"", ""6061-T6"", ConstitModel, Code)}  46   {endif} {Material(17, ""Aluminum"", ""6061-T6"", ConstitModel, {_Density = den_17} {Material(17, ""DEFER"", ""6061-T6"", ConstitModel, {Material(18, ""Aluminum"", ""6061-T6"", ConstitModel, {_Density = den_18} {Material(18, ""DEFER"", ""6061-T6"", ConstitModel, ...Use all of the database properties for materials 17 and 18, execpt we calculated densities to get the correct mass in the model  ""DEFER"")} Code)} ""DEFER"")} Code)} need to use the  Portions of the output of this example are shown below: $ Aprepro ($Revision: 1.36 $) Mon Oct 26 14:15:15 1992 Title Units and Material Database Access Example $ -54.67235974 $ Pronto3D $ JC Damage $ $ NOTE: dimensions - meter, kilogram, kg/m^3, Pa $ $ 5139.507456 $ 5185.690751 $ Control Information: Termination Time 0.001 Plot Time 5e-05 Output Time 5e-06 Write Restart 0.0001 $ Boundary Conditions: No Displacement Y 10 Rigid Surface 400 -0.156 0.0 0.0,1.0 0.0 0.0 Rigid Surface 410 -0.156 0.0 0.0,1.0 0.0 0.0 Rigid Surface 602 -0.156 0.0 0.0,1.0 0.0 0.0 Initial Velocity Material 5 -54.67235974 Initial Velocity Material 6 -54.67235974 Initial Velocity Material 8 -54.67235974 Initial Velocity Material 9 -54.67235974 Initial Velocity Material 10 -54.67235974 Initial Velocity Material 17 -54.67235974 Initial Velocity Material 18 -54.67235974 $ 6061-T6 Aluminum Material 5, JC Damage, 2703.78448$ kg/m^3 Youngs Modulus= 6.894792943e+10$ Pa Poissons Ratio= 0.3157962771$ dimensionless Yield Stress= 324053592.8$ Pa Hardening Constant= 113763495.3$ Pa Hardening Exponent= 0.42$ dimensionless RhoCv= 2423039.586$ Pa/degK Rate Constant= 0.002$ dimensionless Thermal Exponent= 1.34$ dimensionless Ref Temperature= 38.88888889$ degK Melt Temperature= 670$ degK  47   D1 = -0.77, D2 = 1.45, D3 = -0.47, D4 = 0, D5 = 1.6 $ all dimensionless End  $ PBX 9502 (95% TATB, 5% Kel-F 800), Dobratz Material 6, JC Damage, 1895$ kg/m^3 Youngs Modulus= 6894757.293$ Pa Poissons Ratio= 0$ dimensionless Yield Stress= 6894757.293$ Pa Hardening Constant= 113763495.3$ Pa Hardening Exponent= 0.42$ dimensionless RhoCv= 2423039.586$ Pa/degK Rate Constant= 0.002$ dimensionless Thermal Exponent= 1.34$ dimensionless Ref Temperature= 38.88888889$ degK Melt Temperature= 670$ degK D1 = -0.77, D2 = 1.45, D3 = -0.47, D4 = 0, D5 = 1.6 $ all dimensionless End ...Rest of lines not shown  48   10 References 1  G. D. Sjaardema, ""Overview of the Sandia National Laboratories Engineering Analysis Code Access System,"" SAND92-2292, Sandia National Laboratories, Albuquerque, NM, January 1993. C. Donnelly and R. Stallman, ""BISON--The YACC-compatible Parser Generator,"" Free Software Foundation, Inc., 675 Mass Ave., Cambridge, MA, 02139, June 1992. Bison Version 1.19. V. Paxson, J. Poskanzer, and K. Gong, ""FLEX--Fast Lexical Analyzer Generator,"", Free Software Foundation, Inc., 675 Mass Ave., Cambridge, MA 02139, June 1989. Flex Version 2.3.6. G. D. Sjaardema, ""GREPOS: A GENESIS Database Repositioning Program,"" SAND90-0566, Sandia National Laboratories, Albuquerque, NM, April 1990. G. D. Sjaardema and S. W. Attaway, ""Proposed Specification for MATS,"" memo to Distribution, dated January 6, 1992, Sandia National Laboratories, Albuquerque, NM. F. W. Walker, J. R. Parrington, and F. Feiner, ""Nuclides and Isotopes, 14th Edition,"" General Electric Corporation, San Jose, California, 1989. J. C. Jaeger and N. G. W. Cook, Fundamentals of Rock Mechanics, Third Edition, Chapman and Hall Publishers, London, 1979. T. W. Lambe and R. V. Whitman, Soil Mechanics, John Wiley & Sons, New York, New York, 1969. G. R. Simpson, ""Units Computer Program"", copyright 1987. B. Berliner, ""CVS II: Parallelizing Software Development,"" USENIX article, Winter, 1990, Washington, D.C. G. R. Johnson and W. H. Cook, ""A Constitutive Model and Data for Metals Subjected to Large Strains, High Strain Rates, and High Temperatures,"" Proceedings of Seventh International Symposium on Ballistics, The Hague, The Netherlands, pp. 541-548, April 1983.  2  3  4  5  6  7  8  9  10  11  49   50   A Execution Aprepro is executed with the command: aprepro [-dsvieWM] [-c'char'] [var=val] [input_file] [output_file]  The effect of the parameters are: -v prints the code name and version to the terminal. (+version) -d  prints the name and value of each variable defined in the input file to the terminal at the end of the run. See SYNTAX for a description of defining and using variables. (+debug) prints statistics on hash table granularity at end of run. Primarily used for aprepro development. (+statistics)  -s  -c 'char'sets the comment character that Aprepro writes in front of the version string and other specific output lines to the first character of 'char' (+comment 'char') -i puts aprepro into interactive mode in which there is no buffering of output. This is useful when aprepro is used as a pipe for another code. (+interactive) if this is enabled, aprepro will exit when any of the strings EXIT, Exit, exit, QUIT, Quit, or quit are entered. Otherwise, aprepro will exit at end of file. (+exit_on) print a summary of the aprepro command line and the valid options. (+help) do not print warning messages such as redefined variables and undefined variables. (+nowarning) do print informational messages such as notification of included files. (+message) sets the variable `var` equal to the value `val`: This lets you dynamically set the value of a variable and change it between runs without editing the input file. Multiple `var=val` pairs can be specified on the command line. The command line definition of a variable does not override the definition of the same variable in the input file. specifies the file that contains the input to Aprepro. If this parameter is omitted, Aprepro will run interactively.  -e  -h -W -M var=val  input_file  output_file specifies the file that Aprepro will write the processed data to. If this parameter is omitted, Aprepro will write the data to the terminal. (stdout)  The +options at the end of the parameter descriptions are optional long-options that can be specified instead of the short options. For example, the following two lines are equivalent: aprepro +debug +nowarning +statistics +comment # aprepro -dWsc#  Note that the short options can be concatenated.  51   52   B Unit System Defined Variables In the following list, the first column defines the unit variables that are defined in the Aprepro unit system and the second column is a short description of the unit. All units are defined in terms of the five SI Base Units metre (length), second (time), kilogram (mass), temperature (kelvin), and radian (angle)*. The lightly shaded rows delineate the type of unit variable and the base quantities used to define it where L is length, T is time, M is mass, and t is temperature. For example density is defined in terms of M/L^3 which is mass/ length^3. Table 10: Defined Units Variables  Abbreviation Length m, meter, metre cm, centimeter, centimetre mm, millimeter, millimetre um, micrometer, micrometre km, kilometer, kilometre in, inch ft, foot yd, yard mi, mile mil Time second, sec usec, microsecond msec, millisecond minute hr, hour day  Description [L] Metre (base unit) Metre / 100 Metre / 1,000 Metre / 1,000,000 Metre * 1,000 Inch Foot Yard Mile Mil (inch/1000) [T] Second (base unit) Second / 1,000,000 Second / 1,000 Minute Hour Day  * The radian is actually a SI Supplementary Unit since it has not been decided whether it is a Base Unit or a Derived Unit. There are three other SI Base Units, the candela, ampere, and mole, but they are not yet used in the Aprepro units system.  53   Table 10: Defined Units Variables  Abbreviation yr, year decade century Velocity mph kph mps kps fps ips Acceleration ga Mass kg g, gram lbm slug lbfs2pin Density gpcc kgpm3 lbfs2pin4 lbmpin3 lbmpft3 slugpft3 Force N, newton  Description Year = 365.25 days 10 Years 100 Years [L/T] Miles per hour Kilometres per hour Metre per second Kilometre per second Foot per second Inch per second [L/T^2] Gravitational acceleration [M] Kilogram (base unit) Gram Pound (mass) Slug Lbf-sec^2/in [M/L^3] Gram / cm^3 Kilogram / m^3 Lbf-sec^2 / in^4 Lbm / in^3 Lbm / ft^3 Slug / ft^3 [ML/T^2] Newton = 1 kg-m/sec^2  54   Table 10: Defined Units Variables  Abbreviation dyne gf kgf lbf kip pdl, poundal ounce Energy J, joule ftlbf erg calorie Btu therm tonTNT kwh Power W, watt Hp Temperature degK, kelvin degC degF degR, rankine eV Pressure Pa, pascal  Description Dyne = newton/10,000 Gram (force) Kilogram (force) Pound (force) Kilopound (force) Poundal Ounce = lbf / 16 [ML^2/T^2] Joule = 1 newton-metre Foot-lbf Erg = 1e-7 joule International Table Calorie International Table Btu EEC therm Energy in 1 ton TNT Kilowatt hour [ML^2/T^3] Watt = 1 joule / second Elec. Horsepower (746 W) [t] Kelvin (Base Unit) Degree Celsius Degree Fahrenheit Degree Rankine Electron Volt [M/L/T^2] Pascal = 1 newton / metre^2  55   Table 10: Defined Units Variables  Abbreviation MPa GPa bar kbar Mbar atm torr mHg mmHg inHg inH2O ftH2O psi ksi psf Volume liter gal, gallon Angular rad rev deg, degree arcmin arcsec grade  Description Megapascal Gigapascal Bar Kilobar Megabar Standard atmosphere Torr = 1 mmHg Metre of mercury Millimetre of mercury Inch of mercury Inch of water Foot of water Pound per square inch Kilo-pound per square inch Pound per square foot [L^3] Metre^3 / 1000 Gallon (U.S.)  Radian (base unit) Full circle = 360 degree Degree Arc minute = 1/60 degree Arc second = 1/360 degree Grade = 0.9 degree  56   57   Distribution 1 1 1 1 1 13 50 1 1 1 1 1 15 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 15 13 1400 1401 1402 1403 1404 1425 1425 1431 1431 1431 1432 1433 1434 1500 1501 1502 1503 1504 1511 1511 1511 1511 1511 1511 1511 1511 1512 1513 1513 1513 1513 1513 1551 1552 1553 1554 1561 1562 E. J. Barsis J. R. Asay S. S. Dosanjh G. S. Davidson J. A. Ang J. H. Biffle & staff M. K. Smith J. M. McGlaun K. G. Budge J. S. Peery W. T. Brown J. W. Swegle D. R. Martinez & staff D. J. McCloskey C. W. Peterson P. J. Hommert L. W. Davison D. J. McCloskey, actg J. S. Rottler D. K. Gartling M. W. Glass P. L. Hopkins M. J. Martinez P. A. Sackinger P. R. Schunk J. D. Zepper A. C. Ratzel R. D. Skocypec R. G. Baca B. L. Bainbridge R. E. Hogan, Jr. J. L. Moya W. P. Wolfe C. E. Hailey W. L. Hermina W. H. Rutledge H. S. Morgan & staff R. K. Thomas & staff  10 1 1 1 1 1 1 1 5 1 10 1 6 1 1 1 5  1562 1832 2565 6313 6411 6423 6513 6522 7141 7151 7613-2 8523-2 8741 8742 8742 8742 8743  G. D. Sjaardema J. M. Ramage S. T. Montgomery J. Jung A. S. Benjamin J. F. Dempsey D. S. Oscar J. D. Miller Technical Library Technical Publications Document Processing for DOE/OSTI Central Technical Files G. A. Benedetti & staff M. R. Birnbaum J. J. Dike L. I. Weingarten M. L. Callabresi & staff  58"
GX171-49-3838048	"Migrating to ANSI/ISO C++          Introduction   Compiling RogueWave Libraries       Report Additional Issues     Support for Cfront Codes       Compiling old STL   KAI C++ Home     Language Differences   Compiling GNU C++ codes       KAI Home     Library Differences   Compiling old  KCC codes   Contact KAI++             Introduction -- Keeping Up with the Evolution of C++    When you first compile an existing code with  KAI C++  (KCC), you may be shocked at the number of error messages that it generates. In most cases, the problem is the rapid evolution of the C++ language and the fact that KAI C++ tracks this rapid evolution. In general, the designers of C++ have tried to accommodate backwards compatibility to older versions, but in some cases doing so was judged awkward or contradictory.    With KAI C++, sometimes it is sufficient to use the command-line switch  --cfront_3.0  to get the old Cfront behavior. Usually, however, you must make minor changes to your code to bring it up to date with important changes in the language. With a little practice it is possible to modify codes so that they compile under both the old and new rules.  In our experience, the changes take little time, and have the benefit of making the code suitable for more modern C++ compilers. The rest of this document summarize the most common compatibility problems and how to quickly fix them.    The scope of this document is limited to difficulties in migrating existing codes. New C++ language features that you might want to use in new codes are desribed  elsewhere . We also recommend that you look at the  ISO December 1996 Working Paper  when you encounter compilation difficulties, particularly when diagnosing library problems.     Report Additional Issues    If you encounter additional problems in porting your Cfront or GNU C++ code to ISO C++, or porting old STL codes, please  let us know  so we can add that problem to this list, allowing others to learn from your experience.     Support for Cfront and ISO Codes    KAI C++ Version 3.3  supports both the ISO Draft Standard rules and Cfront rules. For brevity, the former will be referred to as ``ISO rules'', though it should always be remembered that the current ISO document is still a draft and subject to some change.    By default, KAI C++ parses according to the ISO rules. The command-line switch  --cfront_3.0  forces Cfront 3.0 rules. The Cfront rules are essentially those of the Annotated Reference Manual (ARM), except that a few obscure Cfront bugs are duplicated.    The combined standard template library and its runtime support code that ships with KAI C++ is distinctly ISO, though with some extensions that support Cfront codes.     Dealing with Language Differences        Basic Approach      Overload resolution      New keywords            bool, false, true        explicit        typename          Implicit use of keyword typename     Scope of for loops      Binding references to temporaries      Lifetime of temporaries       Basic Approach    There are many features in ISO C++, beyond what is the ARM. Most of these new features, such as run-time type information (RTTI), are upward compatible with Cfront. This section concerns the few features that are not upward compatible.    KAI C++  tries hard to be permissive when it comes to language differences between ISO and Cfront. As long as there is no fundamental incompatibility, it tends to allow Cfront code, even in ISO mode. Such permissiveness can be turned off with the command-line switch  --strict .    Overload resolution    ISO and Cfront rules differ on resolution of overloaded functions. Cfront's rules for overload resolution allowed for some fine shades of overload resolution, at the expense of complicated rules. The simpler (and saner) ISO rules disallow some of these fine shades. The most common problem that users encounter is demonstrated by program  overload.C . When compiled by  KAI C++  (without the cfront_3.0 switch),  KAI C++  will object:               ""overload.C"", line 12: error: more than one operator ""[]"" matches these                   operands:                     built-in operator ""pointer-to-object[integer]""                     function ""Vec::operator[](unsigned int)""                     operand types are: Vec [ int ]              v[0] = 1;               ^    By the ISO rules,  KAI C++  finds two matches because there are two possible ""conversion sequences"", and each involves a different parameter. The two matches are described below with references to the relevant sections of the ISO Working Paper.        A: (13.3.3.1.2)    To parameter 0 (which is  v ), apply the user-defined   conversion: sequence  Vec --> int* . This conversion   allows built-in operator  pointer[integer]  to match.    B: (13.3.3.1.1)    To parameter 1 (which is  0 ), apply the standard   conversion sequence  int --> unsigned int . This conversion   allows function  Vec::operator[]  to match.     Under the ARM (Cfront) rules, match B wins since it involves only standard conversions. However, The ISO rules are different (13.3.3). For a match to win, it must have ""better"" conversion sequences for each parameter than the losing match. So we have:        For parameter 0, Match B is ""better"" than A since B requires   no conversion of parameter 0.    For parameter 1, Match A is ""better"" than B since A requires   no conversion.     Thus neither match is better than the other and there is an ambiguity.    So this leaves the question of how to change the code to make it acceptable to ISO C++ compilers. The probably intent was to have match B win. To do this, remove the need for the conversion ( int --> unsigned int ) by making the actual parameter  unsigned . E.g.:                  v[0u] = 1;    The overload problem is not specific to the operators in the example. However, there are so many Cfront codes that have problems only with operator[] that  KAI C++  comes with an option to deal with it while otherwise in ISO mode. The option  --special_subscript_cost  causes the overload resolution algorithm to give special weighting to operator[] and avoid the aforementioned problems. For example,             KCC --special_subscript_cost overload.C    will compile  overload.C .    New keywords    The ISO rules add some new keywords. Even in Cfront mode,  KAI C++  recognizes these keywords:         dynamic_cast        catch     const_cast        mutable           namespace               reinterpret_cast        static_cast        throw     try     typeid            using             wchar_t          This should not be a problem unless an old code uses one of these keywords as an identifier. These keywords are now recognized by a wide variety of C++ compilers, it is worth your time to change obsolescent uses of these as identifiers.    Keywords listed below are given special treatment, because they are very recent or their new usage would break common practice in old codes.        bool, false, true      These keywords are not recognized in Cfront mode, because many old   codes have  #define  or  typedef  for   these keywords, particularly for  false  and  true .   To enable the boolean type in Cfront mode, use the command-line switch    --bool .    explicit      The keyword  explicit  is not recognized in Cfront   mode. To enable it, use the option  --explicit .    typename      The keyword  typename  is not recognized in Cfront   mode. To enable it, use the option  --typename . See   also the discussion of  --no_implicit_typename     .     Implicit use of keyword typename    ISO recently introduced a keyword  typename . Its use is required inside templates for certain contexts by the ISO rules, as demonstrated by  typename.C . However, it is so recent that very few codes use it. Therefore, by default,  KAI C++  infers where the keyword  typename  should have been used. To turn off this inference, use the option:             --no_implicit_typename    The option  --strict  also turns off the inference. If you want strict ISO except for  typename , use the options  --strict --implicit_typename .    Scope of for loops    Consider the loop:             for( int i=0; i<n; i++ ) {             ...          }    The ISO rules limit the scope of  i  to the loop; the Cfront rules treat  i  as though it were declared just before the loop. The most common problem is that the new rules break code that use  i  outside the loop. For instance, a linear search that looks at  i  after the loop exits. The fix is simple: move the declaration and initialization to outside the loop.             int i=0;         for( ; i<n; i++ ) {             ...          }    You should move  both  the declaration and initialization. Below is an example of what could go wrong if just the declaration is moved.             T i;                      // Default constructor.         for( i=0; i<n; i++ ) {    // Assignment to i             ...         }    Now the default constructor  T::T()  and  T::operator=  are used for  i , instead of just the one-argument constructor that was used in the original loop.    The ISO rules can also change how a program behaves, though this is unlikely for real programs. Program  for-scope.C  demonstrates a contrived program whose behavior depends upon ISO versus Cfront rules.  KAI C++  warns about such a change in behavior change with a message such as shown below.             ""for-scope.C"", line 14: warning: reference is to variable ""i"" (declared at                   line 7) -- under old for-init scoping rules it would have been                   variable ""i"" (declared at line 11)               switch( i ) {                       ^    Binding references to temporaries    This is the most insidious difference between ISO and Cfront rules. The problem occurs when binding a reference to a pointer to a qualified type to an unqualified pointer. For example, the behavior of program  bind-ref.C  differs depending upon which rules are used.    One way to look for this problem is to use the following command-line switch:             --diag_warning=340    The switch causes  KAI C++  to report situations where it is generating a temporary for a reference.    The example used a reference for a formal parameter. The problem can also manifest itself with other forms of references, notably class members. In the case of a class member declared as a reference, the generated temporary will almost surely have too short a lifetime, and leave the reference dangling.    Lifetime of temporaries    C++ compilers can generate anonymous temporary objects. Cfront and ISO rules differ on when such objects are destroyed. Cfront let such objects live until the end of the enclosing block; ISO destroys such objects at the end of the containing ``full expression''. For instance, program  lifetime.C  behaves differently depending upon which rules are used.    We have not run into real codes for which lifetimes of temporaries is a problem. The reason is probably that programmers have long since steered clear of this problem, because the ARM gave implementations discretion on when temporaries could be destroyed. Thus implementations of C++ based on the ARM thus varied from giving temporaries long lifetimes (as with Cfront) to extremely short lifetimes (as with the original GNU C++). The ISO rules fall between the extremes, and so are unlikely to cause problems with codes that compiled under both Cfront and GNU C++.     Library Differences        Basic Approach     <foo> vs. <foo.h>      <complex.h>            Type complex is now parameterized        Pass by reference vs. value          <generic.h>      <iostream.h>            Forward declaration of ios, istream, and ostream            Method streambuf::sync replaced        Method streambuf::stossc replaced        No default constructor ostream() or     istream()        Classes iostream and fstream extinct        File mode ios::open_mode::out needs trunc or     append          <math.h> vs. <cmath>      Basic Approach    If you are using commercial libraries such as Rogue Wave's, try reinstalling the libraries with  KAI C++ . The installation process for many commercial libraries automatically figures out how good the  KAI C++  compiler and libraries are, and install the commercial library to match.    The C++ class library shipped with  KAI C++  is a modified form of the Modena C++ Standard Library. This library tracks the ISO Draft Standard. KAI's modifications enable older codes to run with fewer modifications.    <foo> vs. <foo.h>    The biggest change is that the ISO library puts most library identifiers in the namespace  std . To minimize transition difficulties, the include files for  KAI C++  adopt the convention that if header file  <foo>  defines a public symbol  bar , then the header file  <foo.h>  does the same, but exports  bar  to the global namespace too.    For example, the header file  <iostream>  defines the class  std::ostream.  Just having this header file would breaks Cfront codes in two ways:        A Cfront code expects the header file to be called  <iostream.h>     A Cfront code expects ostream to be in the global namespace.     To solve these problems  KAI C++  supplies another header file  <iostream.h> . This header file includes  <iostream> , and then exports  std::ostream  to the global namespace.    There is one exception to the rule. Because many codes expect that  <string.h>  is the header already defined by the ISO C standard, the .h file corresponding to C++ header file  <string>  is called  <bstring.h> , not  <string.h> . The name  <bstring.h>  was chosen to follow the convention of some other existing C++ implementations.    <complex.h>    If you use  <complex.h> , the only way to make your code compatible with the Cfront and ISO libraries is to make judicious use of  typedefs .    For example, we patched in the following for an old copy of a Rogue Wave library:                 #elif defined(__KCC)             #  include <complex.h>                typedef complex  DComplex;                typedef DComplex (*CmathFunTy)(DComplex&);                typedef double  (*CmathFunTy2)(DComplex&);    Of course, if you have a recent copy, reinstalling it with  KAI C++  should fix the problem.    Type complex is now a template    The Cfront  <complex.h>  defines a class  complex  for double-precision complex numbers. The  KAI C++  versions follows the ISO draft -- it defines a template  class complex<T> , where parameter type  T  can be float, double, or long double. To add to the confusion, the old GNU library called it class  Complex .    We advise using a typedef such as  DComplex  for complex numbers, and conditionally defining it:             #if defined(__KCC)         #include <complex.h>         typedef complex<double> DComplex;         #else         #include <complex.h>         typedef complex DComplex;         #endif    Pass by reference vs. value    The Cfront header  <complex.h>  has many functions that pass complex numbers by value. In contrast, the  KAI C++  version (and some others versions such as GNU) pass complex numbers by  const  reference. Normally, the difference is not noticeable. However, we ran across one code that took the address of member functions in  class complex . For instance, it tried to pass  &complex::sqrt  to another function. For the Cfront library, such an address has type:             complex complex::*( complex );    For the  KAI C++  library, such an address has type:             complex  complex ::*( const complex & );    The two pointer-to-member types are incompatible. The most reasonable way to save the code is to use  typedefs  for pointer-to-member. For example, we were able to revive an ancient Rogue Wave code by adding the following to the Rogue Wave  complex.h .             #if defined(__KCC)         #include <complex.h>         typedef DComplex (*CmathFunTy)(DComplex&);         typedef double  (*CmathFunTy2)(DComplex&);         #else         #include <complex.h>         #endif    Reinstalling the Rogue Wave library is probably simpler in most cases. The hacks above are only for old frozen libraries.    <generic.h>    KAI C++ Version 3.0 dropped support for  <generic.h> . This header file is fossil from the age before templates. You have to read Stroustrup's original description of C++ to even find out about it. If you really want a version of it for the current version of KAI C++, ask us, and you can make your own from  this version  from GNU C++.    <iostream.h>    There are numerous minor incompatibilities between Cfront's iostream and ISO's iostream. These may require minor repairs to make old codes comply with the ISO iostream.    Forward declaration of ios, istream, and ostream    In our experience, the biggest problem are codes that contain forward declarations of classes declared in  <iostream> , such as shown below.             class ios;         class istream;         class ostream;    If any of these forward declarations occur before  <iostream.h>  is included,  KAI C++  will report the following sort of error:             include/ostream.h: error: ""ostream"" has already been declared in the current scope         using std::ostream;                    ^    The reason is that  <ostream.h>  defines  std::ostream  and then exports ostream to the global namespace. But the earlier definition of ostream, is already there! There are two ways to fix the problem in existing code. The preferred work-around is to replace the forward declarations with:             #include <iosfwd.h>    This will do the necessary forward declarations. The pure ISO way would be to omit the  .h  and use  #include <iosfwd>  but that will not save old code because it retains the definitions inside the namespace  std:: . Including  <iosfwd.h>  has similar effect, except that the definitions are exported to the global namespace so that pre-namespace code works. One nice property of fixing the code this way is that you can make it run with old C++ compilers by creating your own header file  iosfwd.h  and putting it in the old compiler's search path for include files.     Method streambuf::sync replaced    The method  streambuf::sync  should be replaced with  streambuf::pubsync . In the ISO C++ library,  streambuf  is a  typedef  for the following template instantiation.             std::basic_streambuf<char, std::ios_traits<char> >::sync    Method streambuf::stossc replaced    Calls to the method  streambuf::stossc()  should be replaced by calls  streambuf::sbumpc() , with the result cast to  void . For instance, change  rdbuf->stossc  to  (void)rdbuf->sbumpc() .    No default constructor ostream() or istream()    The Cfront versions of  ostream  and  istream  have default constructors with protected access. The idiom was to use the default constructor, and then call method  init() . Below is an example of the old style for a class  foostream  derived from  ostream .             foostream::foostream( ostream& s ) :              ostream()         {             ios::init(s.rdbuf());         }    The ISO specification has no such constructor  ostream() . Instead, the  streambuf  should be passed to the constructor for  ostream . Below is an ISO version of the aforementioned example.             foostream::foostream( ostream& s ) :              ios( s.rdbuf() ),                ostream( s.rdbuf() )         {             ios::init(str.rdbuf());         }    Classes iostream and fstream extinct    The Cfront library defined classes  iostream  and  fstream , which could be used for both input and output. The corresponding ISO classes are the template classes  std::basic_iostream  and  std::basic_fstream . To ease transition,  KAI C++ 's header files  <iostream.h>  and  <fstream.h>  have (respectively) the two typedefs shown below.             typedef std::basic_iostream<char,std::ios_traits<char> > iostream;         typedef std::basic_fstream<char,std::ios_traits<char> > fstream;    The strict ISO header files  <iostream>  and  <fstream>  do not have these definitions.    File mode ios::open_mode::out needs trunc or append    The following was allowed by Cfront's library, but would seem to not be allowed by the April 1995 public copy of the ISO Draft.             ofstream f;         f.open( ""foo"", ios::open_mode::out );    The problem is that using ``out'' alone is ambiguous -- it does not indicate whether the file is to be truncated or appended. The library shipped with  KAI C++  allows the use of  ios::open_mode::out  and takes it to be the equivalent of  w  for the UNIX fopen, so as to yield the old Cfront behavior.    However, you may want to steer clear of the ambiguity by passing  ios::open_mode::trunc  as part of the flags as shown below.             ofstream f;         f.open( ""foo"", ios::open_mode::out|ios::open_mode::trunc );    <math.h> vs. <cmath>    Cfront had a include file <math.h> corresponding to the same in C.  KAI C++  supplies a similar  <math.h> , so codes using it should compile without difficulty.    However, you may eventually want to migrate to using the ISO header  <cmath> . Though the migration is fairly painless, you should be ready for the following surprise. The header  <cmath>  introduces overloaded prototypes for math functions such as  sqrt . These prototypes declare them for  float  and  long double , and are invaluable for writing templates that work for all precisions. However, these extra prototypes add ambiguity to formerly unambiguous calls. For example, in the code below:             #include <cmath>          double golden_ratio() {return (sqrt(5)+1)/2;}    the call  sqrt(5)  cannot be resolved because the  (int) 5  could be converted to a  float ,  double , or  long double . When switching from  <math.h>  to  <cmath> , you need to add casts to disambiguate such calls. For instance, the aforementioned example can be fixed by replacing the argument  5  with  5.  or  (double)5 .     Compiling GNU C++ codes.        Turning off implicit inclusion      Clamping Down on Excessive inlining      Linkage of template instances      Bitmask ios::open_mode::bin[ary]       Weaknesses in the G++ implementation of templates cause programmers using G++ to adopt a somewhat idiosyncratic style that may cause problems with  KAI C++ . There are also parts of the GCC library that may not match the current ISO Working paper. The list below of problems with compiling G++ codes with  KAI C++  is by no means exhaustive. We appreciate any  feedback  on this issue.    Turning off implicit inclusion    When compiling G++ codes, turn off the implicit inclusion feature with the command-line option  --no_implicit_include . The implicit inclusion feature, which is on by default, is for Cfront template codes and may confuse  KAI C++  when used with G++ codes. The symptom of such confusion is that  KAI C++  appears to be including header files twice.    Clamping Down on Excessive inlining    Problems with G++'s implementation of templates cause some programmers to resort to writing all member functions of template classes inside the template declaration for the class, as shown in  excessive-inline.C  . The ISO C++ rules treat all such member functions as implicitly declared  inline . At optimization level  +K1  and higher,  KAI C++  relentlessly carries out inlining even for very complicated functions. Unless there is a lot of unreachable code involved, the result will be monstrous code bloat.    Use the command-line switch  --inline_keyword_space_time=8  to clamp down on excessive inlining. The value of 8 is a good initial guess for most cases. If you want to tweak it, read Section 3.2.3 (Automatic Inlining) of the  KAI C++  User's Guide for the meaning of the switch.    Linkage of template instances    Some versions of GNU C++ give all template instances internal linkage, even for entities that should have external linkage. We previously advised using the KCC option  -tlocal , but this option has been discontinued because it cannot yield correct results with the KCC draft-standard library. Automatic template instantiation should give correct results unless the program relied on GNU C++'s erroneous template model.    Bitmask  ios::open_mode::bin[ary]    The GNU iostreams library defines a bitmask  ios::open_mode::bin , whereas the ISO specification names it  ios::open_mode::binary .          Compiling old STL codes.        Member overload confusion      Iterator type query functions      New arguments for template class stack         You might think that STL is new enough that no migration problems arise from using it. Alas, STL is evolving with the language.    Member overload confusion    The code fragment and error message in file  vector.C  demonstrate a subtle hassle of the current STL specification. The problem arises from the fact that the following two constructors for class  vector  look very similar to the compiler.             explicit vector (size_type n, const T& value = T ());          template<class InputIterator>           vector (InputIterator first, InputIterator last);    Notice that the latter constructor  matches exactly  any pair of arguments that are of the same type. If your intent is the first constructor, be very careful in typing the arguments, otherwise the second constructor may be a better match.    For example, the declaration  vector<int>(10,1)  does not mean ``a vector of 10 integers initialized to 1''. It means a vector initialized using  int  as an iterator, starting at 10 and ending at 1. Unfortunately, int does not have the properties required of an iterator, and the compilation fails in a somewhat cryptic way deep inside the template instantiations. Writing the  10  as  10u  fixes the problem, since it makes a better match (integral promotion rather than conversion) with the intended constructor.    Iterator type query functions    The old STL had global functions  iterator_category ,  distance_type , and  value_type  that enabled a circuitous style of finding out about types related to iterators. The draft-standard style uses a more  direct style based on the class  iterator_traits .     New arguments for template class stack    The template class stack now takes the element type, not the container type as its argument. See  here  for more details.       Compiling old KCC codes.   Here are issues for application programs being migrated from KCC 3.2 to KCC 3.3. In all cases KCC's new behavior either adheres more closely to the final draft standard, or offers improved efficiency, correctness, or flexibility.      Object files and libraries produced by KCC version 3.3 are  not link-compatible  with      those produced by KCC 3.2 or earlier.  Every component of an application must be recompiled.           Exceptions are now enabled by default.                  Implicit inclusion is now turned off by default.                 Keyword  template              is now required when referring to       member template  typename s.           Function  getline  in <string>             no longer counts characters.           Template class  valarray<T>               no longer has implicit conversions to       T*  and  const T* .   The option --split (used on 3.2 when building archive libraries) is       replaced by the option      -- one_instantiation_per_object       used to build .o files.          Adding or replacing files in an archive library  is now deimplemented.      `` KCC -o libX.a x1.o '' now  removes  libX.a and builds a      new one containing only x1.o.    KCC 3.3's runtime library is now supplied as both a shared object library and      as a traditional archive library.  Most linkers default to choosing the      shared object version, which can require extra care so that it travels       with the application when it is shipped to another host.         Copyright © 1995-1996 by Kuck & Associates, Inc. All rights reserved.   , KAI C++ and KAI are trademarks of Kuck & Associates, Inc."
GX069-10-2450888	"Go forward to  Answers to Exercises . Go backward to  Algebra Tutorial . Go up to  Tutorial .   Programming Tutorial ====================  The Calculator is written entirely in Emacs Lisp, a highly extensible language.  If you know Lisp, you can program the Calculator to do anything you like.  Rewrite rules also work as a powerful programming system.  But Lisp and rewrite rules take a while to master, and often all you want to do is define a new function or repeat a command a few times.  Calc has features that allow you to do these things easily.  (Note that the programming commands relating to user-defined keys are not yet supported under Lucid Emacs 19.)  One very limited form of programming is defining your own functions. Calc's `Z F' command allows you to define a function name and key sequence to correspond to any formula.  Programming commands use the shift-`Z' prefix; the user commands they create use the lower case `z' prefix.       1:  1 + x + x^2 / 2 + x^3 / 6         1:  1 + x + x^2 / 2 + x^3 / 6          .                                     .           ' 1 + x + x^2/2! + x^3/3! RET         Z F e myexp RET RET RET y  This polynomial is a Taylor series approximation to `exp(x)'.  The `Z F' command asks a number of questions.  The above answers say that the key sequence for our function should be `z e'; the `M-x' equivalent should be `calc-myexp'; the name of the function in algebraic formulas should also be `myexp'; the default argument list `(x)' is acceptable; and finally `y' answers the question ""leave it in symbolic form for non-constant arguments?""       1:  1.3495     2:  1.3495     3:  1.3495          .          1:  1.34986    2:  1.34986                         .          1:  myexp(a + 1)                                        .           .3 z e         .3 E           ' a+1 RET z e  First we call our new `exp' approximation with 0.3 as an argument, and compare it with the true `exp' function.  Then we note that, as requested, if we try to give `z e' an argument that isn't a plain number, it leaves the `myexp' function call in symbolic form.  If we had answered `n' to the final question, `myexp(a + 1)' would have evaluated by plugging in `a + 1' for `x' in the defining formula.  (*) *Exercise 1.*  The ""sine integral"" function `Si(x)' is defined as the integral of `sin(t)/t' for `t = 0' to `x' in radians.  (It was invented because this integral has no solution in terms of basic functions; if you give it to Calc's `a i' command, it will ponder it for a long time and then give up.)  We can use the numerical integration command, however, which in algebraic notation is written like `ninteg(f(t), t, 0, x)' with any integrand `f(t)'.  Define a `z s' command and `Si' function that implement this.  You will need to edit the default argument list a bit.  As a test, `Si(1)' should return 0.946083.  (Hint:  `ninteg' will run a lot faster if you reduce the precision to, say, six digits beforehand.) See  1: Programming Answer 1 . (*)  The simplest way to do real ""programming"" of Emacs is to define a ""keyboard macro"".  A keyboard macro is simply a sequence of keystrokes which Emacs has stored away and can play back on demand.  For example, if you find yourself typing `H a S x RET' often, you may wish to program a keyboard macro to type this for you.       1:  y = sqrt(x)          1:  x = y^2          .                        .           ' y=sqrt(x) RET       C-x ( H a S x RET C-x )       1:  y = cos(x)           1:  x = s1 arccos(y) + 2 pi n1          .                        .           ' y=cos(x) RET           X  When you type `C-x (', Emacs begins recording.  But it is also still ready to execute your keystrokes, so you're really ""training"" Emacs by walking it through the procedure once.  When you type `C-x )', the macro is recorded.  You can now type `X' to re-execute the same keystrokes.  You can give a name to your macro by typing `Z K'.       1:  .              1:  y = x^4         1:  x = s2 sqrt(s1 sqrt(y))                             .                   .         Z K x RET            ' y=x^4 RET         z x  Notice that we use shift-`Z' to define the command, and lower-case `z' to call it up.  Keyboard macros can call other macros.       1:  abs(x)        1:  x = s1 y                1:  2 / x    1:  x = 2 / y          .                 .                           .            .        ' abs(x) RET   C-x ( ' y RET a = z x C-x )    ' 2/x RET       X  (*) *Exercise 2.* Define a keyboard macro to negate the item in level 3 of the stack, without disturbing the rest of the stack.  See  2:   Programming Answer 2. (*)  (*) *Exercise 3.* Define keyboard macros to compute the following functions:    1. Compute `sin(x) / x', where `x' is the number on the top of the      stack.    2. Compute the base-`b' logarithm, just like the `B' key except the      arguments are taken in the opposite order.    3. Produce a vector of integers from 1 to the integer on the top of      the stack. See  3: Programming Answer 3 . (*)  (*) *Exercise 4.* Define a keyboard macro to compute the average (mean) value of a list of numbers.  See  4: Programming Answer 4 . (*)  In many programs, some of the steps must execute several times.  Calc has ""looping"" commands that allow this.  Loops are useful inside keyboard macros, but actually work at any time.       1:  x^6          2:  x^6        1: 360 x^2          .            1:  4             .                           .         ' x^6 RET          4         Z < a d x RET Z >  Here we have computed the fourth derivative of `x^6' by enclosing a derivative command in a ""repeat loop"" structure.  This structure pops a repeat count from the stack, then executes the body of the loop that many times.  If you make a mistake while entering the body of the loop, type `Z C-g' to cancel the loop command.  Here's another example:       3:  1               2:  10946      2:  1               1:  17711      1:  20                  .          .       1 RET RET 20       Z < TAB C-j + Z >  The numbers in levels 2 and 1 should be the 21st and 22nd Fibonacci numbers, respectively.  (To see what's going on, try a few repetitions of the loop body by hand; `C-j', also on the Line-Feed or LFD key if you have one, makes a copy of the number in level 2.)  A fascinating property of the Fibonacci numbers is that the `n'th Fibonacci number can be found directly by computing `phi^n / sqrt(5)' and then rounding to the nearest integer, where `phi', the ""golden ratio,"" is `(1 + sqrt(5)) / 2'.  (For convenience, this constant is available from the `phi' variable, or the `I H P' command.)       1:  1.61803         1:  24476.0000409    1:  10945.9999817    1:  10946          .                   .                    .                    .           I H P               21 ^                 5 Q /                R  (*) *Exercise 5.*  The ""continued fraction"" representation of `phi' is `1 + 1/(1 + 1/(1 + 1/( ... )))'. We can compute an approximate value by carrying this however far and then replacing the innermost `1/( ... )' by 1.  Approximate `phi' using a twenty-term continued fraction. See  5: Programming Answer 5 . (*)  (*) *Exercise 6.*  Linear recurrences like the one for Fibonacci numbers can be expressed in terms of matrices.  Given a vector `[a, b]' determine a matrix which, when multiplied by this vector, produces the vector `[b, c]', where `a', `b' and `c' are three successive Fibonacci numbers.  Now write a program that, given an integer `n', computes the `n'th Fibonacci number using matrix arithmetic. See  6: Programming Answer 6 . (*)  A more sophisticated kind of loop is the ""for"" loop.  Suppose we wish to compute the 20th ""harmonic"" number, which is equal to the sum of the reciprocals of the integers from 1 to 20.       3:  0               1:  3.597739      2:  1                   .      1:  20          .       0 RET 1 RET 20         Z ( & + 1 Z )  The ""for"" loop pops two numbers, the lower and upper limits, then repeats the body of the loop as an internal counter increases from the lower limit to the upper one.  Just before executing the loop body, it pushes the current loop counter.  When the loop body finishes, it pops the ""step,"" i.e., the amount by which to increment the loop counter. As you can see, our loop always uses a step of one.  This harmonic number function uses the stack to hold the running total as well as for the various loop housekeeping functions.  If you find this disorienting, you can sum in a variable instead:       1:  0         2:  1                  .            1:  3.597739          .         1:  20                                  .                        .           0 t 7       1 RET 20      Z ( & s + 7 1 Z )       r 7  The `s +' command adds the top-of-stack into the value in a variable (and removes that value from the stack).  It's worth noting that many jobs that call for a ""for"" loop can also be done more easily by Calc's high-level operations.  Two other ways to compute harmonic numbers are to use vector mapping and reduction (`v x 20', then `V M &', then `V R +'), or to use the summation command `a +'.  Both of these are probably easier than using loops.  However, there are some situations where loops really are the way to go:  (*) *Exercise 7.*  Use a ""for"" loop to find the first harmonic number which is greater than 4.0. See  7: Programming Answer 7 . (*)  Of course, if we're going to be using variables in our programs, we have to worry about the programs clobbering values that the caller was keeping in those same variables.  This is easy to fix, though:           .        1:  0.6667       1:  0.6667     3:  0.6667                       .                .          2:  3.597739                                                   1:  0.6667                                                       .          Z `    p 4 RET 2 RET 3 /   s 7 s s a RET    Z '  r 7 s r a RET  When we type `Z `' (that's a back-quote character), Calc saves its mode settings and the contents of the ten ""quick variables"" for later reference.  When we type `Z '' (that's an apostrophe now), Calc restores those saved values.  Thus the `p 4' and `s 7' commands have no effect outside this sequence.  Wrapping this around the body of a keyboard macro ensures that it doesn't interfere with what the user of the macro was doing.  Notice that the contents of the stack, and the values of named variables, survive past the `Z '' command.  The ""Bernoulli numbers"" are a sequence with the interesting property that all of the odd Bernoulli numbers are zero, and the even ones, while difficult to compute, can be roughly approximated by the formula `2 n! / (2 pi)^n'.  Let's write a keyboard macro to compute (approximate) Bernoulli numbers.  (Calc has a command, `k b', to compute exact Bernoulli numbers, but this command is very slow for large `n' since the higher Bernoulli numbers are very large fractions.)       1:  10               1:  0.0756823          .                    .           10     C-x ( RET 2 % Z [ DEL 0 Z : ' 2 $! / (2 pi)^$ RET = Z ] C-x )  You can read `Z [' as ""then,"" `Z :' as ""else,"" and `Z ]' as ""end-if.""  There is no need for an explicit ""if"" command.  For the purposes of `Z [', the condition is ""true"" if the value it pops from the stack is a nonzero number, or ""false"" if it pops zero or something that is not a number (like a formula). Here we take our integer argument modulo 2; this will be nonzero if we're asking for an odd Bernoulli number.  The actual tenth Bernoulli number is `5/66'.       3:  0.0756823    1:  0          1:  0.25305    1:  0          1:  1.16659      2:  5:66             .              .              .              .      1:  0.0757575          .       10 k b RET c f   M-0 DEL 11 X   DEL 12 X       DEL 13 X       DEL 14 X  Just to exercise loops a bit more, let's compute a table of even Bernoulli numbers.       3:  []             1:  [0.10132, 0.03079, 0.02340, 0.033197, ...]      2:  2                  .      1:  30          .        [ ] 2 RET 30          Z ( X | 2 Z )  The vertical-bar `|' is the vector-concatenation command.  When we execute it, the list we are building will be in stack level 2 (initially this is an empty list), and the next Bernoulli number will be in level 1.  The effect is to append the Bernoulli number onto the end of the list.  (To create a table of exact fractional Bernoulli numbers, just replace `X' with `k b' in the above sequence of keystrokes.)  With loops and conditionals, you can program essentially anything in Calc.  One other command that makes looping easier is `Z /', which takes a condition from the stack and breaks out of the enclosing loop if the condition is true (non-zero).  You can use this to make ""while"" and ""until"" style loops.  If you make a mistake when entering a keyboard macro, you can edit it using `Z E'.  First, you must attach it to a key with `Z K'.  One technique is to enter a throwaway dummy definition for the macro, then enter the real one in the edit command.       1:  3                   1:  3           Keyboard Macro Editor.          .                       .           Original keys: 1 RET 2 +                                               type ""1\r""                                              type ""2""                                              calc-plus       C-x ( 1 RET 2 + C-x )    Z K h RET      Z E h  This shows the screen display assuming you have the `macedit' keyboard macro editing package installed, which is usually the case since a copy of `macedit' comes bundled with Calc.  A keyboard macro is stored as a pure keystroke sequence.  The `macedit' package (invoked by `Z E') scans along the macro and tries to decode it back into human-readable steps.  If a key or keys are simply shorthand for some command with a `M-x' name, that name is shown.  Anything that doesn't correspond to a `M-x' command is written as a `type' command.  Let's edit in a new definition, for computing harmonic numbers. First, erase the three lines of the old definition.  Then, type in the new definition (or use Emacs `M-w' and `C-y' commands to copy it from this page of the Info file; you can skip typing the comments that begin with `#').       calc-kbd-push         # Save local values (Z `)      type ""0""              # Push a zero      calc-store-into       # Store it in variable 1      type ""1""      type ""1""              # Initial value for loop      calc-roll-down        # This is the TAB key; swap initial & final      calc-kbd-for          # Begin ""for"" loop...      calc-inv              #   Take reciprocal      calc-store-plus       #   Add to accumulator      type ""1""      type ""1""              #   Loop step is 1      calc-kbd-end-for      # End ""for"" loop      calc-recall           # Now recall final accumulated value      type ""1""      calc-kbd-pop          # Restore values (Z ')  Press `M-# M-#' to finish editing and return to the Calculator.       1:  20         1:  3.597739          .              .           20             z h  If you don't know how to write a particular command in `macedit' format, you can always write it as keystrokes in a `type' command. There is also a `keys' command which interprets the rest of the line as standard Emacs keystroke names.  In fact, `macedit' defines a handy `read-kbd-macro' command which reads the current region of the current buffer as a sequence of keystroke names, and defines that sequence on the `X' (and `C-x e') key.  Because this is so useful, Calc puts this command on the `M-# m' key.  Try reading in this macro in the following form: Press `C-@' (or `C-SPC') at one end of the text below, then type `M-# m' at the other.       Z ` 0 t 1          1 TAB          Z (  & s + 1  1 Z )          r 1      Z '  (*) *Exercise 8.* A general algorithm for solving equations numerically is ""Newton's Method"".  Given the equation `f(x) = 0' for any function `f', and an initial guess `x_0' which is reasonably close to the desired solution, apply this formula over and over:       new_x = x - f(x)/f'(x)  where `f'(x)' is the derivative of `f'.  The `x' values will quickly converge to a solution, i.e., eventually `new_x' and `x' will be equal to within the limits of the current precision.  Write a program which takes a formula involving the variable `x', and an initial guess `x_0', on the stack, and produces a value of `x' for which the formula is zero.  Use it to find a solution of `sin(cos(x)) = 0.5' near `x = 4.5'.  (Use angles measured in radians.)  Note that the built-in `a R' (`calc-find-root') command uses Newton's method when it is able.  See  8: Programming Answer 8 . (*)  (*) *Exercise 9.* The ""digamma"" function `psi(z)' is defined as the derivative of `ln(gamma(z))'.  For large values of `z', it can be approximated by the infinite sum       psi(z) ~= ln(z) - 1/2z - sum(bern(2 n) / 2 n z^(2 n), n, 1, inf)  where `sum' represents the sum over `n' from 1 to infinity (or to some limit high enough to give the desired accuracy), and the `bern' function produces (exact) Bernoulli numbers. While this sum is not guaranteed to converge, in practice it is safe. An interesting mathematical constant is Euler's gamma, which is equal to about 0.5772.  One way to compute it is by the formula, `gamma = -psi(1)'.  Unfortunately, 1 isn't a large enough argument for the above formula to work (5 is a much safer value for `z'). Fortunately, we can compute `psi(1)' from `psi(5)' using the recurrence `psi(z+1) = psi(z) + 1/z'.  Your task:  Develop a program to compute `psi(z)'; it should ""pump up"" `z' if necessary to be greater than 5, then use the above summation formula.  Use looping commands to compute the sum.  Use your function to compute `gamma' to twelve decimal places.  (Calc has a built-in command for Euler's constant, `I P', which you can use to check your answer.) See  9: Programming Answer 9 . (*)  (*) *Exercise 10.* Given a polynomial in `x' and a number `m' on the stack, where the polynomial is of degree `m' or less (i.e., does not have any terms higher than `x^m'), write a program to convert the polynomial into a list-of-coefficients notation.  For example, `5 x^4 + (x + 1)^2' with `m = 6' should produce the list `[1, 2, 1, 0, 5, 0, 0]'.  Also develop a way to convert from this form back to the standard algebraic form.  See  10: Programming Answer 10 . (*)  (*) *Exercise 11.* The ""Stirling numbers of the first kind"" are defined by the recurrences,       s(n,n) = 1   for n >= 0,      s(n,0) = 0   for n > 0,      s(n+1,m) = s(n,m-1) - n s(n,m)   for n >= m >= 1.  This can be implemented using a ""recursive"" program in Calc; the program must invoke itself in order to calculate the two righthand terms in the general formula.  Since it always invokes itself with ""simpler"" arguments, it's easy to see that it must eventually finish the computation.  Recursion is a little difficult with Emacs keyboard macros since the macro is executed before its definition is complete. So here's the recommended strategy:  Create a ""dummy macro"" and assign it to a key with, e.g., `Z K s'.  Now enter the true definition, using the `z s' command to call itself recursively, then assign it to the same key with `Z K s'.  Now the `z s' command will run the complete recursive program.  (Another way is to use `Z E' or `M-# m' (`read-kbd-macro') to read the whole macro at once, thus avoiding the ""training"" phase.)  The task:  Write a program that computes Stirling numbers of the first kind, given `n' and `m' on the stack.  Test it with *small* inputs like `s(4,2)'.  (There is a built-in command for Stirling numbers, `k s', which you can use to check your answers.) See  11: Programming Answer 11 . (*)  The programming commands we've seen in this part of the tutorial are low-level, general-purpose operations.  Often you will find that a higher-level function, such as vector mapping or rewrite rules, will do the job much more easily than a detailed, step-by-step program can:  (*) *Exercise 12.* Write another program for computing Stirling numbers of the first kind, this time using rewrite rules.  Once again, `n' and `m' should be taken from the stack.  See  12: Programming  Answer 12. (*)   This ends the tutorial section of the Calc manual.  Now you know enough about Calc to use it effectively for many kinds of calculations.  But Calc has many features that were not even touched upon in this tutorial.  The rest of this manual tells the whole story."
GX060-27-9194489	"Go forward to  Matrix Functions . Go backward to  Arithmetic . Go up to  Top .   Scientific Functions ********************  The functions described here perform trigonometric and other transcendental calculations.  They generally produce floating-point answers correct to the full current precision.  The `H' (Hyperbolic) and `I' (Inverse) flag keys must be used to get some of these functions from the keyboard.  One miscellanous command is shift-`P' (`calc-pi'), which pushes the value of `pi' (at the current precision) onto the stack.  With the Hyperbolic flag, it pushes the value `e', the base of natural logarithms.  With the Inverse flag, it pushes Euler's constant `gamma' (about 0.5772).  With both Inverse and Hyperbolic, it pushes the ""golden ratio"" `phi' (about 1.618).  (At present, Euler's constant is not available to unlimited precision; Calc knows only the first 100 digits.)  In Symbolic mode, these commands push the actual variables `pi', `e', `gamma', and `phi', respectively, instead of their values; See  Symbolic Mode .  The `Q' (`calc-sqrt') [`sqrt'] function is described elsewhere; See  Basic Arithmetic .  With the Inverse flag [`sqr'], this command computes the square of the argument.  See  Prefix Arguments , for a discussion of the effect of numeric prefix arguments on commands in this chapter which do not otherwise interpret a prefix argument.   Menu    Logarithmic Functions     Trigonometric and Hyperbolic Functions     Advanced Math Functions     Branch Cuts     Random Numbers     Combinatorial Functions     Probability Distribution Functions"
