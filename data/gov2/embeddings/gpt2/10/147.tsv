id	content
GX002-70-10498042	"HMMERBUILD*     [  Program Manual  |  User's Guide  |  Data Files  |  Databases  ]      Table of Contents      FUNCTION   DESCRIPTION   EXAMPLE   OUTPUT   INPUT FILES   RELATED PROGRAMS   RESTRICTIONS   SPECIFYING SEQUENCES FOR HMMERBUILD   ALGORITHM   CONSIDERATIONS   COMMAND-LINE SUMMARY   ACKNOWLEDGEMENT   PARAMETER REFERENCE                       FUNCTION    [   Top  |  Next  ]          HmmerBuild creates a position-specific scoring  table, called a profile hidden  Markov model (HMM),  that is a statistical model  of the consensus of a  multiple sequence alignment.  The  profile HMM can be  used for database searching (HmmerSearch),  sequence alignment (HmmerAlign) or generating  random  sequences that match the model  (HmmerEmit).        DESCRIPTION    [  Previous  |  Top  |  Next  ]          HmmerBuild provides a GCG interface  to the hmmbuild program of  Dr. Sean Eddy's HMMER package.  It allows you to access  most of hmmbuild's parameters from  the GCG command line.    HmmerBuild creates a profile hidden  Markov model from a group  of aligned sequences.  A  profile HMM  is a mathematical model that  represents the primary structure consensus  of a sequence family.   The  output from HmmerBuild is a  file that contains an ASCII  text representation of the profile  HMM.    This profile HMM file can  be used as input to  several other programs in the  HMMER package.  HmmerSearch uses the profile HMM  as a query to find  sequences in a database that  are similar to the  aligned sequences from which the  model was built.  HmmerAlign  uses a profile HMM as  a seed to  optimally align a group of  sequences related to the model.   HmmerEmit generates random sequences  that match the profile HMM.    Instead of creating a single  profile HMM as ouput, you  also can add the resulting  profile HMM directly  to an existing HMM database  by using parameter  -APP end .    The aligned sequences may be  specified to HmmerBuild with an  ambiguous file expression or in  a list  file similar to the input  for  Pretty  or  LineUp .   (See Chapter 2, Using Sequence  Files and Databases in  the User's Guide for more  information.)        EXAMPLE    [  Previous  |  Top  |  Next  ]          Here is a session using  HmmerBuild to make a profile  HMM from aligned 75 kd  heat shock and heat  shock cognate peptide sequences (these  sequences were aligned in the  example session for  PileUp ):        %  hmmerbuild    HMMERBUILD of what aligned sequences ?   hsp70.msf{*}    Type of alignments/searches model should lead to:     G Global    L Local    B Single global    C Single local   Choose a model (* G *) :   Setting model type to global.   What should the output file be called (* hsp70.hmm_g *)?   Creating temporary file for input to hmmbuild.   Calling hmmbuild to perform analysis ...  hmmbuild - build a hidden Markov model from an alignment HMMER 2.1.1 (Dec 1998) Copyright (C) 1992-1998 Washington University School of Medicine HMMER is freely distributed under the GNU General Public License (GPL). - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Training alignment:                hsp70.msf{*} Number of sequences:               25 Search algorithm configuration:    Multiple domain (hmmls) Model construction strategy:       MAP (gapmax hint: 0.50) Null model used:                   (default) Prior used:                        (default) Prior strategy:                    Dirichlet Sequence weighting method:         G/S/C tree weights - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Determining effective sequence number    ... done. [3] Weighting sequences heuristically        ... done. Constructing model architecture          ... done. Converting counts to probabilities       ... done. Setting model name, etc.                 ... done. [hsp70]  Constructed a profile HMM (length 677) Average score:     1633.25 bits Minimum score:     1328.99 bits Maximum score:     1777.86 bits Std. deviation:     131.34 bits  Finalizing model configuration           ... done. Saving model to file                     ... done.  [/usr/users/share/smith/hsp70.hmm_g]  %            OUTPUT    [  Previous  |  Top  |  Next  ]          Here is some of the  output file:      HMMER2.0 NAME  hsp70 LENG  677 ALPH  Amino RF    no CS    no MAP   yes COM   gcg_hmmbuild /usr/users/share/smith//hsp70.hmm__g hsp70.msf NSEQ  25 DATE  Fri Jul  9 14:09:29 1999 CKSUM 3252 XT      -8455     -4  -1000  -1000  -8455     -4  -8455     -4 NULT      -4  -8455 NULE     595  -1558     85    338   -294    453  -1158  ...  -1998   -644 HMM        A      C      D      E      F      G      H  ...      W      Y          m->m   m->i   m->d   i->m   i->i   d->m   d->d    b->m   m->e          -368      *  -2150      1    482  -1538   -242    709  -1777   -345     14 ...  -1783  -1160    27      -   -149   -500    233     43   -381    399    106 ...   -294   -249      -    -18  -6880  -7922   -894  -1115   -701  -1378   -386      *      2    209  -1369   -338    519  -1590   -486    -48 ...  -1681  -1096    28      -   -149   -500    233     43   -381    399    106 ...   -294   -249      -    -18  -6880  -7922   -894  -1115   -701  -1378      *      *  ////////////////////////////////////////////////////////////////////////////////     675   -664  -1701     33   2728  -1813  -1361   -295 ...  -1992  -1378   717      -   -149   -500    233     43   -381    399    106 ...   -294   -249      -    -24  -6511  -7553   -894  -1115   -701  -1378      *      *    676   -576   -717  -2213  -1989  -1191  -1755  -1601 ...  -1918  -1514   718      -   -149   -500    233     43   -381    399    106 ...   -294   -249      -    -24  -6511  -7553   -894  -1115   -701  -1378      *      *    677  -1248  -2485   3484    210  -3124   -286   -821 ...  -3039  -2364   719      -      *      *      *      *      *      *      * ...      *      *      -      *      *      *      *      *      *      *      *      0 //            INPUT FILES    [  Previous  |  Top  |  Next  ]          HmmerBuild accepts multiple sequences (one  or more) all of the  same type.  You can  specify multiple  sequences in a number of  ways:  by using a list file,  for example  @project.list ;  by using an  MSF or  RSF file, for example  project.msf{*} ;  or  by using a sequence specification  with an asterisk ( * )  wildcard, for example  GenEMBL:* .    The function of HmmerBuild depends  on whether your input sequence(s)  are protein or nucleotide.  Programs determine the type of  a sequence by the presence  of either  Type: N  or   Type: P  on the last  line of the text heading  just above the sequence.   If your sequence(s) are not  the correct type, turn to  Appendix VI for information on how  to change or set the  type of a sequence.        RELATED PROGRAMS    [  Previous  |  Top  |  Next  ]           PileUp  creates a multiple sequence  alignment from a group of  related sequences.   LineUp  is  a multiple  sequence editor used to create  multiple sequence alignments.   Pretty   displays multiple sequence  alignments.     ProfileMake  makes a profile from  a multiple sequence alignment.    ProfileSearch  uses the profile to  search a database for sequences  with similarity to the group  of aligned sequences.   ProfileSegments   displays optimal alignments between each  sequence in the  ProfileSearch  output  list and the group of  aligned sequences (represented by the  profile consensus).   ProfileGap  makes  optimal alignments  between one or more sequences  and a group of aligned  sequences represented as a profile.    ProfileScan   finds structural and sequence motifs  in protein sequences, using predetermined  parameters to  determine significance.    HmmerBuild makes a profile hidden  Markov model from a multiple  sequence alignment.  HmmerAlign  aligns one or more sequences  to a profile HMM.   HmmerPfam searches a database of  profile HMMs  with a sequence query in  order to identify known domains  within the sequence.  HmmerSearch  uses a  profile HMM as a query  to search a sequence database  for sequences similar to the  original aligned  sequences.  HmmerCalibrate calibrates a  hidden Markov model so that  database searches using it as  a  query will be more sensitive.   HmmerIndex creates a binary  GSI (""generic sequence index"") for  a  database of profile HMMs.   HmmerFetch retrieves a profile hidden  Markov model by name from  an  indexed database of profile HMMs.   HmmerEmit randomly generates sequences  that match a profile  HMM.  HmmerConvert converts between  different profile HMM file formats  and from profile HMM to  GCG profile file format.     MEME  finds conserved motifs in  a group of unaligned sequences  and saves these motifs as  a set of  profiles.  You can search  a database of sequences with  these profiles using the  MotifSearch   program.        RESTRICTIONS    [  Previous  |  Top  |  Next  ]          Hmmerbuild does not perform alignments.   It is your responsibility  to ensure that the sequences  input  to HmmerBuild are in alignment.    HmmerBuild  will  append the ASCII  text format HMM output to  a binary format file, when  using  parameter  -APP end , but the resulting  file will be unusable by  other programs in the HMMER  package.  It also lets  you create mixed nucleic and  protein profile HMM databases, which  will be  unusable by other programs in  the HMMER package as well.        SPECIFYING SEQUENCES FOR HMMERBUILD    [  Previous  |  Top  |  Next  ]          The sequences used to make  the profile HMM can be  specified in two ways.   (See Chapter 2, Using  Sequence Files and Databases in  the User's Guide for more  information.) A group of sequences  may be  named with an ambiguous expression  like  kf*.pep  or  pileup.msf{*} .   The sequences may also be  specified in a list file,  and a beginning and ending  position can be assigned to  each sequence in the list  with the  begin:  and  end:   sequence attributes, respectively.  (See   ""Using List Files""  in Chapter  2,  Using Sequence Files and Databases  in the User's Guide).   Make sure that the sequence  ranges you  specify will result in the  sequences being in alignment.   If you do not specify  beginning and ending  positions, the entire sequence is  used.    HmmerBuild has several built-in ways  of weighting the input sequences  (see the ALGORITHM topic  for more details).  If  you want to use your  own sequence weighting scheme, add  the appropriate  parameters to the list file,  MSF file, or RSF file  that is used as the  input file.  You must  also use the   -WEI ghting =N  parameter when invoking HmmerBuild  to turn off HmmerBuild's built-in  weighting  schemes so that yours will  take precedence.    If you are using a  list file to input your  files, you can add a  weight attribute to any line  in the list with a  text editor in order to  specify a weight for that  sequence (if no weight attribute  is present, the weight  defaults to 1.0).  For  example:             fa12.ugly    begin: 201       end: 250       weight: 0.5      fo1k.ugly    begin: 201       end: 250       weight: 1.0        You can assign weights to  sequences in an MSF file  by editing the MSF file  and modifying the weight  on the name line for  each sequence.  (See ""Using  Multiple Sequence (MSF) Files"" in  Chapter 2, Using  Sequence Files and Databases in  the User's Guide for a  complete description of MSF files.)              Name: Hs70Plafa       Len:   720  Check:  297  Weight:  0.50       Name: Hs70Thean       Len:   720  Check: 1483  Weight:  1.00        You can also edit RSF  files to add a weight  attibute to each sequence.   (See ""Using Rich Sequence  Format (RSF) Files"" in Chapter  2, Using Sequence Files and  Databases in the User's Guide  for a  complete description of RSF files.)             {      name  hs70plafa      descrip     PileUp  of: @Hsp70.List      type    PROTEIN      longname  hsp70.msf{Hs70Plafa}      checksum    297      weight 0.5      creation-date 08/08/2000 15:40:21      strand  1      sequence        [...]      }      {      name  hs70thean      descrip     PileUp  of: @Hsp70.List      type    PROTEIN      longname  hsp70.msf{Hs70Thean}      checksum    1483      weight 1.0      creation-date 08/08/2000 15:40:21      strand  1      sequence        [...]      }        You can use the  SeqLab   editor to assign weights to  sequences in MSF and RSF  files.  (See ""Viewing and  Editing Sequence Attribute and Reference  Information"" in Chapter 2, Editing  Sequences and  Alignments in the  SeqLab  Guide  for more information about modifying  the sequence weight attributes.)    Weights assigned in a list  file take precedence over weights  assigned within MSF or RSF  files that are  components of the list.        ALGORITHM    [  Previous  |  Top  |  Next  ]             See the Profile HMM Analysis  Essay for an introduction to  profile hidden Markov models and  the  terminology associated with them.             State Assignments          In constructing an HMM, HmmerBuild  must first determine which columns  in the alignment  should be assigned to a  match state and which to  an insert state.  The  profile HMM is then built  from this ""marked"" alignment.   By default, HmmerBuild uses maximum   a posteriori  (MAP)  construction:  a dynamic programming algorithm is  used to determine the maximum   a posteriori   choice of state for each  column in the alignment.   This algorithm can be tuned  to favor longer or  shorter models by means of  the  -ARCH prior  parameter, which can  be set to values between  0.0  and 1.0.  By default  this is set to 0.85.   To favor longer models,  set it higher;  to favor shorter  models, set it lower.    Like most dynamic programming algorithms,  MAP construction is fairly slow.   You can use a  faster heuristic method to ""mark""  the columns by specifying the   -FAS t  parameter.  The  heuristic method assigns a column  in the alignment to the  insert state if the column  contains  more than a certain fraction  of gap characters.  By  default, this fraction is 0.5.   You can change it  using the  -GAPS  parameter.    For more detailed information on  how MAP construction works, see  section 5.7, ""Optimal Model  Construction,"" in Chapter 5 of   Biological Sequence Analysis  by Richard  Durbin, et al. (Cambridge  University Press, 1998).        Probability Parameters and Pseudocounts          After determining the state assignments,  HmmerBuild must next assign the  probability  parameters for the model:  the transition  probabilities and emission probabilities.   If there are a  large number of sequences in  the alignment, this can be  done simply by counting up  the number  of times each transition or  emission is used and doing  a trivial calculation to get  the probability.  For example, if column 57  in an alignment of 100  protein sequences contains 60 L's,  10 I's, 9 V's,  two each of M, A,  T and S, and one  each of the remaining amino  acids, the emission probabilities  would be 0.6 for L,  0.1 for I, 0.09 for  V, 0.02 for M, A,  T, and S, and 0.01  for each of the remaining  13 amino acids.    Unfortunately, for alignments containing a  small number of sequences the  observed counts may  not be representative of the  family as a whole.   For example, an alignment containing  only 20 of  the sequences from the example  above may contain all L's  in column 57, resulting in  an  emissions probability of 1.0 for  L and 0.0 for all  other amino acids.  So  there must be a way  of  adjusting the probabilities to account  for unobserved data.    One approach is to add  pseudocounts to the observed counts  so that no zero probabilities  can  occur.  A simple way  is to just add one  to all counts.  More  accurate adjustments can be obtained  by using prior knowledge about  the behavior of sequence families  to adjust the counts.   Two ways  of applying prior knowledge are  substitition matrices and Dirichlet distributions.    The more intuitive method for  most biologists is the use  of substitution matrices.  With  this  heuristic method, entries in a  substitution matrix are converted into  conditional probabilities  that are used to derive  the pseudocounts.  However, the  default method used by HmmerBuild  is  to use a mixture of  Dirichlet distributions as the prior,  because this has a well-founded  theoretical basis.  This method  has been shown to create  good profile HMMs from alignments  containing as few as 10  or 20 sequences.  (Use  the  -MATR ix  parameter if you  want to override  the default and have HmmerBuild  use the substitution matrix method  rather than Dirichlet  priors.)    You can override the default  Dirichlet priors used by HmmerBuild  by providing your own prior  information in a file.   Use the  -DIRI chlet  parameter to  specify this file.  Files  containing the  default prior information are available  to use as models.   These are GenMoreData:amino.pri and  GenMoreData:nucleic.pri.  For a more  detailed description of the file  format, go to   http://hmmer.wustl.edu/hmmer-html/node34.html .    For more information on how  priors work, see section 5.6,  ""More on estimation of probabilities,""  in Chapter 5 of  Biological  Sequence Analysis  by Richard Durbin,  et al. (Cambridge University  Press, 1998).        Null model for profile HMMs          Alignments between profile HMMs and  sequences are scored by computing  a log-odds score  relative to a  null model   of random sequence composition.   The default null model contains  the  expected background occurrence frequencies of  each residue type plus a  parameter called  p1   that controls the expected length  of the randomly generated sequences.   When a profile HMM  is  built, HmmerBuild stores information about  the null model that was  used to create it along  with  the HMM itself.    For proteins, the frequencies for  each of the 20 amino  acids are set to their  observed frequencies  in release 34 of the  SWISS-PROT database and  p1  is  set to 350/351, which implies  that the  expected mean length of a  protein is about 350 residues.   For nucleic acid sequences,  each of the  four nucleotides is assigned a  frequency of 0.25, and  p1   is set to 1000/1001.    You can override this default  null model by providing your  own null model information in  a file.  Use the  -NUL lmodel  parameter to  inform HmmerBuild of the name  of the file.  Files  containing  the default null model information  are available to use as  models.  These are  GenMoreData:amino.null and GenMoreData:nucleic.null.  For  a more detailed description go  to   http://hmmer.wustl.edu/hmmer-html/node33.html .        Weighting the Sequences in the  Alignment          Usually one's sequence alignments do  not contain a good random  sample of all possible  sequences belonging to the family,  but instead may contain a  group of very closely related  sequences plus a number of  more distantly related sequences.   To account for this distorted  representation of a sequence family,  closely related sequences in the  alignment should have less  individual effect on the final  probability distribution than sequences highly  diverged from all  other sequences in the alignment.   For example, if the  same sequence occurs twice in  your  alignment, each instance of this  sequence should get only half  the weight of a single  sequence.  HmmerBuild provides several built-in weighting  schemes.    By default an algorithm proposed  by Gerstein, Sonnhammer, and Clothia  is used.  An  evolutionary tree of the sequences  in the alignment serves as  a guide to weight each  sequence.  Starting at the leaves of  the tree (level N), the  GSC algorithm assigns each sequence  a weight  equal to its distance to  its parent node at the  next higher level (level N-1)  in the tree.  At  level  N-1, the distance to the  parent node at level N-2  is shared among all sequences  in the subtree  below.  A fraction of  that distance, proportional to their  current weight, is added to  the weights  for each sequence.    Another available weighting scheme is  the BLOSUM filtering algorithm ( -WEI ghting =B ).   This  is based on the same  concept that was used to  create the BLOSUM substitution matrices.   The  sequences are clustered depending on  their percent identity; by default  using 62 percent identity  ( -CLUSTERL evel =0.62 ) as the cutoff for  each cluster (as for the  BLOSUM62 matrix).  Each  cluster is assigned a weight  of 1.0, which in turn  is distributed evenly among all  sequences in the  cluster.    The third algorithm is Krogh-Mitchison  maximum entropy weighting ( -WEI ghting =W ), which  is  a more robust version of  the older Eddy-Mitchison-Durbin algorithm.   The original algorithm  determines a weight at each  position of a sequence by  weighting the least common residue  at  that position in the alignment  most heavily, and the most  common residue least heavily.   These  positional weights are then averaged  to give an overall weight  for the sequence.  The  Krogh-Mitchison version doesn't compute a  simple average over the positional  weights, but  instead uses an entropy maximization  method.  It gives a  slight increase in sensitivity over  the  default GSC weighting method, at  the expense of increased computing  time.    A fourth weighting scheme uses  the Sibbald-Argos Voronoi weighting algorithm  ( -WEI ghting =V ).  The idea is  to picture how all sequences  from a family lie in  ""sequence space.""  Some sequences will lie close  together (be clustered) while other  ones will lie far apart  from any  other sequence.  Weights are  assigned proportional to the empty  space around each sequence.    Lastly you can choose to  disable all built-in weighting schemes  ( -WEI ghting =N ).  Normally you  would do this only if  you are providing your own  weights for the sequences.    For more information on the  built-in weighting schemes, see Section  5.8, ""Weighting training  sequences,"" in Chapter 5 of   Biological Sequence Analysis  by Richard  Durbin, et al. (Cambridge  University Press, 1998).        Alignment type incorporated in HMM          The HMMER programs differ from  commonly used sequence comparison and  alignment  programs in that the type  of alignment you want to  eventually perform with the profile  HMM  (global or local) must be  specified at the time the  model is built, rather than  at the time it is  used.  (Note that this  is with respect to the  model only; if the test  sequence is longer than the  model, the entire model may  align within the sequence and  thus be local with respect  to the  sequence and global with respect  to the model.)    For a global alignment to  a model, the entire profile  HMM is aligned with the  test sequence.  This is equivalent to aligning  the entire original sequence alignment  from which the model is  built to a segment within  the test sequence.  For  a local alignment, only part  of the profile HMM  need be aligned with the  sequence.  This is equivalent  to finding the best section  of the original  alignment that matches the test  sequence.    Another alignment characteristic that is  built into the model is  whether to find single or  multiple  domains in the test sequence.   If the profile HMM  is created for single hits,  only one domain per  sequence will be reported, even  if others are present.   Creating a model for multiple  hits means  that all matching domains in  a sequence will be sought  for and reported.    By default, HmmerBuild creates a  model which will allow multiple  global alignments of the  profile HMM and a sequence  ( -MEN u =g ).  You can build  a single global HMM by  specifying the   -MEN u =b  parameter.  Global models  provide maximum sensitivity at the  expense of only locating  complete domains in the test  sequence.    If you are looking for  domain fragments (only part of  the model might be found  in the test  sequence), build a model that  allows local alignments with respect  to the HMM.  Here  again you  can choose to find only  a single match with each  test sequence ( -MEN u =c ) or to  find multiple  matches ( -MEN u =l ).  There is  a slight loss of sensitivity  with the local models.    For creating local models you  can use the  -SWEN try  and   -SWEX it  parameters to favor which  end of the model should  match the test sequence.   By default these are both  set to 0.5 to indicate  no preference.  Setting  -SWEN try   to zero constrains the alignment  to start at the beginning  of  the model while setting it  to 1.0 prevents it from  starting at the beginning of  the model.  Similarly, setting  -SWEX it  to zero  means that the end of  the alignment must coincide with  the  end of the model, while  a value of 1.0 forces  it not to continue to  the end of the model.   So setting  both of these parameters to  zero is equivalent to changing  the model to a global  profile HMM.            For more information, see Eddy,  et al. (Curr. Opin. Struct. Biol., 6; 361-365 (1996)) and  the Eddy lab  website at  http://hmmer.wustl.edu/eddy/ .           CONSIDERATIONS    [  Previous  |  Top  |  Next  ]          If you use the default  Dirichlet mixture priors, you can  obtain a good profile HMM  with as few as ten  or  twenty aligned sequences.    You should calibrate a profile  HMM with HmmerCalibrate before using  it with HmmerSearch or  HmmerPfam.  This will ensure  a more sensitive search, with  better chances of finding distantly  related  homologs to your original sequences.    HmmerBuild, unlike the original hmmbuild  program, will overwrite existing profile  HMMs without  asking your permission.    When you specify option  -MATR ix   to use a heuristic substitution  matrix-based prior, the default  Dirichlet prior is unaffected.   Therefore in principle you could  use options  -DIRI chlet  and  -MATR ix   together, but this is not  recommended, since it has not  been tested.  (Option  -MATR ix   itself has not  been tested extensively.)        COMMAND-LINE SUMMARY    [  Previous  |  Top  |  Next  ]          All parameters for this program  may be added to the  command line.  Use  -CHE ck   to view the summary  below and to specify parameters  before the program executes.   In the summary below, the  capitalized  letters in the parameter names  are the letters that you   must  type in order to  use the parameter.  Square brackets ([ and ])  enclose parameter values that are  optional.  For more information,  see ""Using  Program Parameters"" in Chapter 3,  Using Programs in the User's  Guide.      Minimal Syntax: % hmmerbuild [-INfile1=]hsp70.msf{*} -Default    Prompted Parameters:    [-OUTfile=]hsp70.hmm_g  names the output file    -MENu=g                 sets model type to multiple global       l                 sets model type to multiple local       b                 sets model type to single global       c                 sets model type to single local    Local Data Files:  None Optional Parameters:    -BEGin1=1 -END1=100     sets the range of interest for each sequence    -SWENtry=0.5            assigns the probability that a local alignment will                           begin at the leftmost end of the model (applies only                           if the model type is l or c) -SWEXit=0.5             assigns the probability that a local alignment will                           end at the rightmost end of the model (applies only                           if the model type is l or c) -PROtein                insists that the sequence alignment is amino acid -DNA                    insists that the sequence alignment is nucleic acid -ARCHprior=0.85         sets the architecture prior used by MAP construction                           algorithm -FASt                   determines model architecture quickly and heuristically                           by assigning columns with more than a certain                           fraction of gap characters to insert states   -GAPS=0.5             sets the minimum fraction of gaps for the -FASt option -NULlmodel=amino.null   uses the null model given in amino.null instead of the                           default null model -DIRIchlet=amino.pri    uses Dirichlet prior information from amino.pri in                           place of the default Dirichlet priors -MATRix=PAM30           uses a heuristic prior based on the PAM30 substitution                             matrix instead of the default Dirichlet priors   -MATWeight=20.0         sets the number of pseudocounts contributed by the                             substitution matrix-based prior -NOEffseqnum            uses the true number of sequences instead of the                           effective sequence number -WEIghting=B            uses the BLOSUM filtering algorithm to weight the                           sequences            M            uses the Krogh/Mitchison maximum entropy algorithm to                           weight the sequences            V            uses the Sibbald/Argos Voronoi sequence weighting                           algorithm to weight the sequences            N            turns off built-in sequence weighting -CLUSTERLevel=0.62      controls determination of effective sequence number and                            sets the clustering threshold when using the                            -WEIghting=B option -NAME=myhmm             sets the internal (not file) name of the profile HMM -APPend                 appends this profile HMM to an existing hmm file -BINary                 writes the profile HMM to hmm file in HMMER binary                           format instead of readable ASCII text -VERbose                prints extra information, such as the individual scores                           for each sequence in the alignment -NOMONitor              doesn't display information about analysis parameters                           used             ACKNOWLEDGEMENT    [  Previous  |  Top  |  Next  ]          The programs comprising the HMMER  package are designed and implemented  by Dr. Sean Eddy of the  Washington University School of Medicine,  St. Louis, Missouri.  The GCG  front-end programs were  written by Christiane van Schlun  in collaboration with Dr. Eddy.    Pfam - A database of  protein domain family alignments and  HMMs Copyright (C) 1996-2000 The  Pfam  Consortium.        PARAMETER REFERENCE    [  Previous  |  Top  |  Next  ]          You can set the parameters  listed below from the command  line.  For more information,  see ""Using  Program Parameters"" in Chapter 3,  Using Programs in the User's  Guide.              Following some of the parameters  described below is a short  expression in parentheses.  These  are the  names of the corresponding parameters  used in the native HMMER  package.  Some of the  GCG  parameters are identical to the  original HMMER parameters, others have  been changed to fit GCG's  conventions.             -BEG in =1          sets the beginning position for  all sequences in the alignment.   When beginning positions are  specified for individual sequences in  a list file, HmmerBuild ignores  the beginning position set on  the command line.        -END=100          sets the ending position for  all sequences in the alignment.   When ending positions are  specified  for individual sequences in a  list file, HmmerBuild ignores the  ending position set on the  command line.        -MEN u =G      ( -g, -f, -s )         sets the model to be  configured to a specific type  of alignment to a target  sequence: multiple  global alignments (G), single global  alignment (B =  -g ), multiple  local alignments (matching  partial domains) (L =  -f ),  single local alignments (C =   -s ).             -SWEN try =0.5      ( --swentry 0.5 )         When  -MEN u =L  or  -MEN u =C , this  parameter gives you control over  the local  vs  global  alignment behavior at the left  (N- or 5'-terminal) side of  the model.  The default  value is  0.5 and the value may  range from 0.0 to 1.0,  inclusive.    Values greater than 0.5 increase  the penalty for matches that  start at the very beginning  of the model and thus  favor local matches on that  side of the model.   Values less than 0.5,  on the other hand, favor  global matches (those that start  at the very beginning of  the  model) on that side.   Thus setting  -SWEN try  to 0.0  constrains the alignment to start  at  the beginning of the model  and setting it to 1.0  constrains it not to start  at the beginning  of the model.        -SWEX it =0.5      ( --swexit 0.5 )         When  -MEN u =L  or  -MEN u =C , this  parameter gives you control over  the local  vs  global  alignment behavior at the right  (C- or 3'-terminal) side of  the model.  The default  value is  0.5 and the value may  range from 0.0 to 1.0,  inclusive.    Values greater than 0.5 increase  the penalty for matches continuing  to the very end of  the  model and thus favor local  matches on that side of  the model.  Values less  than 0.5, on the  other hand, favor global matches  (those that continue to the  very end of the model)  on that  side.  Thus setting  -SWEX it   to 0.0 means that the  end of the alignment must  coincide  with the end of the  model and setting it to  1.0 constrains it not to  end at the end of  the  model.             -PRO tein      ( --amino )         insists that the sequence alignment  is amino acid.  Normally  HmmerBuild autodetects whether  the sequences are protein or  DNA, but if the sequences  are too short, the autodetect  algorithm  may fail.        -DNA      ( --nucleic )         insists that the sequence alignment  is nucleic acid.  Normally  HmmerBuild autodetects whether  the sequences are protein or  DNA, but if the sequences  are too short, the autodetect  algorithm  may fail.        -ARCH prior =0.85      ( --archpri 0.85 )         sets the  architecture prior  used  by MAP architecture construction.   The default is 0.85 and  the  value may range from 0.0  to 1.0, inclusive.  This  parameter governs a geometric prior  distribution over model lengths.   Higher values mean longer models  are favored  a priori .   Lower  values require greater conservation in  a column before it is  regarded as a ""consensus"" match  column in the model architecture.        -FAS t      ( --fast )         determines the architecture of the  model heuristically by assigning all  columns with more than a  certain fraction of gap characters  to insert states.  This  is faster than using the  default MAP  algorithm.             -GAPS=0.5      ( --gapmax 0.5 )         sets the fraction of gap  characters in a column that  will cause that column to  be assigned  to the insert state when  the  -FAS t  parameter is used.   If a column contains  a higher  fraction of gap symbols than  this, it gets assigned to  an insert column.  The  value can lie  between 0.0 and 1.0, inclusive,  and is set to 0.5  by default.  Higher values  mean more  columns get assigned to the  match state, resulting in a  longer model;  with smaller values,  fewer columns are assigned to  the match state, and the  length of the model is  shorter.             -NUL lmodel =amino.null      ( --null amino.null )         reads null model data from  the file amino.null instead of  using the default null model.   By  default, protein sequences use the  amino acid frequencies from release  34 of the SWISS-PROT  database and  p1  = 350/351;  for nucleic acids each base  is assigned the frequency 0.25  and  p1  =  1000/1001.        -DIRI chlet =amino.pri      ( --prior amino.pri )         reads Dirichlet prior data from  a file named amino.pri, instead  of using the default Dirichlet  priors mixture.        -MATR ix =PAM30      ( --pam PAM30 )         specifies a substitution matrix to  use for a heuristic substitution  matrix-based prior in place of  the default Dirichlet priors mixture.   The matrix must be  in  BLAST  matrix format.   If  HmmerBuild can't find the matrix  you specified in your working  directory, it automatically looks  in the directory associated with  the logical name BLASTMAT.             -MATW eight =20.0      ( --pamwgt 20.0 )         the number of pseudocounts contributed  by the heuristic prior when  a substitution  matrix-based prior is specified with  the  -MATR ix  parameter.  Any  positive real number  may be used; the default  value is 20.0.  Very  high values can force the  scoring system to be  entirely driven by the substitution  matrix, making a profile HMM  behave similarly to a  Gribskov profile.             -NOE ffseqnum      ( --noeff )         turns off the effective sequence  number calculation, and uses the  true number of sequences  instead.  This will usually  reduce the sensitivity of the  final model.        -WEI ghting =B      ( --wblosum )         uses the BLOSUM filtering algorithm  to weight the sequences.   Sequences at a given percent  identity are clustered, and each  cluster is assigned a total  weight of 1.0, distributed equally  among the members of that  cluster.        -WEI ghting =M      ( --wme )         uses the Krogh-Mitchison maximum entropy  algorithm to weight the sequences.   This  supercedes the Eddy-Mitchison-Durbin maximum discrimination  algorithm, which gives almost  identical weights but is less  robust.  Maximum entropy weighting  seems to give a marginal  increase in sensitivity over the  default GSC weights, but takes  a fair amount of time.        -WEI ghting =V      ( --wvoronoi )         uses the Sibbald-Argos Voronoi sequence  weighting algorithm in place of  the default GSC  weighting.        -WEI ghting =N      ( --wnone )         turns off all sequence weighting.        -CLUSTERL evel =0.62      ( --idlevel 0.62 )         controls the determination of effective  sequence number and the behavior  of the  -WEI ghting =B   option.  The sequence alignment  is clustered by percent identity,  and the number of clusters  at  the set cutoff threshold is  used to determine the effective  sequence number.  Higher values  give  more clusters and higher effective  sequence numbers; lower values give  fewer clusters and lower  effective sequence numbers.  The  default is 0.62, corresponding to  the clustering level used in  constructing the BLOSUM62 substitution matrix,  and the value needs to  be between 0.0 and 1.0,  inclusive.        -NAME=myhmm      ( -n myhmm )         sets the internal name (not  file name) of the profile  HMM.        -APP end      ( -A )         appends this model to an  existing HMM file, specified by   -OUT file , rather than overwriting it.  Useful for building profile HMM  libraries (like Pfam).        -BIN ary      ( --binary )         writes the profile HMM to  an HMM file in HMMER  binary format instead of readable  ASCII  text.        -VER bose      ( --verbose )         prints additional information to the  screen, such as the individual  scores for each sequence in  the  alignment.        -NOMON itor          suppresses the display of the  program's progress on the screen.                 Printed: February 5, 2001  11:38 (1162)           [  Program Manual  |  User's Guide  |  Data Files  |  Databases  ]       Documentation Comments:  doc-comments@gcg.com  Technical Support:  help@gcg.com      Copyright (c) 1982-2001  Genetics Computer Group  Inc.  A subsidiary of Pharmacopeia, Inc.  All rights reserved.    Licenses and Trademarks Wisconsin Package is a trademark of  Genetics Computer Group , Inc.  GCG and the GCG logo are registered trademarks of  Genetics Computer Group , Inc.    All other product names mentioned in this documentation may be trademarks, and if so, are trademarks or registered trademarks of their respective holders and are used in this documentation for identification purposes only.       www.gcg.com"
GX237-13-11156634	"The JHU/APL HAIRCUT System at TREC-8 James Mayfield, Paul McNamee and Christine Piatko The Johns Hopkins University Applied Physics Laboratory 11100 Johns Hopkins Road Laurel, MD 20723-6099 USA James.Mayfield@jhuapl.edu Paul.McNamee@jhuapl.edu Christine.Piatko@jhuapl.edu  Goals The Johns Hopkins University Applied Physics Laboratory (JHU/APL) is a second-time entrant in the TREC Category A evaluation. The focus of our information retrieval research this year has been on the relative value of and interaction among multiple term types and multiple similarity metrics. In particular, we are interested in examining words and n-grams as indexing terms, and vector models and hidden Markov models as similarity metrics. Approach The Hopkins Automated Information Retriever for Combing Unstructured Text (HAIRCUT) system was built to explore the use of multiple term types, including words, stemmed words, multi-word phrases and character n-grams of various lengths. The system is implemented in Java for ease of development and portability. It supports both a vector model and a hidden Markov model (HMM) for comparing queries against documents. Under the vector model, terms are usually weighted by TF/IDF. Okapi BM 25 [Walker et al., 1998] and plain TF weightings are also supported. Cosines can be computed either relative to the origin, or relative to the corpus centroid. Terms that appear in a high percentage of documents are stop-listed. The HAIRCUT HMM is a simple two-state model capturing both document and collection statistics [Miller et al., 1999]. HAIRCUT also supports breaking documents into passages, although to date we have received no significant boost in average precision from doing so. HAIRCUT performs rudimentary preprocessing on queries to remove stop structure [Allan et al., 1998], e.g., affixes such as ""... would be relevant"" or ""relevant documents should..."". Other than this preprocessing, queries are parsed in the same fashion as are documents in the collection.  After the query is parsed and appropriately weighted (TF/IDF for the vector model, TF for the HMM; query section term-weighting was not used), an initial retrieval is performed with a single round of blind relevance feedback. We found a 27.6% relative increase in average precision on the TREC-7 ad hoc task when using relevance feedback. To perform relevance feedback, HAIRCUT first retrieves the top 1000 documents. The top 20 documents are then used for positive feedback, and the bottom 75 documents for negative feedback. Query terms are reweighted using the Rocchio score (=3, =2, =2) and an affinity score, which is a function of the term's frequency in the retrieved documents and its frequency in the collection as a whole. The topscoring terms, ignoring very high and very low frequency terms, are then used as the revised query. After retrieval using this expanded and reweighted query, we have found a slight improvement by penalizing document scores for documents missing many query terms. We multiply document scores by a penalty factor: 1.25  # of missing terms  PF = 1.0 -    number of terms in query  We use only about one-fifth of the terms of the expanded query for this penalty function: # Top Terms # Penalty Terms words 60 12 6-grams 400 75 We conducted our work on a shared 4-node Sun Microsystems Ultra Enterprise 450 server. The workstation had 2 GB of physical memory and access to 50 GB of hard disk space. The HAIRCUT system comprises approximately 25,000 lines of Java code. For TREC-8 we tested three types of terms: stemmed words, 6-grams and phrases. After eliminating   Figure 1. JHU/APL TREC-8 Ad Hoc Results 100%  90%  80%  70%  60%  apl8c221 apl8c621 apl8p apl8n apl8ctd  Precision  50%  40%  30%  20%  10%  0% 0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%  Recall  punctuation, downcasing letters, and mapping numbers to a single digit, a word was any remaining blank-delimited sequence of characters. For n-grams we used 6-grams formed from the same character stream used for selecting words. In TREC-7 we used  5-grams [Mayfield & McNamee 1999], but we have found 6-grams to be preferable for English. Our use of 6-grams for other languages is based on convenience, not proven superiority.  Figure 2. APL TREC-8 Ad Hoc Results Three Baseline Runs and One Merged Run 100% 90% 80%  (31.5%) Combo: 2:2:1 70%  (29.1%) stems, HMM (28.9%) 6-grams, HMM (23.4%) 6-grams, cosine  Precision  60% 50% 40% 30% 20% 10% 0% 0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%  Recall   Figure 3. JHU/APL TREC-8 Ad Hoc Base Runs by Topic 100% 90% 80% Average Precision 70% 60% 50% 40% 30% 20% 10% 0% Topic TREC-8 best automatic TREC-8 median automatic base run 1: stem HMM base run 2: 6-gram HMM base run 3: 6-gram cosine base run 4: phrases  Our focus this year was on combining evidence from multiple runs. We varied three system features to obtain runs that were then merged:  use of a vector model versus use of a hidden Markov model;  use of n-grams as terms versus use of words or stemmed words as terms; and  use of phrases. We used two different methods for merging these runs. In most cases we used linear combination of normalized scores. Scores were normalized simply by scaling the range of scores exhibited by the top 1000 documents to the range 0..1. In one case, we selected the retrieval technique on a per-query basis. Ad hoc Results The JHU/APL submissions were based on four underlying retrieval runs:  stemhmm: an HMM run using stemmed words, with =0.3.  sixhmm: an HMM run using 6-grams, using =0.15.  sixcos: a vector-based run using 6-grams as terms and TF/IDF term weighting.  phrase: an HMM run using common stem bigrams, in addition to individual stems, as terms. Our phrase list comprised one million stem pairs. JHU/APL submitted five ad hoc runs. All underlying runs were first normalized as described above. Four runs were based on topic/description/narrative (TDN); one run, as required by the TREC-8 rules, was based on topic and description (TD) only:  apl8c221: A linear combination of stemhmm, sixhmm, and sixcos, with scores from both stemhmm and sixhmm receiving twice the weight of sixcos.  apl8c621: A linear combination comprising six parts stemhmm, two parts sixhmm, and one part sixcos.    Figure 4. JHU/APL TREC-8 Official Ad Hoc Runs by Topic 100% 90%  Average Precision  80% 70% 60% 50% 40% 30% 20% 10% 0%  Topic TREC-8 median automatic TREC-8 best automatic apl8c221 apl8c621 apl8p   Figure 5. JHU/APL TREC-8 CLIR Performance 100% 90% 80% 70% Precision 60% 50% 40% 30% 20% 10% 0% aplxl1 aplxl2 aplxl3 aplxl4  0%  10%  20%  30%  40%  50% Recall  60%  70%  80%  90%  100%  apl8p: A query-by-query combination of apl8c221 and phrase, in which queries that the system judged likely to benefit from phrases were handled exclusively by the phrase run, while the remaining queries were handled exactly as in apl8c221.  apl8n: sixhmm unmodified, submitted as a test of the efficacy of raw n-grams.  apl8ctd: A TD run combining stemhmm, sixhmm, and sixcos in a 2:2:1 ratio. Our official results for these five runs are shown in Figure 1. Aggregate numbers for the base and submitted runs are as follows: Average precision 0.2914 0.2885 0.2340 0.2850 0.3150 0.3126 0.3154 0.2885 0.2860 Relevant retrieved 3156 3061 2919 3153 3332 3335 3295 3061 3117 Precision @100 0.2378 0.2436 0.2106 0.2410 0.2558 0.2558 0.2568 0.2436 0.2324    Figure 2 shows the aggregate improvement obtained by combining three base runs to form apl8c221. Figure 3 shows the average precision for each of the fifty TREC-8 ad hoc topics produced by our four base runs. The chart shows wide variability in the responsiveness of queries to the four techniques. As shown in Figure 4, our linear combination method manages to outperform each of the base methods in aggregate by performing in the upper half of the range of base scores for most queries. Our phrase combination method, also shown in Figure 4, is a first attempt to select a retrieval method on a query-byquery basis. Cross Language Track JHU/APL was a first-time entrant in the CLIR track at TREC-8. We used SYSTRAN to translate English queries into German, French and Italian, HAIRCUT to perform both word-based and n-grambased retrieval on the four collections, and linear combination of normalized scores to combine the eight runs. We found that different languages responded differently to words and n-grams; thus (except for run aplxl2) within each language we used the following weights to combine the two types of runs (which weights were derived from training on the TREC-7 CLIR task): English French German Italian 6-grams 1.0 3.3 3.5 1.0 Words 3.0 1.0 1.0 1.2  stemhmm sixhmm sixcos phrase apl8c221 apl8c621 apl8p apl8n apl8ctd  Our submitted TDN runs exhibited eight of the top scores over the fifty queries; our single TD run exhibited four bests: Task pool Best At or above median apl8c221 automatic TDN 0 40 apl8c621 automatic TDN 4 39 apl8p automatic TDN 1 39 apl8n automatic TDN 3 30 apl8ctd automatic TD 4 37   F i gure 6. Words and n-gr am bas e runs for the four CL IR l anguages . Englis h 100 % 10 0%  Fr ench  90 %  90 %  80 %  80 %  70 %  70 %  P r ecis ion  50 %  P r ecis ion 0% 10% 20% 30 % 40% 50 % 6 0% 70 % 8 0% 90 % 100 %  60 %  60 %  50 %  40 %  40 %  30 %  30 %  20 %  20 %  10 %  10 %  0%  0% 0% 10 % 20% 30 % 40 % 50 % 6 0% 7 0% 8 0% 9 0% 10 0%  Recall (25.38% ) 6- gr am s (24.81% ) Wor ds  Recall (33.55% ) 6- gr am s (35.74% ) Wor ds  Ger man 100 % 10 0%  It alian  90 %  90 %  80 %  80 %  70 %  70 %  P r ecis ion  50 %  P r ecis ion 0% 10% 20% 30 % 40% 50 % 6 0% 70 % 8 0% 90 % 100 %  60 %  60 %  50 %  40 %  40 %  30 %  30 %  20 %  20 %  10 %  10 %  0%  0% 0% 10 % 20% 30 % 40 % 50 % 6 0% 7 0% 8 0% 9 0% 10 0%  Recall (28.29% ) 6- gr am s (16.14% ) Wor ds  Recall (23.91% ) 6- gr am s (24.09% ) Wor ds  We submitted four CLIR runs: 1. aplxl1: A combination that weighted the languages as follows: English French German Italian 2.3 2.0 2.0 1.8 These weights were also derived from training on the TREC-7 CLIR task. It is unclear whether these weights optimize average precision on the TREC-7 task because of differing HAIRCUT performance on the various languages, because of the number of relevant documents in the various languages, or because of other factors. 2. aplxl2: A two-phase combination, in which the languages were first individually combined using the following weights:  English French German Italian 6-grams 1.0 2.5 8.5 1.0 Words 6.0 1.0 1.0 1.5 The resulting combined runs were then merged using these weights: English French German Italian 2.0 1.1 1.1 0.6 As with aplxl1, these weights were trained from the TREC-7 CLIR task. 3. aplxl3: A combination that weighted the four languages evenly: English French German Italian 1.0 1.0 1.0 1.0 4. aplxl4: A combination that weighted English as 1.5, and the other languages as 1.0:   English French German Italian 1.5 1.0 1.0 1.0 Results from these four runs are shown in Figure 5. The eight base runs are shown in Figure 6. Aggregate numbers for our submitted CLIR runs are as follows: Average Relevant Precision precision retrieved @100 aplxl1 0.2571 1911 0.2714 aplxl2 0.2471 1944 0.2782 aplxl3 0.2542 1890 0.2711 aplxl4 0.2389 1902 0.2575 The similarity of these runs lead us to believe that tuning weights under this approach to merging is not a cost-effective use of one's time. Our monolingual results for the four languages, using the human-translated queries provided by NIST, were significantly below those seen on the TREC-7 CLIR task: English French German Italian T8 Words 0.2481 0.3780 0.2525 0.3152 T8 6-grams 0.2538 0.3342 0.3933 0.2778 T7 Words 0.4533 0.3715 0.3671 0.3936 T7 6-grams 0.4363 0.3767 0.4143 0.3281 The reasons for this drop in performance are unclear. Given HAIRCUT's average precision of 31.5% on the TREC-8 ad hoc task, it seems unlikely that the drop in English performance is due to some sort of overtraining on the TREC-7 data. We note a significant drop in the number of relevant documents for the TREC-8 CLIR task, which may play a role: English French German Italian TREC-7 1689 991 917 501 TREC-8 956 578 717 170 Query Track JHU/APL also participated in the query track. We generated four query sets, although space aliens in black helicopters managed to prevent two of them from appearing in the official query track collection. These latter two were generated by hand, by reading the narrative version of each source query and generating a title query and a description query for each. Our first official query set (APL5a) was created using a variant of the mutual information statistic [Church & Hanks 1990] to extract important terms from the top 75 documents retrieved for the source query. Our second set (APL5b) used the same statistic to extract important terms from the query track training set. All terms in these query sets were unstemmed words; we did not anticipate that other systems could make use of n-grams.  We used a single each of the 23 configuration used hidden Markov mo  system configuration to process query track query sets. This unstemmed words as terms, and a del to gauge document similarity.  Our results showed tremendous variability in result quality across the 23 query sets. The following table shows HAIRCUT's performance on each query set, the average performance over all eight runs submitted by five different groups to the query track, and HAIRCUT's percentage above or below the all systems average. Our best results were obtained from APL5b, which was developed using training data. For further details on the query track, see the Query Track Overview paper in these proceedings. HAIRCUT Average precision 0.2521 0.2471 0.2912 0.1697 0.2089 0.2261 0.2061 0.2300 0.1622 0.1990 0.2658 0.2208 0.2533 0.1486 0.1292 0.1293 0.1601 0.1758 0.2603 0.2550 0.2791 0.2405 0.2627 Rel. ret. 5553 5648 6242 4261 4902 5195 4901 4480 4201 4673 5427 5367 5440 3725 3766 3430 4220 4470 5999 5610 5946 5555 5816 Prec. @100 0.3316 0.3300 0.4192 0.2242 0.2642 0.2934 0.2788 0.2796 0.2180 0.2586 0.3386 0.2862 0.3222 0.2050 0.1980 0.1716 0.2078 0.2382 0.3590 0.3312 0.3636 0.3040 0.3558 All systs. average prec. 0.2449 N/A N/A 0.1771 0.2124 0.2259 0.1919 0.2269 0.1612 0.1869 0.2407 0.2022 0.2388 0.1320 0.1182 0.1299 0.1578 0.1754 0.2464 0.2384 0.2504 0.2533 0.2364 Diff. in avg. 2.9% N/A N/A -4.2% -1.6% 0.1% 7.4% 1.4% 0.6% 6.5% 10.4% 9.2% 6.1% 12.6% 9.3% -0.5% 1.5% 0.2% 5.6% 7.0% 11.5% -5.1% 11.1%  acs1a APL5a APL5b INQ1a INQ1b INQ1c INQ1d INQ1e INQ2a INQ2b INQ2c INQ2d INQ2e INQ3a INQ3b INQ3c INQ3d INQ3e pir1a Sab1a Sab1b Sab1c Sab3a  Conclusions We had good results using a simple linear combination of scores across several HAIRCUT runs. In general, HMMs outperformed the vector model, while n-grams and words were roughly comparable on average. Using run combination, HAIRCUT sees an 8% relative gain on the ad hoc task over the best base run. Such combination is low risk; we have never found a drop in average precision over fifty or more queries. Furthermore, effective combination does not require disparate systems. A single system can produce the required variability simply by using different term types or similarity metrics. Availability of both words and n-grams also helped us significantly in the cross-language task, for which   HAIRCUT was a first-time participant. HAIRCUT exhibited 79% recall at 1000 on the CLIR task, and a high average precision relative to retrieval using human-translated queries. References [Allan et al., 1998] James Allan, Jamie Callan, W. Bruce Croft, Lisa Ballesteros, Don Byrd, Russell Swan, and Jinxi Xu, `INQUERY does battle with TREC-6.' In E. M. Voorhees and D. K. Harman, eds., The Sixth Text REtrieval Conference (TREC-6). NIST Special Publication 500-240, pp. 169-206, 1998. [Church & Hanks 1990] Kenneth Ward Church and Patrick Hanks, `Word association norms, mutual information, and lexicography.' Computational Linguistics 16(1):22-29, 1990. [Mayfield & McNamee 1999] James Mayfield and Paul McNamee, `Indexing using both n-grams and words.' In E. M. Voorhees and D. K. Harman, eds., The Seventh Text REtrieval Conference (TREC-7). NIST Special Publication 500-242, pp. 419-423, 1999. [Miller et al., 1999] David R. H. Miller, Tim Leek and Richard M. Schwartz, `BBN at TREC7: Using Hidden Markov Models for Information Retrieval.' In E. M. Voorhees and D. K. Harman, eds., The Seventh Text REtrieval Conference (TREC-7). NIST Special Publication 500-242, pp. 133-142, 1999. [Walker et al., 1998] S. Walker, S. E. Robertson, M. Boughanem, G. J. F. Jones and Karen Sparck Jones, `Okapi at TREC-6, Automatic ad hoc, VLC, routing, filtering and QSDR.' In E. M. Voorhees and D. K. Harman, eds., The Sixth Text REtrieval Conference (TREC-6). NIST Special Publication 500-240, pp. 125-136, 1998."
GX050-24-2301068	"HMMERBUILD     [  Program Manual  |  User's Guide  |  Data Files  |  Databases  ]      Table of Contents      FUNCTION   DESCRIPTION   EXAMPLE   OUTPUT   INPUT FILES   RELATED PROGRAMS   RESTRICTIONS   SPECIFYING SEQUENCES FOR HMMERBUILD   ALGORITHM   CONSIDERATIONS   COMMAND-LINE SUMMARY   ACKNOWLEDGEMENT   PARAMETER REFERENCE                       FUNCTION    [   Top  |  Next  ]          HmmerBuild creates a position-specific scoring  table, called a profile hidden  Markov model (HMM),  that is a statistical model  of the consensus of a  multiple sequence alignment.  The  profile HMM can be  used for database searching (HmmerSearch),  sequence alignment (HmmerAlign) or generating  random  sequences that match the model  (HmmerEmit).        DESCRIPTION    [  Previous  |  Top  |  Next  ]          HmmerBuild provides a Wisconsin Package  interface to the hmmbuild program  of Dr. Sean Eddy's  HMMER package.  It allows  you to access most of  hmmbuild's parameters from the Wisconsin  Package  command line.    HmmerBuild creates a profile hidden  Markov model from a group  of aligned sequences.  A  profile HMM  is a mathematical model that  represents the primary structure consensus  of a sequence family.   The  output from HmmerBuild is a  file that contains an ASCII  text representation of the profile  HMM.    This profile HMM file can  be used as input to  several other programs in the  HMMER package.  HmmerSearch uses the profile HMM  as a query to find  sequences in a database that  are similar to the  aligned sequences from which the  model was built.  HmmerAlign  uses a profile HMM as  a seed to  optimally align a group of  sequences related to the model.   HmmerEmit generates random sequences  that match the profile HMM.    Instead of creating a single  profile HMM as ouput, you  also can add the resulting  profile HMM directly  to an existing HMM database  by using parameter  -APP end .    The aligned sequences may be  specified to HmmerBuild with an  ambiguous file expression or in  a list  file similar to the input  for  Pretty  or  LineUp .   (See Chapter 2, Using Sequence  Files and Databases in  the User's Guide for more  information.)        EXAMPLE    [  Previous  |  Top  |  Next  ]          Here is a session using  HmmerBuild to make a profile  HMM from aligned 75 kd  heat shock and heat  shock cognate peptide sequences (these  sequences were aligned in the  example session for  PileUp ):          %  hmmerbuild    HMMERBUILD of what aligned sequences ?   hsp70.msf{*}    Type of alignments/searches model should lead to:     G Global    L Local    B Single global    C Single local   Choose a model (* G *) :   Setting model type to global.   What should the output file be called (* hsp70.hmm_g *)?   Creating temporary file for input to hmmbuild.   Calling hmmbuild to perform analysis ...  hmmbuild - build a hidden Markov model from an alignment HMMER 2.1.1 (Dec 1998) Copyright (C) 1992-1998 Washington University School of Medicine HMMER is freely distributed under the GNU General Public License (GPL). - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Training alignment:                hsp70.msf{*} Number of sequences:               25 Search algorithm configuration:    Multiple domain (hmmls) Model construction strategy:       MAP (gapmax hint: 0.50) Null model used:                   (default) Prior used:                        (default) Prior strategy:                    Dirichlet Sequence weighting method:         G/S/C tree weights - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Determining effective sequence number    ... done. [3] Weighting sequences heuristically        ... done. Constructing model architecture          ... done. Converting counts to probabilities       ... done. Setting model name, etc.                 ... done. [hsp70]  Constructed a profile HMM (length 677) Average score:     1633.25 bits Minimum score:     1328.99 bits Maximum score:     1777.86 bits Std. deviation:     131.34 bits  Finalizing model configuration           ... done. Saving model to file                     ... done.  [/usr/users/share/smith/hsp70.hmm_g]  %              OUTPUT    [  Previous  |  Top  |  Next  ]          Here is some of the  output file:        HMMER2.0 NAME  hsp70 LENG  677 ALPH  Amino RF    no CS    no MAP   yes COM   gcg_hmmbuild /usr/users/share/smith//hsp70.hmm__g hsp70.msf NSEQ  25 DATE  Fri Jul  9 14:09:29 1999 CKSUM 3252 XT      -8455     -4  -1000  -1000  -8455     -4  -8455     -4 NULT      -4  -8455 NULE     595  -1558     85    338   -294    453  -1158  ...  -1998   -644 HMM        A      C      D      E      F      G      H  ...      W      Y          m->m   m->i   m->d   i->m   i->i   d->m   d->d    b->m   m->e          -368      *  -2150      1    482  -1538   -242    709  -1777   -345     14 ...  -1783  -1160    27      -   -149   -500    233     43   -381    399    106 ...   -294   -249      -    -18  -6880  -7922   -894  -1115   -701  -1378   -386      *      2    209  -1369   -338    519  -1590   -486    -48 ...  -1681  -1096    28      -   -149   -500    233     43   -381    399    106 ...   -294   -249      -    -18  -6880  -7922   -894  -1115   -701  -1378      *      *  ////////////////////////////////////////////////////////////////////////////////     675   -664  -1701     33   2728  -1813  -1361   -295 ...  -1992  -1378   717      -   -149   -500    233     43   -381    399    106 ...   -294   -249      -    -24  -6511  -7553   -894  -1115   -701  -1378      *      *    676   -576   -717  -2213  -1989  -1191  -1755  -1601 ...  -1918  -1514   718      -   -149   -500    233     43   -381    399    106 ...   -294   -249      -    -24  -6511  -7553   -894  -1115   -701  -1378      *      *    677  -1248  -2485   3484    210  -3124   -286   -821 ...  -3039  -2364   719      -      *      *      *      *      *      *      * ...      *      *      -      *      *      *      *      *      *      *      *      0 //              INPUT FILES    [  Previous  |  Top  |  Next  ]          HmmerBuild accepts multiple sequences (one  or more) all of the  same type.  You can  specify multiple  sequences in a number of  ways:  by using a list file,  for example  @project.list ;  by using an  MSF or  RSF file, for example  project.msf{*} ;  or  by using a sequence specification  with an asterisk ( * )  wildcard, for example  GenEMBL:* .    The function of HmmerBuild depends  on whether your input sequence(s)  are protein or nucleotide.  Programs determine the type of  a sequence by the presence  of either  Type: N  or   Type: P  on the last  line of the text heading  just above the sequence.   If your sequence(s) are not  the correct type, turn to  Appendix VI for information on how  to change or set the  type of a sequence.        RELATED PROGRAMS    [  Previous  |  Top  |  Next  ]           PileUp  creates a multiple sequence  alignment from a group of  related sequences.   LineUp  is  a multiple  sequence editor used to create  multiple sequence alignments.   Pretty   displays multiple sequence  alignments.     ProfileMake  makes a profile from  a multiple sequence alignment.    ProfileSearch  uses the profile to  search a database for sequences  with similarity to the group  of aligned sequences.   ProfileSegments   displays optimal alignments between each  sequence in the  ProfileSearch  output  list and the group of  aligned sequences (represented by the  profile consensus).   ProfileGap  makes  optimal alignments  between one or more sequences  and a group of aligned  sequences represented as a profile.    ProfileScan   finds structural and sequence motifs  in protein sequences, using predetermined  parameters to  determine significance.    HmmerBuild makes a profile hidden  Markov model from a multiple  sequence alignment.  HmmerAlign  aligns one or more sequences  to a profile HMM.   HmmerPfam searches a database of  profile HMMs  with a sequence query in  order to identify known domains  within the sequence.  HmmerSearch  uses a  profile HMM as a query  to search a sequence database  for sequences similar to the  original aligned  sequences.  HmmerCalibrate calibrates a  hidden Markov model so that  database searches using it as  a  query will be more sensitive.   HmmerIndex creates a binary  GSI (""generic sequence index"") for  a  database of profile HMMs.   HmmerFetch retrieves a profile hidden  Markov model by name from  an  indexed database of profile HMMs.   HmmerEmit randomly generates sequences  that match a profile  HMM.  HmmerConvert converts between  different profile HMM file formats  and from profile HMM to  GCG profile file format.     MEME  finds conserved motifs in  a group of unaligned sequences  and saves these motifs as  a set of  profiles.  You can search  a database of sequences with  these profiles using the  MotifSearch   program.        RESTRICTIONS    [  Previous  |  Top  |  Next  ]          Hmmerbuild does not perform alignments.   It is your responsibility  to ensure that the sequences  input  to HmmerBuild are in alignment.    HmmerBuild  will  append the ASCII  text format HMM output to  a binary format file, when  using  parameter  -APP end , but the resulting  file will be unusable by  other programs in the HMMER  package.  It also lets  you create mixed nucleic and  protein profile HMM databases, which  will be  unusable by other programs in  the HMMER package as well.        SPECIFYING SEQUENCES FOR HMMERBUILD    [  Previous  |  Top  |  Next  ]          The sequences used to make  the profile HMM can be  specified in two ways.   (See Chapter 2, Using  Sequence Files and Databases in  the User's Guide for more  information.) A group of sequences  may be  named with an ambiguous expression  like  kf*.pep  or  pileup.msf{*} .   The sequences may also be  specified in a list file,  and a beginning and ending  position can be assigned to  each sequence in the list  with the  begin:  and  end:   sequence attributes, respectively.  (See   ""Using List Files""  in Chapter  2,  Using Sequence Files and Databases  in the User's Guide).   Make sure that the sequence  ranges you  specify will result in the  sequences being in alignment.   If you do not specify  beginning and ending  positions, the entire sequence is  used.    HmmerBuild has several built-in ways  of weighting the input sequences  (see the ALGORITHM topic  for more details).  If  you want to use your  own sequence weighting scheme, add  the appropriate  parameters to the list file,  MSF file, or RSF file  that is used as the  input file.  You must  also use the   -WEI ghting =N  parameter when invoking HmmerBuild  to turn off HmmerBuild's built-in  weighting  schemes so that yours will  take precedence.    If you are using a  list file to input your  files, you can add a  weight attribute to any line  in the list with a  text editor in order to  specify a weight for that  sequence (if no weight attribute  is present, the weight  defaults to 1.0).  For  example:               fa12.ugly    begin: 201       end: 250       weight: 0.5      fo1k.ugly    begin: 201       end: 250       weight: 1.0          You can assign weights to  sequences in an MSF file  by editing the MSF file  and modifying the weight  on the name line for  each sequence.  (See ""Using  Multiple Sequence (MSF) Files"" in  Chapter 2, Using  Sequence Files and Databases in  the User's Guide for a  complete description of MSF files.)                Name: Hs70Plafa       Len:   720  Check:  297  Weight:  0.50       Name: Hs70Thean       Len:   720  Check: 1483  Weight:  1.00          You can also edit RSF  files to add a weight  attibute to each sequence.   (See ""Using Rich Sequence  Format (RSF) Files"" in Chapter  2, Using Sequence Files and  Databases in the User's Guide  for a  complete description of RSF files.)               {      name  hs70plafa      descrip    PileUp of: @Hsp70.List      type    PROTEIN      longname  hsp70.msf{Hs70Plafa}      checksum    297      weight 0.5      creation-date 08/08/2000 15:40:21      strand  1      sequence        [...]      }      {      name  hs70thean      descrip    PileUp of: @Hsp70.List      type    PROTEIN      longname  hsp70.msf{Hs70Thean}      checksum    1483      weight 1.0      creation-date 08/08/2000 15:40:21      strand  1      sequence        [...]      }          You can use the  SeqLab   editor to assign weights to  sequences in MSF and RSF  files.  (See ""Viewing and  Editing Sequence Attribute and Reference  Information"" in Chapter 2, Editing  Sequences and  Alignments in the  SeqLab  Guide  for more information about modifying  the sequence weight attributes.)    Weights assigned in a list  file take precedence over weights  assigned within MSF or RSF  files that are  components of the list.        ALGORITHM    [  Previous  |  Top  |  Next  ]             See the Profile HMM Analysis  Essay for an introduction to  profile hidden Markov models and  the  terminology associated with them.             State Assignments          In constructing an HMM, HmmerBuild  must first determine which columns  in the alignment  should be assigned to a  match state and which to  an insert state.  The  profile HMM is then built  from this ""marked"" alignment.   By default, HmmerBuild uses maximum   a posteriori  (MAP)  construction:  a dynamic programming algorithm is  used to determine the maximum   a posteriori   choice of state for each  column in the alignment.   This algorithm can be tuned  to favor longer or  shorter models by means of  the  -ARCH prior  parameter, which can  be set to values between  0.0  and 1.0.  By default  this is set to 0.85.   To favor longer models,  set it higher;  to favor shorter  models, set it lower.    Like most dynamic programming algorithms,  MAP construction is fairly slow.   You can use a  faster heuristic method to ""mark""  the columns by specifying the   -FAS t  parameter.  The  heuristic method assigns a column  in the alignment to the  insert state if the column  contains  more than a certain fraction  of gap characters.  By  default, this fraction is 0.5.   You can change it  using the  -GAPS  parameter.    For more detailed information on  how MAP construction works, see  section 5.7, ""Optimal Model  Construction,"" in Chapter 5 of   Biological Sequence Analysis  by Richard  Durbin, et al. (Cambridge  University Press, 1998).        Probability Parameters and Pseudocounts          After determining the state assignments,  HmmerBuild must next assign the  probability  parameters for the model:  the transition  probabilities and emission probabilities.   If there are a  large number of sequences in  the alignment, this can be  done simply by counting up  the number  of times each transition or  emission is used and doing  a trivial calculation to get  the probability.  For example, if column 57  in an alignment of 100  protein sequences contains 60 L's,  10 I's, 9 V's,  two each of M, A,  T and S, and one  each of the remaining amino  acids, the emission probabilities  would be 0.6 for L,  0.1 for I, 0.09 for  V, 0.02 for M, A,  T, and S, and 0.01  for each of the remaining  13 amino acids.    Unfortunately, for alignments containing a  small number of sequences the  observed counts may  not be representative of the  family as a whole.   For example, an alignment containing  only 20 of  the sequences from the example  above may contain all L's  in column 57, resulting in  an  emissions probability of 1.0 for  L and 0.0 for all  other amino acids.  So  there must be a way  of  adjusting the probabilities to account  for unobserved data.    One approach is to add  pseudocounts to the observed counts  so that no zero probabilities  can  occur.  A simple way  is to just add one  to all counts.  More  accurate adjustments can be obtained  by using prior knowledge about  the behavior of sequence families  to adjust the counts.   Two ways  of applying prior knowledge are  substitition matrices and Dirichlet distributions.    The more intuitive method for  most biologists is the use  of substitution matrices.  With  this  heuristic method, entries in a  substitution matrix are converted into  conditional probabilities  that are used to derive  the pseudocounts.  However, the  default method used by HmmerBuild  is  to use a mixture of  Dirichlet distributions as the prior,  because this has a well-founded  theoretical basis.  This method  has been shown to create  good profile HMMs from alignments  containing as few as 10  or 20 sequences.  (Use  the  -MATR ix  parameter if you  want to override  the default and have HmmerBuild  use the substitution matrix method  rather than Dirichlet  priors.)    You can override the default  Dirichlet priors used by HmmerBuild  by providing your own prior  information in a file.   Use the  -DIRI chlet  parameter to  specify this file.  Files  containing the  default prior information are available  to use as models.   These are GenMoreData:amino.pri and  GenMoreData:nucleic.pri.  For a more  detailed description of the file  format, go to   http://hmmer.wustl.edu/hmmer-html/node34.html .    For more information on how  priors work, see section 5.6,  ""More on estimation of probabilities,""  in Chapter 5 of  Biological  Sequence Analysis  by Richard Durbin,  et al. (Cambridge University  Press, 1998).        Null model for profile HMMs          Alignments between profile HMMs and  sequences are scored by computing  a log-odds score  relative to a  null model   of random sequence composition.   The default null model contains  the  expected background occurrence frequencies of  each residue type plus a  parameter called  p1   that controls the expected length  of the randomly generated sequences.   When a profile HMM  is  built, HmmerBuild stores information about  the null model that was  used to create it along  with  the HMM itself.    For proteins, the frequencies for  each of the 20 amino  acids are set to their  observed frequencies  in release 34 of the  SWISS-PROT database and  p1  is  set to 350/351, which implies  that the  expected mean length of a  protein is about 350 residues.   For nucleic acid sequences,  each of the  four nucleotides is assigned a  frequency of 0.25, and  p1   is set to 1000/1001.    You can override this default  null model by providing your  own null model information in  a file.  Use the  -NUL lmodel  parameter to  inform HmmerBuild of the name  of the file.  Files  containing  the default null model information  are available to use as  models.  These are  GenMoreData:amino.null and GenMoreData:nucleic.null.  For  a more detailed description go  to   http://hmmer.wustl.edu/hmmer-html/node33.html .        Weighting the Sequences in the  Alignment          Usually one's sequence alignments do  not contain a good random  sample of all possible  sequences belonging to the family,  but instead may contain a  group of very closely related  sequences plus a number of  more distantly related sequences.   To account for this distorted  representation of a sequence family,  closely related sequences in the  alignment should have less  individual effect on the final  probability distribution than sequences highly  diverged from all  other sequences in the alignment.   For example, if the  same sequence occurs twice in  your  alignment, each instance of this  sequence should get only half  the weight of a single  sequence.  HmmerBuild provides several built-in weighting  schemes.    By default an algorithm proposed  by Gerstein, Sonnhammer, and Clothia  is used.  An  evolutionary tree of the sequences  in the alignment serves as  a guide to weight each  sequence.  Starting at the leaves of  the tree (level N), the  GSC algorithm assigns each sequence  a weight  equal to its distance to  its parent node at the  next higher level (level N-1)  in the tree.  At  level  N-1, the distance to the  parent node at level N-2  is shared among all sequences  in the subtree  below.  A fraction of  that distance, proportional to their  current weight, is added to  the weights  for each sequence.    Another available weighting scheme is  the BLOSUM filtering algorithm ( -WEI ghting =B ).   This  is based on the same  concept that was used to  create the BLOSUM substitution matrices.   The  sequences are clustered depending on  their percent identity; by default  using 62 percent identity  ( -CLUSTERL evel =0.62 ) as the cutoff for  each cluster (as for the  BLOSUM62 matrix).  Each  cluster is assigned a weight  of 1.0, which in turn  is distributed evenly among all  sequences in the  cluster.    The third algorithm is Krogh-Mitchison  maximum entropy weighting ( -WEI ghting =W ), which  is  a more robust version of  the older Eddy-Mitchison-Durbin algorithm.   The original algorithm  determines a weight at each  position of a sequence by  weighting the least common residue  at  that position in the alignment  most heavily, and the most  common residue least heavily.   These  positional weights are then averaged  to give an overall weight  for the sequence.  The  Krogh-Mitchison version doesn't compute a  simple average over the positional  weights, but  instead uses an entropy maximization  method.  It gives a  slight increase in sensitivity over  the  default GSC weighting method, at  the expense of increased computing  time.    A fourth weighting scheme uses  the Sibbald-Argos Voronoi weighting algorithm  ( -WEI ghting =V ).  The idea is  to picture how all sequences  from a family lie in  ""sequence space.""  Some sequences will lie close  together (be clustered) while other  ones will lie far apart  from any  other sequence.  Weights are  assigned proportional to the empty  space around each sequence.    Lastly you can choose to  disable all built-in weighting schemes  ( -WEI ghting =N ).  Normally you  would do this only if  you are providing your own  weights for the sequences.    For more information on the  built-in weighting schemes, see Section  5.8, ""Weighting training  sequences,"" in Chapter 5 of   Biological Sequence Analysis  by Richard  Durbin, et al. (Cambridge  University Press, 1998).        Alignment type incorporated in HMM          The HMMER programs differ from  commonly used sequence comparison and  alignment  programs in that the type  of alignment you want to  eventually perform with the profile  HMM  (global or local) must be  specified at the time the  model is built, rather than  at the time it is  used.  (Note that this  is with respect to the  model only; if the test  sequence is longer than the  model, the entire model may  align within the sequence and  thus be local with respect  to the  sequence and global with respect  to the model.)    For a global alignment to  a model, the entire profile  HMM is aligned with the  test sequence.  This is equivalent to aligning  the entire original sequence alignment  from which the model is  built to a segment within  the test sequence.  For  a local alignment, only part  of the profile HMM  need be aligned with the  sequence.  This is equivalent  to finding the best section  of the original  alignment that matches the test  sequence.    Another alignment characteristic that is  built into the model is  whether to find single or  multiple  domains in the test sequence.   If the profile HMM  is created for single hits,  only one domain per  sequence will be reported, even  if others are present.   Creating a model for multiple  hits means  that all matching domains in  a sequence will be sought  for and reported.    By default, HmmerBuild creates a  model which will allow multiple  global alignments of the  profile HMM and a sequence  ( -MEN u =g ).  You can build  a single global HMM by  specifying the   -MEN u =b  parameter.  Global models  provide maximum sensitivity at the  expense of only locating  complete domains in the test  sequence.    If you are looking for  domain fragments (only part of  the model might be found  in the test  sequence), build a model that  allows local alignments with respect  to the HMM.  Here  again you  can choose to find only  a single match with each  test sequence ( -MEN u =c ) or to  find multiple  matches ( -MEN u =l ).  There is  a slight loss of sensitivity  with the local models.    For creating local models you  can use the  -SWEN try  and   -SWEX it  parameters to favor which  end of the model should  match the test sequence.   By default these are both  set to 0.5 to indicate  no preference.  Setting  -SWEN try   to zero constrains the alignment  to start at the beginning  of  the model while setting it  to 1.0 prevents it from  starting at the beginning of  the model.  Similarly, setting  -SWEX it  to zero  means that the end of  the alignment must coincide with  the  end of the model, while  a value of 1.0 forces  it not to continue to  the end of the model.   So setting  both of these parameters to  zero is equivalent to changing  the model to a global  profile HMM.            For more information, see Eddy,  et al. (Curr. Opin. Struct. Biol., 6; 361-365 (1996)) and  the Eddy lab  website at  http://hmmer.wustl.edu/ .           CONSIDERATIONS    [  Previous  |  Top  |  Next  ]          If you use the default  Dirichlet mixture priors, you can  obtain a good profile HMM  with as few as ten  or  twenty aligned sequences.    You should calibrate a profile  HMM with HmmerCalibrate before using  it with HmmerSearch or  HmmerPfam.  This will ensure  a more sensitive search, with  better chances of finding distantly  related  homologs to your original sequences.    HmmerBuild, unlike the original hmmbuild  program, will overwrite existing profile  HMMs without  asking your permission.    When you specify option  -MATR ix   to use a heuristic substitution  matrix-based prior, the default  Dirichlet prior is unaffected.   Therefore in principle you could  use options  -DIRI chlet  and  -MATR ix   together, but this is not  recommended, since it has not  been tested.  (Option  -MATR ix   itself has not  been tested extensively.)        COMMAND-LINE SUMMARY    [  Previous  |  Top  |  Next  ]          All parameters for this program  may be added to the  command line.  Use  -CHE ck   to view the summary  below and to specify parameters  before the program executes.   In the summary below, the  capitalized  letters in the parameter names  are the letters that you   must  type in order to  use the parameter.  Square brackets ([ and ])  enclose parameter values that are  optional.  For more information,  see ""Using  Program Parameters"" in Chapter 3,  Using Programs in the User's  Guide.        Minimal Syntax: % hmmerbuild [-INfile1=]hsp70.msf{*} -Default    Prompted Parameters:    [-OUTfile=]hsp70.hmm_g  names the output file    -MENu=g                 sets model type to multiple global       l                 sets model type to multiple local       b                 sets model type to single global       c                 sets model type to single local    Local Data Files:  None Optional Parameters:    -BEGin1=1 -END1=100     sets the range of interest for each sequence    -SWENtry=0.5            assigns the probability that a local alignment will                           begin at the leftmost end of the model (applies only                           if the model type is l or c) -SWEXit=0.5             assigns the probability that a local alignment will                           end at the rightmost end of the model (applies only                           if the model type is l or c) -PROtein                insists that the sequence alignment is amino acid -DNA                    insists that the sequence alignment is nucleic acid -ARCHprior=0.85         sets the architecture prior used by MAP construction                           algorithm -FASt                   determines model architecture quickly and heuristically                           by assigning columns with more than a certain                           fraction of gap characters to insert states   -GAPS=0.5             sets the minimum fraction of gaps for the -FASt option -NULlmodel=amino.null   uses the null model given in amino.null instead of the                           default null model -DIRIchlet=amino.pri    uses Dirichlet prior information from amino.pri in                           place of the default Dirichlet priors -MATRix=PAM30           uses a heuristic prior based on the PAM30 substitution                             matrix instead of the default Dirichlet priors   -MATWeight=20.0         sets the number of pseudocounts contributed by the                             substitution matrix-based prior -NOEffseqnum            uses the true number of sequences instead of the                           effective sequence number -WEIghting=B            uses the BLOSUM filtering algorithm to weight the                           sequences            M            uses the Krogh/Mitchison maximum entropy algorithm to                           weight the sequences            V            uses the Sibbald/Argos Voronoi sequence weighting                           algorithm to weight the sequences            N            turns off built-in sequence weighting -CLUSTERLevel=0.62      controls determination of effective sequence number and                            sets the clustering threshold when using the                            -WEIghting=B option -NAME=myhmm             sets the internal (not file) name of the profile HMM -APPend                 appends this profile HMM to an existing hmm file -BINary                 writes the profile HMM to hmm file in HMMER binary                           format instead of readable ASCII text -VERbose                prints extra information, such as the individual scores                           for each sequence in the alignment -NOMONitor              doesn't display information about analysis parameters                           used               ACKNOWLEDGEMENT    [  Previous  |  Top  |  Next  ]          The programs comprising the HMMER  package are designed and implemented  by Dr. Sean Eddy of the  Washington University School of Medicine,  St. Louis, Missouri.  The Wisconsin  Package front-end  programs were written by Christiane  van Schlun in collaboration with  Dr. Eddy.    Pfam - A database of  protein domain family alignments and  HMMs Copyright (C) 1996-2000 The  Pfam  Consortium.        PARAMETER REFERENCE    [  Previous  |  Top  |  Next  ]          You can set the parameters  listed below from the command  line.  For more information,  see ""Using  Program Parameters"" in Chapter 3,  Using Programs in the User's  Guide.              Following some of the parameters  described below is a short  expression in parentheses.  These  are the  names of the corresponding parameters  used in the native HMMER  package.  Some of the  GCG  parameters are identical to the  original HMMER parameters, others have  been changed to fit GCG's  conventions.             -BEG in =1          sets the beginning position for  all sequences in the alignment.   When beginning positions are  specified for individual sequences in  a list file, HmmerBuild ignores  the beginning position set on  the command line.        -END=100          sets the ending position for  all sequences in the alignment.   When ending positions are  specified  for individual sequences in a  list file, HmmerBuild ignores the  ending position set on the  command line.        -MEN u =G      ( -g, -f, -s )         sets the model to be  configured to a specific type  of alignment to a target  sequence: multiple  global alignments (G), single global  alignment (B =  -g ), multiple  local alignments (matching  partial domains) (L =  -f ),  single local alignments (C =   -s ).             -SWEN try =0.5      ( --swentry 0.5 )         When  -MEN u =L  or  -MEN u =C , this  parameter gives you control over  the local  vs  global  alignment behavior at the left  (N- or 5'-terminal) side of  the model.  The default  value is  0.5 and the value may  range from 0.0 to 1.0,  inclusive.    Values greater than 0.5 increase  the penalty for matches that  start at the very beginning  of the model and thus  favor local matches on that  side of the model.   Values less than 0.5,  on the other hand, favor  global matches (those that start  at the very beginning of  the  model) on that side.   Thus setting  -SWEN try  to 0.0  constrains the alignment to start  at  the beginning of the model  and setting it to 1.0  constrains it not to start  at the beginning  of the model.        -SWEX it =0.5      ( --swexit 0.5 )         When  -MEN u =L  or  -MEN u =C , this  parameter gives you control over  the local  vs  global  alignment behavior at the right  (C- or 3'-terminal) side of  the model.  The default  value is  0.5 and the value may  range from 0.0 to 1.0,  inclusive.    Values greater than 0.5 increase  the penalty for matches continuing  to the very end of  the  model and thus favor local  matches on that side of  the model.  Values less  than 0.5, on the  other hand, favor global matches  (those that continue to the  very end of the model)  on that  side.  Thus setting  -SWEX it   to 0.0 means that the  end of the alignment must  coincide  with the end of the  model and setting it to  1.0 constrains it not to  end at the end of  the  model.             -PRO tein      ( --amino )         insists that the sequence alignment  is amino acid.  Normally  HmmerBuild autodetects whether  the sequences are protein or  DNA, but if the sequences  are too short, the autodetect  algorithm  may fail.        -DNA      ( --nucleic )         insists that the sequence alignment  is nucleic acid.  Normally  HmmerBuild autodetects whether  the sequences are protein or  DNA, but if the sequences  are too short, the autodetect  algorithm  may fail.        -ARCH prior =0.85      ( --archpri 0.85 )         sets the  architecture prior  used  by MAP architecture construction.   The default is 0.85 and  the  value may range from 0.0  to 1.0, inclusive.  This  parameter governs a geometric prior  distribution over model lengths.   Higher values mean longer models  are favored  a priori .   Lower  values require greater conservation in  a column before it is  regarded as a ""consensus"" match  column in the model architecture.        -FAS t      ( --fast )         determines the architecture of the  model heuristically by assigning all  columns with more than a  certain fraction of gap characters  to insert states.  This  is faster than using the  default MAP  algorithm.             -GAPS=0.5      ( --gapmax 0.5 )         sets the fraction of gap  characters in a column that  will cause that column to  be assigned  to the insert state when  the  -FAS t  parameter is used.   If a column contains  a higher  fraction of gap symbols than  this, it gets assigned to  an insert column.  The  value can lie  between 0.0 and 1.0, inclusive,  and is set to 0.5  by default.  Higher values  mean more  columns get assigned to the  match state, resulting in a  longer model;  with smaller values,  fewer columns are assigned to  the match state, and the  length of the model is  shorter.             -NUL lmodel =amino.null      ( --null amino.null )         reads null model data from  the file amino.null instead of  using the default null model.   By  default, protein sequences use the  amino acid frequencies from release  34 of the SWISS-PROT  database and  p1  = 350/351;  for nucleic acids each base  is assigned the frequency 0.25  and  p1  =  1000/1001.        -DIRI chlet =amino.pri      ( --prior amino.pri )         reads Dirichlet prior data from  a file named amino.pri, instead  of using the default Dirichlet  priors mixture.        -MATR ix =PAM30      ( --pam PAM30 )         specifies a substitution matrix to  use for a heuristic substitution  matrix-based prior in place of  the default Dirichlet priors mixture.   The matrix must be  in  BLAST  matrix format.   If  HmmerBuild can't find the matrix  you specified in your working  directory, it automatically looks  in the directory associated with  the logical name BLASTMAT.             -MATW eight =20.0      ( --pamwgt 20.0 )         the number of pseudocounts contributed  by the heuristic prior when  a substitution  matrix-based prior is specified with  the  -MATR ix  parameter.  Any  positive real number  may be used; the default  value is 20.0.  Very  high values can force the  scoring system to be  entirely driven by the substitution  matrix, making a profile HMM  behave similarly to a  Gribskov profile.             -NOE ffseqnum      ( --noeff )         turns off the effective sequence  number calculation, and uses the  true number of sequences  instead.  This will usually  reduce the sensitivity of the  final model.        -WEI ghting =B      ( --wblosum )         uses the BLOSUM filtering algorithm  to weight the sequences.   Sequences at a given percent  identity are clustered, and each  cluster is assigned a total  weight of 1.0, distributed equally  among the members of that  cluster.        -WEI ghting =M      ( --wme )         uses the Krogh-Mitchison maximum entropy  algorithm to weight the sequences.   This  supercedes the Eddy-Mitchison-Durbin maximum discrimination  algorithm, which gives almost  identical weights but is less  robust.  Maximum entropy weighting  seems to give a marginal  increase in sensitivity over the  default GSC weights, but takes  a fair amount of time.        -WEI ghting =V      ( --wvoronoi )         uses the Sibbald-Argos Voronoi sequence  weighting algorithm in place of  the default GSC  weighting.        -WEI ghting =N      ( --wnone )         turns off all sequence weighting.        -CLUSTERL evel =0.62      ( --idlevel 0.62 )         controls the determination of effective  sequence number and the behavior  of the  -WEI ghting =B   option.  The sequence alignment  is clustered by percent identity,  and the number of clusters  at  the set cutoff threshold is  used to determine the effective  sequence number.  Higher values  give  more clusters and higher effective  sequence numbers; lower values give  fewer clusters and lower  effective sequence numbers.  The  default is 0.62, corresponding to  the clustering level used in  constructing the BLOSUM62 substitution matrix,  and the value needs to  be between 0.0 and 1.0,  inclusive.        -NAME=myhmm      ( -n myhmm )         sets the internal name (not  file name) of the profile  HMM.        -APP end      ( -A )         appends this model to an  existing HMM file, specified by   -OUT file , rather than overwriting it.  Useful for building profile HMM  libraries (like Pfam).        -BIN ary      ( --binary )         writes the profile HMM to  an HMM file in HMMER  binary format instead of readable  ASCII  text.        -VER bose      ( --verbose )         prints additional information to the  screen, such as the individual  scores for each sequence in  the  alignment.        -NOMON itor          suppresses the display of the  program's progress on the screen.                 Printed: January 9, 2002  13:45 (1162)           [  Program Manual  |  User's Guide  |  Data Files  |  Databases  ]       Technical Support:  support-us@accelrys.com  or  support-eu@accelrys.com      Copyright (c) 1982-2002 Accelrys Inc.  A subsidiary of Pharmacopeia, Inc.  All rights reserved.    Licenses and Trademarks Wisconsin Package is a trademark and GCG and the GCG logo are registered trademarks of Accelrys Inc.    All other product names mentioned in this documentation may be trademarks, and if so, are trademarks or registered trademarks of their respective holders and are used in this documentation for identification purposes only.       www.accelrys.com/bio"
GX251-20-8800014	"10.1 Golden Section Search in One Dimension  397  one-dimensional sub-minimization. Turn to 10.6 for detailed discussion and implementation.  The second family goes under the names quasi-Newton or variable metric methods, as typified by the Davidon-Fletcher-Powell (DFP) algorithm (sometimes referred to just as Fletcher-Powell) or the closely related Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm. These methods require of order N 2 storage, require derivative calculations and onedimensional sub-minimization. Details are in 10.7. You are now ready to proceed with scaling the peaks (and/or plumbing the depths) of practical optimization. CITED REFERENCES AND FURTHER READING: Dennis, J.E., and Schnabel, R.B. 1983, Numerical Methods for Unconstrained Optimization and Nonlinear Equations (Englewood Cliffs, NJ: Prentice-Hall). Polak, E. 1971, Computational Methods in Optimization (New York: Academic Press). Gill, P.E., Murray, W., and Wright, M.H. 1981, Practical Optimization (New York: Academic Press). Acton, F.S. 1970, Numerical Methods That Work; 1990, corrected edition (Washington: Mathematical Association of America), Chapter 17. Jacobs, D.A.H. (ed.) 1977, The State of the Ar t in Numerical Analysis (London: Academic Press), Chapter III.1. Brent, R.P. 1973, Algorithms for Minimization without Derivatives (Englewood Cliffs, NJ: PrenticeHall). Dahlquist, G., and Bjorck, A. 1974, Numerical Methods (Englewood Cliffs, NJ: Prentice-Hall), Chapter 10.  Sample page from NUMERICAL RECIPES IN C: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43108-5) Copyright (C) 1988-1992 by Cambridge University Press. Programs Copyright (C) 1988-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  10.1 Golden Section Search in One Dimension Recall how the bisection method finds roots of functions in one dimension (9.1): The root is supposed to have been bracketed in an interval (a, b). One then evaluates the function at an intermediate point x and obtains a new, smaller bracketing interval, either (a, x) or (x, b). The process continues until the bracketing interval is acceptably small. It is optimal to choose x to be the midpoint of (a, b) so that the decrease in the interval length is maximized when the function is as uncooperative as it can be, i.e., when the luck of the draw forces you to take the bigger bisected segment. There is a precise, though slightly subtle, translation of these considerations to the minimization problem: What does it mean to bracket a minimum? A root of a function is known to be bracketed by a pair of points, a and b, when the function has opposite sign at those two points. A minimum, by contrast, is known to be bracketed only when there is a triplet of points, a < b < c (or c < b < a), such that f (b) is less than both f (a) and f (c). In this case we know that the function (if it is nonsingular) has a minimum in the interval (a, c). The analog of bisection is to choose a new point x, either between a and b or between b and c. Suppose, to be specific, that we make the latter choice. Then we evaluate f (x). If f (b) < f (x), then the new bracketing triplet of points is (a, b, x);   398  Chapter 10.  Minimization or Maximization of Functions  2 4 1 5 4 6 Sample page from NUMERICAL RECIPES IN C: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43108-5) Copyright (C) 1988-1992 by Cambridge University Press. Programs Copyright (C) 1988-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  5  6  3  Figure 10.1.1. Successive bracketing of a minimum. The minimum is originally bracketed by points 1,3,2. The function is evaluated at 4, which replaces 2; then at 5, which replaces 1; then at 6, which replaces 4. The rule at each stage is to keep a center point that is lower than the two outside points. After the steps shown, the minimum is bracketed by points 5,3,6.  contrariwise, if f (b) > f (x), then the new bracketing triplet is (b, x, c). In all cases the middle point of the new triplet is the abscissa whose ordinate is the best minimum achieved so far; see Figure 10.1.1. We continue the process of bracketing until the distance between the two outer points of the triplet is tolerably small. How small is ""tolerably"" small? For a minimum located at a value b, you might naively think that you will be able to bracket it in as small a range as (1 - )b < b < (1 + )b, where is your computer's floating-point precision, a number like 3  10 -8 (for float) or 10 -15 (for double). Not so! In general, the shape of your function f (x) near b will be given by Taylor's theorem 1 f (x)  f (b)+ f (b)(x - b)2 2 (10.1.1)  The second term will be negligible compared to the first (that is, will be a factor smaller and will act just like zero when added to it) whenever |x - b| <  |b| 2 |f (b)| b2 f (b) (10.1.2)  The reason for writing the right-hand side in this way is that, for most functions, the final square root is a number of order unity. Therefore, as rule of thumb, it a times its central is hopeless to ask for a bracketing interval of width less than value, a fractional width of only about 10 -4 (single precision) or 3  10 -8 (double precision). Knowing this inescapable fact will save you a lot of useless bisections! The minimum-finding routines of this chapter will often call for a user-supplied argument tol, and return with an abscissa whose fractional precision is about tol (bracketing interval of fractional size about 2tol). Unless you have a better   10.1 Golden Section Search in One Dimension  399  estimate for the right-hand side of equation (10.1.2), you should set tol equal to (not much less than) the square root of your machine's floating-point precision, since smaller values will gain you nothing. It remains to decide on a strategy for choosing the new point x, given (a, b, c). Suppose that b is a fraction w of the way between a and c, i.e. b-a =w c-a c-b =1-w c-a Sample page from NUMERICAL RECIPES IN C: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43108-5) Copyright (C) 1988-1992 by Cambridge University Press. Programs Copyright (C) 1988-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  (10.1.3)  Also suppose that our next trial point x is an additional fraction z beyond b, x-b =z c-a (10.1.4)  Then the next bracketing segment will either be of length w + z relative to the current one, or else of length 1 - w. If we want to minimize the worst case possibility, then we will choose z to make these equal, namely z = 1 - 2w (10.1.5)  We see at once that the new point is the symmetric point to b in the original interval, namely with |b - a| equal to |x - c|. This implies that the point x lies in the larger of the two segments (z is positive only if w < 1/2). But where in the larger segment? Where did the value of w itself come from? Presumably from the previous stage of applying our same strategy. Therefore, if z is chosen to be optimal, then so was w before it. This scale similarity implies that x should be the same fraction of the way from b to c (if that is the bigger segment) as was b from a to c, in other words, z =w 1-w Equations (10.1.5) and (10.1.6) give the quadratic equation  3- 5 2  0.38197 w - 3w +1 = 0 yielding w= 2 (10.1.6)  (10.1.7)  In other words, the optimal bracketing interval (a, b, c) has its middle point b a fractional distance 0.38197 from one end (say, a), and 0.61803 from the other end (say, b). These fractions are those of the so-called golden mean or golden section, whose supposedly aesthetic properties hark back to the ancient Pythagoreans. This optimal method of function minimization, the analog of the bisection method for finding zeros, is thus called the golden section search, summarized as follows: Given, at each stage, a bracketing triplet of points, the next point to be tried is that which is a fraction 0.38197 into the larger of the two intervals (measuring from the central point of the triplet). If you start out with a bracketing triplet whose segments are not in the golden ratios, the procedure of choosing successive points at the golden mean point of the larger segment will quickly converge you to the proper, self-replicating ratios. The golden section search guarantees that each new function evaluation will (after self-replicating ratios have been achieved) bracket the minimum to an interval   400  Chapter 10.  Minimization or Maximization of Functions  just 0.61803 times the size of the preceding interval. This is comparable to, but not quite as good as, the 0.50000 that holds when finding roots by bisection. Note that the convergence is linear (in the language of Chapter 9), meaning that successive significant figures are won linearly with additional function evaluations. In the next section we will give a superlinear method, where the rate at which successive significant figures are liberated increases with each successive function evaluation.  Sample page from NUMERICAL RECIPES IN C: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43108-5) Copyright (C) 1988-1992 by Cambridge University Press. Programs Copyright (C) 1988-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  Routine for Initially Bracketing a Minimum The preceding discussion has assumed that you are able to bracket the minimum in the first place. We consider this initial bracketing to be an essential part of any one-dimensional minimization. There are some one-dimensional algorithms that do not require a rigorous initial bracketing. However, we would never trade the secure feeling of knowing that a minimum is ""in there somewhere"" for the dubious reduction of function evaluations that these nonbracketing routines may promise. Please bracket your minima (or, for that matter, your zeros) before isolating them! There is not much theory as to how to do this bracketing. Obviously you want to step downhill. But how far? We like to take larger and larger steps, starting with some (wild?) initial guess and then increasing the stepsize at each step either by a constant factor, or else by the result of a parabolic extrapolation of the preceding points that is designed to take us to the extrapolated turning point. It doesn't much matter if the steps get big. After all, we are stepping downhill, so we already have the left and middle points of the bracketing triplet. We just need to take a big enough step to stop the downhill trend and get a high third point. Our standard routine is this: #include   #include ""nrutil.h"" #define GOLD 1.618034 #define GLIMIT 100.0 #define TINY 1.0e-20 #define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d); Here GOLD is the default ratio by which successive intervals are magnified; GLIMIT is the maximum magnification allowed for a parabolic-fit step. void mnbrak(float *ax, float *bx, float *cx, float *fa, float *fb, float *fc, float (*func)(float)) Given a function func, and given distinct initial points ax and bx, this routine searches in the downhill direction (defined by the function as evaluated at the initial points) and returns new points ax, bx, cx that bracket a minimum of the function. Also returned are the function values at the three points, fa, fb, and fc. { float ulim,u,r,q,fu,dum; *fa=(*func)(*ax); *fb=(*func)(*bx); if (*fb > *fa) { SHFT(dum,*ax,*bx,dum) SHFT(dum,*fb,*fa,dum) } *cx=(*bx)+GOLD*(*bx-*ax); *fc=(*func)(*cx); while (*fb > *fc) { r=(*bx-*ax)*(*fb-*fc); q=(*bx-*cx)*(*fb-*fa); u=(*bx)-((*bx-*cx)*q-(*bx-*ax)*r)/  Switch roles of a and b so that we can go downhill in the direction from a to b. First guess for c. Keep returning here until we bracket. Compute u by parabolic extrapolation from a, b, c. TINY is used to prevent any possible division by zero.   10.1 Golden Section Search in One Dimension  401  (2.0*SIGN(FMAX(fabs(q-r),TINY),q-r)); ulim=(*bx)+GLIMIT*(*cx-*bx); We won't go farther than this. Test various possibilities: if ((*bx-u)*(u-*cx) > 0.0) { Parabolic u is between b and c: try it. fu=(*func)(u); if (fu < *fc) { Got a minimum between b and c. *ax=(*bx); *bx=u; *fa=(*fb); *fb=fu; return; } else if (fu > *fb) { Got a minimum between between a and u. *cx=u; *fc=fu; return; } u=(*cx)+GOLD*(*cx-*bx); Parabolic fit was no use. Use default magfu=(*func)(u); nification. } else if ((*cx-u)*(u-ulim) > 0.0) { Parabolic fit is between c and its fu=(*func)(u); allowed limit. if (fu < *fc) { SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx)) SHFT(*fb,*fc,fu,(*func)(u)) } } else if ((u-ulim)*(ulim-*cx) >= 0.0) { Limit parabolic u to maximum allowed value. u=ulim; fu=(*func)(u); } else { Reject parabolic u, use default magnification. u=(*cx)+GOLD*(*cx-*bx); fu=(*func)(u); } SHFT(*ax,*bx,*cx,u) Eliminate oldest point and continue. SHFT(*fa,*fb,*fc,fu) } }  Sample page from NUMERICAL RECIPES IN C: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43108-5) Copyright (C) 1988-1992 by Cambridge University Press. Programs Copyright (C) 1988-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  (Because of the housekeeping involved in moving around three or four points and their function values, the above program ends up looking deceptively formidable. That is true of several other programs in this chapter as well. The underlying ideas, however, are quite simple.)  Routine for Golden Section Search #include #define #define #define #define   R 0.61803399 The golden ratios. C (1.0-R) SHFT2(a,b,c) (a)=(b);(b)=(c); SHFT3(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);  float golden(float ax, float bx, float cx, float (*f)(float), float tol, float *xmin) Given a function f, and given a bracketing triplet of abscissas ax, bx, cx (such that bx is between ax and cx, and f(bx) is less than both f(ax) and f(cx)), this routine performs a golden section search for the minimum, isolating it to a fractional precision of about tol. The abscissa of the minimum is returned as xmin, and the minimum function value is returned as golden, the returned function value. { float f1,f2,x0,x1,x2,x3;   402  Chapter 10.  Minimization or Maximization of Functions  x0=ax; At any given time we will keep track of four x3=cx; points, x0,x1,x2,x3 . if (fabs(cx-bx) > fabs(bx-ax)) { Make x0 to x1 the smaller segment, x1=bx; x2=bx+C*(cx-bx); and fill in the new point to be tried. } else { x2=bx; x1=bx-C*(bx-ax); } f1=(*f)(x1); The initial function evaluations. Note that f2=(*f)(x2); we never need to evaluate the function while (fabs(x3-x0) > tol*(fabs(x1)+fabs(x2))) { at the original endpoints. if (f2 < f1) { One possible outcome, SHFT3(x0,x1,x2,R*x1+C*x3) its housekeeping, SHFT2(f1,f2,(*f)(x2)) and a new function evaluation. } else { The other outcome, SHFT3(x3,x2,x1,R*x2+C*x0) SHFT2(f2,f1,(*f)(x1)) and its new function evaluation. } } Back to see if we are done. if (f1 < f2) { We are done. Output the best of the two *xmin=x1; current values. return f1; } else { *xmin=x2; return f2; } }  Sample page from NUMERICAL RECIPES IN C: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43108-5) Copyright (C) 1988-1992 by Cambridge University Press. Programs Copyright (C) 1988-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  10.2 Parabolic Interpolation and Brent's Method in One Dimension We already tipped our hand about the desirability of parabolic interpolation in the previous section's mnbrak routine, but it is now time to be more explicit. A golden section search is designed to handle, in effect, the worst possible case of function minimization, with the uncooperative minimum hunted down and cornered like a scared rabbit. But why assume the worst? If the function is nicely parabolic near to the minimum -- surely the generic case for sufficiently smooth functions -- then the parabola fitted through any three points ought to take us in a single leap to the minimum, or at least very near to it (see Figure 10.2.1). Since we want to find an abscissa rather than an ordinate, the procedure is technically called inverse parabolic interpolation. The formula for the abscissa x that is the minimum of a parabola through three points f (a), f (b), and f (c) is x=b- 1 (b - a)2 [f (b) - f (c)] - (b - c)2 [f (b) - f (a)] 2 (b - a)[f (b) - f (c)] - (b - c)[f (b) - f (a)] (10.2.1)  as you can easily derive. This formula fails only if the three points are collinear, in which case the denominator is zero (minimum of the parabola is infinitely far"
GX034-25-12140964	"[  Index |  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V  W  X  Y Z ]       RADREC: Range, ra and dec to rectangular coordinates         Abstract      Convert from range, right ascension, and declination to     rectangular coordinates.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  ---------------------------------------------------     range      I   Distance of a point from the origin.     ra         I   Right ascension, angular distance of the point from                    the XZ plane radians.     dec        I   Declination, angular distance of the point from the                    XY plane in radians.     rectan     O   Rectangular coordinates of the point, in input                    units.       Detailed Input      range      is the distance of the point from the origin. Input                should be in terms of the same units in which the                output is desired.      ra         is the right ascension, the angular distance measured                toward the east from the XZ plane to the point. ra                normally ranges from 0 to ( 2 *  pi  ) radians; however,                this routine accepts angles not in this range.      dec        is the declination, the angular distance from the XY                plane to the point.  dec normally ranges from                -(  pi /2 ) to (  pi /2 ) radians; however this routine                accepts angles not in this range. Occasionally the                declination is an angle greater than  pi /2.       Detailed Output      rectan     is the array containing the rectangular coordinates of                the point.  The output unit of the rectangular                coordinates is the same as the input unit of the range.        Parameters      None.       Particulars      This routine converts the right ascension, declination, and range     describing a point into the associated rectangular coordinates by     calling the CSPICE routine  latrec .      The input is defined by a distance from a central reference point,     an angle from a reference meridian, and an angle above the equator     of a sphere centered at the central reference point.      This is a companion routine to  recrad . These routines exist as a     convenience, and merely call other routines.       Examples      The following code fragment converts right ascension and     declination from  B1950  to  J2000 .            SpiceDouble      ra;          SpiceDouble      dec;           SpiceDouble      r;          SpiceInt         oldref;          SpiceInt         newref;          SpiceDouble      rotab  [ 3 ][ 3 ];           SpiceDouble      oldvec [ 3 ];          SpiceDouble      newvec [ 3 ];             radrec  ( 1.0, ra, dec, oldvec );           irfnum ( ' B1950 ', oldref );          irfnum ( ' J2000 ', newref );          irfrot ( oldref,  newref, rotab  );            mxv     ( rotab,   oldvec, newvec );           recrad  ( newvec,  R,      ra,     dec );        Restrictions      None.       Exceptions      Error free.       Files      None.       Author and Institution      H.A. Neilan     (JPL)       Literature References      ""Celestial Mechanics, A Computational Guide for the Practitioner""     by Laurence G. Taff       Version      -CSPICE Version 1.0.0, 08-FEB-1998 (EDW)      Index Entries      range ra and dec to rectangular coordinates     right_ascension and declination to rectangular             RAV2XF: Rotation and angular velocity to transform         Abstract      This routine determines from a state transformation matrix     the associated rotation matrix and angular velocity of the     rotation.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  --------------------------------------------------     rot        I   Rotation matrix.    av         I   Angular velocity vector.     xform      O   State transformation associated with rot and av.      Detailed Input      rot         is a rotation that gives the transformation from                 some  frame  frame1 to another  frame  frame2.      av          is the angular velocity of the transformation.                 In other words, if p is the position of a fixed                 point in frame2, then from the point of view of                 frame1,  p rotates (in a right handed sense) about                 an axis parallel to av.  Moreover the rate of rotation                 in radians per unit time is given by the length of                 av.                  More formally, the velocity v of p in frame1 is                 given by                                    t                     v  = av x ( rot * p )       Detailed Output      xform       is a state transformation matrix associated                 with rot and av.  If s1 is the state of an object                 with respect to frame1, then the state s2 of the                 object with respect to frame2 is given by                      s2  =  xform * s1                  where ""*"" denotes matrix-vector multiplication.        Parameters      None.       Particulars      This routine is essentially a macro routine for converting     a rotation and angular velocity of the rotation to the     equivalent state transformation matrix.      This routine is an inverse of  xf2rav .      Examples      Suppose that you wanted to determine state transformation     matrix from a platform  frame  to the  J2000   frame .         /.       The following call obtains the  J2000 -to-platform transformation       matrix and platform angular velocity at the time of interest.       The time value is expressed as encoded SCLK.       ./         ckgpav  ( ckid, time, tol, "" J2000 "", rot, av, &clkout, &fnd );        /.       Recall that rot and av are the rotation and angular velocity        of the transformation from  J2000  to the platform  frame .        ./        if ( fnd )       {           /.          First get the state transformation from  J2000  to the platform            frame .           ./            rav2xf  ( rot, av, j2plt );           /.            Invert  the state transformation matrix (using invstm) to            the desired state transformation matrix.           ./           invstm ( j2plt, xform );       }       Restrictions      None.       Exceptions      Error free.      1) No checks are performed on ROT to ensure that it is indeed        a rotation matrix.       Files      None.       Author and Institution      N.J. Bachman    (JPL)    W.L. Taber      (JPL)       Literature References      None.       Version      -CSPICE Version 1.0.0, 18-JUN-1999 (WLT) (NJB)       Index Entries     State transformation to rotation and angular velocity             RAXISA: Rotation axis of a matrix         Abstract      Compute the axis of the rotation given by an input matrix     and the angle of the rotation about that axis.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading       ROTATION        Brief I/O       VARIABLE  I/O  DESCRIPTION      --------  ---  --------------------------------------------------      matrix     I   3x3 rotation matrix in double precision.      axis       O   Axis of the rotation.      angle      O   Angle through which the rotation is performed.       Detailed Input       matrix     is a 3x3 rotation matrix in double precision.       Detailed Output       axis       is a unit vector pointing along the axis of the                 rotation.  In other words, axis is a unit eigen vector                 of the input matrix.       angle      is the angle between v and matrix*v for any non-zero                 vector v orthogonal to axis.  Angle is given in                 radians.       Parameters       None.       Particulars       Using the formulas developed in the reference this routine      computes the axis and angle of the rotation matrix.       The pertinent formulas are:       Let r be the rotation matrix            r11  r12  r13           r21  r22  r23           r31  r32  r33       cosine(angle) = 0.5* trace (r) - 0.5        w1  =  2*sine(angle)*axis[0]  =  r32 - r23      w2  =  2*sine(angle)*axis[1]  =  r13 - r31      w3  =  2*sine(angle)*axis[2]  =  r21 - r12       If the angle is a multiple of  pi , then r is given by           2*w1**2 - 1   2*w1*w2         2*w1*w3          2*w1*w2       2*w2**2 - 1     2*w2*w3          2*w1*w3       2*w2*w3         2*w3**2 - 1       These equations are those used to compute the axis and angle of      the rotation.       Examples       This routine can be used to numerically approximate the      instantaneous angular velocity vector of a rotating object.       Suppose that r(t) is the rotation matrix whose columns      represent the inertial pointing vectors of the bodyfixed      axes of an object at time t.       Then the angular velocity vector points along the vector      given by:                             T         limit  axis( r(t+h)r )         h-->0       And the magnitude of the angular velocity at time t is given by:                              T         d angle ( r(t+h)r(t) )         ----------------------   at   h = 0         dh       Thus to approximate the angular velocity vector the following      code fragment will do          [ Load t      into the double precision variable t           Load h      into the double precision variable h           Load r(t+h) into the 3 by 3 double precision array rth           Load r(t)   into the 3 by 3 double precision array rt            .            .            .         ]         /.                                                     T        Compute the infinitesimal rotation r(t+h)r(t)          ./         mxmt  ( rth, rt, infrot );         /.        Compute the axis and angle of the infinitesimal rotation.        /.         raxisa  ( infrot, axis, &angle );         /.        Scale axis to get the angular velocity vector.        ./         vscl  ( angle/h, axis, angvel );        Restrictions       It's the user's responsibility to make sure the input matrix      is indeed a rotation matrix.       The user should be aware that the input matrix is taken to be an      object that acts on (rotates) vectors---it is not regarded as      a coordinate transformation.  If the user needs to find the axis      and angle of a coordinate transformation he/she should input      the transpose of that matrix to this routine.       Exceptions      Error free       Files       None.       Author and Institution       W.L. Taber      (JPL)      N.J. Bachman    (JPL)      Literature References       JPL IOM 314.8-568, 14 October 1985. ""Rotations and Their Habits"",      by W. L. Taber       Version      -CSPICE Version 1.0.0, 31-MAY-1999 (WLT) (NJB)      Index Entries      rotation axis of a matrix             RDTEXT: Read a line from a text file         Abstract      Read the next line of text from a text file.      Copyright      Copyright (1999), California Institute of Technology.    U.S. Government sponsorship acknowledged.      Required Reading      None.      Brief I/O      VARIABLE  I/O  DESCRIPTION    --------  ---  ---------------------------------------------------    file       I   Name of text file.    lenout     I   Available room in output line.    line       O   Next line from the text file.    eof        O   End-of-file indicator.      Detailed Input      file        is the name of the text file from which the next                line is to be read. If the file is not currently                open, it is opened with a logical unit determined                at run time, and the first line of the file is                returned. Otherwise, the next line not yet read                from the file is read and returned.     lenout      is the available room in the output line, including                the terminating null.  If the maximum expected length                of an output line is N, lenout should be at least N+1.      Detailed Output      line        is next line of text in the specified file.                If the end of the file is reached, LINE is blank.     eof         is true when the end of the file is reached, and is                otherwise false.      Parameters      None.      Particulars       rdtext  reads the next line from a text file. If the file is    not currently open, it is opened with a logical unit determined    at run time, and the first line of the file is returned.    Otherwise, the next line not yet read from the file is returned.     If the end of the file is reached, an empty line is returned,    the end-of-file indicator is true, and the file is closed.     Several files may be opened and read simultaneously. Thus,    you may begin reading from one file before the end of another    file has been reached.  rdtext  maintains a separate file pointer    for each file.      Examples      Let FILE.1 contain the following lines.        Mary had a little lamb       Everywhere that Mary went     Let FILE.2 contain the following lines.        Its fleece was white as snow.       The lamb was sure to go.        Note:  You do not what and end-of-file on the same line as       text.  That text will be ignored.      Then the code fragment     #include ""SpiceUsr.h""    #define LENOUT 32     main(void)       {        SpiceBoolean eof;       SpiceChar    line[LENOUT];        eof = SPICEFALSE;        do {           rdtext  ( ""file.1"", LENOUT, line, &eof );          printf ( ""%s \n"", line );            rdtext  ( ""file.2"", LENOUT, line, &eof );          printf ( ""%s \n"", line );          }       while ( !eof );        }     produces the following output        Mary had a little lamb       Its fleece was white as snow.       Everywhere that Mary went       The lamb was sure to go.      Restrictions      None.      Exceptions      1) If too many files are open already, the error       SPICE(TOOMANYFILESOPEN) is signaled.     2) If the attempt to open the file fails, the error       SPICE(FILEOPENFAILED) is signaled.     3) If the attempt to read from the file fails, the error       SPICE(FILEREADFAILED) is signaled.     4) If the attempt to ""inquire"" the status of the file fails,       the error SPICE(INQUIREFAILED) is signaled.      Files      See input FILE.      Author and Institution      N.J. Bachman    (JPL)    H.A. Neilan     (JPL)    M.J. Spencer    (JPL)    I.M. Underwood  (JPL)      Literature References      None.      Version      -CSPICE Version 2.0.0, 07-OCT-1999   (NJB)        Changed argument list to conform to SPICE convention:  LENOUT       now precedes the output string.        Added description of lenout to the header.        Added local logical variable for EOF flag.     -CSPICE Version 1.0.0, 25-MAY-1999   (EDW)      Index Entries      read a line from a text file            RECCYL: Rectangular to cylindrical coordinates         Abstract      Convert from rectangular to cylindrical coordinates.        Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  -------------------------------------------------     rectan     I   Rectangular coordinates of a point.     r          O   Distance of the point from z axis.     lon        O   Angle (radians) of the point from xZ plane     z          O   Height of the point above xY plane.       Detailed Input      rectan     Rectangular coordinates of the point of interest.       Detailed Output      r          Distance of the point of interest from z axis.      lon        Cylindrical angle (in radians) of the point of                interest from xZ plane.      z          Height of the point above xY plane.       Parameters      None.       Particulars      This routine transforms the coordinates of a point from     rectangular to cylindrical coordinates.       Examples      Below are two tables.      Listed in the first table (under x(1), x(2) and x(3) ) are a     number of points whose rectangular coordinates coorindates are     taken from the set {-1, 0, 1}.      The result of the code fragment            reccyl  ( x, r,  lon, z );          Use the CSPICE routine  convrt  to convert the angular          quantities to degrees            convrt  (  lon, ""RADIANS"", ""DEGREES"", lon  );     are listed to 4 decimal places in the second parallel table under     r (radius), lon  (longitude), and  z (same as rectangular z     coordinate).         x(1)       x(2)     x(3)        r         lon      z       --------------------------      -------------------------       0.0000     0.0000   0.0000      0.0000    0.0000   0.0000       1.0000     0.0000   0.0000      1.0000    0.0000   0.0000       0.0000     1.0000   0.0000      1.0000   90.0000   0.0000       0.0000     0.0000   1.0000      0.0000    0.0000   1.0000      -1.0000     0.0000   0.0000      1.0000  180.0000   0.0000       0.0000    -1.0000   0.0000      1.0000  270.0000   0.0000       0.0000     0.0000  -1.0000      0.0000    0.0000  -1.0000       1.0000     1.0000   0.0000      1.4142   45.0000   0.0000       1.0000     0.0000   1.0000      1.0000    0.0000   1.0000       0.0000     1.0000   1.0000      1.0000   90.0000   1.0000       1.0000     1.0000   1.0000      1.4142   45.0000   1.0000       Restrictions      None.       Exceptions      Error free.       Files      None.       Author and Institution      W.L. Taber      (JPL)       Literature References      None.       Version      -CSPICE Version 1.1.0, 21-OCT-1998 (NJB)        Made input vector const.     -CSPICE Version 1.0.0, 08-FEB-1998   (EDW)      Index Entries      rectangular to cylindrical coordinates             RECGEO: Rectangular to geodetic         Abstract      Convert from rectangular coordinates to geodetic coordinates.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  --------------------------------------------------     rectan     I   Rectangular coordinates of a point.     re         I   Equatorial radius of the reference ellipsoid.     f          I   Flattening coefficient.     lon        O   Geodetic longitude of the point (radians).     lat        O   Geodetic latitude  of the point (radians).     alt        O   Altitude of the point above reference ellipsoid.       Detailed Input       rectan    Rectangular coordinates of the input point.  Note that               the X, Y and Z axes point in the directions of               (0 lat, 0 lon), (0 lat, 90 lon) and (90 lat, 0 lon)               respectively. (The units used in this description are               in degrees.  The input units for latitude and               longitude should be radians.)      re        Equatorial radius of the reference spheroid.      f         Flattening coefficient = (re-rp) / re, where rp is               the polar radius of the spheroid.       Detailed Output      lon       Geodetic longitude of point (radians).      lat       Geodetic latitude  of point (radians).      alt       Altitude of point above the reference spheroid.       Parameters       None.       Particulars      Given the bodyfixed rectangular coordinates of a point, and the     constants describing the reference spheroid,  this routine     returns the geodetic coordinates of the point.  The bodyfixed     rectangular  frame  is that having the x-axis pass through the     0 degree latitude 0 degree longitude point.  The y-axis passes     through the 0 degree latitude 90 degree longitude.  The z-axis     passes through the 90 degree latitude point.  For some bodies     this coordinate system may not be a right-handed coordinate     system.       Examples      This routine can be used to convert body fixed rectangular     coordinates (such as the Satellite Tracking and Data Network     of 1973) to geodetic coordinates such as those used by the     United States Geological Survey topographic maps.      The code would look something like this             /.            Shift the STDN-73 coordinates to line up with the center            of the Clark66 reference system.            ./                vsub  ( STDNX, OFFSET, X );            /.           Using the equatorial radius of the Clark66 spheroid            (CLARKR = 6378.2064 km) and the Clark 66 flattening            factor (CLARKF = 1.0 / 294.9787 ) convert to            geodetic coordinates of the North American Datum of 1927.            ./             recgeo  ( X, CLARKR, CLARKF, lon, lat, alt )        Below are two tables.      Listed in the first table (under X[0], X[1] and X(3) ) are a     number of points whose rectangular coordinates are     taken from the set {-1, 0, 1}.        The result of the code fragment            recgeo  ( X, CLARKR, CLARKF, lon, lat, alt );          Use the CSPICE routine  convrt  to convert the angular          quantities to degrees            convrt  ( lat, ""RADIANS"", ""DEGREES"", lat  );          convrt  ( lon, ""RADIANS"", ""DEGREES"", lon );     are listed to 4 decimal places in the second parallel table under     r (radius), colat (co-latitude), and  lon (longitude).          X[0]       X[1]     X(3)         lon      colat        alt       --------------------------       ----------------------------       0.0000     0.0000   0.0000       0.0000    90.0000   -6356.5838       1.0000     0.0000   0.0000       0.0000     0.0000   -6377.2063       0.0000     1.0000   0.0000      90.0000     0.0000   -6377.2063       0.0000     0.0000   1.0000       0.0000    90.0000   -6355.5838      -1.0000     0.0000   0.0000     180.0000     0.0000   -6377.2063       0.0000    -1.0000   0.0000     -90.0000     0.0000   -6377.2063       0.0000     0.0000  -1.0000       0.0000   -90.0000   -6355.5838       1.0000     1.0000   0.0000      45.0000     0.0000   -6376.7921       1.0000     0.0000   1.0000       0.0000    88.7070   -6355.5725       0.0000     1.0000   1.0000      90.0000    88.7070   -6355.5725       1.0000     1.0000   1.0000      45.0000    88.1713   -6355.5612       Restrictions       The bodyfixed rectangular  frame  is that having the x-axis pass      through the 0 degree latitude 0 degree longitude point.  The      y-axis passes through the 0 degree latitude 90 degree longitude.      The z-axis passes through the 90 degree latitude point.  For some      bodies this coordinate system may not be a right-handed      coordinate system.       Exceptions       1) If the equatorial radius is non-positive, the error         SPICE(VALUEOUTOFRANGE) is signalled.       2) If the flattening coefficient is greater than or equal to         one, the error SPICE(VALUEOUTOFRANGE) is signalled.       Files       None.       Author and Institution       H.A. Neilan     (JPL)      W.L. Taber      (JPL)       Literature References       See FUNDAMENTALS OF ASTRODYNAMICS, Bate, Mueller, White      published by Dover for a description of geodetic coordinates.       Version      -CSPICE Version 1.1.0, 21-OCT-1998 (NJB)        Made input vector const.     -CSPICE Version 1.0.0, 08-FEB-1998   (EDW)      Index Entries      rectangular to geodetic             RECLAT: Rectangular to latitudinal coordinates         Abstract      Convert from rectangular coordinates to latitudinal coordinates.      Copyright      Copyright (1997), California Institute of Technology.    U.S. Government sponsorship acknowledged.      Required Reading      None.      Brief I/O      VARIABLE  I/O  DESCRIPTION    --------  ---  --------------------------------------------------    rectan     I   Rectangular coordinates of the point.    radius     O   Distance of a point from the origin.    longitude  O   Angle of the point from the XZ plane in radians.    latitude   O   Angle of the point from the XY plane in radians.      Detailed Input      rectan     The rectangular coordinates of the input point, a 3               vector.      Detailed Output      radius     Distance of a point from the origin.     longitude  Angle of the point from the XZ plane in radians.     latitude   Angle of the point from the XY plane in radians.      Parameters      None.       Particulars      This routine returns the latitudinal coordinates of a point    whose position is input in rectangular coordinates.     Latitudinal coordinates are defined by a distance from a central    reference point, an angle from a reference meridian, and an angle    above the equator of a sphere centered at the central reference    point.      Examples      Below are two tables.     Listed in the first table (under rectan[0], rectan[1], and rectan[2])     are a number of points whose rectangular coordinates coorindates are    taken from the set {-1, 0, 1}.     The result of the code fragment         reclat  ( rectan, &r, &longitude, &latitude );        latitude  = latitude  *  dpr ();       longitude = longitude *  dpr ();     are listed to 4 decimal places in the second parallel table under    r (radius), longitude, and latitude.     rectan[0]  rectan[1] rectan[2]    r       longitude  latitude    -------------------------------   ----------------------------      0.0000     0.0000   0.0000      0.0000    0.0000    0.0000      1.0000     0.0000   0.0000      1.0000    0.0000    0.0000      0.0000     1.0000   0.0000      1.0000   90.0000    0.0000      0.0000     0.0000   1.0000      1.0000    0.0000   90.0000     -1.0000     0.0000   0.0000      1.0000  180.0000    0.0000      0.0000    -1.0000   0.0000      1.0000  -90.0000    0.0000      0.0000     0.0000  -1.0000      1.0000    0.0000  -90.0000      1.0000     1.0000   0.0000      1.4142   45.0000    0.0000      1.0000     0.0000   1.0000      1.4142    0.0000   45.0000      0.0000     1.0000   1.0000      1.4142   90.0000   45.0000      1.0000     1.0000   1.0000      1.7320   45.0000   35.2643      Restrictions      None.      Exceptions      Error free.       Files      None.       Author and Institution      W.L. Taber      (JPL)     E.D. Wright     (JPL)      Literature References      None.      Version      -CSPICE Version 1.1.0, 21-OCT-1998 (NJB)        Made input vector const.     -CSPICE Version 1.0.0, 08-FEB-1998 (EDW)      Index Entries      rectangular to latitudinal coordinates            RECRAD: Rectangular coordinates to ra and dec         Abstract       Accepts as input rectangular coordinates and returns the range,      right ascension, and declination.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  --------------------------------------------------     rectan     I   Rectangular coordinates of a point.     range      O   Distance of the point from the origin.     ra         O   Right ascension in radians.     dec        O   Declination in radians.       Detailed Input      rectan     contains the rectangular coordinates of a point.       Detailed Output      range      is the distance of the point from the origin.      ra         is the right ascension, the angular distance                measured toward the east from the XZ plane to the                point.  ra ranges from 0 to ( 2 *  pi  ) radians.      dec        is the angle from the XY plane to the point.                dec ranges from - (  pi /2 ) to (  pi /2 ) radians.       Parameters      None.       Particulars      This routine returns the range, right ascension, and declination     of a point whose position is input in rectangular coordinates.      The output is defined by a distance from a central reference     point, an angle from a reference meridian, and an angle above     the equator of a sphere centered at the central reference     point.      This subroutine calls  reclat  which returns range, latitude, and     longitude. The longitude ranges from -  pi  to  pi  radians.  The     right ascension however, ranges from zero to two  pi  radians.     If the longitude returned by  reclat  is negative, this subroutine     adds two  pi  to it so that it then falls within the range of the     right ascension.       Examples      The following code fragment demonstrates the use of  recrad .       Determine the intersection of a line-of-sight vector with the     surface of an ellipsoid.        surfpt  ( positn, u, a, b, c, point, &found );      Convert to range, right ascension, and declination.        recrad  ( point, &range, &ra, &dec );       Restrictions      None.       Exceptions      Error free.       Files      None.       Author and Institution      H.A. Neilan     (JPL)       Literature References      None.       Version      -CSPICE Version 1.1.0, 22-OCT-1998 (NJB)        Made input vector const.     -CSPICE Version 1.0.0, 08-FEB-1998 (EDW)      Index Entries      rectangular coordinates to ra and dec     rectangular to right_ascension and declination             RECSPH: Rectangular to spherical coordinates         Abstract      Convert from rectangular coordinates to spherical coordinates.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  --------------------------------------------------     rectan     I   Rectangular coordinates of a point.     r          O   Distance of the point from the origin.     colat      O   Angle of the point from the positive Z-axis.     lon        O   Angle of the point from the XY plane in radians.       Detailed Input      rectan     The rectangular coordinates of a point.       Detailed Output      r          Distance of the point from the origin.      colat      Angle between the point and the positive z-axis.      lon        Angle of the point from the XY plane in radians.       Parameters      None.       Particulars      This routine returns the spherical coordinates of a point     whose position is input in rectangular coordinates.      spherical coordinates are defined by a distance from a central     reference point, an angle from a reference meridian, and an angle     from the z-axis.       Examples      Below are two tables.      Listed in the first table (under X(1), X(2) and X(3) ) are a     number of points whose rectangular coordinates are     taken from the set {-1, 0, 1}.      The result of the code fragment            recsph  ( X, r, colat, lon  )           Use the CSPICE routine  convrt  to convert the angular          quantities to degrees            convrt  ( colat, ""RADIANS"", ""DEGREES"", colat )           convrt  (  lon,  ""RADIANS"", ""DEGREES"", lon   )      are listed to 4 decimal places in the second parallel table under     r (radius), colat (co-latitude), and  lon  (longitude).        X(1)       X(2)     X(3)        r         colat       lon        --------------------------      ----------------------------       0.0000     0.0000   0.0000      0.0000     0.0000     0.0000       1.0000     0.0000   0.0000      1.0000    90.0000     0.0000       0.0000     1.0000   0.0000      1.0000    90.0000    90.0000       0.0000     0.0000   1.0000      1.0000     0.0000     0.0000      -1.0000     0.0000   0.0000      1.0000    90.0000   180.0000       0.0000    -1.0000   0.0000      1.0000    90.0000   -90.0000       0.0000     0.0000  -1.0000      1.0000   180.0000     0.0000       1.0000     1.0000   0.0000      1.4142    90.0000    45.0000       1.0000     0.0000   1.0000      1.4142    45.0000     0.0000       0.0000     1.0000   1.0000      1.4142    45.0000    90.0000       1.0000     1.0000   1.0000      1.7320    54.7356    45.0000       Restrictions      None.       Exceptions      Error free.       Files      None.       Author and Institution      W.L. Taber      (JPL)     E.D. Wright     (JPL)      Literature References      None.       Version      -CSPICE Version 1.1.0, 22-OCT-1998 (NJB)        Made input coordinate array const.     -CSPICE Version 1.0.0, 08-FEB-1998 (EDW)      Index Entries      rectangular to spherical coordinates             RESET: Reset Error Status         Abstract       Reset  the CSPICE error status to a value of ""no error.""    As a result, the status routine,  failed , will return a value    of SPICEFALSE      Copyright      Copyright (1998), California Institute of Technology.    U.S. Government sponsorship acknowledged.      Required Reading       ERROR       Brief I/O      VARIABLE  I/O  DESCRIPTION    --------  ---  --------------------------------------------------    None.      Detailed Input      None.      Detailed Output      None.      Parameters      None.      Particulars      Please read the ""required reading"" first!     The effects of this routine are:     1. The CSPICE status is set to a value of ""no error.""     2. The long and short error messages are set to blank.     3. Setting of the long error message is re-enabled.      Subsequent to a call to  reset , references to the status    indicator function,  failed , will return a value of SPICEFALSE,    until an error is detected.     This routine should be called in cases where one wishes    to attempt to continue processing after detection of an    error, and the ""RETURN"" error action is being used.  When    the error response action is set to ""RETURN"", routines    that have external references, or that can    detect errors, return immediately upon entry when an    error condition  exists .  This prevents a program from    crashing, but does not allow for a recovery attempt.     If one does wish to attempt to recover,    in general the procedure is to test for an error    condition, and if one  exists , respond to the error    (by outputting diagnostic messages, for example).  Next,    a call to  reset  can be made.  After resetting the    error status, the normal execution thread can be resumed.     It is also appropriate to call this routine when the error    response action is ""REPORT"", if one wishes to recover    from errors.      Examples      1.  In this example, we try to read a line from the file,        SPUD.DAT, using the toolkit routine,  rdtext .        When  failed  indicates an error, we grab the short        error message and its explanation, using  getmsg  (see),        log the messages using our user-defined routine,        USER_LOG (NOT a CSPICE routine),  reset  the        status, and keep going.            /.           We read a line from SPUD.DAT:           ./             rdtext  ( ""SPUD.DAT"", line, LENOUT, &eof );            if (  failed () )              {               /.              Oops! an error occurred during the read.              Recover the short error message and its              explanation,  reset  the error status,              log the messages, and continue...              ./                getmsg    ( ""SHORT""  , LENOUT, short_mess );               getmsg    ( ""EXPLAIN"", LENOUT, explain_mess );               USER_LOG (  SMSG );              USER_LOG (  EXPL );                reset ();              }      Restrictions      It can be dangerous to call this routine without    RESPONDING to the error condition first; by calling     reset , you are wiping out the CSPICE's knowledge of    the error.      Exceptions      This routine does not detect any errors.     However, this routine is part of the CSPICE error    handling mechanism.      Files      None.      Author and Institution      N.J. Bachman    (JPL)    K.R. Gehringer  (JPL)      Literature References      None.      Version      -CSPICE Version 1.0.1, 25-MAR-1998 (EDW)        Minor corrections to header.     -CSPICE Version 1.0.0, 08-FEB-1998 (EDW)      Index Entries       reset  error status            RETURN: Immediate Return Indicator         Abstract      True if CSPICE routines should return immediately upon entry.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading        ERROR        Brief I/O       VARIABLE  I/O  DESCRIPTION      --------  ---  --------------------------------------------------       The function returns the value, SPICETRUE, if and only if CSPICE      routines should return immediately upon entry.       Detailed Input       None.       Detailed Output       The function returns the value, SPICETRUE, if and only if CSPICE      routines should return immediately upon entry.  The criterion      for this is that the error response action is set to      ""RETURN"", and an error condition  exists .       Parameters      None.       Particulars       Please read the ""required reading"" first!       This routine can be referenced in non-toolkit code; in      fact, its use is encouraged.  Its purpose is to signal      to the routine calling it that the caller should      return immediately.  The reference to return should      be the first executable line of the calling program.       In ""RETURN"" mode, CSPICE routines      that have external references, or that can      detect errors, return immediately upon entry when an      error condition  exists .  They use return to determine      when these conditions are met.  Non--toolkit routines      can do the same.       Additionally, when an error is signalled in ""RETURN"" mode,      no further errors can be signalled until the error condition      is  reset  by a call to  reset .  Calls to  SIGERR  simply have      no effect.  Therefore, the error messages set in response      to the FIRST error that was detected will be saved until       reset  is called.  These messages can be retrieved by      calls to  getmsg .       There are a number of advantages to using this mechanism.      First, the likelihood of an error resulting in crash      in a different routine is greatly reduced.  Second,      a program does not have to test the error status      (using a reference to  failed ) after each call to a toolkit      routine, but rather can make one test of status at the end      of a series of calls.  See ""Examples"" below.       See the subroutine  erract  for definitions of the error action       codes.       Examples       1.  In this example, we show how to place a reference          to return in your code:          /.                No executable lines precede this one.                 Test whether to return before doing                anything else.         ./                 if ( return() )                  {                  return;                         }                 [ rest of code goes here]                           .                          .                          .        2.  Here's how one might code a sequence of calls          to routines with code that follows the pattern          given in example #1 above:                          .                         .                         .                 [ code may go here ]          /.                We call routines A, B, and C;  then we                test for errors, using the CSPICE error                status indicator,  failed :         ./                 A();                B();               C();                if (  failed () )                  {         /.                   If we're here, an error occurred.  The                   error might have been detected by A, B, C,                   or by a routine called by one of them.                   Get the explanation of the short error message                   and output it using the routine, user_out                   [user_out is a fictitious routine]:         ./                     getmsg  ( ""EXPLAIN"", MSG );                   user_out ( MSG );                   }                 [ rest of code goes here ]                            .                           .                           .       Restrictions       This routine has no effect unless the error action is ""RETURN""!       Exceptions       This routine does not detect any errors.       However, this routine is part of the CSPICE error      handling mechanism.       Files       None.       Author and Institution       N.J. Bachman    (JPL)      K.R. Gehringer  (JPL)       Literature References       None.       Version      -CSPICE Version 1.0.0, 08-FEB-1998   (EDW)      Index Entries      immediate return indicator             ROTATE: Generate a rotation matrix         Abstract      Calculate the 3x3 rotation matrix generated by a rotation     of a specified angle about a specified axis. This rotation     is thought of as rotating the coordinate system.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  --------------------------------------------------     angle      I   Angle of rotation (radians).     iaxis      I   Axis of rotation (X=1, Y=2, Z=3).     mout       O   Resulting rotation matrix [angle]                                                     iaxis       Detailed Input      angle   The angle given in radians, through which the rotation             is performed.      iaxis   The index of the axis of rotation.  The X, Y, and Z             axes have indices 1, 2 and 3 respectively.       Detailed Output      mout    Rotation matrix which describes the rotation of the             COORDINATE system through angle radians about the             axis whose index is iaxis.       Parameters      None.       Particulars      A rotation about the first, i.e. x-axis, is described by         |  1        0          0      |        |  0   cos(theta) sin(theta)  |        |  0  -sin(theta) cos(theta)  |      A rotation about the second, i.e. y-axis, is described by         |  cos(theta)  0  -sin(theta)  |        |      0       1        0      |        |  sin(theta)  0   cos(theta)  |      A rotation about the third, i.e. z-axis, is described by         |  cos(theta) sin(theta)   0   |        | -sin(theta) cos(theta)   0   |        |       0          0       1   |       rotate  decides which form is appropriate according to the value     of IAXIS.       Examples      If  rotate  is called from a C program as follows:             rotate  (  pi ()/4, 3, mout );      then mout will be given by                   | sqrt(2)/2   sqrt(2)/2   0  |           mout = |-sqrt(2)/2   sqrt(2)/2   0  |                  |     0           0       1  |       Restrictions      None.       Exceptions      Error free.      1) If the axis index is not in the range 1 to 3 it will be        treated the same as that integer 1, 2, or 3 that is congruent        to it mod 3.       Files      None.       Author and Institution      N.J. Bachman    (JPL)    W.M. Owen       (JPL)     W.L. Taber      (JPL)       Literature References      None.       Version      -CSPICE Version 1.0.0 08-FEB-1998 (NJB)        Based on SPICELIB Version 1.0.1, 10-MAR-1992 (WLT)      Index Entries      generate a rotation matrix             ROTMAT: Rotate a matrix         Abstract       rotmat  applies a rotation of angle radians about axis iaxis to a     matrix.  This rotation is thought of as rotating the coordinate     system.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  --------------------------------------------------     m1        I     Matrix to be rotated.     angle     I     Angle of rotation (radians).     iaxis     I     Axis of rotation (X=1, Y=2, Z=3).     mout      O     Resulting rotated matrix.      Detailed Input      m1      This is a matrix to which a rotation is to be applied.             In matrix algebra, the components of the matrix are             relative to one particular coordinate system. Applying              rotmat  changes the components of m1 so that they are             relative to a rotated coordinate system.      angle   The angle in radians through which the original             coordinate system is to be rotated.      iaxis   An index for the axis of the original coordinate system             about which the rotation by angle is to be performed.             iaxis = 1,2 or 3 designates the x-, y- or z-axis,             respectively.       Detailed Output      mout    The matrix resulting from the application of the             specified rotation to the input matrix m1.  If                 [angle]                              iaxis              denotes the rotation matrix by angle radians about iaxis,            (see the Rotations Required Reading document) then mout is             given by the following matrix equation:                 mout = [angle]      * m1                              iaxis              mout can overwrite m1.       Parameters      None.       Particulars      None.       Examples      Suppose that to  rotate  the a set of inertial axes to body fixed     axes, one must first roll the coordinate axes about the x-axis by     angle r to get x', y', z'.  From this one must pitch about the     y' axis by angle o to get x'', y'', z''.  And finally yaw the     x'', y'', z'' about the z'' axis by angle y to obtain the     transformation to bodyfixed coordinates.  If id is the identity     matrix, then the following code fragment generates the     transformation from interitial to body fixed.          rotmat  ( id, r, 1, m1   );         rotmat  ( m1, p, 2, m2   );         rotmat  ( m2, y, 3, tibf );       Restrictions      None.       Exceptions      Error free.      1) If the axis index is not in the range 1 to 3 it will be        treated the same as that integer 1, 2, or 3 that is congruent        to it mod 3.       Files      None.       Author and Institution      N.J. Bachman    (JPL)    W.M. Owen       (JPL)     W.L. Taber      (JPL)       Literature References      None.       Version      -CSPICE Version 1.1.0, 22-OCT-1998 (NJB)        Made input matrix const.     -CSPICE Version 1.0.0, 08-FEB-1998 (NJB)        Based on SPICELIB Version 1.0.1, 10-MAR-1992 (WLT)      Index Entries       rotate  a matrix             ROTVEC: Transform a vector via a rotation         Abstract      Transform a vector to a new coordinate system rotated by angle     radians about axis iaxis.  This transformation rotates v1 by     -angle radians about the specified axis.      Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.      Brief I/O      VARIABLE  I/O  DESCRIPTION     --------  ---  --------------------------------------------------     v1        I    Vector whose coordinate system is to be rotated.     angle     I    Angle of rotation in radians.     iaxis     I    Axis of rotation (X=1, Y=2, Z=3).     vout      O    Resulting vector [angle]      * v1 expressed in                                            iaxis                    the new coordinate system. vout can overwrite v1.       Detailed Input      v1      This is a vector (typically representing a vector fixed             in inertial space) which is to be expressed in another             coordinate system.  The vector remains fixed but the             coordinate system changes.      angle   The angle given in radians, through which the rotation             is performed.      iaxis   The index of the axis of rotation.  The X, Y, and Z             axes have indices 1, 2 and 3 respectively.       Detailed Output      vout    This is the vector expressed in the new coordinate system             specified by the angle of rotation and axis. If             [angle]       represents the rotation matrix described by                    iaxis             the angle and axis, (refer to the routine  ROTATE )             then vout = [angle]      * v1                                iaxis       Parameters      None.       Particulars      A rotation about the first, i.e. x-axis, is described by      |  1        0          0      |     |  0   cos(theta) sin(theta)  |     |  0  -sin(theta) cos(theta)  |      A rotation about the second, i.e. y-axis, is described by      |  cos(theta)  0  -sin(theta)  |     |      0       1        0      |     |  sin(theta)  1   cos(theta)  |      A rotation about the third, i.e. z-axis, is described by      |  cos(theta) sin(theta)   0   |     | -sin(theta) cos(theta)   0   |     |       0          0       1   |       rotvec  decides which form is appropriate according to the value     of iaxis and applies the rotation to the input vector.       Examples      Suppose that     v1 = (1.414, 0, 0), angle =  PI /4, iaxis = 3     then after calling  rotvec  according to              rotvec  (v1, angle, iaxis, vout)      vout will be equal to (1, -1, 0).       Restrictions      None       Exceptions      1) If the axis index is not in the range 1 to 3 it will be treated        the same as that integer 1, 2, or 3 that is congruent to it mod        3.       Files      None       Author and Institution      W.M. Owen       (JPL)     W.L. Taber      (JPL)       Literature References      None       Version      -CSPICE Version 1.1.1, 04-OCT-1999 (NJB)        Procedure line and abstract and were changed to dispel the       impression that the input vector is rotated by +angle       radians about the specified axis.     -CSPICE Version 1.1.0, 22-OCT-1998 (NJB)        Made input vector const.     -CSPICE Version 1.0.0, 08-FEB-1998   (EDW)      Index Entries       rotate  a vector             RPD: Radians per degree         Abstract      Return the number of radians per degree.      Copyright      Copyright (1997), California Institute of Technology.    U.S. Government sponsorship acknowledged.      Required Reading      None.      Brief I/O      The function returns the number of radians per degree.       Detailed Input      None.       Detailed Output      The function returns the number of radians per degree:  pi /180.    The value of  pi  is determined by the ACOS function. That is,         rpd  = acos ( -1. ) / 180.      Parameters      None.       Particulars      When the function is referenced, the value computed as shown     above is returned.      Examples      The code fragment below illustrates the use of  rpd .        /. Convert all angles to radians for output  ./           clock *=  rpd ()           cone  *=  rpd ()           twist *=  rpd ()        Restrictions      None.      Exceptions      Error free.       Files      None.       Author and Institution      W.L. Taber      (JPL)     I.M. Underwood  (JPL)     E.D. Wright     (JPL)      Literature References      None.      Version      -CSPICE Version 1.0.0, 08-FEB-1998 (EDW)      Index Entries      radians per degree            RQUAD: Roots of a quadratic equation         Abstract      Find the roots of a quadratic equation.       Copyright      Copyright (1995), California Institute of Technology.     U.S. Government sponsorship acknowledged.       Required Reading      None.       Brief I/O      Variable  I/O  Description     --------  ---  --------------------------------------------------      a          I   Coefficient of quadratic term.     b          I   Coefficient of linear term.     c          I   Constant.     root1      O   Root built from positive discriminant term.     root2      O   Root built from negative discriminant term.       Detailed Input      a,     b,     c              are the coefficients of a quadratic polynomial                          2                       ax   +   bx   +   c.       Detailed Output      root1,     root2         are the roots of the equation,                          2                       ax   +   bx   +   c   =  0.                     root1 and root2 are both arrays of length 2.  The                   first element of each array is the real part of a                   root; the second element contains the complex part                   of the same root.                    When a is non-zero, root1 represents the root                                     ____________                                   /  2                      - b   +    \/  b    -   4ac                      ---------------------------                                    2a                     and root2 represents the root                                     ____________                                   /  2                      - b   -    \/  b    -   4ac                      --------------------------- .                                    2a                     When a is zero and b is non-zero, root1 and root2                   both represent the root                       - c / b.       Parameters      None.       Particulars      None.       Examples      1)   Humor us and suppose we want to compute the ""golden ratio.""           The quantity r is defined by the equation              1/r = r/(1-r),           which is equivalent to               2             r   +  r  -  1  =  0.           The following code fragment does the job.               /.            Compute ""golden ratio.""  The root we want,                        __                      /               -1 + \/  5               -----------,                    2              is contained in root1.            ./               rquad  ( 1., 1., -1., root1, root2 );              printf ( ""The \""golden ratio\"" is %f\n"", root1[0] );       2)   The equation,               2             x   +  1  =  0           can be solved by the code fragment               /.            Let's do one with imaginary roots just for fun.             ./              rquad  ( 1.,  0.,  1.,  root1,  root2 );              printf ( ""root1 is %f   %f\n"", root1[0], root1[1] );             printf ( ""root2 is %f   %f\n"", root2[0], root2[1] );            The printed results will be something like:              root1 is 0.000000000000000   1.000000000000000             root2 is 0.000000000000000   -1.000000000000000       Restrictions      No checks for overflow of the roots are performed.       Exceptions      1)   If the input coefficients a and b are both zero, the error          SPICE(DEGENERATECASE) is signalled.  The output arguments          are not modified.       Files      None.       Author and Institution      N.J. Bachman   (JPL)       Literature References      None.       Version      -CSPICE Version 1.0.0, 13-JUN-1999 (NJB)      Index Entries      roots of a quadratic equation            [  Index |  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V  W  X  Y Z ]     $Id: Created Tue Nov 21 11:00:51 2000 by gen_spice_html.pl v1.6 $     Ed Santiago  /  esm@lanl.gov"
GX194-07-0618135	1                                   c     2                                   c     cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc     3                                         subroutine  green_function ( mtasa , n_spin_pola , n_spin_cant ,     4                                        >                           lmax , lmaxp , kkrsz , wx , wy , wz ,     5                                        >                           rins , r_zpl1 , r_zpl2 , r_mesh , jmt , jws ,     6                                        >                           pnrel , tau00_l , matom , zlr , jlr ,     7                                        >                           wfreg , wfirr , wf_ldim , kmax_phi , kmax_kkr ,     8                                        >                           ngaussr ,     9                                        >                           cgnt , lmax_gnt ,     10                                        >                           dos , dosck , green , dipole ,     11                                        >                           dele1 , lofk , mofk , lmax_rho ,     12                                        >                           irfit , irstart , irpts , irjpts , ie , nume ,     13                                        >                           iprint , istop , itscf )     14                                   c     ================================================================     15                                   c     16                                   c     17                                   c     ****************************************************************     18                                   c     input:     19                                   c                tau00_l     20                                   c                kkrsz   (size of KKR-matrix)     21                                   c                istop   (index of subroutine prog. stops in)     22                                   c     output:     23                                   c                dos     (wigner-seitz cell density of states)     24                                   c                dosck   (muffin-tin density of states)     25                                   c                green   (Green's function)     26                                   c     ****************************************************************     27                                   c     28                                         implicit   none     29                                   c     30                                   c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++     31                                         include    ' atom_param.h '     32                                   c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++     33                                   c     34                                         character   istop *20     35                                         character   sname *20     36                                   c     37                                         integer     mtasa , wf_ldim , kmax_phi , kmax_kkr , itscf     38                                         integer     irpts     39                                         integer     irjpts     40                                         integer     n_spin_pola     41                                         integer     n_spin_cant     42                                         integer     lmax , lmaxp     43                                         integer     lmax_rho , lmax_gnt     44                                         integer     kkrsz     45                                         integer     jmt     46                                         integer     jws     47                                         integer     m     48                                         integer     ie     49                                         integer     nume     50                                         integer     ir , l , l1     51                                         integer     ngaussr     52                                         integer     iprint     53                                         integer     zsl     54                                         integer     zsr     55                                         integer     zj_flag     56                                         integer     isp     57                                         integer     irfit (( lmax_rho + 1 ) * ( lmax_rho + 2 ) / 2 )     58                                         integer     irstart (( lmax_rho + 1 ) * ( lmax_rho + 2 ) / 2 )     59                                         integer     lofk ( kmax_phi )     60                                         integer     mofk ( kmax_phi )     61                                   c     62                                         real* 8       rins , r_zpl1 , r_zpl2 , r_mesh ( iprpts )     63                                         real* 8       cgnt ( lmax_gnt + 1 ,( lmax_gnt + 1 ) ** 2 ,( lmax_gnt + 1 ) ** 2 )     64                                         real* 8       fnpi     65                                         real* 8       pi     66                                         real* 8       two     67                                         parameter ( two = 2.0d0 )     68                                   c     69                                         complex* 16   wx ( 4 )     70                                         complex* 16   wy ( 4 )     71                                         complex* 16   wz ( 4 )     72                                         complex* 16   pnrel     73                                         complex* 16   matom ( lmax + 1 , n_spin_cant )     74                                         complex* 16   tau00_l ( kkrsz * kkrsz * n_spin_cant * n_spin_cant )     75                                         complex* 16   zlr ( iprpts * ( iplmax + 1 ), n_spin_cant )     76                                         complex* 16   jlr ( iprpts * ( iplmax + 1 ), n_spin_cant )     77                                         complex* 16   dos ( n_spin_cant * n_spin_cant )     78                                         complex* 16   dosck ( n_spin_cant * n_spin_cant )     79                                         complex* 16   green ( iprjpts , n_spin_cant * n_spin_cant )     80                                         complex* 16   dipole ( 6 , n_spin_cant * n_spin_cant )     81                                         complex* 16   t1     82                                         complex* 16   t2     83                                         complex* 16   t3     84                                         complex* 16   t4     85                                         complex* 16   dele1     86                                         complex* 16   wfreg ( wf_ldim , kmax_phi , kmax_kkr , n_spin_cant )     87                                         complex* 16   wfirr ( wf_ldim , kmax_phi , kmax_kkr , n_spin_cant )     88                                   c     89                                         parameter ( sname =' green_function ')     90                                   c     91                                   c     write(6,'(''green_f::r_zpl1,r_zpl2'',2f12.5)')r_zpl1,r_zpl2     92                                          pi = fnpi ()     93                                         call  zeroout ( green , 2 * iprjpts * n_spin_cant * n_spin_cant )     94                                   c     95                                         do  isp = 1 , n_spin_cant * n_spin_cant     96                                            if( isp .eq. 1 ) then     97                                                zsl = 1     98                                                zsr = 1     99                                                zj_flag = 1     100                                            else if( isp .eq. 2 ) then     101                                                zsl = 2     102                                                zsr = 1     103                                                zj_flag = 0     104                                            else if( isp .eq. 3 ) then     105                                                zsl = 1     106                                                zsr = 2     107                                                zj_flag = 0     108                                            else if( isp .eq. 4 ) then     109                                                zsl = 2     110                                                zsr = 2     111                                                zj_flag = 1     112                                            endif     113                                   c        --------------------------------------------------------------     114                                   c        write(6,'(''green::wf_ldim,lmax'',2i5)')wf_ldim,lmax     115                                   c        do ir=1,wf_ldim,50     116                                   c         do l1=0,lmax     117                                   c            write(6,'(''green::l,r,z,wf'',2i5,9d12.5)')     118                                   c    >       l1,(l1+1)**2,     119                                   c    >       r_mesh(ir),zlr(ir+iprpts*(l1),zsl),     120                                   c    >       wfreg(ir,(l1+1)**2,(l1+1)**2,zsl)     121                                   c        enddo     122                                   c        enddo     123                                            call  gf_local ( mtasa , zj_flag , lmax , lmaxp , kkrsz , rins ,     124                                        >                  r_zpl1 , r_zpl2 , r_mesh , jmt , jws , isp ,     125                                        >                  wx , wy , wz , n_spin_cant ,     126                                        >                  pnrel , tau00_l ( kkrsz * kkrsz * ( isp - 1 ) + 1 ),     127                                        >                  matom ( 1 , zsl ), matom ( 1 , zsr ),     128                                        >                  zlr ( 1 , zsl ), zlr ( 1 , zsr ), jlr ( 1 , zsr ),     129                                        >                  wfreg ( 1 , 1 , 1 , zsl ), wfreg ( 1 , 1 , 1 , zsr ),     130                                        >                  wfirr ( 1 , 1 , 1 , zsr ), wf_ldim , kmax_phi , kmax_kkr ,     131                                        >                  ngaussr , cgnt , lmax_gnt ,     132                                        >                  dos ( isp ), dosck ( isp ), green , dipole ( 1 , isp ),     133                                        >                  dele1 , lofk , mofk , lmax_rho ,     134                                        >                  irfit , irstart , irpts , irjpts , ie , nume ,     135                                        >                  pi , iprint , istop , itscf )     136                                   c        --------------------------------------------------------------     137                                         enddo     138                                   c     139                                   c     ================================================================     140                                   c     re-calculate dos and green so that:     141                                   c     142                                   c     dos(1) = Tr[dos],           green(r,1) = Tr[green(r)]     143                                   c                 ---                             -----     144                                   c     145                                   c     dos(2) = Tr[dos*wx],        green(r,2) = Tr[green(r)*wx]     146                                   c                 --- --                          -----    --     147                                   c     148                                   c     dos(3) = Tr[dos*wy],        green(r,3) = Tr[green(r)*wy]     149                                   c                 --- --                          -----    --     150                                   c     151                                   c     dos(4) = Tr[dos*wz],        green(r,4) = Tr[green(r)*wz]     152                                   c                 --- --                          -----    --     153                                   c     154                                   c     ================================================================     155                                         if( n_spin_cant .eq. 2 ) then         ! spin canting case     156                                             t1 = dos ( 1 ) + dos ( 4 )     157                                             t2 = dos ( 1 ) * wx ( 1 ) + dos ( 2 ) * wx ( 3 ) + dos ( 3 ) * wx ( 2 ) + dos ( 4 ) * wx ( 4 )     158                                             t3 = dos ( 1 ) * wy ( 1 ) + dos ( 2 ) * wy ( 3 ) + dos ( 3 ) * wy ( 2 ) + dos ( 4 ) * wy ( 4 )     159                                             t4 = dos ( 1 ) * wz ( 1 ) + dos ( 2 ) * wz ( 3 ) + dos ( 3 ) * wz ( 2 ) + dos ( 4 ) * wz ( 4 )     160                                             dos ( 1 )= t1     161                                             dos ( 2 )= t2     162                                             dos ( 3 )= t3     163                                             dos ( 4 )= t4     164                                             t1 = dosck ( 1 ) + dosck ( 4 )     165                                             t2 = dosck ( 1 ) * wx ( 1 ) + dosck ( 2 ) * wx ( 3 ) + dosck ( 3 ) * wx ( 2 ) + dosck ( 4 ) * wx ( 4 )     166                                             t3 = dosck ( 1 ) * wy ( 1 ) + dosck ( 2 ) * wy ( 3 ) + dosck ( 3 ) * wy ( 2 ) + dosck ( 4 ) * wy ( 4 )     167                                             t4 = dosck ( 1 ) * wz ( 1 ) + dosck ( 2 ) * wz ( 3 ) + dosck ( 3 ) * wz ( 2 ) + dosck ( 4 ) * wz ( 4 )     168                                             dosck ( 1 )= t1     169                                             dosck ( 2 )= t2     170                                             dosck ( 3 )= t3     171                                             dosck ( 4 )= t4     172                                   c        do ir=1,irjpts     173                                   c           t1=green(ir,1)+green(ir,4)     174                                   c           t2=green(ir,1)*wx(1)+green(ir,2)*wx(3)+     175                                   c    >         green(ir,3)*wx(2)+green(ir,4)*wx(4)     176                                   c           t3=green(ir,1)*wy(1)+green(ir,2)*wy(3)+     177                                   c    >         green(ir,3)*wy(2)+green(ir,4)*wy(4)     178                                   c           t4=green(ir,1)*wz(1)+green(ir,2)*wz(3)+     179                                   c    >         green(ir,3)*wz(2)+green(ir,4)*wz(4)     180                                   c           green(ir,1)=t1     181                                   c           green(ir,2)=t2     182                                   c           green(ir,3)=t3     183                                   c           green(ir,4)=t4     184                                   c        enddo     185                                     do  m = 1 , 6     186                                             t1 = dipole ( m , 1 ) + dipole ( m , 4 )     187                                             t2 = dipole ( m , 1 ) * wx ( 1 ) + dipole ( m , 2 ) * wx ( 3 ) + dipole ( m , 3 ) * wx ( 2 ) +     188                                        &       dipole ( m , 4 ) * wx ( 4 )
GX260-54-16323461	"Multiprecision Translation and Execution of Fortran Programs David H. Bailey February 3, 1993 Ref: ACM Trans. on Mathematical Software, vol. 19, no. 3 (Sept. 1993), pg. 288319 Abstract This paper describes two Fortran utilities for multiprecision computation. The first is a package of Fortran subroutines that perform a variety of arithmetic operations and transcendental functions on floating point numbers of arbitrarily high precision. This package is in some cases over 200 times faster than that of certain other packages that have been developed for this purpose. The second utility is a translator program, which facilitates the conversion of ordinary Fortran programs to use this package. By means of source directives (special comments) in the original Fortran program, the user declares the precision level and specifies which variables in each subprogram are to be treated as multiprecision. The translator program reads this source program and outputs a program with the appropriate multiprecision subroutine calls. This translator supports multiprecision integer, real and complex datatypes. The required array space for multiprecision data types is automatically allocated. In the evaluation of computational expressions, all of the usual conventions for operator precedence and mixed mode operations are upheld. Furthermore, most of the Fortran-77 intrinsics, such as ABS, MOD, NINT, COS, EXP are supported and produce true multiprecision values.  The author is with the NAS Applied Research Branch, NASA Ames Research Center, Moffett Field, CA 94035. E-mail: dbailey@nas.nasa.gov. 1   Intro duction Section 1 of this paper gives an introduction to the problem of multiprecision computation, including a number of specific applications. Section 2 describes in moderate detail the multiprecision function package (MPFUN), emphasizing the algorithms and computational techniques used. For full details, including a listing of the subroutines and argument definitions, see [4]. Section 3 describes the multiprecision translator program (TRANSMP), including instructions for usage. It is not necessary to understand details of the MPFUN package in order to effectively use it via the translator program. Readers mainly interested in the translator may skip directly to section 3. Full documentation and the actual source code for both of these programs may be obtained either from the ACM TOMS database or directly from the author by sending e-mail to dbailey@nas.nasa.gov. 1.0 Applications of Multiprecision Computation Multiprecision computation (i.e. computation using numeric precision beyond the single or double precision ordinarily provided in hardware) has been performed on electronic computers since the earliest models were introduced over forty years ago. One question that is frequently raised in this context is what applications justify a multiprecision facility. Actually, there are quite a number of applications, ranging from the highly theoretical to the completely practical. One important area of applications is in pure mathematics. While some still dispute whether a computer calculation can be the basis of a formal mathematical proof, certainly computations can be used to explore conjectures and reject those that are not sound. Some particularly nice applications of high precision computation to pure mathematics include the disproof of the Mertens conjecture by A. M. Odlyzko and H. J. J. te Riele [26], the disproof of the Bernstein conjecture in approximation theory by Varga and Carpenter and the resolution of the ""one-ninth"" conjecture [31]. A number of other examples of multiprecision applications in analysis, approximation theory and numerical analysis are also described in [31]. One area in which multiprecision computations are especially useful is the study of mathematical constants. For example, although Euler's constant  is believed to be transcendental, it has not been proven that  is even irrational. There is similar ignorance regarding other classical constants, such as log  and e +  , and also regarding some constants that have arisen in twentieth century mathematics, such as the Feigenbaum  constant (4.669201609 ) [13, 19] and the Bernstein  constant (0.2801694990 ) [31]. However, in most of these cases algorithms are known that permit these numbers to be computed to high precision. When this is done, the hypothesis of whether a constant  satisfies some reasonably simple, low-degree polynomial can be tested by computing the vector (1,,2 ,  ,n-1 ) and then applying one of the recently discovered integer relation finding algorithms [5, 20, 21]. Such algorithms, when applied to an n-long vector x, determine whether there exist integers ai such that ai xi = 0. Thus if a computation 2   finds such a set of integers ai , these integers are the coefficients of a polynomial satisfied by . Even if no such relation is found, these algorithms also produce bounds within which no relation can exist, which results are of interest by themselves. The author has performed some computations of this type [3, 5], and others are in progress. Some recent results include the following: if  satisfies an integer polynomial of degree 50 or less, then the Euclidean norm of the coefficients must exceed 7  1017 ; if Feigenbaum's  constant satisfies an integer polynomial of degree 20 or less, then the Euclidean norm of the coefficients must exceed 2  1015 . This last result is based on joint work with K. Briggs of the University of Melbourne in Australia. Computations of this sort have also been applied to study a certain conjecture regarding the  function. It is well known [8] that    (2) = 3 k=1  1 k 2 2k k -1 3 2k k  5  (3) = 2  (4) =   k=1   (-1)k k 1 k  36 17  k=1  4 2k k  These results have led some to suggest that   Z5 =  (5)/ k=1  (-1)k k  -1  5 2k k  might also be a simple rational or algebraic number. Unfortunately, the author and K. Briggs have established that if Z5 satisfies a polynomial of degree 25 or less, then the Euclidean norm of the coefficients must exceed 2  1037 . In one case the author, working in conjunction with H. R. P. Ferguson, obtained the following positive result: the third bifurcation point of the chaotic iteration xk+1 = rxk (1 - xk ), namely the constant 3.54409035955 , satisfies the polynomial 4913 + 2108t2 - 604t3 - 977t4 +8t5 +44t6 + 392t7 - 193t8 - 40t9 +48t10 - 12t11 + t12 (verified to a precision level of over 1000 digits). In this case, it can be proven fairly easily that this constant must be algebraic. The fact that it satisfies a polynomial of only degree 12 is something of a surprise. One of the oldest applications of multiprecision computation is to explore the perplexing question of whether the decimal expansions (or the expansions in any other radix) of  classical constants such as , e, 2, etc. are random in some sense. Almost any reasonable notion of randomness could be used here, including the property that every digit occurs with limiting frequency 1/10, or the stronger property that every n-long string of digits occurs with limiting frequency 10-n . This conjecture is believed to hold for a very wide range of mathematical constants, including all irrational algebraic numbers and the transcendentals  and e, among others. Its verification for a certain class of constants would 3   potentially have the practical application of providing researchers with provably reliable pseudorandom number generators. Unfortunately, however, this conjecture has not been proven in even a single instance among the classical constants of mathematics. Thus there is continuing interest in computations of certain constants to very high precision, in order to see if there are any statistical anomalies in the results. The computation of  has been of particular interest in this regard, and recently the one billion digit mark was passed by both Kanada [22] and the Chudnovskys [15], and the Chudnovskys have more recently extended their calculation to beyond two billion digits [16]. Statistical analyses of these results have so far not yielded any statistical anomalies (see for example [1]). An eminently practical application of multiprecision computation is the emerging field of public-key cryptography, in particular research on the Rivest-Shamir-Adleman (RSA) cryptosystem [27, 17]. This cryptosystem relies on the exponentiation of a large integer to a large integer power modulo a third large integer. The RSA cryptosystem has also spawned a great deal of research into advanced algorithms for factoring large integers, since the RSA system can be ""broken"" if one can factor the modulus. The most impressive result in this area so far is the recent factorization of the ninth Fermat number 2512 +1, an integer with 155 digits, which was accomplished by means of numerous computer systems communicating by electronic mail. This computation employed a new factoring algorithm, known as the ""number field sieve"" [25]. An indirect application of multiprecision computation is the integrity testing of computer systems. A unique feature of multiprecision computations is that they are exceedingly unforgiving of hardware or compiler error. This is because if even a single computational error occurs, the result will almost certainly be completely incorrect after a possibly correct initial section. In many other scientific computations, a hardware error in particular might simply retard the convergence to the correct solution. 2.0 Overview of the MPFUN Package The MPFUN package consists of approximately 10,000 lines of Fortran code organized into 87 subprograms. These routines operate on three custom data types: multiprecision (MP) numbers, multiprecision complex (MPC) numbers and double precision plus exponent (DPE) numbers. A MP number is represented by a single precision floating point array. The sign of the first word is the sign of the MP number. The magnitude of the first word is the number of mantissa words. The second word of the MP array contains the exponent, which represents the power of the radix, which is either 222 = 4194304 for Cray systems or 224 = 16777216 for most other systems, including systems based on the IEEE 754 standard. Words beginning with the third word in the array contain the mantissa. Mantissa words are floating point whole numbers between 0 and one less than the radix. For MP numbers with zero exponent, the ""decimal"" point is assumed after the first mantissa word. For example, the MP number 3 is represented by the three-long array (1., 0., 3.). A MP zero is represented by the two-long array (0., 0.). If sufficient memory is available, the maximum precision level for MP numbers is ap4   proximately 50 million digits. The limiting factor for this precision level is the accuracy of calculations in the FFT-based multiplication routine. Beyond a certain level, rounding the double precision results of the final FFT to nearest integer is no longer reliable (see section 2.1 below). The maximum dynamic range of MP numbers is about 1014,000,000 . A MPC number is represented as two consecutive MP numbers, which are the real and imaginary parts of the complex number. A DPE number is a pair (A, N), where A is a double precision scalar and N is an integer. It represents A * 2**N. These DPE numbers are useful in multiple precision applications to represent numbers that do not require high precision but may have large exponent ranges. One distinguishing feature of the MPFUN package is its portability. The standard version of MPFUN should run correctly, without alteration, on any computer with a Fortran77 compiler that satisfies some minimal accuracy requirements. Any system based on the IEEE 754 floating point standard, with a 24 bit mantissa in single precision and a 52 bit mantissa in double precision (24 and 53 bits, including the hidden bit), easily meets these requirements. All DEC VAX systems meet these requirements. All IBM mainframes and workstations meet these requirements. Cray systems meet these requirements with double precision disabled (i.e. by using only single precision). To insure that these routines are working correctly, a test suite is available. It exercises virtually all of the routines in the package and checks the results. This test program is useful in its own right as a computer system integrity test. Versions of this program have on numerous occasions disclosed hardware and software bugs in scientific computer systems. 2.1 The Four Basic Arithmetic Op erations Multiprecision addition and subtraction are not computationally expensive compared to multiplication, division, and square root extraction. Thus simple algorithms suffice to perform addition and subtraction. The only part of these operations that is not immediately conducive to vector processing is releasing the carries for the final result. A key component of a high-performance multiprecision arithmetic system is the multiply operation, since in real applications typically a significant fraction of the total time is spent here. The author's basic multiply routine, which is used for modest levels of precision, employs a conventional ""schoolboy"" scheme, although care has been taken to insure that the operations are vectorizable. A significant saving is achieved by not releasing the carries after each vector multiply operation, but instead waiting until 32 such vector multiply operations have been completed (16 on Crays). An additional saving is achieved by computing only the first half of the multiplication ""pyramid"". The schoolboy scheme for multiprecision multiplication has computational complexity proportional to n2 , where n is the number of words or digits. For higher precision levels, other more sophisticated techniques have a significant advantage, with complexity as low as n log n log log n. The history of the development of advanced multiprecision multiplication algorithms will not be reviewed here. The interested reader is referred to Knuth [23]. Because of the difficulty of implementing these advanced schemes and the widespread misconception that these algorithms are not suitable for ""practical"" application, they are 5   rarely employed. For example, none of the widely used multiprecision packages employs an ""advanced"" multiplication algorithm, to the author's knowledge. One instance where an advanced multiplication technique was employed is [17]. Another is Slowinski's searches for large Mersenne prime numbers [29]. The author has implemented a number of these schemes, including variations of the Karatsuba-Winograd algorithm and schemes based on the discrete Fourier transform (DFT) in various number fields [23]. Based on performance studies of these implementations, the author has found that a scheme based on complex DFTs appears to be the most effective and efficient for modern scientific computer systems. The complex DFT and the inverse complex DFT of the sequence x = (x0 ,x1 ,x2 ,  ,xN -1 ) are given by N -1  Fk (x) = - Fk 1 (x) =  j =0  xj e-  2ij k/N  1 N  N -1 j =0  xj e2ij  k/N  Let C (x, y ) denote the circular convolution of the sequences x and y : N -1  Ck (x, y ) =  j =0  xj y  k -j  where the subscript k - j is to be interpreted as k - j + N if k - j is negative. Then the convolution theorem for discrete sequences states that F [C (x, y )] = F (x)F (y ) or expressed another way C (x, y ) = F -1  [F (x)F (y )]  This result is applicable to multiprecision multiplication in the following way. Let x and y be n-long representations of two multiprecision numbers (without the sign or exponent words). Extend x and y to length 2n by appending n zeroes at the end of each. Then the multiprecision product z of x and y , except for releasing the carries, can be written as follows: z0 = x0 y0 z1 = x0 y1 + x1 y0 z2 = x0 y2 + x1 y1 + x2 y0   zn-1 = x0 yn-1 + x1 yn-2 +  + x   n-1 y0  6   z2n- z2n- z2n-  3 2 1   =x =x =0  n-1 yn-2 n-1 yn-1  +x  n-2 yn-1  It can now be seen that this multiplication pyramid is precisely the convolution of the two sequences x and y , where N = 2n. In other words, the multiplication pyramid can be obtained by performing two forward DFTs, one vector complex multiplication, and one inverse DFT, each of length N = 2n. Once the inverse DFT results have been adjusted to the nearest integer to compensate for any numerical error, the final multiprecision product may be obtained by merely releasing the carries as described above. The computational savings arises from the fact that complex DFTs may of course be economically computed using some variation of the fast Fourier transform (FFT) algorithm. The particular FFT algorithm utilized for the MPFUN advanced multiplication routine is described in [2]. Since in this application the two inputs and the final output of the convolution are purely real, an algorithm is employed that converts the problem of computing the FFT on real data to that of computing the FFT on complex data of half the size. This results in a computational savings of approximately 50 percent. One important detail has been omitted from the above discussion. Since the radix of MP numbers is either 222 or 224 , the products xj yk-j may be as large as 248 - 1, and the sum of a large number of these products cannot be represented exactly as a 64 bit floating point value, no matter how it is computed. In particular, the nearest integer operation at the completion of the final inverse FFT cannot reliably recover the exact multiplication pyramid result. For this reason, each input data word is split into two words upon entry to the FFT-based multiply routine. This permits computations of up to approximately 50 million digits to be performed correctly. The division of two MP numbers of modest precision is performed using a fairly straightforward scheme. Trial quotients are computed in double precision. This guarantees that the trial quotient is virtually always correct. In those rare cases where one or more words of the quotient are incorrect, the result is automatically fixed in a cleanup routine at no extra computational cost. In the advanced division routine, the quotient of a and b is computed as follows. First the following Newton-Raphson iteration is employed, which converges to 1/b: x k+1  = xk + xk (1 - bxk )  Multiplying the final approximation to 1/b by a gives the quotient. Note that this algorithm involves only an addition and a subtraction, plus two multiplications, which can be performed using the FFT-based technique mentioned above. Also note that the term in parentheses is small. In fact, the product of xk with this term can be performed with half the normal level of precision. Algorithms based on Newton iterations have the desirable property that they are inherently self-correcting. Thus these Newton iterations can be performed with a precision 7   level that doubles with each iteration. One difficulty with this procedure is that errors can accumulate in the trailing mantissa words. This error can be economically controlled by repeating the next-to-last iteration. This increases the run time by only about 25 percent, and yet the result is accurate to all except possibly the last two words. It can easily be seen that the total cost of computing a reciprocal by this means is about 2.5 times the cost of the final iteration. The total cost of a multiprecision division is only about five times the cost of a multiprecision multiplication operation of equivalent size. 2.2 Other Algebraic Op erations Complex multiprecision multiplication is performed using the identity (a1 + a2 i)(b1 + b2 i) = [a1 b1 - a2 b2 ]+[(a1 + a2 )(b1 + b2 ) - a1 b1 - a2 b2 ]i Note that this formula can be implemented using only three multiprecision multiplications, whereas the straightforward formula requires four. Complex division is performed using the identity (a1 + a2 i)(b1 - b2 i) a1 + a 2 i = b1 + b2 i b2 + b2 1 2 where the complex product in the numerator is evaluated as above. Since division is significantly more expensive than multiplication, the two real divisions ordinarily required in this formula are replaced with a reciprocal computation of b2 + b2 followed by two 1 2 multiplications. The advanced routines for complex multiplication and division utilize these same formulas, but they call the advanced routines for real multiplication and division. The general scheme described in the previous section to perform division by Newton iterations is also employed to evaluate a number of other algebraic operations. For example, square roots are computed by employing the following Newton iteration, which converges  to 1/ a: x k+1  = xk +   Multiplying the final approximation to 1/ a by a gives the square root. As with division, these iterations are performed with a precision level that approximately doubles with each iteration. The basic square root routine computes each iteration to one word more than a power of two. As a result, errors do not accumulate very much, and it suffices to repeat the third-from-the-last iteration to insure full accuracy in the final result. The added cost of repeating this iteration is negligible. The advanced square root routine cannot compute each iteration to one greater than a power of two words, since the levels of precision are restricted to exact powers of two by the FFT-based multiply procedure. Thus the advanced routine repeats the next-tolast iteration. As in the advanced divide routine, repeating the next-to-last iteration adds about 25 percent to the run time. 8  xk (1 - ax2 ) k 2   The complex square root of z = x + iy can be computed by applying the formulas  |x| + x2 + y 2 s= 2  y z = s+i if x  0 2s |y |  is if x < 0 = 2s where the  sign is taken to be the same as the sign of y . Cube roots are computed by the following Newton iteration, which converges to a- xk xk+1 = xk + (1 - a2 x3 ) k 3  2/3  :  Multiplying the final approximation to a-2/3 by a gives the cube root. Included in the MPFUN package are basic and advanced routines to compute the n-th power of multiprecision real and complex numbers. These operations are performed using the binary rule for exponentiation [23]. When n is negative, the reciprocal is taken of the final result. Along with the n-th power routines are two n-th root routines. When the argument a is very close to one and n is large, the n-th root is computed using a binomial expansion. Otherwise, it is computed using the following Newton iteration, which converges to a-1/n : xk xk+1 = xk + (1 - axn ) k n The reciprocal of the final approximation to a-1/n is the n-th root. These iterations are performed with a dynamic precision level as before. The MPFUN package includes four routines for computing roots of polynomials. There is a basic and an advanced routine for computing real roots of real polynomials and complex roots of complex polynomials. Let P (x) be a polynomial and let P (x) be the derivative of P (x). Let x0 be a starting value that is close to the desired root. These routines then employ the following Newton iteration, which converges directly to the root: x k+1  = xk - P (xk )/P (xk )  These iterations are computed with a dynamic precision level scheme similar to the routines described above. One requirement for this method to work is that the desired root is not a repeated root. If one wishes to apply these routines to find a repeated root, it is first necessary to reduce the polynomial to one that has only simple roots. This can be done by performing the Euclidean algorithm in the ring of polynomials to determine the greatest common divisor Q(x) of P (x) and P (x). Then R(x) = P (x)/Q(x) is a polynomial that has only simple roots. In section 1.0, the usage of integer relation finding algorithms was mentioned in exploring the transcendence of certain mathematical constants. The author has tested two 9   recently discovered algorithms for this purpose, the ""small integer relation algorithm"" in [21], which will be termed the HJLS routine from the initials of the authors, and the ""partial sum of squares"" (PSOS) algorithm of H. R. P. Ferguson [5]. While each has its merits, the author has found that the HJLS routine is generally faster. Thus it has been implemented in MPFUN. Neither algorithm will be presented here. Interested readers are referred to the respective papers. 2.3 Computing  The computation of  to high precision has a long and colorful history. Interested readers are referred to [6] for discussion of the classical history of computing  . Recently a number of advanced algorithms have been discovered for the computation of  that feature very high rates of convergence [8, 9]. The first of these was discovered independently by Salamin [28] and Brent [10] and is referred to as either the Salamin-Brent algorithm or the Gauss-Legendre algorithm, since the mathematical basis of this algorithm has its roots in the nineteenth century. This algorithm exhibits quadratic convergence, i.e. each iteration approximately doubles the number of correct digits. Subsequently the Borweins have discovered a class of algorithms that exhibit m-th order convergence for any m [8, 9]. The author has tested a number of these algorithms. Surprisingly, although the Borwein algorithms exhibit higher rates of convergence, the overall run time is generally comparable to that of the Salamin-Brent algorithm. Since the Salamin-Brent algorithm is simpler, it wa chosen for implementation in MPFUN. It may be stated as follows. Set a0 = 1, b0 = s  1/ 2, and d0 = 2 - 1/2. Then iterate the following operations beginning with k = 1: a b k  = (a =  k -1  +b  k -1  )/2  k  a  k -1 bk -1  dk = dk  -1  - 2k (ak - bk )2  Then pk = (ak + bk )2 /dk converges quadratically to  . Unfortunately this algorithm is not self-correcting like algorithms based on Newton iterations. Thus all iterations must be done with at least the precision level desired for the final result. 2.4 Transcendental Functions The basic routine for exp employs a modification of the Taylor's series for et : r2 r3 r4 et = (1 + r + + + )256 2n 2! 3! 4! where r = t /256, t = t - n log 2 and where n is chosen to minimize the absolute value of t . The exponentiation in this formula is performed by repeated squaring. Reducing t modulo log 2 and dividing by 256 insures that -0.001 < r  0.001, which significantly accelerates convergence in the above series. The basic routine for log employs the following Newton iteration, which converges to log t: t - exp xk xk+1 = xk + exp xk 10   The run time of the basic log routine is only about 2.5 times that of the exp routine. The advanced routine for log employs a quadratically convergent algorithm due to Salamin, as described in [12]. Inputs t that are extremely close to 1 are handled using a Taylor series. Otherwise let n be the number of bits of precision required in the result. If t is exactly two, select m > n/2. Then the following formula gives log 2 to the required precision:  log 2 = 2mA(1, 4/2m ) Here A(a, b) is the limit of the arithmetic-geometric mean: let a0 = a and b0 = b. Then iterate ak b +1  k+1  ak + b 2 = ak b k =  k  For other t select m such that s = t2m > 2n/2 . Then the following formula gives log t to the required precision:  - m log 2 log t = 2A(1, 4/s) The advanced routine for exp employs the following Newton iteration, which converges to et : x k+1  = xk (t +1 - log xk )  It might be mentioned that quadratically convergent algorithms for exp and log were first presented by Brent in [10], and others were presented by the Borweins in [7, 8]. Based on the author's comparisons, however, the Salamin algorithm is significantly faster than either the Brent or the Borwein algorithm. For this reason the Salamin algorithm was selected for inclusion in this package. The basic routine for sin and cos utilizes the Taylor's series for sin s: sin s = s - s3 s5 s7 + -  3! 5! 7!  where s = t - a /2 - b /16 and the integers a and b are chosen to minimize the absolute value of s. We can then compute sin t = sin(s + a /2+ b /16) cos t = cos(s + a /2+ b /16) by applying elementary trigonometric identities for sums. The sin and cos of b /16 are of  the form 0.5 2  2  2. Reducing t in this manner insures that -/32 < s  /32, which significantly accelerates convergence in the above series. 11   The advanced routines for cos and sin, and for inverse cos and inverse sin, employ complex arithmetic versions of the advanced algorithms described above for exp and log (recall that eix = cos x + i sin x). 2.5 Accuracy of Results Most of the basic routines, and the advanced multiplication routine, are designed to produce results correct to the last word of working precision. In the case of the transcendental functions, the last word should be accurate provided the input values  and log 2 have been computed to at least one word of precision greater than the working precision. Even so, an entire word can easily be lost in many calculations due to normalization, such as when the reciprocal of a number slightly less than one is computed. Thus computations should always be performed with at least one extra word of precision than required for the final results. For the advanced routines other than multiplication, the last two to four words are not reliable, as explained in the previous sections. For example, the ratio of two integers computed using the advanced division routine, the first of which is an exact multiple of the second, may not give the correct integer result. This situation should be familiar to users of Cray computers, which also uses Newton iterations to calculate reciprocals. Most anomalies of this sort can be remedied by adding a ""fuzz"" to results. The accuracy of results from the MPFUN routines can also be controlled by setting a rounding mode parameter. Depending on the value of this parameter, results are either truncated at the last mantissa word of working precision, or else the last word is rounded up depending on contents of the first omitted word. Whichever routines and rounding mode are used, it is not easy to determine ahead of time what level of precision is necessary to produce results accurate to a desired tolerance. Also, despite safeguards and testing, a package of this sort cannot be warranted to be free from bugs. Additionally, compiler and hardware errors do occur, and it is not certain that they will be detected by the package. Thus the following procedure is recommended to increase one's confidence in computed results: 1. Start with a working double precision program, and then check that the ported multiprecision code duplicates intermediate and final results to a reasonable accuracy. 2. Where possible, use the ported multiprecision code to compute special values that can be compared with other published high precision values. 3. Repeat the calculation with the rounding mode parameter changed, in order to test the sensitivity of the calculation to numerical error. Alternatively, repeat the calculation with the precision level set to a higher level. 4. Repeat the calculation on another computer system, in order to certify that no hardware or compiler error has occurred.  12   2.6 MPFUN Performance One application of a package such as MPFUN is to remedy difficult numerical problems that sometimes arise in conventional scientific programs. In these cases, a precision level perhaps double or triple that of ordinary machine precision is all that is required. One might wonder how much longer such a program is likely to run using calls to MPFUN. Using the translator program described below, the author has converted to multiprecision a program that, among other things, computes fast Fourier transforms (FFTs). The precision level was 40 digits. On a Silicon Graphics RISC workstation, the multiprecision code ran 135 times slower than the same program with ordinary double precision (64-bit) arithmetic. Thus while such runs are indeed possible, they are not to be considered lightly. Another application of a package such as MPFUN is for problems where the precision level required is much higher than that which can be obtained through ordinary machine arithmetic, perhaps hundreds or even thousands of digits. Such applications arise most often in numerical studies of mathematical questions. In such cases the dominant computational cost is not merely subroutine calling overhead, and algorithmic factors become more significant. One way to compare the performance of the author's package with other multiprecision packages is to compare timings for the computation of a mathematical constant such as  to high precision, since this is easily programmed and yet exercises all of the basic arithmetic routines. Tables 1 and 2 give some performance results on this problem for the MPFUN package, the Mathematica package and Brent's package. The algorithm used by Mathematica is not mentioned in the Mathematica reference book [32], but it is probably either the Salamin-Brent algorithm or one of the Borwein algorithms. The algorithm used by Brent's package for computing  is the Salamin-Brent algorithm, basically the same as described in section 2.3. The timings in Table 1 are for a Silicon Graphics model 4D-380 RISC workstation (one processor), which has a theoretical peak performance of 16 MFLOPS and a Linpack performance of 4.9 MFLOPS (double precision figures). The timings in Table 2 are for a Cray Y-MP supercomputer (one processor), which has a theoretical peak performance of 330 MFLOPS and a Linpack performance of 90 MFLOPS. When these runs were made, the SGI system was running IRIX 3.3 system software, and the Cray was running UNICOS 6.0. A blank in the table indicates that the run would have taken an unreasonable amount of time and was not performed. The numbers of digits in the second column of the two tables correspond to 7.225  2m and 6.623  2m , respectively, which are the sizes convenient for the FFT-based multiplication scheme described above. It can be seen from these results that the MPFUN package is the fastest of the three at all precision levels on both systems. On the SGI system, MPFUN is nearly twice as fast as Mathematica and three times as fast as Brent's package for the lowest precision levels. Once the level of precision rises above 1000 digits, MPFUN has a considerable advantage, due mainly to its FFT-based multiply routine. At 29,590 digit precision, the highest level at which all three could be compared, the MPFUN package is seven times faster than Mathematica and 18 times faster than Brent's package. 13   m Digits MPFUN Mathematica Brent 3 60 0.011 0.020 0.033 4 115 0.024 0.040 0.062 5 230 0.053 0.100 0.174 6 460 0.139 0.340 0.543 7 925 0.444 1.190 2.150 8 1,850 1.420 4.570 8.610 9 3,700 4.880 17.410 34.550 10 7,400 14.150 68.240 145.330 11 14,795 41.800 270.600 619.160 12 29,590 146.890 1080.000 2661.640 13 59,185 504.090 14 118,370 1361.190 Table 1: SGI Workstation Performance Results (seconds)  m Digits MPFUN Brent 4 105 0.006 0.019 5 210 0.010 0.037 6 425 0.018 0.088 7 845 0.037 0.229 8 1,695 0.088 0.815 9 3,390 0.177 3.176 10 6,780 0.386 13.040 11 13,565 0.772 54.620 12 27,125 1.598 230.800 13 54,250 3.450 975.600 14 108,505 7.503 15 217,010 16.710 16 434,020 36.490 17 868,045 81.690 18 1,736,090 173.300 Table 2: Cray Y-MP Performance Results (seconds)  14   On the Cray Y-MP, the MPFUN package is three times faster than Brent's package at the lowest precision level and 280 times faster at 54,250 digits precision, the highest level at which both could be compared. Two reasons this ratio is so high on the Cray Y-MP are (1) the MPFUN routines employ floating point arithmetic, whereas Brent's package uses integer operations, and (2) a high percentage of operations in the MPFUN routines are performed in vector mode, whereas much of the computation in Brent's package is done in scalar mode. At the highest precision level listed, the Y-MP is running the author's code at 195 MFLOPS, or 59% of the one processor peak rate. Since Brent's package and Mathematica are perhaps the most widely used packages of this sort, other authors typically compare their performance figures with one of these. For example, Smith [30] compares his package with Brent's. Since Smith's timings for fundamental add and multiply operations are roughly comparable to Brent's, it would be expected that MPFUN would exhibit similar performance ratios with Smith's package. 3.0 Overview of the Multiprecision Translator Conversion of a conventional scientific application program to use the MPFUN routines is generally straightforward, but it is often tedious and error prone. For example, if the slightest error is made in any of the arguments to the many subroutine calls, not only will the results be in error, but the program may abort with little information to guide the programmer. As a result of these difficulties, few serious scientific programs have been manually converted to use the MPFUN routines. Similar difficulties have plagued programmers who have attempted to use other multiprecision systems, such as Brent's package [11]. To facilitate such conversions, the author has developed a translator program that accepts as input a conventional Fortran-77 program to which has been added certain special comments that declare the desired level of precision and specify which variables in each subprogram are to be treated as multiprecision. This translator then parses the input code and generates an output program that has all of the calls to the appropriate MPFUN routines. This output program may then be compiled and linked with the MPFUN package for execution. This translation program allows one to extend the Fortran-77 language with the datatypes MULTIP INTEGER, MULTIP REAL and MULTIP COMPLEX. These datatypes can be used for integer, floating point or complex numbers of an arbitrarily high, pre-specified level of precision. Variables in the input program may be declared to have one of these multiprecision types in the output program by placing directives (special comments) in the input file. In this way, the input file remains an ANSI Fortran-77 compatible program and can be run at any time using ordinary arithmetic on any Fortran system for comparison with the multiprecision equivalent. This translator supports a large number of Fortran-77 constructs involving multiprecision variables, including all the standard arithmetic operators, mixed mode expressions, automatic type conversions, comparisons, logical IF constructs, function calls, READ and WRITE statements and most of the Fortran intrinsics (i.e. ABS, MOD, COS, EXP, etc.). 15   Storage is automatically allocated for multiprecision variables, including temporaries, and the required initialization for the MPFUN package is automatically performed. This processor translates programs to use the standard MP routines from the author's MPFUN package. If one wishes to utilize this translator in connection with the extra-high precision routines of this package, which are designed for precision levels greater than about 1,000 digits, contact the author for instructions. 3.1 Op eration of the Translator Program This translator program should run on any Fortran-77 system that supports recursive subroutine references. On some systems, including Sun and IBM workstations, a minor source modification and/or a special compiler option must be enabled to permit the program to run correctly. Detailed instructions for compiling and testing the translator on various systems are given in a ""read-me"" file that accompanies the program code. The translator has been successfully implemented on Cray supercomputers, Sun workstations, SGI workstations, IBM workstations and mainframes (AIX operating system), DEC workstations, HP workstations and Intel parallel computers. The translator is in effect a compiler in the sense that it identifies and analyzes every input statement. It develops a symbol table that contains type and dimension information for all variables used in a subprogram. A number of Fortran statements, such as DO, CONTINUE and OPEN statements, are not modified by the translator. Most other statements are analyzed in detail, including type declarations, IMPLICIT, COMMON, DIMENSION, PARAMETER, READ, WRITE and CALL statements, as well as all assignment statements. If any input statement is modified or translated, the original statement is included in the output file as a comment, starting with the string CMP>. The comment CMP< is placed after the translated lines. Warnings and error messages are also written in the output file. Warnings are issued as comments starting with CMP*. Fatal error messages start with ***. When a fatal error is detected, the message is output on the output file, and processing is terminated. Thus to make sure that the translation of an input program was successful, check the end of the output file to make sure there is no fatal error message. It is also strongly recommended that the output program be scanned for CMP* warning messages before it is compiled and executed. 3.2 Precision Level and Explicit Typ e Directives In the following, an MP statement will be defined as a statement that has at least one MP variable. An MP subprogram will be defined as a subprogram with at least one MP variable. Table 3 gives several datatype abbreviations that will be used hereafter in this paper. At the beginning of a file containing a conventional Fortran-77 code to be translated, before any program or subroutine statement, a directive (i.e. special comment) of the following form must be inserted: CMP+ PRECISION LEVEL 120  16   IN SP DP CO DC MPI MPR MPC MP  Integer Single precision real Double precision real Single precision complex Double precision complex (non-ANSI extension of Fortran-77) Multiprecision integer Multiprecision real Multiprecision complex Denotes the three multiprecision types collectively Table 3: Datatype Abbreviations  This denotes that the maximum precision level to be employed in this program is 120 digits. Only one such declaration is allowed in a single file, and Fortran-77 files whose translated routines later will be linked together must have equivalent precision level declarations. This directive must precede any of the other CMP+ directives to be described below. This and all other MP directives described in this paper may alternately be written with lower case alphabetics. Variables in a subprogram of the input Fortran-77 program file that are to be treated as MP by the translator program may be declared by explicit MP type directives, such as the following: CMP+ MULTIP INTEGER IA, IPR, KMAX3 CMP+ MULTIP REAL SUM, TOL34, X, Y CMP+ MULTIP COMPLEX W, ZAB  An MP variable must be declared prior to any appearance of that variable in the subprogram, including any appearance in a type declaration, DIMENSION or COMMON statement. An exception to this rule is that MP variable names appearing in the argument list of a FUNCTION or SUBROUTINE statement may be afterwards declared. However, if the function name of a function subprogram is to have an MP type, this name must be declared with an MP type directive immediately preceding the FUNCTION statement. The dimensions for MP variables are not included in MP type directives. These dimensions will be taken from the standard type declaration, DIMENSION or COMMON statement where these dimensions are defined in the original program. 3.3 Implicit Typ e Directives Many Fortran-77 codes utilize implicit typing of variables, either with the default convention or with IMPLICIT statements. For example, many programmers use an IMPLICIT statement to automatically declare all variables whose first letters are in the ranges A-H and O-Z to be DP. To simplify the translation of such code, implicit MP type directives may be used, as in these examples: 17   CMP+ IMPLICIT MULTIP REAL (A-H, O-Z) CMP+ IMPLICIT MULTIP INTEGER (M) CMP+ IMPLICIT MULTIP COMPLEX (C, Z)  Implicit MP type directives should appear at the beginning of a subprogram, just like standard IMPLICIT statements. An implicit MP type directive overrides any standard IMPLICIT statement, but it does not override either an explicit MP type directive or a standard type statement. In function subprograms, an implicit MP type directive may not be used to declare the type of the function name. Use an explicit MP type directive for this purpose, placed immediately before the FUNCTION statement. 3.4 The SAFE and FAST Options Expressions involving MP variables and constants are evaluated using precedence conventions of Fortran-77, and using predictable extensions of 77 mixed mode conventions. There are two options for the evaluation of operations: FAST and SAFE. The difference between these conventions may the following example, where A and B are MPR and N is an ordinary integer B = A + 1.D0 / N  the operator the Fortranmixed mode be seen with variable:  With the FAST option, the subexpression 1.D0 / N is evaluated using DP arithmetic, and the result temporary has type DP. With the SAFE option, which is the default, 1.D0 / N is performed using MP arithmetic, and the result temporary has type MPR. As the name signifies, the FAST option produces somewhat more efficient translated code, but it may also give unexpectedly inaccurate answers, for instance if N in the above example has the value 7. An exception to the SAFE option is in the argument lists of subroutine calls or nonintrinsic function references. Expressions appearing in these lists are always evaluated using the FAST option, since this corresponds more closely to the Fortran convention that most users expect. Thus in the statement B = 3 * FUN (N - 1, A)  the subexpression N - 1 is always evaluated using ordinary integer arithmetic, and the result temporary, which is passed to FUN, has type IN. The user may switch between these options by inserting one of the following directives in the declaration section of any subprogram: CMP+ MIXED MODE FAST CMP+ MIXED MODE SAFE  For the operators + - * /, Tables 4 and 5 give the types of results with these two options. Table 6 lists the argument types and results defined for the ** operator. In Table 6, if a particular combination is not listed, or if its position in the table is blank, then it is not 18   defined. Comparison operations (i.e. .EQ., .LT., etc.), where one or both of the operands are MP, are permitted both in logical IF statements and in logical assignment statements. If one of the operands has type CO, DC or MPC, only .EQ. and .NE. comparisons are permitted. 3.5 Multiprecision Constants With the SAFE option, all IN constants appearing in MP statements are considered MPI constants and are converted to full precision, and all SP or DP constants in MP statements are considered MPR constants and are converted to full precision. With the FAST option, IN, SP and DP constants are recognized and treated as such by the translator. They are merely passed unchanged to the output program and are converted to binary by the underlying Fortran system. For modest sized whole numbers and exact binary fractions, these constants are converted exactly and produce accurate results when they appear in expressions with MP variables. However, SP or DP constants that cannot be precisely converted (i.e. 1.01D0), or IN, SP or DP constants that have more significant digits than can be exactly accommodated in these datatypes, may result in inaccurate MP calculations. To avoid such difficulties with the FAST option, the user may explicitly specify that a constant in the input program will be treated as an MP constant for the output program. This is done by appending +0 to the constant, as in the following examples: 3+0 -12345678901234567890+0 3.141592653589793+0 1.2345678901234567890D-13+0  The first two constants have type MPI, and the last two have type MPR. Embedded blanks are allowed anywhere in these constants. MP constants must appear in a context where the plus operation would actually be performed between the two components of the MP constant if interpreted according to the standard Fortran rules for evaluating expressions. For example, the expression N*12345+0 is not treated as containing an MP constant. Write this as N*(12345+0) if so intended. MP constants are recognized as such only in MP statements. There is no definition of this sort for MPC constants, but MPC constants may be defined by using the special conversion function DPCMPL (see section 3.6), where the two arguments are MPR constants. MP constants may be defined symbolically using PARAMETER statements. The parameter assignment expression for an MP variable may reference previously defined MP and nonMP parameters, and it may also include intrinsic function references. All such assignments are performed upon entry to the subprogram the first time it is called. 3.6 Intrinsic Functions Table 7 lists Fortran intrinsic functions that are supported by this translator with MP arguments. References to these functions will be automatically translated to call 19   Arg. 1 / Arg. 2 IN IN IN SP SP DP DP CO CO DC DC MPI MPI MPR MPR MPC MPC  SP SP SP DP CO DC MPR MPR MPC  DP DP DP DP CO DC MPR MPR MPC  CO CO CO DC CO DC MPC MPC MPC  DC MPI MPR DC MPI MPR DC MPR MPR DC MPR MPR DC MPC MPC DC MPC MPC MPC MPI MPR MPC MPR MPR MPC MPC MPC  MPC MPC MPC MPC MPC MPC MPC MPC MPC  Table 4: Results of Mixed Mode Arithmetic Operations with the FAST option  Arg. 1 / Arg. 2 IN IN MPI SP MPR DP MPR CO MPC DC MPC MPI MPI MPR MPR MPC MPC  SP MPR MPR MPR MPC MPC MPR MPR MPC  DP MPR MPR MPR MPC MPC MPR MPR MPC  CO MPC MPC MPC MPC MPC MPC MPC MPC  DC MPC MPC MPC MPC MPC MPC MPC MPC  MPI MPI MPR MPR MPC MPC MPI MPR MPC  MPR MPR MPR MPR MPC MPC MPR MPR MPC  MPC MPC MPC MPC MPC MPC MPC MPC MPC  Table 5: Results of Mixed Mode Arithmetic Operations with the SAFE option (default)  20   Arg. 1 IN IN or SP IN, SP or DP IN, SP or CO IN, SP, DP, CO or DC IN IN, SP or DP CO CO CO DC DC MPI MPI MPR MPC  Arg. 2 IN SP DP CO DC MPI MPR IN SP DP or DC IN SP, DP, CO or DP IN or MPI SP, DP or MPR IN, SP, DP, MPI or MPR IN  Result FAST SAFE IN MPI SP MPR DP MPR CO DC MPI MPI MPR MPR CO MPC CO DC DC MPC DC MPI MPI MPR MPR MPR MPR MPC MPC  Table 6: Defined Combinations for the ** Operator  21   the appropriate routines from the MPFUN package, provided the arguments are of the appropriate MP type. If the SAFE option is in effect, non-MP arguments are first converted to MP, so that true MP results are always returned. If the user requires either a function not listed here or a function with an argument type not listed here, contact the author. Note that Table 7 does not include any of the (obsolescent) type-specific Fortran-77 functions (i.e. AMOD, DABS, MIN0, etc.). This is in keeping with the Fortran-77 convention that these are defined only for specific IN, SP and DP argument types. References to these functions are not permitted in MP statements. Use the equivalent generic Fortran-77 functions (i.e. MOD, ABS, MIN, etc.) instead. Also note in Table 7 that the conversion intrinsics of Fortran-77, namely INT, CMPLX, DBLE, DCMPLX and REAL, return results of types IN, CO, DP, DC and SP, respectively, even though the arguments have MP types. This is in keeping with the conventions of Fortran-77. If one wishes to truncate an MPR number to MPI, form an MPC number from two MPR numbers, or extract the MPR real and imaginary components of an MPC number, the special functions MPINT, DPCMPL, DPREAL, DPIMAG (see Table 8) should be used instead. These special functions are not defined for ordinary SP, DP, CO or DC arguments in the translated program (although they may be in the input program). Thus, for example, DPREAL cannot be used to convert a DP number to MPR. Type conversions such as this can be performed either by simple assignment statements, or else by defining an external MP function. To preserve comparable functionality between an input Fortran-77 program that uses one of these four special conversion functions and the output MP program, equivalent SP or DP function subprograms should be included in the input file. Table 9 has some examples of equivalent definitions for these functions that use DP and DC datatypes. If your program uses ordinary SP and CO datatypes instead, these sample subprograms need to be changed accordingly. Do not place any MP directives in these function subprograms. If another subprogram references one of these functions, it should declare the argument and function names to be of the appropriate types (i.e. IN, DP or DC). However, the names MPINT, DPCMPL, DPREAL and DPIMAG do not need to be declared with MP type directives in the subprograms where they are referenced. In the output program, MP results will be automatically be returned with types according to Table 8, and these sample subprograms will be ignored. With the FAST option, non-MP arguments to intrinsic functions appearing in MP statements are passed without change to the non-MP intrinsic functions. For non-MP arguments the translator recognizes the following ""generic"" intrinsic function names and assigns result types according to argument types, in accordance with the standard Fortran conventions: ABS, ACOS, AINT, AIMAG, ANINT, ASIN, ATAN, ATAN2, CHAR, CMPLX, CONJG, COS, COSH, DBLE, DCMPLX, DIM, DIMAG, DREAL, EXP, ICHAR, INDEX, INT, LEN, LOG, LOG10, MAX, MIN, MOD, NINT, REAL, SIGN, SIN, SINH, SQRT, TAN, TANH.  Note that this list, like Table 7, does not include any of the type-specific Fortran-77 intrinsic functions (i.e. AMOD, DABS, MIN0, etc.). References to these functions are not permitted 22   Function ABS  ACOS AINT ANINT ASIN ATAN ATAN2 CMPLX CONJG COS COSH DBLE  DCMPLX EXP INT  LOG LOG10 MAX MIN MOD NINT REAL  SIGN SIN SINH SQRT TAN TANH  Arg. 1 MPI MPR MPC MPR MPR MPR MPR MPR MPR MPC MPC MPR MPR MPI MPR MPC MPC MPR MPI MPR MPC MPR MPR MPI MPR MPI MPR MPI MPR MPI MPR MPI MPR MPC MPI MPR MPR MPR MPR MPC MPR MPR  Arg. 2  MPR  MPI MPR MPI MPR MPI MPR  MPI MPR  Result MPI MPR MPR MPR MPR MPR MPR MPR MPR CO MPC MPR MPR DP DP DP DC MPR IN IN IN MPR MPR MPI MPR MPI MPR MPI MPR MPI MPR SP SP SP MPI MPR MPR MPR MPR MPC MPR MPR  Table 7: Fortran Intrinsics Supported with MP Arguments 23   Function MPINT DPCMPL DPREAL DPIMAG  Arg. 1 Arg. 2 Result MPR MPI MPR MPR MPC MPC MPR MPC MPR  Table 8: Special MP Conversion Functions  FUNCTION MPINT (X) DOUBLE PRECISION X MPINT = INT (X) RETURN END FUNCTION DPCMPL (A, B) DOUBLE COMPLEX DPCMPL DOUBLE PRECISION A, B DPCMPL = DCMPLX (A, B) RETURN END FUNCTION DPREAL (C) DOUBLE PRECISION DPREAL DOUBLE COMPLEX C DPREAL = DBLE (C) RETURN END FUNCTION DPIMAG (C) DOUBLE PRECISION DPIMAG DOUBLE COMPLEX C DPIMAG = DIMAG (C) RETURN END  Table 9: DP Equivalents of the Special Conversion Functions  24   in MP statements. Use the equivalent generic Fortran-77 functions (i.e. MOD, ABS, MIN, etc.) instead. 3.7 Other Sp ecial Functions and Constants Whenever the translator encounters a reference to COS or SIN in the source program, it inserts a call to the MPFUN routine MPCSSN. However, in many instances the user's code requires both function values for a single argument, often computed in adjacent lines of code. Since MPCSSN actually returns both the cosine and sine of the input argument at no extra cost, the two calls to MPCSSN are redundant and may represent a significant waste of computing time. If run-time performance is an issue in such programs, the user may optionally replace the separate references to COS and SIN with a single call to the special MP subroutine DPCSSN, which has three arguments: the first is the input value, and the second and third are the output cosine and sine values. The translator recognizes this subroutine name and will substitute a call to MPCSSN to produce MP results. For compatibility purposes, a functional equivalent of DPCSSN should be included in the program file. A DP example is shown in Table 10. The analogous subroutine name recognized for the hyperbolic functions COSH and SINH is DPCSSH (see Table 10). Another operation of this nature is root extraction, i.e. B = A ** (1.D0 / N), for which the efficient routine MPNRT exists in the MPFUN package. Thus it is recommended (for improved run-time performance) that any code in the input program that performs root extraction using the ** operator be changed to reference the function DPNRT instead, i.e. B = DPNRT (A, N). A DP equivalent of DPNRT is shown in Table 10. One additional special function that many users may find useful produces pseudorandom MPR numbers. The routine MPRAND in the MPFUN package generates pseudorandom numbers uniformly in the range (0, 1). To access this routine by means of the translator, one references the special function DPRAND. This function has no arguments. One references it by means of statements such as A = 3 * DPRAND (). It is not possible to write a completely equivalent DP version of this routine. However, the basic pseudorandom number functionality can be reproduced by means of a simple routine such as the one shown in Table 10. The sample program definitions for DPCSSN, DPCSSH, DPNRT and DPRAND in Table 10, like the definitions of the special conversion functions in Table 9, are only for the purpose of providing comparable functionality when the input program is run with ordinary SP or DP arithmetic, and are ignored in the translated program. Do not place any MP directives in any of these sample subprograms. If another subprogram references either DPNRT or DPRAND, it should declare the function name to be of the appropriate type (DP in the examples above). However, the names DPNRT and DPRAND do not need to be declared with an MP type directive in subprograms that reference them. The constants log 2 = 0.69314  , log 10 = 2.30258  and  = 3.14159  are computed in the program initialization and are available in any subprogram that contains MP variables. These values may be referenced by the user by means of the special variable 25   SUBROUTINE DPCSSN (A, X, Y) DOUBLE PRECISION A, X, Y X = COS (A) Y = SIN (A) RETURN END SUBROUTINE DPCSSH (A, X, Y) DOUBLE PRECISION A, X, Y X = COSH (A) Y = SINH (A) RETURN END FUNCTION DPNRT (A, N) DOUBLE PRECISION A, DPNRT DPNRT = A ** (1.D0 / N) RETURN END FUNCTION DPRAND () C C C C C This routine returns a pseudorandom DP floating number nearly uniformly distributed between 0 and 1 by means of a linear congruential scheme. 2^28 pseudorandom numbers with 30 bits each are returned before repeating. IMPLICIT DOUBLE PRECISION (A-H, O-Z) PARAMETER (F7 = 78125.D0, R30 = 0.5D0 ** 30, T30 = 2.D0 ** 30) SAVE SD DATA SD/314159265.D0/ C T1 = F7 * SD T2 = AINT (R30 * T1) SD = T1 - T30 * T2 DPRAND = R30 * SD C RETURN END  Table 10: Suggested DP Equivalents of DPCSSN, DPCSSH, DPNRT and DPRAND  26   names DPL02, DPL10 and DPPIC. Whenever any of these names appears in a statement, the translator substitutes the MP value. For compatibility purposes, any subprogram that references one of these constants should declare it to be SP or DP and set its approximate decimal value in a parameter statement. Example: DOUBLE PRECISION DPPIC PARAMETER (DPPIC = 3.141592653589793D0)  This parameter statement will be ignored in the output program, and the MP value will be used instead. The names DPL02, DPL10 and DPPIC do not need to be declared with an MP type directive. Do not attempt to define any of these values by means of assignments or function calls. 3.8 Input and Output of MP Numb ers MP variables may appear in READ or WRITE statements only with the following two special forms: WRITE (6, *) VAR1, VAR2(I), VAR3(I,J) READ (11) VAR1, VAR2, VAR3  Either form may be a READ or WRITE, but neither may employ implied DO loops. Convert implied DO loops to explicit DO loops instead. The unit numbers may be integer variables instead of integer constants. Non-MP variables and constants may be included in the list, in which case they are handled using ordinary Fortran I/O. The first form is used for input and output of individual MP numbers (not entire unsubscripted arrays) in ordinary decimal form. The digits of the number may span more than one line. A comma at the end of the last line denotes the end of an MP number. Input lines may not exceed 120 characters in length, but embedded blanks are allowed anywhere. The exponent is optional in an input number, but if present it must appear first, as in the following example: 10 ^ -4 x 3.14159 26535 89793 23846 26433 83279 50288 41971 69399 37510,  MPC numbers are input or output as two consecutive MPR numbers. The output of an MP write operation is in the correct form for a subsequent MP read operation. By default, all digits of an MP number are output. The user can control the number of mantissa digits output by including a directive such as CMP+ OUTPUT PRECISION 200  in the declaration section of any subprogram. It remains in effect until the end of file or until another such directive is encountered. The second form of READ/WRITE statement above is used to perform binary I/O of entire MP arrays. Subscripted variables are not allowed in the second form. 27   3.9 Controlling the Multiprecision ""Epsilon"" and Precision Level Many programs need to control the MP ""epsilon"" for performing comparisons. To this end, the user can reference the special MP constant DPEPS. For compatibility purposes, any subprogram that uses DPEPS should declare it to be SP or DP and set it to some nominal small value in a parameter statement. Example: DOUBLE PRECISION DPEPS PARAMETER (DPEPS = 1D-16)  Whenever this name appears in a subprogram that contains MP variables, the translator substitutes the MP ""epsilon"" value, which by default is 107-D , where D is the number of digits of precision specified in the precision level directive. DPEPS does not need to be declared with an MP type directive. The MP epsilon value may be modified (independent of the precision level directive) by inserting a directive such as CMP+ EPSILON 1E-200  in the declaration section of any subprogram (for instance, adjacent to the parameter statement in which DPEPS is defined). It remains in effect until the end of file or until another such directive is encountered. The number of mantissa words allocated by the translator for MP numbers is approximately one seventh the number of digits specified in the precision level directive. The first dimension of MP arrays is this number plus 4. The user may access the number of mantissa words in the special constant MPNWP. For compatibility purposes, any subprogram that uses MPNWP should be declare it to be of type IN and set it to some nominal integer value in a parameter statement. Example: INTEGER MPNWP PARAMETER (MPNWP = 1)  MPNWP, like MPL02 and MPPIC, is considered a constant and may not be changed. If one wishes to dynamically change the working precision level within a program (which is not recommended for novice users), this may be done by calling the MPFUN routines MPSETP and MPINQP, as follows: CALL MPSETP ('NW', 35) CALL MPINQP ('NW', NX)  The first line sets the working precision level to 35 words. This value must not be greater than the value of MPNWP. The second line sets NX to be the value of the current working precision. If the user is not concerned about possible name conflicts, the same functions can be accomplished by simply including the MPFUN common block COMMON /MPCOM1/ NW, IDB, LDB, IER, MCR, IRD, ICS, IHS, IMS  28   in the subprogram and directly modifying the variable NW. 3.10 Single Precision Scratch Space for the MPFUN Package The maximum amount of SP scratch space in common block MPCOM3 (see the documentation for the MPFUN package [4]), cannot be determined in advance by the translator program. The MPFUN package allocates 1024 SP cells in this block, which for most programs is sufficient. If the ""insufficient single precision scratch space"" error is encountered during execution of the resulting MP program, place a directive of the form CMP+ SCRATCH SPACE 2000  at the beginning of the input file, before the PROGRAM statement but after the precision level directive. The number placed on this line should be at least the size mentioned in the error message. 3.11 Other Restrictions and Limitations It should be emphasized again that the Fortran-77 language is not perfectly or completely supported by the translator. In addition to the restrictions already mentioned, a number of other limitations apply. A complete list is included below. However, note that in almost every case there is a simple change that can be made to the input program to make it acceptable to this translation program, while retaining both its functionality and Fortran-77 compliance. The ma jority of these restrictions are merely good programming practice. 1. A number of identifiers beginning with DP and MP are reserved for use by the translator, and the translator will flag an error if any of these appears in the user's input program. To be safe, do not use such names in your program, other than as instructed in this paper. 2. ENTRY,typed FUNCTION (i.e. INTEGER FUNCTION), assigned GOTO, arithmetic IF, READ or WRITE without parentheses, and PRINT statements are not allowed. Please replace these constructs, which in most cases are obsolescent, with more conventional alternatives: FUNCTION statements followed by type statements, normal subroutine calls, computed or ordinary GOTO statements, logical IF statements and normal READ or WRITE statements, respectively. 3. References to the (obsolescent) type-specific Fortran-77 intrinsic functions (i.e. AMOD, DABS, MIN0, etc.) are not allowed in MP statements. Use the equivalent generic Fortran-77 functions (i.e. MOD, ABS, MIN, etc.) instead. 4. Statement functions may not be used to define MP functions. Convert these into MP function subprograms or subroutines. 5. MP variables may not appear in DATA statements. Convert these into parameter or assignment statements. 29   6. MP variables or constants may not appear in DO statements, array dimensions or array subscripts. 7. An MP statement may not be the terminal line of a DO loop. Place the line number on a CONTINUE line immediately following the statement. If the line number is also the target of a GOTO, the DO loop must be changed to use a separate terminal line number. 8. MP variables or constants may not appear in formatted READ or WRITE statements, and other restrictions apply to the I/O of MP data. See section 3.8 for details. 9. The logical operators .NOT., .EQV. and .NEQV. may not appear in MP statements. Rewrite such statements using .AND. and .OR. operators, or move such subexpressions to a separate statement. 10. Complex constants [i.e. (3., 2.)] may not appear in MP statements. Either use the intrinsic functions CMPLX or DCMPLX, or else assign such constants to CO or DC variables in separate statements. 11. Except for variables in the argument list, variables that appear in a type statement or an MP type directive may not have previously appeared in the subprogram. 12. A single IMPLICIT statement may be used to declare the initial letter(s) for only one datatype. A single COMMON statement may be used to declare only one common block. 13. DATA statements and FORMAT statements may appear only after the end of the specification section of the program, i.e. only after type declaration, DIMENSION statements, COMMON statements, etc. 14. Fortran keywords (i.e. CALL, DO, IF, READ, RETURN, etc.) may not be used as identifiers. 15. Embedded blanks may not appear in Fortran keywords, line numbers, variable names, comparison operators and logical operators. Exceptions: DOUBLE PRECISION, DOUBLE COMPLEX, ELSE IF, END DO, END IF, GO TO are permitted. 16. Fortran keywords must be followed by a blank or an operator. Also, a blank must follow the line number in a DO statement. 17. If an integer constant is followed by a comparison or logical operator, the constant and the operator must be separated by a blank (i.e. 12340 .LE. X). 18. Input code must be in the standard 72 column format. Comments up to 80 characters long are correctly copied to the output file. 19. Tab characters are not allowed. Convert these to blanks with a text editor. 30   On the other hand, this program will correctly process code with the following features, which do not comply with the Fortran-77 standard, provided the user's Fortran compiler also supports such constructs: 1. Both upper and lower case alphabetics may be used in identifiers and Fortran keywords. 2. Long variable names (up to 16 characters long) are permitted. 3. Character strings may be delimited with pairs of quotation marks [""] instead of apostrophes [']. 4. The double complex (DC) datatype is supported, including DC intrinsics. 5. The IMPLICIT NONE statement is supported. Untyped variables found in executable MP statements will be flagged as errors. 6. The datatypes INTEGER*4, REAL*8, etc. are supported. REAL*8 is interpreted as DP; COMPLEX*16 is interpreted as DC. 7. .T. and .F. may be used in place of the logical constants .TRUE. and .FALSE.. 8. DO-ENDDO constructs are permitted. 9. Recursive subroutine calls are permitted. 3.12 Error Checking More than 100 error conditions are checked by the translator program, and if any of these is encountered, an error message is output, together with the line number of the statement in the input file where the error was detected. An attempt has been made to cover all of the prohibited situations mentioned in this paper, as well as many violations of the standard rules of Fortran. In some cases, certain possible Fortran errors are not checked by the translator, because if they do occur, they will certainly be trapped when an attempt is made to compile the output program. One example of an error condition that is checked by the translator is any type mismatch between the argument list of a reference to a subroutine or function and its definition (provided both are in the same file). Such errors can easily occur when, for example, a DP constant is used as an argument, but the defining subprogram expects a MPR value. These errors can also occur if the name of an MPR function is not declared to be of type MPR in the subprograms where it is referenced. Although this is certainly not a recommended programming practice, type mismatches between argument lists do exist in some working Fortran programs. For example, some codes pass a scratch array of type real to a subroutine when a complex scratch array is expected. Because in some cases it may be difficult to remove type mismatches from an 31   existing code, and since the resulting code may work correctly anyway, a provision has been made for the translator to toggle type error trapping on and off. This is done by inserting one of the following directives in the declaration section of any subprogram: CMP+ TYPE ERROR ON CMP+ TYPE ERROR OFF  It remains in effect until the end of file or until another such directive is encountered. When type error trapping is disabled with the OFF option, a non-fatal warning message is included in the output file for the programmer's information. 3.13 Performance of Translated Co de A number of fairly large programs have been successfully translated with this program. These include the Linpack benchmark [18], both a real and a complex FFT benchmark [2], a vortex analysis code [24], a Feigenbaum number calculation [13], implementations of Ferguson's PSOS and PSLQ integer relation algorithms [5, 20], and an implementation of the RSA public-key cryptosystem [27]. All appear to work correctly. In most cases where the author had previously coded the application by hand using the MPFUN routines, the performance of the translated code (using the FAST option) is not significantly different. Thus it appears that in most cases there will not be a performance penalty for using the translator. Partly this is due to the fact that in translating arithmetic expressions, the translator program separately handles each of the many mixed mode cases, as opposed to merely handling all cases in a stock fashion. However, users should be prepared for a substantial slowdown, compared with conventional IN, SP or DP code. See the performance results in section 2.6 for details. Acknowledgments The author wishes to acknowledge helpful comments and suggestions by W. Kahan of the University of California, Berkeley, by K. Briggs of the University of Melbourne, Australia, and by R. Brent of the Australian National University.  32   References [1] D. H. Bailey, ""The Computation of  to 29,360,000 Decimal Digits Using Borweins' Quartically Convergent Algorithm"", Mathematics of Computation, vol. 50 (Jan. 1988), p. 283  296. [2] D. H. Bailey, ""A High Performance FFT Algorithm for Vector Supercomputers"", International Journal of Supercomputer Applications, vol. 2 (Spring 1988), p. 82 87. [3] D. H. Bailey, ""Numerical Results on the Transcendence of Constants Involving  , e, and Euler's Constant"", Mathematics of Computation, vol. 50 (Jan. 1988), p. 275  281. [4] D. H. Bailey, ""A Portable High Performance Multiprecision Package"", Technical Report RNR-90-022, NASA Ames Research Center, 1990. [5] D. H. Bailey and H. R. P. Ferguson, ""Numerical Results on Relations Between Numerical Constants Using a New Algorithm"", Mathematics of Computation, vol. 53 (October 1989), p. 649 - 656. [6] P. Beckmann, A History of Pi, Golem Press, Boulder CO, 1977. [7] J. M. Borwein and P. B. Borwein, ""The Arithmetic-Geometric Mean and Fast Computation of Elementary Functions"", SIAM Review vol. 26 (1984), p. 351  365. [8] J. M. Borwein and P. B. Borwein, Pi and the AGM, John Wiley, New York, 1987. [9] J. M. Borwein, P. B. Borwein and D. H. Bailey, ""Ramanujan, Modular Equations, and Approximations to Pi"", The American Mathematical Monthly, vol. 96 (1989), p. 201  219. [10] R. P. Brent, ""Fast Multiple-Precision Evaluation of Elementary Functions"", Journal of the ACM, vol. 23 (1976), p. 242  251. [11] R. P. Brent, ""A Fortran Multiple Precision Arithmetic Package"", ACM Transactions on Mathematical Software, vol. 4 (1978), p. 57  70. [12] R. P. Brent, ""Multiple-Precision Zero-Finding Methods and the Complexity of Elementary Function Evaluation"", Analytic Computational Complexity, Academic Press, New York, 1976, p. 151  176. [13] K. Briggs, ""A Precise Calculation of the Feigenbaum Constants"", Mathematics of Computation, vol. 57 (1991), p. 435 - 439. [14] D. Buell, and R. Ward, ""A Multiprecise Integer Arithmetic Package"", Journal of Supercomputing, vol. 3 (1989), p. 89  107. 33   [15] D. V. Chudnovsky and G. V. Chudnovsky, ""Computation and Arithmetic Nature of Classical Constants"", IBM Research Report, IBM T. J. Watson Research Center, RC14950 (#66818), 1989. [16] D. V. Chudnovsky and G. V. Chudnovsky, personal communication, 1991. [17] P. G. Comba, ""Exponentiation Cryptosystems on the IBM PC"", IBM Systems Journal, vol. 29 (1990), p. 526  538. [18] J. J. Dongarra, ""The Linpack Benchmark: An Explanation"", SuperComputing (Spring 1988), p. 10 - 14. [19] M. J. Feigenbaum, ""Quantitative Universality for a Class of Nonlinear Transformations"", Journal of Statistical Physics, vol. 19 (1978), p. 25  52. [20] H. R. P. Ferguson and D. H. Bailey, ""A Polynomial Time, Numerically Stable Integer Relation Algorithm"", Technical Report RNR-91-032, NAS Applied Research Branch, NASA Ames Research Center, Moffett Field, CA 94035, March 1992. [21] J. Hastad, B. Just, J. C. Lagarias, and C. Schnorr, ""Polynomial Time Algorithms for Finding Integer Relations Among Real Numbers"", SIAM Journal on Computing, vol. 18 (1988), p. 859  881. [22] Y. Kanada, personal communication, 1989. [23] D. E. Knuth, The Art of Computer Programming, Addison Wesley, Menlo Park, 1981. [24] R. Krasny, ""Desingularization of Periodic Vortex Sheet Roll-Up"", Journal of Computational Physics, vol. 65, no. 2 (August 1986), p. 292 - 313. [25] A. K. Lenstra, H. W. Lenstra, M. S. Manasse and J. M. Pollard, ""The Number Field Sieve"", 1990 ACM Symposium on the Theory of Computing, p. 564  572. [26] A. M. Odlyzko and H. J. J. te Riele, ""Disproof of the Mertens Conjecture"", J. Reine Angew. Mathematik, vol. 357 (1985), p. 138  160. [27] R. L. Rivest, A. Shamir, and L. Adleman, ""A Method for Obtaining Digital Signatures and Public-Key Cryptosystems"", Communications of the ACM, vol. 21 (1978), p. 120 - 126. [28] E. Salamin, ""Computation of  Using Arithmetic-Geometric Mean"", Mathematics of Computation, vol. 30 (1976), p. 565  570. [29] D. Slowinski, personal communication, 1991. [30] D. M. Smith, ""A FORTRAN Package for Floating-Point Multiple-Precision Arithmetic"", ACM Transactions on Mathematical Software, vol. 17, no. 2 (June 1991), p. 273  283. 34   [31] R. S. Varga, Scientific Computation on Mathematical Problems and Conjectures, SIAM, Philadelphia, 1990. [32] S. Wolfram, Mathematica: A System for Doing Mathematics by Computer, AddisonWesley, New York, 1988.  35"
GX241-48-1482350	"A Compendium of BBP-Type Formulas for Mathematical Constants David H. Bailey1 28 November 2000  Abstract A 1996 paper by the author, Peter Borwein and Simon Plouffe showed that any mathematical constant given by an infinite series of a certain type has the property that its n-th digit in a particular number base could be calculated directly, without needing to compute any of the first n - 1 digits, by means of a simple algorithm that does not require multiple-precision arithmetic. Several such formulas were presented in that paper, including formulas for the constants  and log 2. Since then, numerous other formulas of this type have been found. This paper presents a compendium of currently known results of this sort, both formal and experimental. Many of these results were found in the process of compiling this collection and have not previously appeared in the literature. Several conjectures suggested by these results are mentioned.  Lawrence Berkeley National Laboratory, Berkeley, CA 94720, USA, dhbailey@lbl.gov. Bailey's work is supported by the Director, Office of Computational and Technology Research, Division of Mathematical, Information, and Computational Sciences of the U.S. Department of Energy, under contract number DE-AC03-76SF00098.  1  1   1. Intro duction This is a collection of formulas for various mathematical constants that are of the form similar to that first noted in the ""BBP"" paper [3]. That article presented the following formula for  (which was discovered using Ferguson's PSLQ integer relation finding algorithm [10, 4]): =  k=0  1 16k  4 2 1 1 - - - 8k +1 8k +4 8k +5 8k +6  (1)  It was shown in [3] that this formula permits one to calculate the n-th hexadecimal or binary digit of  , without computing any of the first n - 1 digits, by means of a simple algorithm that does not require multiple-precision arithmetic. Further, as shown in [3], several other well-known constants also have this individual digit-computation property. One of these is log 2, based on the following centuries-old formula:   log 2 = k=1  1 k 2k  (2)  In general, any constant C that can be written in the form C=  k=0  p(k ) , q (k )bk  where p and q are integer polynomials, deg(p) < deg(q ), and p(k )/q (k ) is nonsingular for nonnegative k , possesses this individual digit-computation property. Note that formula 1 can be written in this form, since the four fractions can be combined into one, yielding =  k=0  1 47 + 151k + 120k 2 16k 15 + 194k + 712k 2 + 1024k 3 + 512k  4  Since the publication of [3], other papers have presented formulas of this type for various constants, including several constants that arise in quantum field theory [7, 8, 5]. More recently, interest in BBP-type formulas has been heightened by the observation that the question of the statistical randomness of the digit expansions of these constants can be reduced to the following hypothesis regarding the behavior of a particular class of chaotic iterations [5]: Hyp othesis A (from the paper [5]). Denote by rn = p(n)/q (n) a rational-polynomial function, i.e. p, q  Z [X ]. Assume further that 0  deg p < deg q , with rn nonsingular for positive integers n. Choose an integer b  2 and initialize x0 = 0. Then the sequence x = (x0 ,x1 ,x2 ,...) determined by the iteration: x n  = (bx  n-1  + rn ) mod 1.  either has a finite attractor or is equidistributed in [0, 1). Assuming this hypothesis, it is shown in [5] that any BBP-type constant is either normal to base b (i.e., any n-long string digits appears in the base b expansion with 2   limiting frequency b-n ), or else it is rational. No proof of Hypothesis A was presented in [5], and indeed it is likely that Hypothesis A is rather difficult to prove. However, it should be emphasized that even particular instances of Hypothesis A, if established, would have interesting consequences. For example, if it could be established that the specific iteration given by x0 = 0, and x n  = (2x  n-1  +  1 ) mo d 1 n  is equidistributed in [0, 1), then it would follow that log 2 is normal to base 2. In a similar vein, if it could be established that the iteration given by x0 = 0 and x n  =  16x  n-1  +  120n2 - 89n +16 512n4 - 1024n3 + 712n2 - 206n +21  mod 1  is equidistributed in [0, 1), then it would follow that  is normal to base 16 (and thus to base 2 also). One additional impetus for the study of BPP-type constants comes from a recent paper by Lagarias [13], who demonstrates a connection to G-functions and to a conjecture of Furstenberg from ergodic theory. Lagarias' analysis suggests that there may be a special signficance to constants that have BBP-type formulas in two or more bases -- say both a base 2 and a base 3 formula. This paper is a compendium of the growing set of BBP-type formulas that have been found by various researchers. Part of these formulas are collected here from previously published sources. In other cases, formulas whose existence has been demonstrated in the literature are presented here explicitly for the first time. Still others are new, having been found using the author's PSLQ program [4] in the course of this research. The PSLQ integer relation algorithm [10] or one of its variants [4] can be used to find formulas such as those listed in this paper as follows. Suppose, for example, that it is conjectured that a given constant  satisfies a BBP-type formula of the form 1 = r  k=0  1 bk  a2 an a1 + +  + , s s (kn +1) (kn +2) (kn + n)s  where r and ak are unknown integers, for a specified selection of the parameters b, s and n. Then one calculates the vector ( k0 1/(bk (kn + j )s ), 1  j  n), as well as  itself, to very high precision and then gives this (n + 1)-long vector (including  at the end) to an integer relation finding program. If a solution vector (aj ) is found with sufficiently high numerical fidelity, then = -1 an+1  k=0  1 bk  a1 a2 an + +  + s s (kn +1) (kn +2) (kn + n)s  (at least to the level of numeric precision used). This compendium is not intended to be a comprehensive listing of all such formulas -- ordinarily a formula is not listed here if 3   1. it is a telescoping sum. 2. it is a formal rewriting of another formula on the list. 3. it can be derived by a straightforward formal manipulation starting with another formula in the list. 4. it is a linear combination of two or more formulas already in the list. Item 1 refers to a summation such as S=  k=1  1 bk  1 b2 , - k k +2  which, if split into two summations, has the property that the terms of the first series cancel with offset terms of the second series, so that S reduces to a rational number (in this example, S = b + 1/2). Item 2 refers to the fact that a formula with base b and length n can be rewritten as a formula with base br and length rn. Item 4 refers to the fact that the rational linear sum of two BBP series can, in many cases, be written as a single BBP series. This is clear if the two individual series have the same base b. If one has base br and the other has base bs , their sum can be written as a single BBP series with base blcm(r,s) [5]. Along this line, many of the formulas listed below possess variants that can be obtained by adding to the listed formula a rational multiple of one of the zero relations listed in Section 11. The formulas are listed below using a notation introduced in [5]: P (s, b, n, A) =  k=0  1 bk  n j =1  aj (kn + j )s  (3)  where s, b and n are integers, and A = (a1 , a2 ,  , an ) is a vector of integers. For instance, using this notation we can write formulas 1 and 2 more compactly as follows:  = P (1, 16, 8, (4, 0, 0, -2, -1, -1, 0, 0)) 1 P (1, 2, 1, (1)) log 2 = 2 (4) (5)  In most cases below, the representation shown using this notation is a translation from the original source. Also, in some cases the formula listed here is not precisely the one mentioned in the cited reference -- an equivalent one is listed here instead -- but the original discoverer is given due credit. In cases where the formula has been found experimentally (i.e., by using the PSLQ integer relation finding algorithm), and no formal proof . is available, the relation is listed here with the = notation instead of an equal sign. The P notation formulas listed below have been checked using a computer program A that parses the L TEXsource of this document, then computes the left-hand and right-hand sides of these formulas to 2000 decimal digit accuracy. Additional contributions to this compendium are welcome -- please send a note to the author at dhbailey@lbl.gov. 4   2. Logarithm Formulas Clearly log n can be written with a binary BBP formula (i.e. a formula with b for some integer m) provided n factors completely using primes whose logarithms binary BBP formulas -- one merely combines the individual series for the different p into a single binary BBP formula. We have seen above that log 2 possesses a binary formula, and so does the log 3, by the following reasoning: log 3 = 2 log 2 + log 1 - = = k=0  = 2m have rimes BBP  1 4    =2 k=1  1 - k 2k  k=0   k=1  1 k 4k 2 2k +2 (6)  1 2    k=0   1 4k  1 1 2 - + 2k +1 2k +2 4 1 2k +1  1 4k  1 4k  = P (1, 4, 2, (1, 0))  In a similar manner, one can show, by examining the factorization of 2n +1 and 2n - 1, where n is an integer, that numerous other primes have this property. Harley [11] further extended this list of primes by writing Re log 1  1+ i 2n = 1 1 - n log 2 + log(22n-1  2n +1), 2 2  where Re denotes the real part. He noted that the Taylor series of the left-hand side can be written as a binary BBP-type formula and then applied Aurefeuille's factorization formula 24n-2 +1 = (22n-1 +2n + 1)(22n-1 - 2n +1) to the right-hand side. More recently, Jonathan Borwein has observed that both of these sets of results can be derived by working with the single expression Re log 1  (1 + i)k 2n .  A preliminary list of primes p such that log p has a binary BBP formula was given in [3]. This list has now been augmented by the author to the following: 2, 3, 5, 7, 11, 13, 17, 19, 29, 31, 37, 41, 43, 61, 73, 109, 113, 127, 151, 241, 257, 337, 397, 683, 1321, 1613, 2113, 2731, 5419, 8191, 43691, 61681, 87211, 131071, 174763, 262657, 524287, 2796203, 15790321, 18837001, 22366891, 4278255361, 4562284561, 2932031007403, 4363953127297, 4432676798593 (7) This list is certainly not complete, and it is unknown whether or not all primes have this property, or even whether the list of such primes is finite or infinite. The actual  5   formulas for log p for the primes above are generally straightforward to derive and are not shown here. One can also obtain BBP formulas in non-binary bases for the logarithms of certain integers and rational numbers. One example is given by the base ten formula 46 below, which was used in [3] to compute the ten billionth decimal digit of log(9/10). 3. Arctangent Formulas Shortly after the original BBP paper appeared in 1996, Adamchik and Wagon observed that [1] tan-1 2 = 1 P (1, 16, 8, (8, 0, 4, 0, -2, 0, -1, 0)) 8 (8)  More recently, binary BBP formulas have been found for tan-1 q for a large set of rational numbers q . These experimental results, which were obtained by the author using the PSLQ program, coincide exactly in the cases studied so far with the set of rationals given by q = |Im(T )/Re(T )| or |Re(T )/Im(T )|, where T= m k=1  1  (1 + i)u 2vk  k  w  k  .  (9)  The arctangents of these q clearly possess binary BBP formulas, because Im(log T ) decomposes into a linear sum of terms, the Taylor series of which are binary BBP formulas. The author is indebited to Jonathan Borwein for this observation. See also [6, pg. 344]. Alternatively, one can write 9 as T= m k=1  i 1 t 2k  u  k  1+ i 1 v 2k  w  k  (10)  for various m-long nonnegative integer vectors t, u, v , w and choices of signs as shown. For example, setting t = (1, 1), u = (1, 1), v = (1, 3), w = (1, 1), with signs (1, -1, -1, 1), gives the result T = 25/32 - 5i/8, which yields q = 4/5. Indeed one can obtain the formula tan- 1  4 5  =  1 P (1, 220 , 40, (0, 219 , 0, -3  217 , -15  215 , 0, 0, 5  215 , 0, 215 , 0, 217 -3  213 , 0, 0, 5  210 , 5  211 , 0, 211 , 0, 210 , 0, 0, 0, 5  27 , 15  25 , 128, 0, -96, 0, 0, 0, 40, 0, 8, -5, -6, 0, 0, 0, 0)) (11)  In this manner, it can be seen that binary BBP formulas exist for the arctangents of the following rational numbers. Only those rationals with numerators < denominators  50 are listed here. 1/2, 1/3, 2/3, 1/4, 3/4, 1/5, 2/5, 3/5, 4/5, 1/7, 3/7, 4/7, 6/7, 1/8, 7/8, 1/9, 2/9, 7/9, 8/9, 3/10, 2/11, 3/11, 7/11, 8/11, 10/11, 1/12, 5/12, 1/13, 6/13, 7/13, 9/13, 11/13, 3/14, 5/14, 1/15, 4/15, 8/15, 1/16, 11/16, 13/16, 15/16, 1/17, 6/17, 7/17, 11/17, 15/17, 6   16/17, 1/18, 13/18, 4/19, 6/19, 7/19, 8/19, 9/19, 11/19, 17/19, 1/21, 16/21, 3/22, 7/22, 9/22, 19/22, 2/23, 4/23, 6/23, 7/23, 11/23, 14/23, 15/23, 7/24, 11/24, 23/24, 13/25, 19/25, 21/25, 7/26, 23/26, 5/27, 11/27, 2/29, 3/29, 15/29, 17/29, 24/29, 28/29, 17/30, 1/31, 5/31, 8/31, 12/31, 13/31, 17/31, 18/31, 22/31, 27/31, 1/32, 9/32, 31/32, 1/33, 4/33, 10/33, 14/33, 19/33, 31/33, 32/33, 7/34, 27/34, 13/35, 25/36, 5/37, 9/37, 10/37, 16/37, 29/37, 36/37, 1/38, 5/38, 13/38, 21/38, 20/39, 23/39, 37/39, 9/40, 3/41, 23/41, 27/41, 28/41, 38/41, 11/42, 19/42, 37/42, 6/43, 19/43, 23/43, 32/43, 33/43, 7/44, 23/44, 27/44, 3/46, 9/46, 17/46, 35/46, 37/46, 1/47, 13/47, 14/47, 16/47, 19/47, 27/47, 19/48, 3/49, 8/49, 13/49, 18/49, 31/49, 37/49, 43/49, 29/50, 49/50  (12)  Note that not all ""small"" rationals appear in this list. For instance, it is not known whether tan-1 (1/6) possesses a binary BBP formula. For that matter, it has not been proven that formulas 9 and 10 above generate all such rational numbers, although this is a reasonable conjecture. One can obtain BBP formulas in non-binary bases for the arctangents of certain rational numbers by employing appropriate variants of formulas 9 and 10. 4. Other Degree 1 Binary Formulas We present here some additional degree 1 binary BBP-type formulas (in other words, in the P notation defined in equation 3 above, s = 1, and b = 2m for some integer m > 0). =   2  3   2ln(1 + 2)  2tan- 1  = = = = =  1  2  1 P (1, 16, 8, (8, 8, 4, 0, -2, -2, -1, 0)) 4 P (1, -4, 4, (2, 2, 1, 0)) 1 P (1, 64, 12, (32, 0, 8, 0, 8, 0, -4, 0, -1, 0, -1, 0)) 8 9 P (1, 64, 6, (16, 8, 0, -2, -1, 0)) 32 1 P (1, 16, 8, (8, 0, 4, 0, 2, 0, 1, 0)) 8 1 P (1, 16, 8, (8, 0, -4, 0, 2, 0, -1, 0)) 8  (13) (14) (15) (16) (17) (18)  Formula 13 was first found by Ferguson [10], while 14, which is the alternating sign equivalent of 13, was found independently by Hales and by Adamchik and Wagon [1]. Technically speaking, these formulas can be obtained from the original BBP formula for  (formula 1) by adding 1/4 times relation 52 of Section 11, but they are included here for historical interest, since their discovery predated the discovery of relation 52. Formula 15 appeared in [3]. Formulas 16, 17 and 18 are due to Knuth [12, pg. 628]. 7   5. Degree 2 Binary Formulas Here are some degree 2 binary formulas (i.e., s = 2, and b = 2m for some integer m > 0). The constant G here is Catalan's constant, namely G = 1 - 1/32 +1/52 - 1/72 +  = 0.9159655941 ....   2 2  log2 2 log2 2 1 G -  log 2 8  log 2    3log 2  G  = P (2, 16, 8, (16, -16, -8, -16, -4, -4, 2, 0)) 9 = P (2, 64, 6, (16, -24, -8, -6, 1, 0)) 8 .1 = P (2, 16, 8, (16, -40, -8, -28, -4, -10, 2, -3)) 6 1 = P (2, 64, 6, (64, -160, -56, -40, 4, -1)) 32 1 = P (2, 16, 8, (8, 8, 4, 0, -2, -2, -1, 0)) 16 1 . P (2, 212 , 24, (212 , -213 , -51  29 , 15  210 , -210 , 39  28 , 0, = 256 45  28 , 37  26 , -29 , 0, 3  28 , -64, 0, 51  23 , 45  24 , 16, 196, 0, 60, -37, 0, 0, 0)) 1 P (2, 212 , 24, (9  29 , -27  29 , -9  211 , 27  29 , 0, 81  27 , = 128 9  26 , 45  28 , 9  28 , 0, 0, 9  26 , -72, -216, 9  25 , 9  26 , 0, 162, -9, 72, -36, 0, 0, 0, )) 1 . = 10 P (2, 212 , 24, (210 , 210 , -29 , -3  210 , -256, -211 , -256, 2 -9  27 , -5  26 , 64, 64, 0, -16, 64, 8, -72, 4, -8, 4, -12, 5, 4, -1, 0))  (19) (20) (21) (22) (23)  (24)  (25)  (26)  Formulas 19, 20, 22 and 23 were presented in [3] (although 23 appeared in a 1909 book by Nielsen [14, pg. 105]). Formulas 21 and 25 were found by the author, using the PSLQ program. Formulas for  log 2 and G were first derived by Broadhurst, although the specific explicit formulas given here (24 and 26) were found by the author in the course of this research. 6. Degree 3 Binary Formulas 1 P (3, 212 , 24, (3  211 , -21  211 , 3  213 , 15  211 , -3  29 , 3  210 , 7  28 3  28 , 0, -3  210 , -21  27 , -192, -3  29 , -96, -21  25 , -3  27 , 0, 24, 48, -12, 120, 48, -42, 3, 0)) (27) 1 . P (3, 212 , 24, (0, 3  213 , -27  212 , 3  214 , 0, 93  29 , 0, 3  214 , 27  29 , log3 2 = 256 3  29 , 0, 75  26 , 0, 3  27 , 27  26 , 3  210 , 0, 93  23 , 0, 192, -216, 24, 0, 3)) (28)  (3) = 8   1 P (3, 212 , 24, (0, 9  211 , -135  29 , 9  211 , 0, 99  28 , 0, 27  210 , 135  26 , 32 9  27 , 0, 45  26 , 0, 9  25 , 135  23 , 27  26 , 0, 396, 0, 72, -135, 18, 0, 0)) (29) 1 .  log2 2 = 56 P (3, 260 , 120, (7  259 , -37  260 , -63  258 , 85  259 , 3861  256 , 2 -3357  255 , 0, -655  258 , 347  254 , 79  253 , 0, 4703  252 , -7  253 , 0, -1687  252 , -655  254 , 7  251 , -4067  249 , 0, -6695  248 , -347  248 , 0, 0, -7375  246 , -3861  246 , -37  248 , -63  246 , 85  247 , -7  245 , -933  245 , 0, -655  246 , 347  242 , -37  244 , 875  243 , 4703  240 , -7  241 , 0, 63  240 , -3105  238 , 7  239 , -4067  237 , 0, 85  239 , 441  239 , 0, 0, -7375  234 , 7  235 , 79  233 , -63  234 , 85  235 , -7  233 , -3357  231 , -875  233 , -655  234 , 347  230 , -37  232 , 0, -167  232 , -7  229 , 0, 63  228 , -655  230 , -3861  226 , -4067  225 , 0, 85  227 , -347  224 , -375  223 , 0, -7375  222 , 7  223 , -37  224 , 1687  222 , 85  223 , -7  221 , -3357  219 , 0, -3105  218 , 347  218 , -37  220 , 0, 4703  216 , 3861  216 , 0, 63  216 , -655  218 , 7  215 , -923  215 , 0, 85  215 , -347  212 , 0, -875  213 , -7375  210 , 7  211 , -37  212 , -63  210 , -6695  28 , -7  29 , -3357  27 , 0, -655  210 , -441  29 , -37  28 , 0, 4703  24 , -224, -375  23 , 63  24 , -655  26 , 56, -8134, 875  23 , 85  23 , -347, 0, 0, 0)) (30) 1 .  3 = 54 P (3, 260 , 120, (5  259 , -15  260 , -225  258 , 95  259 , 4115  256 , 2 -3735  255 , 0, -685  258 , 505  254 , 5  253 , 0, 5485  252 , -5  253 , 0, -1775  252 , -685  254 , 5  251 , -3945  249 , 0, -7365  248 , -505  248 , 0, 0, -8125  246 , -4115  246 , -15  248 , -225  246 , 95  247 , -5  245 , -965  245 , 0, -685  246 , 505  242 , -15  244 , 125  246 , 5485  240 , -5  241 , 0, 225  240 , -2835  238 , 5  239 , -3945  237 , 0, 95  239 , 905  238 , 0, 0, -8125  234 , 5  235 , 5  233 , -225  234 , 95  235 , -5  233 , -3735  231 , -125  236 , -685  234 , 505  230 , -15  232 , 0, -165  232 , -5  229 , 0, 225  228 , -685  230 , -4115  226 , -3945  225 , 0, 95  227 , -505  224 , -125  223 , 0, -8125  222 , 5  223 , -15  224 , 1775  222 , 95  223 , -5  221 , -3735  219 , 0, -2835  218 , 505  218 , -15  220 , 0, 5485  216 , 4115  216 , 0, 225  216 , -685  218 , 5  215 , -955  215 , 0, 95  215 , -505  212 , 0, -125  216 , -8125  210 , 5  211 , -15  212 , -225  210 , -7365  28 , -5  29 , -3735  27 , 0, -685  210 , -905  28 , -15  28 , 0, 5485  24 , -160, -125  23 , 225  24 , -685  26 , 40, -7890, 125  26 , 95  23 , -505, 0, 0, 0)) (31) 9  .  2 log 2 =   The existence of BBP formulas for these constants was originally established by Broadhurst [8]. However, except for 27, which appeared in [5], the specific explicit formulas listed here were produced by the author's PSLQ program. The results for  log2 and  3 were produced by a special parallel version of this program, running on the IBM SP parallel computer system in the NERSC supercomputer facility at the Lawrence Berkeley National Laboratory. 7. Degree 4 Binary Formulas 1 P (4, 212 , 24, (27  211 , -513  211 , 135  214 , -27  211 , -27  29 , 164 -621  210 , 27  28 , -729  210 , -135  211 , -513  27 , -27  26 , -189  29 , -27  25 , -513  25 , -135  28 , -729  26 , 216, -621  24 , -108, -216, 135  25 , -1026, 27, 0)) (32) 1 . log4 2 = P (4, 212 , 24, (73  212 , -2617  212 , 8455  212 , -2533  212 , 5 205  2 -73  210 , -25781  29 , 73  29 , -6891  211 , -8455  29 , -2617  28 , -73  27 , -23551  26 , -73  26 , -2617  26 , -8455  26 , -6891  27 , 73  24 , -25781  23 , -73  23 , -2533  24 , 8455  23 , -10468, 146, -615)) (33) 1 . P (4, 212 , 24, (121  211 , -3775  211 , 10375  211 , -1597  211 ,  2 log2 2 = 41  25 -121  29 , -3421  211 , 121  28 , -7695  210 , -10375  28 , -3775  27 , -121  26 , -3539  28 , -121  25 , -3775  25 , -10375  25 , -7695  26 , (34) 121  23 , -3421  25 , -484, -1597  23 , 41500, -7550, 121, 0))  4  . =  The existence of BBP-type formulas for these constants was originally established by Broadhurst [8], although the explicit formulas given here were found by the author's PSLQ program. 8. Degree 5 Binary Formulas .  (5) = 1 P (5, 260 , 120, (279  259 , -7263  260 , 293715  257 , 62651  249 -13977  260 , -1153683  256 , 28377  260 , 279  256 , 83871  259 , -293715  254 , -7263  256 , -279  254 , -889173  253 , -279  253 , -7263  254 , 429705  252 , 83871  255 , 279  251 , 28377  254 , -279  250 , 1041309  249 , 293715  248 , -7263  250 , 279  248 , 1153125  247 , 1153683  246 , -7263  248 , 293715  245 , -13977  248 , -279  245 , 28377  248 , 279  244 , 83871  247 , -293715  242 , -7263  244 , -1153683  241 , -889173  241 , -279  241 , -7263  242 , -293715  239 , 188811  239 , 279  239 , 28377  242 , -279  238 , 10   -13977  240 , -429705  237 , -7263  238 , 279  236 , 1153125  235 , 279  235 , -7263  236 , 293715  233 , -13977  236 , -279  233 , 28377  236 , 1153683  231 , 83871  235 , -293715  230 , -7263  232 , -279  230 , 16497  233 , -279  229 , -7263  230 , -293715  227 , 83871  231 , 1153683  226 , 28377  230 , -279  226 , -13977  228 , 293715  224 , -7263  226 , 279  224 , 1153125  223 , 279  223 , -7263  224 , -429705  222 , -13977  224 , -279  221 , 28377  224 , 279  220 , 188811  219 , -293715  218 , -7263  220 , -279  218 , -889173  217 , -1153683  216 , -7263  218 , -293715  215 , 83871  219 , 279  215 , 28377  218 , -279  214 , -13977  216 , 293715  212 , -7263  214 , 1153683  211 , 1153125  211 , 279  211 , -7263  212 , 293715  29 , 1041309  29 , -279  29 , 28377  212 , 279  28 , 83871  211 , 429705  27 , -7263  28 , -279  26 , -889173  25 , -279  25 , -7263  26 , -293715  23 , 83871  27 , 279  23 , (35) 28377  26 , -2307366, -13977  24 , 293715, -29052, 279, 0)) 1 . P (5, 260 , 120, (2783  259 , -32699  262 , 7171925  257 , log5 2 = 2021  252 -187547  261 , -41252441  256 , 9391097  257 , 2783  256 , 52183  265 , -7171925  254 , -32699  258 , -2783  254 , -29483621  253 , -2783  253 , -32699  256 , 17037475  252 , 52183  261 , 2783  251 , 9391097  251 , -2783  250 , 38246123  249 , 7171925  248 , -32699  252 , 2783  248 , 41307505  247 , 41252441  246 , -32699  250 , 7171925  245 , -187547  249 , -2783  245 , 9391097  245 , 2783  244 , 52183  253 , -7171925  242 , -32699  246 , -41252441  241 , -29483621  241 , -2783  241 , -32699  244 , -7171925  239 , 12188517  239 , 2783  239 , 9391097  239 , -2783  238 , -187547  241 , -17037475  237 , -32699  240 , 2783  236 , 41307505  235 , 2783  235 , -32699  238 , 7171925  233 , -187547  237 , -2783  233 , 9391097  233 , 41252441  231 , 52183  241 , -7171925  230 , -32699  234 , -2783  230 , 5881627  230 , -2783  229 , -32699  232 , -7171925  227 , 52183  237 , 41252441  226 , 9391097  227 , -2783  226 , -187547  229 , 7171925  224 , -32699  228 , 2783  224 , 41307505  223 , 2783  223 , -32699  226 , -17037475  222 , -187547  225 , -2783  221 , 9391097  221 , 2783  220 , 11   12188517  219 , -7171925  218 , -32699  222 , -2783  218 , -29483621  217 , -41252441  216 , -32699  220 , -7171925  215 , 52183  225 , 2783  215 , 9391097  215 , -2783  214 , -187547  217 , 7171925  212 , -32699  216 , 41252441  211 , 41307505  211 , 2783  211 , -32699  214 , 7171925  29 , 38246123  29 , -2783  29 , 9391097  29 , 2783  28 , 52183  217 , 17037475  27 , -32699  210 , -2783  26 , -29483621  25 , -2783  25 , -32699  28 , -7171925  23 , 52183  213 , 2783  23 , 9391097  23 , -82504882, -187547  25 , 7171925, (36) -32699  24 , 2783, 30315)) 1 . P (5, 260 , 120, (21345  259 , -464511  261 , 47870835  257 ,  2 log3 2 = 2021  253 -1312971  261 , -236170815  256 , 1579179  262 , 21345  256 , 286131  265 , -47870835  254 , -464511  257 , -21345  254 , -173704605  253 , -21345  253 , -464511  255 , 94128645  252 , 286131  261 , 21345  251 , 1579179  256 , -21345  250 , 215120589  249 , 47870835  248 , -464511  251 , 21345  248 , 236128125  247 , 236170815  246 , -464511  249 , 47870835  245 , -1312971  249 , -21345  245 , 1579179  250 , 21345  244 , 286131  253 , -47870835  242 , -464511  245 , -236170815  241 , -173704605  241 , -21345  241 , -464511  243 , -47870835  239 , 56870019  239 , 21345  239 , 1579179  244 , -21345  238 , -1312971  241 , -94128645  237 , -464511  239 , 21345  236 , 236128125  235 , 21345  235 , -464511  237 , 47870835  233 , -1312971  237 , -21345  233 , 1579179  238 , 236170815  231 , 286131  241 , -47870835  230 , -464511  233 , -21345  230 , 1950735  234 , -21345  229 , -464511  231 , -47870835  227 , 286131  237 , 236170815  226 , 1579179  232 , -21345  226 , -1312971  229 , 47870835  224 , -464511  227 , 21345  224 , 236128125  223 , 21345  223 , -464511  225 , -94128645  222 , -1312971  225 , -21345  221 , 1579179  226 , 21345  220 , 56870019  219 , -47870835  218 , -464511  221 , -21345  218 , -173704605  217 , -236170815  216 , -464511  219 , -47870835  215 , 286131  225 , 21345  215 , 1579179  220 , -21345  214 , -1312971  217 , 47870835  212 , -464511  215 , 236170815  211 , 236128125  211 , 21345  211 , -464511  213 , 47870835  29 , 215120589  29 , -21345  29 , 1579179  214 , 21345  28 , 286131  217 , 94128645  27 , -464511  29 , 12   -21345  26 , -173704605  25 , -21345  25 , -464511  27 , -47870835  23 , 286131  213 , 21345  23 , 1579179  28 , -472341630, -1312971  25 , 47870835, -464511  23 , 21345, 0)) (37) 1 .  4 log 2 = P (5, 260 , 120, (5157  259 , -89127  261 , 7805295  257 , 50 2021  2 -195183  261 , -32325939  256 , 1621107  259 , 5157  256 , 37287  265 , -7805295  254 , -89127  257 , -5157  254 , -24620409  253 , -5157  253 , -89127  255 , 12255165  252 , 37287  261 , 5157  251 , 1621107  253 , -5157  250 , 29192697  249 , 7805295  248 , -89127  251 , 5157  248 , 32315625  247 , 32325939  246 , -89127  249 , 7805295  245 , -195183  249 , -5157  245 , 1621107  247 , 5157  244 , 37287  253 , -7805295  242 , -89127  245 , -32325939  241 , -24620409  241 , -5157  241 , -89127  243 , -7805295  239 , 5866263  239 , 5157  239 , 1621107  241 , -5157  238 , -195183  241 , -12255165  237 , -89127  239 , 5157  236 , 32315625  235 , 5157  235 , -89127  237 , 7805295  233 , -195183  237 , -5157  233 , 1621107  235 , 32325939  231 , 37287  241 , -7805295  230 , -89127  233 , -5157  230 , 480951  233 , -5157  229 , -89127  231 , -7805295  227 , 37287  237 , 32325939  226 , 1621107  229 , -5157  226 , -195183  229 , 7805295  224 , -89127  227 , 5157  224 , 32315625  223 , 5157  223 , -89127  225 , -12255165  222 , -195183  225 , -5157  221 , 1621107  223 , 5157  220 , 5866263  219 , -7805295  218 , -89127  221 , -5157  218 , -24620409  217 , -32325939  216 , -89127  219 , -7805295  215 , 37287  225 , 5157  215 , 1621107  217 , -5157  214 , -195183  217 , 7805295  212 , -89127  215 , 32325939  211 , 32315625  211 , 5157  211 , -89127  213 , 7805295  29 , 29192697  29 , -5157  29 , 1621107  211 , 5157  28 , 37287  217 , 12255165  27 , -89127  29 , -5157  26 , -24620409  25 , -5157  25 , -89127  27 , -7805295  23 , 37287  213 , 5157  23 , 1621107  25 , -64651878, -195183  25 , 7805295, -89127  23 , 5157, 0)) (38) As before, the existence of BBP-type formulas for these constants was originally established by Broadhurst [8], although the explicit formulas given here were found by the author's PSLQ program. 13   9. Ternary Formulas No ternary BBP formulas (i.e. formulas with b = 3m for some integer m > 0) were presented in [3], but several have subsequently been discovered. Here are some that are now known: 2 P (1, 9, 2, (1, 0)) (39) log 2 = 3   3 1 P (1, 9, 3, (3, -1, 0)) (40) 3tan-1 = 7 6  1 3= P (1, 36 , 12, (81, -54, 0, -9, 0, -12, -3, -2, 0, -1, 0, 0)) (41) 9 1 log 3 = (42) P (1, 36 , 6, (729, 81, 81, 9, 9, 1)) 729 2 2 = P (2, 36 , 12, (243, -405, 0, -81, -27, -72, -9, -9, 0, 27 -5, 1, 0)) (43) 1 P (2, 36 , 12, (4374, -13122, 0, -2106, -486, -243  23 , log2 3 = 729 -162, -234, 0, -162, 18, -8)) (44)  2 P (2, 36 , 12, (243, -405, -486, -135, 27, 0, -9, 15, 18,  3log 3 = 27 5, -1, 0)) (45) Formulas 39 and 40 appeared in [5]. Formulas 41 through 45 are due to Broadhurst [7]. 10. Other BBP-Typ e Formulas Here are several interesting results in other bases, together with two formulas for an  arbitrary base b. Here  = (1 + 5)/2 is the golden mean. log   25 781 log   2 256 1  tan-  1   51/4 233 - 329 5   5938   57 - 5 5  57 + 5 5    9 -1 P (1, 10, 1, (1)) = 10 10 5  (46) (47)     = P (1, 55 , 5, (0, 5, 1, 0, 0)) + =   tan- 1   51/4 939 + 281 5   5938  log  1111111111 387420489 b2 + b +1 b2 - 2b +1  1 P (1, 55 , 5, (125, -25, 5, -1, 0)) (48) 13/4 25 1 = P (1, 1010 , 10, (108 , 107 , 106 , 105 , 104 , 103 , 8 10 (49) 102 , 101 , 1, 0)) = 3P (1,b3 , 3, (b, 1, 0)) 14 (50)  b2 log   b  b-2  log  bb - 1 (b - 1)b  = P (1,bb ,b, (b  b- 2  ,b  b- 3  ,  ,b2 ,b, 1))  (51)  Formula 46 appeared in [3] (although it is an elementary observation). Formulas 47 through 51 appeared in [5]. 11. Zero Relations Below are some of the known BBP zero relations, or in other words BBP-type formulas that evaluate to zero. These have been discovered using the author's PSLQ program, and most are new with this compilation. For brevity, not all of the zero relations that have been found are listed here -- some of the larger ones are omitted -- although the author has a complete set. Further, zero relations that are merely a rewriting of another on the list, such as by expanding a relation with base b and length n to one with base br and length rn, are not included in these listings. For convenience, however, the total number of linearly independent zero relations for various choices of s, b and n, including rewritings and unlisted relations, are tabulated in Table 1. Knowledge of these zero relations is essential for finding formulas such as those above using integer relation programs (such as PSLQ). This is because unless these zero relations are excluded from the search for a conjectured BBP-type formula, the search may only recover a zero relation. A zero relation may be excluded from a integer relation search by setting the input vector element whose position corresponds to the zero relation's smallest nonzero element to some value that is not linearly related to the other entries of the input vector. For example, note in Table 1 below that there are five zero relations with s = 1, b = 212 and n = 24. These relations are given below as formulas 54 through 58. If one is searching for a conjectured formula with these parameters using PSLQ, then these five zero relations must be excluded. This can be done by setting entries 19 through 23 of the PSLQ input vector to e, e2 , e3 , e4 and e5 , respectively, where e is the base of natural logarithms. Positions 19 through 23 are specified here because in relations 54 through 58 below, the smallest nonzero entries appear in positions 23, 22, 21, 20 and 19, respectively. Powers of e are specified here because, as far as anyone can tell (although this has not been rigorously proven), e is not a polylogarithmic constant in the sense of this paper, and thus it and its powers are not expected to satisfy BBP-type linear relations (this assumption is confirmed by extensive experience using the author's PSLQ programs). In any event, it is clear that many other sets of transcendental constants could be used here. Note that by simply adding a rational multiple of one of these zero relations to one the formulas above (with matching arguments s, b and n), one can produce a valid variant of that formula. Clearly infinitely many variants can be produced in this manner. Aside from the discussion in [9], these zero relations are somewhat mysterious -- it is not understood why zero relations occur for certain s, b and n, but not others. It should also be noted that in most but not all cases where a zero relation has been found, nontrivial BBP-type formulas have been found with the same parameters. This suggests that significant BBP-type results may remain to be discovered. In any event, it is hoped that this compilation will spur some additional insight into these questions. 15   s 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1  b 16 64 28 212 212 216 218 220 224 224 228 230 230 232 236 236 240 242 242 244 36  n 8 6 16 12 24 32 18 40 24 48 56 30 60 64 36 72 80 42 84 88 12  No. zero relations 1 1 1 1 5 1 1 3 1 5 1 1 1 1 1 5 3 1 1 1 2  s 1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3 3 3 3 4  248 248 252 254 256 260 260 212 220 224 236 240 248 260 212 224 236 248 260 260  b  n 48 96 104 54 112 60 120 24 40 48 72 80 96 120 24 48 72 96 120 120  No. zero relations 1 5 1 1 1 1 7 2 1 2 2 1 2 4 1 1 1 1 2 1  Table 1: Zero relation counts for various parameters  Note that all of these formulas except for the last two are binary formulas (i.e. b = 2m for some integer m > 0). 0 = P (1, 16, 8, (-8, 8, 4, 8, 2, 2, -1, 0)) (52) 0 = P (1, 64, 6, (16, -24, -8, -6, 1, 0)) (53) . 12 11 11 9 8 0 = P (1, 2 , 24, (0, 0, 2 , -2 , 0, -2 , 256, -3  2 , 0, 0, -64, -128, 0, -32, -32, -48, 0, -24, -4, -8, 0, -2, 1, 0)) (54) . 12 9 10 10 8 8 7 0 = P (1, 2 , 24, (-2 , -2 , 2 , 7  2 , 256, 3  2 , 64, 3  2 , 0, 0, 0, 0, 8, -32, -16, 12, -4, 4, -1, 8, 0, -1, 0, 0)) (55) . 12 9 10 9 7 0 = P (1, 2 , 24, (2 , -2 , -2 , 256, 0, 256, 64, 3  2 , 64, 0, 0, 0, -8, -16, 8, 12, 0, 4, -1, 2, -1, 0, 0, 0)) (56) . 12 9 10 7 0 = P (1, 2 , 24, (3  2 , -3  2 , 0, -256, 0, 0, 192, 3  2 , 0, 0, 0, -64, -24, -48, 0, -12, 0, 0, -3, 2, 0, 0, 0, 0)) (57) . 12 10 99 0 = P (1, 2 , 24, (-2 , 3  2 , 2 , 256, 128, 128, -64, -192, 0, 32, 0, 32, 16, 16, 16   -8, 0, -2, -2, 1, 0, 0, 0, 0, 0)) (58) . 20 18 18 17 16 16 15 16 14 13 0 = P (1, 2 , 40, (0, 2 , -2 , 2 , 0, -5  2 , 2 , -5  2 , 0, -2 , -2 , 2 , 0, -5  212 , -214 , -5  211 , 0, 210 , -210 , -211 , 0, -5  28 , 256, -5  27 , 0, 64, -64, 32, 0, 0, 16, -40, 0, 4, 16, 2, 0, -5, 1, 0)) (59) . 20 18 19 17 15 16 14 13 13 12 12 0 = P (1, 2 , 40, (2 , -2 , 0, -2 , 3  2 , 2 , 0, 0, 2 , 2 , 0, -2 , -2 , 2 , 5  210 , 0, 210 , -211 , 0, -29 , -256, 256, 0, 0, -96, -128, 0, -32, -16, -24, 0, 0, 4, -8, -5, -2, -1, 1, 0, 0)) (60) . 0 = P (1, 220 , 40, (-218 , 3  218 , 0, -218 , -13  215 , 0, 0, 5  215 , -214 , 213 , 0, -214 , 212 , 0, 5  210 , 5  211 , -210 , 3  210 , 0, 3  29 , 256, 0, 0, 5  27 , 13  25 , 192, 0, -64, 16, 40, 0, 40, -4, 12, -5, -4, 1, 0, 0, 0)) (61) . 0 = P (2, 212 , 24, (0, 210 , -3  210 , 29 , 0, 210 , 0, 9  27 , 3  27 , 64, 0, 128, 0, 16, 48, 72, 0, 16, 0, 2, -6, 1, 0, 0)) (62) . 12 11 11 10 9 10 8 0 = P (2, 2 , 24, (-2 , 0, 17  2 , -17  2 , 2 , -15  2 , -256, -63  2 , -17  28 , 0, 64, -5  28 , 32, 0, -17  25 , -63  24 , -8, -240, 4, -68, 68, 0, -1, 0)) (63) . 20 19 20 18 18 20 18 16 0 = P (2, 2 , 40, (2 , -3  2 , -2 , 13  2 , 3  2 , -3  2 , 2 , -25  216 , 215 , -3  216 , -214 , 13  214 , -213 , -3  214 , -3  215 , -25  212 , 211 , -3  212 , -210 , -3  212 , -29 , -3  210 , 256, -25  28 , -3  210 , -3  28 , -64, 13  26 , -32, -192, 16, -25  24 , 8, -48, 96, 52, -2, -12, 1, 0)) (64) . 0 = P (3, 212 , 24, (211 , -19  211 , 5  214 , -211 , -29 , -23  210 , 256, -27  210 , -5  211 , -19  27 , -64, -7  29 , -32, -19  25 , -5  28 , -27  26 , 8, -23  24 , -4, -8, 160, -38, 1, 0)) (65) . 0 = P (1, 729, 12, (0, 81, -162, 0, 27, 36, 0, 9, 6, 4, -1, 0)) (66) . 0 = P (1, 729, 12, (243, -324, -162, -81, 0, -36, -9, 0, 6, -1, 0, 0)) (67) Relation 52 appeared in [3]. Relation 53 and 54 were given in [5]. Relations 55 through 67 were found by the author using his PSLQ program, and are new with this compilation. 12. Curiosities There are two other formulas worth mentioning, although neither, technically speaking, is a BBP-type formula. The first formula employs the irrational base b = 2/ = 2 -2, where  is the golden mean (see Section 9):  1 3  = 9 P (1, 2/ , 10, (256, 128 3 , 64 4 , 32 4 , 0, -8 6 , -4 8 , -2 9 , 0)) (68) 5/4 5 2 The second example of this class is the formula 1  cos 19 -1  k=0  9 10  =  1 10  Dk 10k  1 k +1 17  (69)   where the D coefficients satisfy the recurrence D k  2. It is possible that a variant of the original case, on the idea that the Dk comprise a Lucas of sequence elements mod n can be effected via formulas appeared in [5].  0  = D1 = 1, and Dk+1 = Dk - 5Dk-1 for BBP algorithm can be fashioned for this sequence, and as is known, evaluations exponential-ladder methods. These two  13. Acknowledgements The author wishes to acknowledge some very helpful comments and suggestions from J. Borwein, P. Borwein, R. Crandall and S. Wagon.  18   References [1] Victor Adamchik and Stan Wagon, ""A Simple Formula for Pi,"" American Mathematical Monthly, Nov. 1997, pg. 852-855. [2] Victor Adamchik and Stan Wagon, ""Pi: A 2000-Year-Old Search Changes Direction,"" Mathematica in Science and Education, vol. 5 (1996), no. 1, pg. 11-19. [3] David H. Bailey, Peter B. Borwein and Simon Plouffe, ""On The Rapid Computation of Various Polylogarithmic Constants,"" Mathematics of Computation, vol. 66, no. 218, 1997, pp. 903913. [4] David H. Bailey and David J. Broadhurst, ""Parallel Integer Relation Detection: Techniques and Applications,"" Mathematics of Computation, to appear, 2000. [5] David H. Bailey and Richard E. Crandall, ""On the Random Character of Fundamental Constant Expansions,"" manuscript, Oct. 2000, available from http://www.nersc.gov/~dhbailey. [6] Jonathan M. Borwein and Peter B. Borwein, Pi and the AGM, John Wiley and Sons, New York, 1987. [7] David J. Broadhurst, ""Massive 3-loop Feynman Diagrams Reducible to SC Primitives of Algebras of the Sixth Root of Unity,"" preprint, Mar. 1998, available from http://xxx.lanl.gov/format/hep-ph/9803091. [8] David J. Broadhurst, ""Polylogarithmic Ladders, Hypergeometric Series and the Ten Millionth Digits of  (3) and  (5),"" preprint, March 1998, available from http://xxx.lanl.gov/format/math/9803067. [9] David J. Broadhurst, ""Vanishing Polylogarithmic Ladders,"" manuscript, March 2000, available from author. [10] Helaman R. P. Ferguson, David H. Bailey and Stephen Arno, ""Analysis of PSLQ, An Integer Relation Finding Algorithm,"" Mathematics of Computation, vol. 68, no. 225 (Jan. 1999), pg. 351-369. [11] Robert Harley, personal communication to Peter Borwein, 1995. [12] Donald E. Knuth, The Art of Computer Programming, vol. 2, third edition, AddisonWesley, 1998. [13] Jeffrey C. Lagarias, ""On the Normality of Arithmetical Constants,"" manuscript, Sept. 2000. [14] N. Nielsen, Der Eulersche Dilogarithmus, Halle, Leipzig, 1909.  19"
GX241-51-11186167	D01  Quadrature  D01GDF  NAG Fortran Library Routine Document Note. Before using this routine, please read the Users' Note for your implementation to check the interpretation of bold italicised terms and other implementation-dependent details.  1  Purp ose  D01GDF calculates an approximation to a definite integral in up to 20 dimensions, using the Korobov Conroy number theoretic metho d. This routine is designed to be particularly efficient on vector pro cessors.  2  Sp ecification SUBROUTINE D01GDF(NDIM, VECFUN, VECREG, NPTS, VK, NRAND, ITRANS, 1 RES, ERR, IFAIL) INTEGER NDIM, NPTS, NRAND, ITRANS, IFAIL real VK(NDIM), RES, ERR EXTERNAL VECFUN, VECREG  3  Description d 1  This routine calculates an approximation to the integral, d n  I= c 1  ... c n  f (x1 ,... ,xn )dxn ... dx1  (1)  using the KorobovConroy number theoretic metho d ([1], [2], [3]). The region of integration defined in (1) is such that generally ci and di may be functions of x1 ,x2 ,...,xi-1 , for i = 2, 3,... ,n, with c1 and d1 constants. The integral is first of all transformed to an integral over the n-cube [0, 1]n by the change of variables i = 1, 2,... ,n. xi = ci +(di - ci )yi , The metho d then uses as its basis the number theoretic formula for the n-cube, [0, 1]n : 1 1 p  ... 0 0  g (x1 ,...,xn )dxn ...dx1 =  1 p  g k=1  k  a1 p  ,..., k  an p  -E  (2)  where {x} denotes the fractional part of x, a1 ,... ,an are the so-called optimal co efficients, E is the error and p is a prime integer. (It is strictly only necessary that p be relatively prime to all a1 ,...,an and is in fact chosen to be even for some cases in Conroy, [3].) The metho d makes use of properties of the Fourier expansion of g (x1 ,...,xn ) which is assumed to have some degree of perio dicity. Depending on the choice of a1 ,... ,an the contributions from certain groups of Fourier co efficients are eliminated from the error, E . Korobov shows that a1 ,... ,an can be chosen so that the error satisfies E  CK p -  ln p  (3)  where  and C are real numbers depending on the convergence rate of the Fourier series,  is a constant depending on n and K is a constant depending on  and n. There are a number of pro cedures for calculating these optimal co efficients. Korobov imposes the constraint that a1 = 1 ai = a i-1  (mo d p)  and gives a pro cedure for calculating the parameter, a, to satisfy the optimal conditions. In this routine the periodisation is achieved by the simple transformation 2 xi = yi (3 - 2yi ),  i = 1, 2,... ,n.  More sophisticated periodisation procedures are available but in practice the degree of perio disation does not appear to be a critical requirement of the metho d. [NP3390/19/pdf ] D01GDF.1   D01GDF  D01  Quadrature  An easily calculable error estimate is not available apart from repetition with an increasing sequence of values of p which can yield erratic results. The difficulties have been studied by Cranley and Patterson [4] who have proposed a Monte Carlo error estimate arising from converting (2) into a sto chastic integration rule by the inclusion of a random origin shift which leaves the form of the error (3) unchanged; i.e., in the formula (2), k ai is replaced by i + k ai , for i = 1, 2,... ,n, where each i , is uniformly distributed p p over [0, 1]. Computing the integral for each of a sequence of random vectors  allows a `standard error' to be estimated. This routine provides built-in sets of optimal co efficients, corresponding to six different values of p. Alternatively, the optimal coefficients may be supplied by the user. D01GYF and D01GZF compute the optimal coefficients for the cases where p is a prime number or p is a pro duct of two primes, respectively. This routine is designed to be particularly efficient on vector pro cessors, although it is very important that the user also co des the subroutines VECFUN and VECREG efficiently.  4  References  [1] Korobov N M (1957) The approximate calculation of multiple integrals using number theoretic methods Dokl. Acad. Nauk SSSR 115 10621065 [2] Korobov N M (1963) Number Theoretic Methods in Approximate Analysis Fizmatgiz, Moscow [3] Conroy H (1967) Molecular Shro edinger equation VIII. A new metho d for evaluting multidimensional integrals J. Chem. Phys. 47 53075318 [4] Cranley R and Patterson T N L (1976) Randomisation of number theoretic metho ds for mulitple integration SIAM J. Numer. Anal. 13 904914  5 1:  Parameters NDIM -- INTEGER On entry: the number of dimensions of the integral, n. Constraint: 1  NDIM  20. Input  2:  VECFUN -- SUBROUTINE, supplied by the user. VECFUN must evaluate the integrand at a specified set of points. Its specification is: SUBROUTINE VECFUN(NDIM, X, FV, M) INTEGER NDIM, M real X(M,NDIM), FV(M) 1:  External Procedure  NDIM -- INTEGER On entry: the number of dimensions of the integral, n.  Input  2:  X(M,NDIM) -- real array Input On entry: the co-ordinates of the m points at which the integrand must be evaluated. X(i, j ) contains the j th co-ordinate of the ith point. FV(M) -- real array Output On exit: FV(i) must contain the value of the integrand of the ith point. i.e., FV(i) = f (X(i, 1), X(i, 2),... , X(i, NDIM)), for i = 1, 2,...,M. M -- INTEGER On entry: the number of points m at which the integrand is to be evaluated. Input  3:  4:  VECFUN must be declared as EXTERNAL in the (sub)program from which D01GDF is called. Parameters denoted as Input must not be changed by this pro cedure. D01GDF.2 [NP3390/19/pdf ]   D01  Quadrature  D01GDF  3:  VECREG -- SUBROUTINE, supplied by the user. Its specification is: SUBROUTINE VECREG(NDIM, X, J, C, D, M) INTEGER NDIM, J, M real X(M,NDIM), C(M), D(M) 1:  External Procedure  VECREG must evaluate the limits of integration in any dimension for a set of points.  NDIM -- INTEGER On entry: the number of dimensions of the integral, n.  Input  2:  X(M,NDIM) -- real array Input On entry: for i = 1, 2,... ,m, X(i,1), X(i,2),...,X(i, j - 1) contain the current values of the first j - 1 co-ordinates of the ith point, which may be used if necessary in calculating the m values of cj and dj . J -- INTEGER Input On entry: the index, j , of the dimension for which the limits of the range of integration are required. C(M) -- real array Output On exit: C(i) must be set to the lower limit of the range for X(i, j ), for i = 1, 2,... ,m. D(M) -- real array Output On exit: D(i) must be set to the upper limit of the range for X(i, j ), for i = 1, 2,... ,m. M -- INTEGER Input On entry: the number of points m at which the limits of integration must be specified.  3:  4:  5:  6:  VECREG must be declared as EXTERNAL in the (sub)program from which D01GDF is called. Parameters denoted as Input must not be changed by this pro cedure. 4:  NPTS -- INTEGER (a) 1  NPTS  6.  Input  On entry: the Korobov rule to be used. There are two alternatives depending on the value of NPTS.  In this case one of six preset rules is chosen using 2129, 5003, 10007, 20011, 40009 or 80021 points depending on the respective value of NPTS being 1, 2, 3, 4, 5 or 6. (b) NPTS > 6. NPTS is the number of actual points to be used with corresponding optimal co efficients supplied in the array VK. Constraint: NPTS  1 5:  VK(NDIM) -- real array  Input/Output  On entry: If NPTS > 6, VK must contain the n optimal co efficients (which may be calculated using D01GYF or D01GZF); if NPTS  6, VK need not be set. On exit: if NPTS > 6, VK is unchanged; if NPTS  6, VK contains the n optimal co efficients used by the preset rule. 6:  NRAND -- INTEGER  Input  On entry: the number of random samples to be generated (generally a small value, say 3 to 5, is sufficient). The estimate, RES, of the value of the integral returned by the routine is then the average of NRAND calculations with different random origin shifts. If NPTS > 6, the total number of integrand evaluations will be NRAND  NPTS. If 1  NPTS  6, then the number of integrand [NP3390/19/pdf ] D01GDF.3   D01GDF  D01  Quadrature  evaluations will be NRAND  p, where p is the number of points corresponding to the six preset rules. For reasons of efficiency, these values are calculated a number at a time in VECFUN. Constraint: NRAND  1 7:  ITRANS -- INTEGER On entry: indicates whether the perio dising transformation is to be used:  Input  if ITRANS = 0, the transformation is to be used. if ITRANS = 0, the transformation is to be suppressed (to cover cases where the integrand may already be periodic or where the user desires to specify a particular transformation in the definition of VECFUN). Suggested value: ITRANS = 0. 8:  RES -- real On exit: an estimate of the value of the integral.  Output  9:  ERR -- real  Output  On exit: the standard error as computed from NRAND sample values. If NRAND = 1, then ERR contains zero. 10:  IFAIL -- INTEGER  Input/Output  On entry: IFAIL must be set to 0, -1 or 1. For users not familiar with this parameter (described in Chapter P01) the recommended value is 0. On exit: IFAIL = 0 unless the routine detects an error (see Section 6).  6  Error Indicators and Warnings  If on entry IFAIL = 0 or -1, explanatory error messages are output on the current error message unit (as defined by X04AAF). Errors detected by the routine: IFAIL = 1 On entry, NDIM < 1, or NDIM > 20. IFAIL = 2 On entry, NPTS < 1. IFAIL = 3 On entry, NRAND < 1.  7  Accuracy  If NRAND > 1, an estimate of the absolute standard error is given by the value, on exit, of ERR.  D01GDF.4  [NP3390/19/pdf ]   D01  Quadrature  D01GDF  8  Further Comments  This routine performs the same computation as the D01GCF. However, the interface has been mo dified so that it can perform more efficiently on machines with vector pro cessing capabilities. In particular, the routines VECFUN and VECREG must calculate the integrand and limits of integration at a set of points. For some problems the amount of time spent in these two subroutines, which must be supplied by the user, may account for a significant part of the total computation time. For this reason it is vital that the user considers the possibilities for vectorization in the co de supplied for these two subroutines. The time taken will be approximately proportional to NRAND  p, where p is the number of points used, but may depend significantly on the efficiency of the co de provided by the user in subroutines VECFUN and VECREG. The exact values of RES and ERR returned by D01GDF will depend (within statistical limits) on the sequence of random numbers generated within the routine by calls to G05CAF. To ensure that the results returned by D01GDF in separate runs are identical, users should call G05CBF immediately before calling D01GDF; to ensure that they are different, call G05CCF.  9  Example 1 0 0 1 0 1 0 1  This example calculates the integral cos(0.5+2(x1 + x2 + x3 + x4 ) - 4) dx1 dx2 dx3 dx4 .  9.1  Program Text  Note. The listing of the example program presented below uses bold italicised terms to denote precision-dependent details. Please read the Users' Note for your implementation to check the interpretation of these terms. As explained in the Essential Introduction to this manual, the results produced may not be identical for all implementations.  * * *  *  * * *  D01GDF Example Program Text Mark 14 Release. NAG Copyright 1989. .. Parameters .. INTEGER NOUT PARAMETER (NOUT=6) INTEGER NDIM PARAMETER (NDIM=4) .. Local Scalars .. real ERR, RES INTEGER IFAIL, ITRANS, NPTS, NRAND .. Local Arrays .. real VK(NDIM) .. External Subroutines .. EXTERNAL D01GDF, VECFUN, VECREG .. Executable Statements .. WRITE (NOUT,*) 'D01GDF Example Program Results' WRITE (NOUT,*) NPTS = 2 ITRANS = 0 NRAND = 4 IFAIL = 0 CALL D01GDF(NDIM,VECFUN,VECREG,NPTS,VK,NRAND,ITRANS,RES,ERR,IFAIL)  * * WRITE (NOUT,99999) 'Result = ', RES, ', standard error = ', ERR STOP * 99999 FORMAT (1X,A,F13.5,A,e10.2) END [NP3390/19/pdf ] D01GDF.5   D01GDF  D01  Quadrature  * * * * * * SUBROUTINE VECFUN(NDIM,X,FV,M) .. Scalar Arguments .. INTEGER M, NDIM .. Array Arguments .. real FV(M), X(M,NDIM) .. Local Scalars .. INTEGER I, J .. Intrinsic Functions .. INTRINSIC COS, real .. Executable Statements .. DO 20 I = 1, M FV(I) = 0.0e0 CONTINUE DO 60 J = 1, NDIM DO 40 I = 1, M FV(I) = FV(I) + X(I,J) CONTINUE CONTINUE DO 80 I = 1, M FV(I) = COS(0.5e0+2.0e0*FV(I)-real(NDIM)) CONTINUE RETURN END  20  40 60  80  * * * * * SUBROUTINE VECREG(NDIM,X,J,C,D,M) .. Scalar Arguments .. INTEGER J, M, NDIM .. Array Arguments .. real C(M), D(M), X(M,NDIM) .. Local Scalars .. INTEGER I .. Executable Statements .. DO 20 I = 1, M C(I) = 0.0e0 D(I) = 1.0e0 20 CONTINUE RETURN END  9.2 None.  Program Data  9.3  Program Results D01GDF Example Program Results Result = 0.43999, standard error = 0.18E-05  D01GDF.6 (last)  [NP3390/19/pdf ]
GX252-17-13624814	"7.1 Uniform Deviates  267  As for references on this subject, the one to turn to first is Knuth [1 ]. Then try [2 ]. Only a few of the standard books on numerical methods [3-4 ] treat topics relating to random numbers.  CITED REFERENCES AND FURTHER READING: Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  Knuth, D.E. 1981, Seminumerical Algorithms, 2nd ed., vol. 2 of The Ar t of Computer Programming (Reading, MA: Addison-Wesley), Chapter 3, especially 3.5. [1] Bratley, P., Fox, B.L., and Schrage, E.L. 1983, A Guide to Simulation (New York: SpringerVerlag). [2] Dahlquist, G., and Bjorck, A. 1974, Numerical Methods (Englewood Cliffs, NJ: Prentice-Hall), Chapter 11. [3] Forsythe, G.E., Malcolm, M.A., and Moler, C.B. 1977, Computer Methods for Mathematical Computations (Englewood Cliffs, NJ: Prentice-Hall), Chapter 10. [4]  7.1 Uniform Deviates Uniform deviates are just random numbers that lie within a specified range (typically 0 to 1), with any one number in the range just as likely as any other. They are, in other words, what you probably think ""random numbers"" are. However, we want to distinguish uniform deviates from other sorts of random numbers, for example numbers drawn from a normal (Gaussian) distribution of specified mean and standard deviation. These other sorts of deviates are almost always generated by performing appropriate operations on one or more uniform deviates, as we will see in subsequent sections. So, a reliable source of random uniform deviates, the subject of this section, is an essential building block for any sort of stochastic modeling or Monte Carlo computer work.  System-Supplied Random Number Generators Your computer very likely has lurking within it a library routine which is called a ""random number generator."" That routine typically has an unforgettable name like ""ran,"" and a calling sequence like x=ran(iseed) sets x to the next random number and updates iseed  You initialize iseed to a (usually) arbitrary value before the first call to ran. Each initializing value will typically return a different subsequent random sequence, or at least a different subsequence of some one enormously long sequence. The same initializing value of iseed will always return the same random sequence, however. Now our first, and perhaps most important, lesson in this chapter is: Be very, very suspicious of a system-supplied ran that resembles the one just described. If all scientific papers whose results are in doubt because of bad rans were to disappear from library shelves, there would be a gap on each shelf about as big as your fist. System-supplied rans are almost always linear congruential generators, which   268  Chapter 7.  Random Numbers  generate a sequence of integers I 1 ,I2 ,I3 ,... , each between 0 and m - 1 (a large number) by the recurrence relation Ij +1  = aIj + c  (mod m)  (7.1.1) Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  Here m is called the modulus, and a and c are positive integers called the multiplier and the increment, respectively. The recurrence (7.1.1) will eventually repeat itself, with a period that is obviously no greater than m. If m, a, and c are properly chosen, then the period will be of maximal length, i.e., of length m. In that case, all possible integers between 0 and m - 1 occur at some point, so any initial ""seed"" choice of I 0 is as good as any other: The sequence just takes off from that point. The real number between 0 and 1 which is returned is generally I j +1 /m, so that it is strictly less than 1, but occasionally (once in m calls) exactly equal to zero. iseed is set to I j +1 (or some encoding of it), so that it can be used on the next call to generate I j +2 , and so on. The linear congruential method has the advantage of being very fast, requiring only a few operations per call, hence its almost universal use. It has the disadvantage that it is not free of sequential correlation on successive calls. If k random numbers at a time are used to plot points in k dimensional space (with each coordinate between 0 and 1), then the points will not tend to ""fill up"" the k -dimensional space, but rather will lie on (k - 1)-dimensional ""planes."" There will be at most about m 1/k such planes. If the constants m, a, and c are not very carefully chosen, there will be many fewer than that. The number m is usually close to the machine's largest representable integer, e.g.,  2 32 . So, for example, the number of planes on which triples of points lie in three-dimensional space is usually no greater than about the cube root of 2 32 , about 1600. You might well be focusing attention on a physical process that occurs in a small fraction of the total volume, so that the discreteness of the planes can be very pronounced. Even worse, you might be using a ran whose choices of m, a, and c have been botched. One infamous such routine, RANDU, with a = 65539 and m = 2 31 , was widespread on IBM mainframe computers for many years, and widely copied onto other systems [1 ]. One of us recalls producing a ""random"" plot with only 11 planes, and being told by his computer center's programming consultant that he had misused the random number generator: ""We guarantee that each number is random individually, but we don't guarantee that more than one of them is random."" Figure that out. Correlation in k -space is not the only weakness of linear congruential generators. Such generators often have their low-order (least significant) bits much less random than their high-order bits. If you want to generate a random integer between 1 and 10, you should always do it using high-order bits, as in j=1+int(10.*ran(iseed))  and never by anything resembling j=1+mod(int(1000000.*ran(iseed)),10)   7.1 Uniform Deviates  269  (which uses lower-order bits). Similarly you should never try to take apart a ""ran"" number into several supposedly random pieces. Instead use separate calls for every piece.  Portable Random Number Generators Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  Park and Miller [1 ] have surveyed a large number of random number generators that have been used over the last 30 years or more. Along with a good theoretical review, they present an anecdotal sampling of a number of inadequate generators that have come into widespread use. The historical record is nothing if not appalling. There is good evidence, both theoretical and empirical, that the simple multiplicative congruential algorithm Ij +1  = aIj  (mod m)  (7.1.2)  can be as good as any of the more general linear congruential generators that have c = 0 (equation 7.1.1) -- if the multiplier a and modulus m are chosen exquisitely carefully. Park and Miller propose a ""Minimal Standard"" generator based on the choices a = 75 = 16807 m=2 31  - 1 = 2147483647  (7.1.3)  First proposed by Lewis, Goodman, and Miller in 1969, this generator has in subsequent years passed all new theoretical tests, and (perhaps more importantly) has accumulated a large amount of successful use. Park and Miller do not claim that the generator is ""perfect"" (we will see below that it is not), but only that it is a good minimal standard against which other generators should be judged. It is not possible to implement equations (7.1.2) and (7.1.3) directly in a high-level language, since the product of a and m - 1 exceeds the maximum value for a 32-bit integer. Assembly language implementation using a 64-bit product register is straightforward, but not portable from machine to machine. A trick due to Schrage [2,3 ] for multiplying two 32-bit integers modulo a 32-bit constant, without using any intermediates larger than 32 bits (including a sign bit) is therefore extremely interesting: It allows the Minimal Standard generator to be implemented in essentially any programming language on essentially any machine. Schrage's algorithm is based on an approximate factorization of m, m = aq + r, i.e., q = [m/a], r = m mod a (7.1.4)  with square brackets denoting integer part. If r is small, specifically r < q , and 0 < z < m - 1, it can be shown that both a(z mod q ) and r[z/q ] lie in the range 0,... ,m - 1, and that az mod m = a(z mod q ) - r[z/q ] a(z mod q ) - r[z/q ]+ m if it is  0, otherwise (7.1.5)  The application of Schrage's algorithm to the constants (7.1.3) uses the values q = 127773 and r = 2836. Here is an implementation of the Minimal Standard generator:   270  Chapter 7.  Random Numbers  *  FUNCTION ran0(idum) INTEGER idum,IA,IM,IQ,IR,MASK REAL ran0,AM PARAMETER (IA=16807,IM=2147483647,AM=1./IM, IQ=127773,IR=2836,MASK=123459876) ""Minimal"" random number generator of Park and Miller. Returns a uniform random deviate between 0.0 and 1.0. Set or reset idum to any integer value (except the unlikely value MASK) to initialize the sequence; idum must not be altered between calls for successive deviates in a sequence. INTEGER k idum=ieor(idum,MASK) XORing with MASK allows use of zero and other simple k=idum/IQ bit patterns for idum. idum=IA*(idum-k*IQ)-IR*k Compute idum=mod(IA*idum,IM) without overflows by if (idum.lt.0) idum=idum+IM Schrage's method. ran0=AM*idum Convert idum to a floating result. idum=ieor(idum,MASK) Unmask before return. return END  Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  The period of ran0 is 2 31 - 2  2.1  109 . A peculiarity of generators of the form (7.1.2) is that the value 0 must never be allowed as the initial seed -- it perpetuates itself -- and it never occurs for any nonzero initial seed. Experience has shown that users always manage to call random number generators with the seed idum=0. That is why ran0 performs its exclusive-or with an arbitrary constant both on entry and exit. If you are the first user in history to be proof against human error, you can remove the two lines with the ieor function. Park and Miller discuss two other multipliers a that can be used with the same m = 231 - 1. These are a = 48271 (with q = 44488 and r = 3399) and a = 69621 (with q = 30845 and r = 23902). These can be substituted in the routine ran0 if desired; they may be slightly superior to Lewis et al.'s longer-tested values. No values other than these should be used. The routine ran0 is a Minimal Standard, satisfactory for the majority of applications, but we do not recommend it as the final word on random number generators. Our reason is precisely the simplicity of the Minimal Standard. It is not hard to think of situations where successive random numbers might be used in a way that accidentally conflicts with the generation algorithm. For example, since successive numbers differ by a multiple of only 1.6  10 4 out of a modulus of more than 2  10 9 , very small random numbers will tend to be followed by smaller than average values. One time in 106 , for example, there will be a value < 10 -6 returned (as there should be), but this will always be followed by a value less than about 0.0168. One can easily think of applications involving rare events where this property would lead to wrong results. There are other, more subtle, serial correlations present in ran0. For example, if successive points (Ii ,Ii+1 ) are binned into a two-dimensional plane for i = 1, 2,... ,N , then the resulting distribution fails the  2 test when N is greater than a few 107 , much less than the period m - 2. Since low-order serial correlations have historically been such a bugaboo, and since there is a very simple way to remove them, we think that it is prudent to do so. The following routine, ran1, uses the Minimal Standard for its random value, but it shuffles the output to remove low-order serial correlations. A random deviate derived from the j th value in the sequence, I j , is output not on the j th call, but rather on a randomized later call, j +32 on average. The shuffling algorithm is due to Bays and Durham as described in Knuth [4 ], and is illustrated in Figure 7.1.1.   7.1 Uniform Deviates  271  *  FUNCTION ran1(idum) INTEGER idum,IA,IM,IQ,IR,NTAB,NDIV REAL ran1,AM,EPS,RNMX PARAMETER (IA=16807,IM=2147483647,AM=1./IM,IQ=127773,IR=2836, NTAB=32,NDIV=1+(IM-1)/NTAB,EPS=1.2e-7,RNMX=1.-EPS) ""Minimal"" random number generator of Park and Miller with Bays-Durham shuffle and added safeguards. Returns a uniform random deviate between 0.0 and 1.0 (exclusive of the endpoint values). Call with idum a negative integer to initialize; thereafter, do not alter idum between successive deviates in a sequence. RNMX should approximate the largest floating value that is less than 1. INTEGER j,k,iv(NTAB),iy SAVE iv,iy DATA iv /NTAB*0/, iy /0/ if (idum.le.0.or.iy.eq.0) then Initialize. idum=max(-idum,1) Be sure to prevent idum = 0. do 11 j=NTAB+8,1,-1 Load the shuffle table (after 8 warm-ups). k=idum/IQ idum=IA*(idum-k*IQ)-IR*k if (idum.lt.0) idum=idum+IM if (j.le.NTAB) iv(j)=idum enddo 11 iy=iv(1) endif k=idum/IQ Start here when not initializing. idum=IA*(idum-k*IQ)-IR*k Compute idum=mod(IA*idum,IM) without overflows by if (idum.lt.0) idum=idum+IM Schrage's method. j=1+iy/NDIV Will be in the range 1:NTAB. iy=iv(j) Output previously stored value and refill the shuffle taiv(j)=idum ble. ran1=min(AM*iy,RNMX) Because users don't expect endpoint values. return END  Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  The routine ran1 passes those statistical tests that ran0 is known to fail. In fact, we do not know of any statistical test that ran1 fails to pass, except when the number of calls starts to become on the order of the period m, say > 10 8  m/20. For situations when even longer random sequences are needed, L'Ecuyer [6 ] has given a good way of combining two different sequences with different periods so as to obtain a new sequence whose period is the least common multiple of the two periods. The basic idea is simply to add the two sequences, modulo the modulus of either of them (call it m). A trick to avoid an intermediate value that overflows the integer wordsize is to subtract rather than add, and then add back the constant m - 1 if the result is  0, so as to wrap around into the desired interval 0,... ,m - 1. Notice that it is not necessary that this wrapped subtraction be able to reach all values 0,... ,m - 1 from every value of the first sequence. Consider the absurd extreme case where the value subtracted was only between 1 and 10: The resulting sequence would still be no less random than the first sequence by itself. As a practical matter it is only necessary that the second sequence have a range covering substantially all of the range of the first. L'Ecuyer recommends the use of the two generators m1 = 2147483563 (with a1 = 40014, q1 = 53668, r1 = 12211) and m2 = 2147483399 (with a2 = 40692, q2 = 52774, r2 = 3791). Both moduli are slightly less than 231 . The periods m 1 - 1 = 2  3  7  631  81031 and m2 - 1 = 2  19  31  1019  1789 share only the factor 2, so the period of the combined generator is  2.3  10 18 . For present computers, period exhaustion is a practical impossibility.   272  Chapter 7.  Random Numbers  iy  1 Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  iv  1  OUTPUT  RAN  3  2  iv  32  Figure 7.1.1. Shuffling procedure used in ran1 to break up sequential correlations in the Minimal Standard generator. Circled numbers indicate the sequence of events: On each call, the random number in iy is used to choose a random element in the array iv. That element becomes the output random number, and also is the next iy. Its spot in iv is refilled from the Minimal Standard routine.  Combining the two generators breaks up serial correlations to a considerable extent. We nevertheless recommend the additional shuffle that is implemented in the following routine, ran2. We think that, within the limits of its floating-point precision, ran2 provides perfect random numbers; a practical definition of ""perfect"" is that we will pay $1000 to the first reader who convinces us otherwise (by finding a statistical test that ran2 fails in a nontrivial way, excluding the ordinary limitations of a machine's floating-point representation). FUNCTION ran2(idum) INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV REAL ran2,AM,EPS,RNMX PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1, IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211, IR2=3791,NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS) Long period (> 2  1018 ) random number generator of L'Ecuyer with Bays-Durham shuffle and added safeguards. Returns a uniform random deviate between 0.0 and 1.0 (exclusive of the endpoint values). Call with idum a negative integer to initialize; thereafter, do not alter idum between successive deviates in a sequence. RNMX should approximate the largest floating value that is less than 1. INTEGER idum2,j,k,iv(NTAB),iy SAVE iv,iy,idum2 DATA idum2/123456789/, iv/NTAB*0/, iy/0/ if (idum.le.0) then Initialize. idum=max(-idum,1) Be sure to prevent idum = 0. idum2=idum do 11 j=NTAB+8,1,-1 Load the shuffle table (after 8 warm-ups). k=idum/IQ1  * *   7.1 Uniform Deviates  273  idum=IA1*(idum-k*IQ1)-k*IR1 if (idum.lt.0) idum=idum+IM1 if (j.le.NTAB) iv(j)=idum enddo 11 iy=iv(1) endif k=idum/IQ1 idum=IA1*(idum-k*IQ1)-k*IR1 if (idum.lt.0) idum=idum+IM1 k=idum2/IQ2 idum2=IA2*(idum2-k*IQ2)-k*IR2 if (idum2.lt.0) idum2=idum2+IM2 j=1+iy/NDIV iy=iv(j)-idum2 iv(j)=idum if(iy.lt.1)iy=iy+IMM1 ran2=min(AM*iy,RNMX) return END  Start here when not initializing. Compute idum=mod(IA1*idum,IM1) without overflows by Schrage's method. Compute idum2=mod(IA2*idum2,IM2) likewise. Will be in the range 1:NTAB. Here idum is shuffled, idum and idum2 are combined to generate output. Because users don't expect endpoint values.  Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  L'Ecuyer [6 ] lists additional short generators that can be combined into longer ones, including generators that can be implemented in 16-bit integer arithmetic. Finally, we give you Knuth's suggestion [4 ] for a portable routine, which we have translated to the present conventions as ran3. This is not based on the linear congruential method at all, but rather on a subtractive method (see also [5 ]). One might hope that its weaknesses, if any, are therefore of a highly different character from the weaknesses, if any, of ran1 above. If you ever suspect trouble with one routine, it is a good idea to try the other in the same application. ran3 has one nice feature: if your machine is poor on integer arithmetic (i.e., is limited to 16-bit integers), substitution of the three ""commented"" lines for the ones directly preceding them will render the routine entirely floating-point. FUNCTION ran3(idum) Returns a uniform random deviate between 0.0 and 1.0. Set idum to any negative value to initialize or reinitialize the sequence. INTEGER idum INTEGER MBIG,MSEED,MZ REAL MBIG,MSEED,MZ REAL ran3,FAC PARAMETER (MBIG=1000000000,MSEED=161803398,MZ=0,FAC=1./MBIG) PARAMETER (MBIG=4000000.,MSEED=1618033.,MZ=0.,FAC=1./MBIG) According to Knuth, any large mbig, and any smaller (but still large) mseed can be substituted for the above values. INTEGER i,iff,ii,inext,inextp,k INTEGER mj,mk,ma(55) The value 55 is special and should not be modified; see REAL mj,mk,ma(55) Knuth. SAVE iff,inext,inextp,ma DATA iff /0/ if(idum.lt.0.or.iff.eq.0)then Initialization. iff=1 mj=abs(MSEED-abs(idum)) Initialize ma(55) using the seed idum and the large nummj=mod(mj,MBIG) ber mseed. ma(55)=mj mk=1 do 11 i=1,54 Now initialize the rest of the table, ii=mod(21*i,55) in a slightly random order, ma(ii)=mk with numbers that are not especially random. mk=mj-mk if(mk.lt.MZ)mk=mk+MBIG  C C  C   274  Chapter 7.  Random Numbers  mj=ma(ii) enddo 11 do 13 k=1,4 We randomize them by ""warming up the generator."" do 12 i=1,55 ma(i)=ma(i)-ma(1+mod(i+30,55)) if(ma(i).lt.MZ)ma(i)=ma(i)+MBIG enddo 12 enddo 13 inext=0 Prepare indices for our first generated number. inextp=31 The constant 31 is special; see Knuth. idum=1 endif inext=inext+1 Here is where we start, except on initialization. Increment if(inext.eq.56)inext=1 inext, wrapping around 56 to 1. inextp=inextp+1 Ditto for inextp. if(inextp.eq.56)inextp=1 mj=ma(inext)-ma(inextp) Now generate a new random number subtractively. if(mj.lt.MZ)mj=mj+MBIG Be sure that it is in range. ma(inext)=mj Store it, ran3=mj*FAC and output the derived uniform deviate. return END  Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  Quick and Dirty Generators One sometimes would like a ""quick and dirty"" generator to embed in a program, perhaps taking only one or two lines of code, just to somewhat randomize things. One might wish to process data from an experiment not always in exactly the same order, for example, so that the first output is more ""typical"" than might otherwise be the case. For this kind of application, all we really need is a list of ""good"" choices for m, a, and c in equation (7.1.1). If we don't need a period longer than 104 to 106 , say, we can keep the value of (m - 1)a + c small enough to avoid overflows that would otherwise mandate the extra complexity of Schrage's method (above). We can thus easily embed in our programs jran=mod(jran*ia+ic,im) ran=float(jran)/float(im)  whenever we want a quick and dirty uniform deviate, or jran=mod(jran*ia+ic,im) j=jlo+((jhi-jlo+1)*jran)/im  whenever we want an integer between jlo and jhi, inclusive. (In both cases jran was once initialized to any seed value between 0 and im-1.) Be sure to remember, however, that when im is small, the kth root of it, which is the number of planes in k-space, is even smaller! So a quick and dirty generator should never be used to select points in k-space with k > 1. With these caveats, some ""good"" choices for the constants are given in the accompanying table. These constants (i) give a period of maximal length im, and, more important, (ii) pass Knuth's ""spectral "" for dimensions 2, 3, 4, 5, and 6. The increment ic is a prime, close to test the value ( 1 - 1 3)im; actually almost any value of ic that is relatively prime to im will do 2 6 just as well, but there is some ""lore"" favoring this choice (see [4 ], p. 84).   7.1 Uniform Deviates  275  Constants for Quick and Dirty Random Number Generators overflow at 220 221 222 im 6075 7875 7875 ia 106 211 421 ic 1283 1663 1663 1283 1399 2531 228 227 overflow at im ia ic 18257 25673 54773 24749 25673 66037 30809 36979 49297 51749  86436 1093 121500 1021 259200 421 117128 1277 121500 2041 312500 741 145800 175000 233280 244944 3661 2661 1861 1597  Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  223  6075 1366 6655 936 11979 430 14406 29282 53125  2  24  967 3041 419 6173 171 11213  229  225  12960 1741 2731 14000 1541 2957 21870 1291 4621 31104 625 6571 139968 205 29573 29282 1255 6173 81000 421 17117 134456 281 28411  230 231 232  139968 3877 29573 214326 3613 45289 714025 1366 150889 134456 8121 259200 7141 28411 54773  233280 9301 49297 714025 4096 150889  2  26  An Even Quicker and Dirtier Generator Many FORTRAN compilers can be abused in such a way that they will multiply two 32-bit integers ignoring any resulting overflow. In such cases, on many machines, the value returned is predictably the low-order 32 bits of the true 64-bit product. (C compilers, incidentally, can do this without the requirement of abuse -- it is guaranteed behavior for so-called unsigned long int integers. On VMS VAXes, the necessary FORTRAN command is FORTRAN/CHECK=NOOVERFLOW .) If we now choose m = 232 , the ""mod"" in equation (7.1.1) is free, and we have simply I j +1  = aIj + c  (7.1.6)  Knuth suggests a = 1664525 as a suitable multiplier for this value of m. H.W. Lewis has  conducted extensive tests of this value of a with c = 1013904223, which is a prime close to ( 5 - 2)m. The resulting in-line generator (we will call it ranqd1) is simply idum=1664525*idum+1013904223  This is about as good as any 32-bit linear congruential generator, entirely adequate for many uses. And, with only a single multiply and add, it is very fast. To check whether your compiler and machine have the desired overflow properties, see if you can generate the following sequence of 32-bit values (given here in hex): 00000000, 3C6EF35F, 47502932, D1CCF6E9, AAF95334, 6252E503, 9F2EC686, 57FE6C2D, A3D95FA8, 81FDBEE7, 94F0AF1A, CBF633B1. If you need floating-point values instead of 32-bit integers, and want to avoid a divide by floating-point 232 , a dirty trick is to mask in an exponent that makes the value lie between 1 and 2, then subtract 1.0. The resulting in-line generator (call it ranqd2) will look something like   276  Chapter 7.  Random Numbers  INTEGER idum,itemp,jflone,jflmsk REAL ftemp EQUIVALENCE (itemp,ftemp) DATA jflone /Z'3F800000'/, jflmsk /Z'007FFFFF'/ ... idum=1664525*idum+1013904223 itemp=ior(jflone,iand(jflmsk,idum)) ran=ftemp-1.0  Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  The hex constants 3F800000 and 007FFFFF are the appropriate ones for computers using the IEEE representation for 32-bit floating-point numbers (e.g., IBM PCs and most UNIX workstations). For DEC VAXes, the correct hex constants are, respectively, 00004080 and FFFF007F. Notice that the IEEE mask results in the floating-point number being constructed out of the 23 low-order bits of the integer, which is not ideal. Also notice that your compiler may require a different notation for hex constants, e.g., x'3f800000', '3F800000'X,or even 16#3F800000 . (Your authors have tried very hard to make almost all of the material in this book machine and compiler independent -- indeed, even programming language independent. This subsection is a rare aberration. Forgive us. Once in a great while the temptation to be really dirty is just irresistible.)  Relative Timings and Recommendations Timings are inevitably machine dependent. Nevertheless the following table is indicative of the relative timings, for typical machines, of the various uniform generators discussed in this section, plus ran4 from 7.5. Smaller values in the table indicate faster generators. The generators ranqd1 and ranqd2 refer to the ""quick and dirty"" generators immediately above.  Generator ran0 ran1 ran2 ran3 ranqd1 ranqd2 ran4  Relative Execution Time  1.0  1.3  2.0  0.6  0.10  0.25  4.0  On balance, we recommend ran1 for general use. It is portable, based on Park and Miller's Minimal Standard generator with an additional shuffle, and has no known (to us) flaws other than period exhaustion. If you are generating more than 100,000,000 random numbers in a single calculation (that is, more than about 5% of ran1's period), we recommend the use of ran2, with its much longer period. Knuth's subtractive routine ran3 seems to be the timing winner among portable routines. Unfortunately the subtractive method is not so well studied, and not a standard. We like to keep ran3 in reserve for a ""second opinion,"" substituting it when we suspect another generator of introducing unwanted correlations into a calculation. The routine ran4 generates extremely good random deviates, and has some other nice properties, but it is slow. See 7.5 for discussion.   7.2 Transformation Method: Exponential and Normal Deviates  277  Finally, the quick and dirty in-line generators ranqd1 and ranqd2 are very fast, but they are machine dependent, nonportable, and at best only as good as a 32-bit linear congruential generator ever is -- in our view not good enough in many situations. We would use these only in very special cases, where speed is critical. CITED REFERENCES AND FURTHER READING: Park, S.K., and Miller, K.W. 1988, Communications of the ACM, vol. 31, pp. 11921201. [1] Schrage, L. 1979, ACM Transactions on Mathematical Software, vol. 5, pp. 132138. [2] Bratley, P., Fox, B.L., and Schrage, E.L. 1983, A Guide to Simulation (New York: SpringerVerlag). [3] Knuth, D.E. 1981, Seminumerical Algorithms, 2nd ed., vol. 2 of The Ar t of Computer Programming (Reading, MA: Addison-Wesley), 3.23.3. [4] Kahaner, D., Moler, C., and Nash, S. 1989, Numerical Methods and Software (Englewood Cliffs, NJ: Prentice Hall), Chapter 10. [5] L'Ecuyer, P. 1988, Communications of the ACM, vol. 31, pp. 742774. [6] Forsythe, G.E., Malcolm, M.A., and Moler, C.B. 1977, Computer Methods for Mathematical Computations (Englewood Cliffs, NJ: Prentice-Hall), Chapter 10. Sample page from NUMERICAL RECIPES IN FORTRAN 77: THE ART OF SCIENTIFIC COMPUTING (ISBN 0-521-43064-X) Copyright (C) 1986-1992 by Cambridge University Press. Programs Copyright (C) 1986-1992 by Numerical Recipes Software. Permission is granted for internet users to make one paper copy for their own personal use. Further reproduction, or any copying of machinereadable files (including this one) to any server computer, is strictly prohibited. To order Numerical Recipes books or CDROMs, visit website http://www.nr.com or call 1-800-872-7423 (North America only), or send email to directcustserv@cambridge.org (outside North America).  7.2 Transformation Method: Exponential and Normal Deviates In the previous section, we learned how to generate random deviates with a uniform probability distribution, so that the probability of generating a number between x and x + dx, denoted p(x)dx, is given by p(x)dx = dx 0 0"
