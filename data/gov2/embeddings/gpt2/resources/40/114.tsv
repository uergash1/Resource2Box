id	content
GX016-50-3666937	"Dataplot                                                              Vol 1                                                              Auxillary Chapter                                         SVG     Name:            SVG          Type:            Output Device Command          Purpose:            Create SVG (Scalable Vector Graphics) format graphics files.          Description:            The ability to generate graphics for web based applications is     increasingly important.  The three most common formats for     web applications are:                        GIF          JPEG          PNG (Portable Network Graphics)                   Note that these are all bit mapped formats.            SVG (Scalable Vector Graphics) is an emerging graphics     format for web applications.  SVG is an XML (extensible     markup language) based format.  Note that XML is a meta     markup language, that is it is a langauge for defining      languages.  SVG is one specific implementation of an     XML language.  This is analogous to HTML being a specific     implementation of a SGML (Standard Generalized Markup     Language) language.  SVG is expected to develop into an     important format over the next several years.            SVG is a relatively new standard (as of 3/2002) and not     all browsers will support it.  Adobe provides a freely     downloadable plugin for Netscape and Internet Explorer on the     PC and Mac OSX.  Search for the ""SVG Viewer"" on the Adobe     web site (http://www.adobe.com).  Also, there are several     SVG viewers/browsers (e.g., XSMILES) under development.     Support for SVG graphics in web pages should grow rapidly     in the next few years.            SVG is a vector based rather than a bitmap based protocol.     Also, SVG is an ASCII file that contains a textual     description of the graph.  One of the primary advantages     of this approach is that web graphics can be easily edited     much the way the HTML files can be edited.  This can make     the maintenance of the graphics on a web site easier.            In addition to web applications, it is expected that     SVG will be supported by many graphics editing programs     (e.g., Photoshop, Corel Draw).         Syntax 1:            SVG            This form designates device 1 as an SVG graphics device,     which results in the SVG output being written to the     screen.  This syntax is not partiucularly useful since the     SVG needs to be saved in a file so that an external SVG viewer     can read it.          Syntax 2:            DEVICE <1/2/3> SVG            This form designates one of DATAPLOT's 3 devices (typically     device 2) as an SVG device.          Examples:            DEVICE 2 SVG       DEVICE 3 SVG            Note:            For SVG, it is often desirable to put each plot in a     separate file with a unique name.  This can     be accomplished with a sequence of commands like the following:                      SET IPL1NA  PLOT1.SVG           DEVICE 2 SVG              generate first plot           DEVICE 2 CLOSE           SET IPL1NA  PLOT2.SVG           DEVICE 2 SVG              generate second plot           DEVICE 2 CLOSE                    The SET IPL1NA command specifies the name of the file.  Note     that this name is currently converted to upper case.     This command should come before the DEVICE 2 SVG command.          Note:            The default image size is 600 pixels by 450 pixels.  You     can change the default size of the image by using the     DEVICE ... PICTURE POINTS command.  For example,                      SET IPL1NA  PLOT1.SVG           DEVICE 2 SVG           DEVICE 2 PICTURE POINTS  300 300              generate first plot           DEVICE 2 CLOSE                  Note:            Style sheets allow easier maintenance/editing by specifying     default attributes in an external style sheet file.  The     default Dataplot style sheet is ""dataplot.css"" and it is     stored in the Dataplot ""HELP"" sub-directory.           Currently, Dataplot supports the following class for     the background (this only sets the color, not the size):                     rect.background                  Currently, Dataplot supports the following classes for     lines:                     polyline.narrow-solid          polyline.medium-solid          polyline.wide-solid          polyline.extrawide-solid          polyline.narrow-dotted          polyline.medium-dotted          polyline.wide-dotted          polyline.extrawide-dotted          polyline.narrow-dash          polyline.medium-dash          polyline.wide-dash          polyline.extrawide-dash          polyline.narrow-dash2          polyline.medium-dash2          polyline.wide-dash2          polyline.extrawide-dash2          polyline.narrow-dash3          polyline.medium-dash3          polyline.wide-dash3          polyline.extrawide-dash3          polyline.narrow-dash4          polyline.medium-dash4          polyline.wide-dash4          polyline.extrawide-dash4          polyline.narrow-dash5          polyline.medium-dash5          polyline.wide-dash5          polyline.extrawide-dash5                    Currently, Dataplot supports the following classes for     text:                     text.left-horizontal          text.center-horizontal          text.right-horizontal                    Currently, no classes are supported for region fills.           As we develop more experience with SVG graphics, we may     expand the supported classes.           When using external style sheets, you modify the attributes     of the clases.  However, you do not edit which classes are     available (Dataplot generates the SVG file based on the above     classes.           Dataplot will check the value of certain attributes     (color for lines, color and size for text) when generating     the SVG file.  If these are not the default values, then     a local ""style"" option will be added for that element     to override the value in the style sheet.           To make your own style sheets, simply copy the default     file ""dataplot.css"" to a new file name and then edit that     file.  Use the SET SVG STYLE SHEET NAME command (see below)     to specify the location of the style sheet you wish to use     (this should be the location of the style sheet relative to     the location of the SVG file on your web pages).         Note:            The following SET commands apply to the SVG output.                     SET SVG COORDINATE SYSTEM  <PIXEL/PERCENT>            - specify whether coordinates are specified in              pixel units or percent untis.  Currently, only              pixel units are supported.  The PERCENT option is              reserved for possible future implementation.                      SET SVG FONT NAME <SERIF/SANS/MONOSPACE>            - specify the font name for hardware characters.              Generic names (i.e., supported on all SVG viewers)              are: serif, sans-serif, and monospace.  Specific              font names (e.g., arial) depend on what fonts are              installed on your local system.  Currently, only              the generic fonts are supported.  For specific              fonts, use style sheets and set the name in the              style sheet.  The default is sans-serif.         SET SVG FONT WEIGHT <NORMAL/BOLD>            - specify whether text is drawn as bold or normal.              The default is bold.         SET SVG FONT STYLE <NORMAL/ITALIC>            - specify whether text is drawn in an italic style              or a normal style.  The default is normal.                       SET SVG CAP STYLE <BUTT/ROUND/SQUARE/NONE>            - specify the cap style for line drawing.  The default              is butt.          SET SVG JOIN STYLE <MITER/ROUND/BEVEL/NONE>            - specify the join style for line draweing.  The default              is miter.                       SET SVG HARDWARE FILL SWITCH <NONZERO/EVENODD/SOFTWARE>            - by default, region fills are performed in hardware              using a ""non-zero"" rule.  You can also specify              that an ""evenodd"" rule be used.  In general, using              hardware region fill will have better performance.              However, hardware fills can occassionally have              unpredictable results.  In this case, you can              have Dataplot perform region fills in software              by specifing SOFTWARE.                       SET SVG STYLE SHEET <INTERNAL/EXTERNAL/NONE>            - specify whether the SVG graphics are generated              using style sheets (EXTERNAL) or not (NONE).  In              general, style sheets are most beneficial when              multiple graphics are being used on a web site.              SVG supports both external style sheets (i.e.,              stored in a separate file) or internal to the              SVG file.  Currently, Dataplot only supports              external style sheets.  The INTERNAL switch is              reserved for possible future implementation.              There is also an EXTERNAL USE and an EXTERNAL              CREATE option.  This is reserved for future use,              but it currently has no effect.          SET SVG STYLE SHEET NAME <file name>            - specify the name of the external file sheet              (up to 80 characters).  The default name is              ""dataplot.css"".          SET SVG FOREGROUND COLOR <color>            - specify the default foreground color when style              sheets are being used.  If a line or text color              does not match this foreground color, then Dataplot              inserts a ""style"" option that overrides the style              sheet value.  Note that the default color is              set independently in the style sheet file.  So              you may need to edit the style sheet as well.              Note:            Each ""page"" is assigned an ID using the "" "" element.     You can add your own translate, scale, and rotate options     to the SVG file to transform the full plot (this is an element     of the ""Scalable"" part of Scalable Vector Graphics).          Note:            Currently, Dataplot generates static plots in SVG format.     SVG supports advanced capabilities such as animation,     gradients, and Javascript scripting.  Support for at least     some of these capabilities may be added in future     implementations.  However, you can edit the SVG file     (either via an ASCII text editor or a graphics editing     program) to add such capabilities.          Default:            None          Synonyms:            None          Device Notes:               HARDWARE TEXT - The SVG device currently supports            hardware characters.  Available fonts may depend on what            fonts you have supported on your system.         COLOR - SVG supports the full range of 88 colors supported            by Dataplot.         HARDWARE FILL - Solid area fills are done in hardware.  You            can override this to generate them in software.         DASH PATTERNS - The following dash patterns are available:                            DASH  - 3 pixels on, 3 pixels off;                 DOT   - 1 pixel on, 1 pixels off;                 DASH2 - 9 pixels on, 5 pixels off                 DASH3 - 5 pixels on, 3 pixels off,                       9 pixel on, 2 pixel off;                  DASH4 - 9 pixels on, 3 pixels off,                       5 pixel on, 9 pixel off,                        3 pixel on, 5 pixel off;                  DASH5 - 5 pixels on, 2 pixels off;                         If you want to modify these patterns, it is recommended            that you use external style sheets.         LINE WIDTH - Thick lines are generated in hardware.         GRAPHICS INPUT - The CROSS-HAIR command is not supported            for this device.         The CHARACTER PIXEL option is supported on this device.         Related Commands:                                                   GD PNG/JPEG                                        = Direct graphical output to a file in PNG/JPEG format.                                                            POSTSCRIPT                                        = Direct graphical output to a Postscript device.                                                            HPGL                                        = Direct graphical output to an HPGL device.                                                            DEVICE                                        = Specify certain actions for the graphics output.                                        Applications:            Web Applications, Graphics Import Into Graphics Editing     Programs          Reference:            ""SVG Essentials"", David Eisenberg, O'Reilly, 2002.           ""Designing SVG Web Graphics"", Andrew Watt, New Riders, 2002.          Implementation Date:            2002/3          Program:            SET IPL1NA PLOT1.SVG       DEVICE 2 SVG      DEVICE 2 PICTURE POINTS 400 300       TITLE SAMPLE SVG PLOT       PLOT X**2 FOR X = 1 1 9       DEVICE 2 CLOSE       SET IPL1NA PLOT2.SVG       DEVICE 2 SVG       DEVICE 2 PICTURE POINTS 500 400       TITLE SECOND SAMPLE SVG PLOT       PLOT X**3 FOR X = 1 1 9       DEVICE 2 CLOSE                                                        Date created: 3/27/2002         Last updated: 4/4/2003         Please email comments on this WWW page to         alan.heckert@nist.gov ."
GX031-88-3550026	Next:   2 64  -2 10  + 1    Up:   Random Number Generators    Previous:   48-bit CRI Linear Congruential                61-bit Prime Modulus Linear Congruential Generator      This algorithm is slower than the generators using a power of two modulus, but produces a random number sequence free of short period patterns in the low order bits. A pattern does occur for this generator, however, and is described in [ 5 ]. The next value for the random state   x [ n ] is determined from the current value  x [ n  - 1] by:             x [ n ] =  a   x [ n  - 1]   ( mod p )     (6)      Where the multiplier,    a  = 437799614237992725, is hardwired into the algorithm and   p  is a Mersenne prime; that is, a prime that is of the form    p  = 2 m  - 1 where  m  is also a prime. For this generator  m  = 61, which is the largest value of m less than 64 for which 2 m  - 1 and  m  are primes.  The multiplier was again chosen to obtain maximal period of the generator,   2 61  -2   2.3  x  10 18 , for this algorithm.  This generator is the same as the default one-stream SPRNG pmlcg generator and was checked to insure that it satisfies the requirements for maximal period. The interface routines for this generator are declared as:  Rng_Type RngP61Seed( Rng_UInt32 i, Rng_UInt32 j );      Rng_Type RngP61Spawn( Rng_Type *x );      int iRngP61( Rng_Type *x );      double dRngP61( Rng_Type *x );      float fRngP61( Rng_Type *x );                                Next:   2 64  -2 10  + 1    Up:   Random Number Generators    Previous:   48-bit CRI Linear Congruential
GX019-81-13588789	"APREPRO Predefined Variables                               A few commonly used variables are predefined in           APREPRO . These are listed below. The default output format is specified          as a C language format string, see your C language documentation for more          information. The default format and comment variables are defined with          a leading underscore in their name so they can be redefined without generating          an error message.                                                              Predefined Variables                                    Name                       Value                       Description                                PI                       3.14159265358979323846                       p                                PI_2                       1.57079632679489661923                       p/2                                SQRT2                       1.41421356237309504880                                                      DEG                       57.2957795130823208768                       180  / p            degrees per radian                                RAD                       0.01745329251994329576                       p/180  radians          per degree                                E                       2.71828182845904523536                       base of natural logarithm                                GAMMA                       0.57721566490153286060                       euler-mascheroni constant 1                                PHI                       1.61803398874989484820                       golden ratio ( +          1)/2                                VERSION                       Varies, string value                       current version of CUBIT                                _ FORMAT                       ""%.10g""                       default output format                                _C_                       ""#""                       default comment character                                                                                   1 The euler-mascheroni constant is defined          as the limit of 1 + 1/2 + ... + 1/s - log(s) as s approaches infinity.                                                              Note that the output format is used to output          both integers and floating point numbers. Therefore, it should use the          %g format descriptor which will use either the decimal (%d), exponential          (%e), or float (%f) format, whichever is shorter, with insignificant zeros          suppressed. The table below illustrates the effect of different format          specifications on the output of the variable  PI  and the value 1.0          . See the documentation of your C compiler for more information. For most          cases, the default value is sufficient.                                                              Effect of Various Output Format          Specifications                                    Format                       PI Output                       1.0 Output                                %.10g                       3.141592654                       1                                %.10e                       3.1415926536e+00                       1.0000000000e+00                                %.10f                       3.1415926536                       1.0000000000                                %.10d                       1413754136                       0000000000                                                                                                            The comment character should be set to the character          that the program which will read the processed file uses as a comment          character. The default value of ""$"" is the comment character used by the          SEACAS codes at Sandia National Laboratories. The  -c  command line          option * automatically changes the value of the comment variable to match          the character specified on the command line."
GX029-87-4684231	"[   source navigation   ]   [   identifier search   ]   [   freetext search   ]   [   file search   ]   [   repository   ]         Software     Cross Reference            . / usatlas / fisyak / root.removed / postscript / src / TSVG.cxx             Version:      [   current   ]           File /home/lxr/source/current//usatlas/fisyak/root.removed/postscript/src/TSVG.cxx     1   // @(#)root/postscript:$Name:  $:$Id: TSVG.cxx,v 1.1.1.5 2003/01/20 18:13:15 fisyak Exp $     2   // Author: Olivier Couet     3       4   /*************************************************************************     5    * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *     6    * All rights reserved.                                                  *     7    *                                                                       *     8    * For the licensing terms see $ROOTSYS/LICENSE.                         *     9    * For the list of contributors see $ROOTSYS/README/CREDITS.             *    10    *************************************************************************/    11     12   //////////////////////////////////////////////////////////////////////////    13   //                                                                      //    14   // TSVG                                                                 //    15   //                                                                      //    16   // Graphics interface to SVG.                                           //    17   //                                                                      //    18   //////////////////////////////////////////////////////////////////////////    19      20  #ifdef  WIN32    21  #pragma  optimize ( """" ,off)   22  #endif   23     24  #include  <stdlib.h>> >   25  #include  <string.h>> >   26  #include  <ctype.h>> >   27     28  #include "" Riostream.h ""   29  #include "" TROOT.h ""   30  #include "" TColor.h ""   31  #include "" TVirtualPad.h ""   32  #include "" TPoints.h ""   33  #include "" TSVG.h ""   34  #include "" TStyle.h ""   35  #include "" TMath.h ""   36     37   ClassImp ( TSVG )   38     39   //______________________________________________________________________________    40   //Begin_Html    41   /*    42   <a href="" http://www.w3.org/Graphics/SVG/Overview.htm8""><b>SVG</b></a>  is a    43   language for describing two-dimensional graphics in XML. <b>SVG</b> allows for    44   three types of graphic objects: vector graphic shapes, images and text.    45   Graphical objects can be grouped, styled, transformed and composed into    46   previously rendered objects. The feature set includes nested transformations,    47   clipping paths, alpha masks, filter effects and template objects. <b>SVG</b>    48   drawings can be interactive and dynamic. Animations can be defined and    49   triggered either declaratively or via scripting.    50   <p>    51   The way to access <b>SVG</b> in <b>ROOT</b> (in my private version only) is the    52   following:    53   <PRE>    54      <A HREF=""html/TSVG.html"">TSVG</A> mysvg(&quot;myfile.svg&quot;)    55      object-&gt;Draw();    56      mysvg.Close();    57   </PRE>    58   The result is the ASCII file <tt>myfile.svg</tt>, it is best viewed with    59   Internet Explorer and you need the    60   <a href="" http://www.adobe.com/svg/viewer/install/main.html"">Adobe  <b>SVG</b>    61   Viewer</a>. To zoom using the Adobe <b>SVG</b> Viewer, position the mouse over    62   the area you want to zoom and click the right button. To define the zoom area,    63   use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.    64   By clicking with the right mouse button on the <b>SVG</b> graphics you will get    65   a pop-up menu giving other ways to interact with the image.    66   <p>    67   <b>SVG</b> files can be used directly in compressed mode to minimize the time    68   transfer over the network. Compressed <b>SVG</b> files should be created using    69   <tt>gzip</tt> on a normal ASCII <b>SVG</b> file and should then be renamed    70   using the file extension <tt>.svgz</tt>.    71   */    72   //End_Html    73      74   //______________________________________________________________________________    75   TSVG :: TSVG () :  TVirtualPS ()   76  {   77      // Default SVG constructor    78      79     fStream = 0;   80     fType   = 0;   81      gVirtualPS  =  this ;   82  }   83     84   //______________________________________________________________________________    85   TSVG :: TSVG ( const   char  * fname ,  Int_t  wtype) :  TVirtualPS ( fname , wtype)   86  {   87      // Initialize the SVG interface    88       //    89       //  fname : SVG file name    90       //  wtype : SVG workstation type. Not used in the SVG driver. But as TSVG    91       //          inherits from TVirtualPS it should be kept. Anyway it is not    92       //          necessary to specify this parameter at creation time because it    93       //          has a default value (which is ignore in the SVG case).    94      95     fStream = 0;   96      Open ( fname , wtype);   97  }   98     99   //______________________________________________________________________________   100   void   TSVG :: Open ( const   char  * fname ,  Int_t  wtype)  101  {  102      // Open a SVG file   103     104      if  (fStream) {  105         Warning ( ""Open"" ,  ""SVG file already open"" );  106         return ;  107     }  108    109     fType =  abs (wtype);  110     SetLineScale( gStyle ->GetLineScalePS());  111      gStyle -> GetPaperSize (fXsize, fYsize);  112      Float_t  xrange, yrange;  113      if  ( gPad ) {  114         Double_t  ww =  gPad -> GetWw ();  115         Double_t  wh =  gPad -> GetWh ();  116        ww *=  gPad ->GetWNDC();  117        wh *=  gPad ->GetHNDC();  118         Double_t   ratio  = wh/ww;  119        xrange = fXsize;  120        yrange = fXsize* ratio ;  121         if  (yrange > fYsize) { yrange = fYsize; xrange = yrange/ ratio ;}  122        fXsize = xrange; fYsize = yrange;  123     }  124    125      // Open OS file   126      fStream   =  new   ofstream ( fname , ios :: out );  127      if  (fStream == 0) {  128         printf ( ""ERROR in TSVG::Open: Cannot open file:%s\n"" , fname );  129         return ;  130     }  131    132      gVirtualPS  =  this ;  133    134      for  ( Int_t  i=0;i<512;i++) fBuffer[i] =  ' ' ;  135    136     fBoundingBox =  kFALSE ;  137    138     fRange       =  kFALSE ;  139    140      // Set a default range   141       Range (fXsize, fYsize);  142    143      NewPage ();  144  }  145    146   //______________________________________________________________________________   147   TSVG :: ~TSVG ()  148  {  149      // Default SVG destructor   150     151      Close ();  152  }  153    154   //______________________________________________________________________________   155   void   TSVG :: Close ( Option_t  *)  156  {  157      // Close a SVG file   158       if  (! gVirtualPS )  return ;  159      if  (!fStream)  return ;  160      if  ( gPad )  gPad -> Update ();  161      PrintStr ( ""</svg>@"" );  162    163      // Close file stream   164       if  (fStream) { fStream-> close ();  delete  fStream; fStream = 0;}  165    166      gVirtualPS  = 0;  167  }  168    169   //______________________________________________________________________________   170   void   TSVG ::On()  171  {  172      // Activate an already open SVG file   173     174      // fType is used to know if the SVG file is open. Unlike TPostScript, TSVG   175       // has no ""workstation type"". In fact there is only one SVG type.   176     177      if  (!fType) {  178         Error ( ""On"" ,  ""no SVG file open"" );  179         Off ();  180         return ;  181     }  182      gVirtualPS  =  this ;  183  }  184    185   //______________________________________________________________________________   186   void   TSVG :: Off ()  187  {  188      // Deactivate an already open SVG file   189     190      gVirtualPS  = 0;  191  }  192    193   //______________________________________________________________________________   194   void   TSVG :: DrawBox ( Double_t  x1,  Double_t  y1,  Double_t  x2,  Double_t   y2)  195  {  196      // Draw a Box   197     198      static   Double_t  x[4], y[4];  199      Int_t   ix1  =  XtoSVG (x1);  200      Int_t   ix2  =  XtoSVG (x2);  201      Int_t   iy1  =  YtoSVG (y1);  202      Int_t   iy2  =  YtoSVG (y2);  203      Int_t  fillis = fFillStyle/1000;  204      Int_t  fillsi = fFillStyle%1000;  205    206      if  (fillis == 3 || fillis == 2) {  207         if  (fillsi > 99) {  208           x[0] = x1;   y[0] = y1;  209           x[1] = x2;   y[1] = y1;  210           x[2] = x2;   y[2] = y2;  211           x[3] = x1;   y[3] = y2;  212            return ;  213        }  214         if  (fillsi > 0 && fillsi < 26) {  215           x[0] = x1;   y[0] = y1;  216           x[1] = x2;   y[1] = y1;  217           x[2] = x2;   y[2] = y2;  218           x[3] = x1;   y[3] = y2;  219            DrawPS (-4, &x[0], &y[0]);  220        }  221         if  (fillsi == -3) {  222            PrintFast (9, ""<rect x=\"""" );  223            WriteInteger ( ix1 , 0);  224            PrintFast (5, ""\"" y=\"""" );  225            WriteInteger ( iy2 , 0);  226            PrintFast (9, ""\"" width=\"""" );  227            WriteInteger ( ix2 - ix1 , 0);  228            PrintFast (10, ""\"" height=\"""" );  229            WriteInteger ( iy1 - iy2 , 0);  230            PrintFast (7, ""\"" fill="" );  231            SetColor (5);  232            PrintFast (2, ""/>"" );  233        }  234     }  235      if  (fillis == 1) {  236         PrintFast (9, ""<rect x=\"""" );  237         WriteInteger ( ix1 , 0);  238         PrintFast (5, ""\"" y=\"""" );  239         WriteInteger ( iy2 , 0);  240         PrintFast (9, ""\"" width=\"""" );  241         WriteInteger ( ix2 - ix1 , 0);  242         PrintFast (10, ""\"" height=\"""" );  243         WriteInteger ( iy1 - iy2 , 0);  244         PrintFast (7, ""\"" fill="" );  245         SetColor (fFillColor);  246         PrintFast (2, ""/>"" );  247     }  248      if  (fillis == 0) {  249         PrintFast (9, ""<rect x=\"""" );  250         WriteInteger ( ix1 , 0);  251         PrintFast (5, ""\"" y=\"""" );  252         WriteInteger ( iy2 , 0);  253         PrintFast (9, ""\"" width=\"""" );  254         WriteInteger ( ix2 - ix1 , 0);  255         PrintFast (10, ""\"" height=\"""" );  256         WriteInteger ( iy1 - iy2 , 0);  257         PrintFast (21, ""\"" fill=\""none\"" stroke="" );  258         SetColor (fLineColor);  259         PrintFast (2, ""/>"" );  260     }  261  }  262    263   //______________________________________________________________________________   264   void   TSVG :: DrawFrame ( Double_t  xl,  Double_t  yl,  Double_t  xt,  Double_t   yt,  265                               Int_t   mode ,  Int_t   border ,  Int_t  dark,  Int_t  light)  266  {  267      // Draw a Frame around a box   268       //   269       // mode = -1  the box looks as it is behind the screen   270       // mode =  1  the box looks as it is in front of the screen   271       // border is the border size in already pre-computed SVG units dark is the   272       // color for the dark part of the frame light is the color for the light   273       // part of the frame   274     275      static   Int_t  xps[7], yps[7];  276      Int_t  i, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  277    278      //- Draw top&left part of the box   279     280     xps[0] =  XtoSVG (xl);          yps[0] =  YtoSVG (yl);  281     xps[1] = xps[0] +  border ;     yps[1] = yps[0] -  border ;  282     xps[2] = xps[1];              yps[2] =  YtoSVG (yt) +  border ;  283     xps[3] =  XtoSVG (xt) -  border ; yps[3] = yps[2];  284     xps[4] =  XtoSVG (xt);          yps[4] =  YtoSVG (yt);  285     xps[5] = xps[0];              yps[5] = yps[4];  286     xps[6] = xps[0];              yps[6] = yps[0];  287    288     ixd0 = xps[0];  289     iyd0 = yps[0];  290      PrintFast (10, ""<path d=\""M"" );  291      WriteInteger (ixd0, 0);  292      PrintFast (1, "","" );  293      WriteInteger (iyd0, 0);  294    295      idx  = 0;  296     idy = 0;  297      for  (i=1; i<7; i++) {  298        ixdi = xps[i];  299        iydi = yps[i];  300        ix   = ixdi - ixd0;  301        iy   = iydi - iyd0;  302        ixd0 = ixdi;  303        iyd0 = iydi;  304         if ( ix && iy) {  305            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  306            if ( idy ) {  MovePS (0,idy); idy = 0; }  307            MovePS (ix,iy);  308            continue ;  309        }  310         if  ( ix ) {  311            if ( idy )  {  MovePS (0,idy); idy = 0; }  312            if ( ! idx  ) {  idx  = ix;  continue ;}  313            if ( ix* idx  > 0 ) {  314               idx  += ix;  315           }  else  {  316               MovePS ( idx ,0);  317               idx   = ix;  318           }  319            continue ;  320        }  321         if ( iy ) {  322            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  323            if ( !idy) { idy = iy;  continue ;}  324            if ( iy*idy > 0 ) {  325              idy += iy;  326           }  else  {  327               MovePS (0,idy);  328              idy  = iy;  329           }  330        }  331     }  332      if (  idx  )  MovePS ( idx ,0);  333      if ( idy )  MovePS (0,idy);  334      PrintFast (8, ""z\"" fill="" );  335      if  ( mode  == -1) {  336         SetColor (dark);  337     }  else  {  338         SetColor (light);  339     }  340      PrintFast (2, ""/>"" );  341    342      //- Draw bottom&right part of the box   343      xps[0] =  XtoSVG (xl);          yps[0] =  YtoSVG (yl);  344     xps[1] = xps[0] +  border ;     yps[1] = yps[0] -  border ;  345     xps[2] =  XtoSVG (xt) -  border ; yps[2] = yps[1];  346     xps[3] = xps[2];              yps[3] =  YtoSVG (yt) +  border ;  347     xps[4] =  XtoSVG (xt);          yps[4] =  YtoSVG (yt);  348     xps[5] = xps[4];              yps[5] = yps[0];  349     xps[6] = xps[0];              yps[6] = yps[0];  350    351     ixd0 = xps[0];  352     iyd0 = yps[0];  353      PrintFast (10, ""<path d=\""M"" );  354      WriteInteger (ixd0, 0);  355      PrintFast (1, "","" );  356      WriteInteger (iyd0, 0);  357    358      idx  = 0;  359     idy = 0;  360      for  (i=1;i<7;i++) {  361        ixdi = xps[i];  362        iydi = yps[i];  363        ix   = ixdi - ixd0;  364        iy   = iydi - iyd0;  365        ixd0 = ixdi;  366        iyd0 = iydi;  367         if ( ix && iy) {  368            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  369            if ( idy ) {  MovePS (0,idy); idy = 0; }  370            MovePS (ix,iy);  371            continue ;  372        }  373         if  ( ix ) {  374            if ( idy )  {  MovePS (0,idy); idy = 0; }  375            if ( ! idx  ) {  idx  = ix;  continue ;}  376            if ( ix* idx  > 0 ) {  377               idx  += ix;  378           }  else  {  379               MovePS ( idx ,0);  380               idx   = ix;  381           }  382            continue ;  383        }  384         if ( iy ) {  385            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  386            if ( !idy) { idy = iy;  continue ;}  387            if ( iy*idy > 0 ) {  388              idy += iy;  389           }  else  {  390               MovePS (0,idy);  391              idy  = iy;  392           }  393        }  394     }  395      if (  idx  )  MovePS ( idx ,0);  396      if ( idy )  MovePS (0,idy);  397      PrintFast (8, ""z\"" fill="" );  398      if  ( mode  == -1) {  399         SetColor (light);  400     }  else  {  401         SetColor (dark);  402     }  403      PrintFast (2, ""/>"" );  404  }  405    406   //______________________________________________________________________________   407   void   TSVG :: DrawPolyLine ( Int_t  nn,  TPoints  *xy)  408  {  409      // Draw a PolyLine   410       //   411       //  Draw a polyline through  the points  xy.   412       //  If NN=1 moves only to point x,y.   413       //  If NN=0 the x,y are  written  in the SVG        file   414       //     according to the current transformation.   415       //  If NN>0 the line is clipped as a line.   416       //  If NN<0 the line is clipped as a fill area.   417     418      Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  419    420      if  (nn > 0) {  421        n = nn;  422   ///     SetLineStyle(fLineStyle);   423   ///     SetLineWidth(fLineWidth);   424   ///     SetColor(Int_t(fLineColor));   425      }  else  {  426        n = -nn;  427   ///     SetLineStyle(1);   428   ///     SetLineWidth(1);   429   ///     SetColor(Int_t(fLineColor));   430      }  431    432     ixd0 =  XtoSVG (xy[0]. GetX ());  433     iyd0 =  YtoSVG (xy[0]. GetY ());  434   ///  WriteInteger(ixd0);   435   ///  WriteInteger(iyd0);   436       if ( n <= 1) {  437         if ( n == 0)  return ;  438   ///     PrintFast(2,"" m"");   439          return ;  440     }  441    442      PrintFast (2, "" m"" );  443      idx  = 0;  444     idy = 0;  445      for  ( Int_t  i=1;i<n;i++) {  446        ixdi =  XtoSVG (xy[i]. GetX ());  447        iydi =  YtoSVG (xy[i]. GetY ());  448        ix   = ixdi - ixd0;  449        iy   = iydi - iyd0;  450        ixd0 = ixdi;  451        iyd0 = iydi;  452         if ( ix && iy) {  453            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  454            if ( idy ) {  MovePS (0,idy); idy = 0; }  455            MovePS (ix,iy);  456            continue ;  457        }  458         if  ( ix ) {  459            if ( idy )  {  MovePS (0,idy); idy = 0; }  460            if ( ! idx  ) {  idx  = ix;  continue ;}  461            if ( ix* idx  > 0 ) {  462               idx  += ix;  463           }  else  {  464               MovePS ( idx ,0);  465               idx   = ix;  466           }  467            continue ;  468        }  469         if ( iy ) {  470            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  471            if ( !idy) { idy = iy;  continue ;}  472            if ( iy*idy > 0 ) {  473              idy += iy;  474           }  else  {  475               MovePS (0,idy);  476              idy  = iy;  477           }  478        }  479     }  480      if (  idx  )  MovePS ( idx ,0);  481      if ( idy )  MovePS (0,idy);  482    483      if  (nn > 0 ) {  484   ///     if (xy[0].GetX() == xy[n-1].GetX() && xy[0].GetY() == xy[n-1].GetY()) PrintFast(3,"" cl"");   485   ///     PrintFast(2,"" s"");   486      }  else  {  487   ///     PrintFast(2,"" f"");   488      }  489  }  490    491   //______________________________________________________________________________   492   void   TSVG :: DrawPolyLineNDC ( Int_t  nn,  TPoints  *xy)  493  {  494      // Draw a PolyLine in NDC space   495       //   496       //  Draw a polyline through  the points  xy.   497       //  If NN=1 moves only to point x,y.   498       //  If NN=0 the x,y are  written  in the SVG        file   499       //     according to the current transformation.   500       //  If NN>0 the line is clipped as a line.   501       //  If NN<0 the line is clipped as a fill area.   502     503      Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  504    505      if  (nn > 0) {  506        n = nn;  507   ///     SetLineStyle(fLineStyle);   508   ///     SetLineWidth(fLineWidth);   509   ///     SetColor(Int_t(fLineColor));   510      }  else  {  511        n = -nn;  512   ///     SetLineStyle(1);   513   ///     SetLineWidth(1);   514   ///     SetColor(Int_t(fLineColor));   515      }  516    517     ixd0 =  UtoSVG (xy[0]. GetX ());  518     iyd0 =  VtoSVG (xy[0]. GetY ());  519   ///  WriteInteger(ixd0);   520   ///  WriteInteger(iyd0);   521       if ( n <= 1) {  522         if ( n == 0)  return ;  523   ///     PrintFast(2,"" m"");   524          return ;  525     }  526    527   ///  PrintFast(2,"" m"");   528       idx  = 0;  529     idy = 0;  530      for  ( Int_t  i=1;i<n;i++) {  531        ixdi =  UtoSVG (xy[i]. GetX ());  532        iydi =  VtoSVG (xy[i]. GetY ());  533        ix   = ixdi - ixd0;  534        iy   = iydi - iyd0;  535        ixd0 = ixdi;  536        iyd0 = iydi;  537         if ( ix && iy) {  538            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  539            if ( idy ) {  MovePS (0,idy); idy = 0; }  540            MovePS (ix,iy);  541            continue ;  542        }  543         if  ( ix ) {  544            if ( idy )  {  MovePS (0,idy); idy = 0; }  545            if ( ! idx  ) {  idx  = ix;  continue ;}  546            if ( ix* idx  > 0 ) {  547               idx  += ix;  548           }  else  {  549               MovePS ( idx ,0);  550               idx   = ix;  551           }  552            continue ;  553        }  554         if ( iy ) {  555            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  556            if ( !idy) { idy = iy;  continue ;}  557            if ( iy*idy > 0 ) {  558              idy += iy;  559           }  else  {  560               MovePS (0,idy);  561              idy  = iy;  562           }  563        }  564     }  565      if (  idx  )  MovePS ( idx ,0);  566      if ( idy )  MovePS (0,idy);  567    568      if  (nn > 0 ) {  569         if  (xy[0]. GetX () == xy[n-1]. GetX () && xy[0]. GetY () == xy[n-1]. GetY ())  PrintFast (3, "" cl"" );  570   ///     PrintFast(2,"" s"");   571      }  else  {  572   ///     PrintFast(2,"" f"");   573      }  574  }  575    576   //______________________________________________________________________________   577   void   TSVG :: DrawPS ( Int_t  nn,  Double_t  *xw,  Double_t  *yw)  578  {  579      // This function defines a path with xw and yw and draw it according the   580       // value of nn:   581       //   582       //  If nn>0 a line is drawn.   583       //  If nn<0 a closed polygon is drawn.   584     585   ///   static Float_t dyhatch[24] = {.0075,.0075,.0075,.0075,.0075,.0075,.0075,.0075,   586   ///                                 .01  ,.01  ,.01  ,.01  ,.01  ,.01  ,.01  ,.01  ,   587   ///                                 .015 ,.015 ,.015 ,.015 ,.015 ,.015 ,.015 ,.015};   588   ///   static Float_t anglehatch[24] = {180, 90,135, 45,150, 30,120, 60,   589   ///                                    180, 90,135, 45,150, 30,120, 60,   590   ///                                    180, 90,135, 45,150, 30,120, 60};   591       Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy, fais, fasi;  592     fais = fasi = 0;  593    594      if  (nn > 0) {  595        n = nn;  596     }  else  {  597        n = -nn;  598        fais = fFillStyle/1000;  599        fasi = fFillStyle%1000;  600         if  (fais == 3 || fais == 2) {  601            if  (fasi > 100 && fasi <125) {  602   ///        DrawHatch(dyhatch[fasi-101],anglehatch[fasi-101], n, xw, yw);   603                return ;  604           }  605            if  (fasi > 0 && fasi < 26) {  606   ///        SetFillPatterns(fasi, Int_t(fFillColor));   607            }  608        }  609     }  610    611       if ( n <= 1) {  612          Error ( ""DrawPS"" ,  ""Two points are needed"" );  613          return ;  614      }  615    616      ixd0 =  XtoSVG (xw[0]);  617      iyd0 =  YtoSVG (yw[0]);  618    619       PrintFast (10, ""<path d=\""M"" );  620       WriteInteger (ixd0, 0);  621       PrintFast (1, "","" );  622       WriteInteger (iyd0, 0);  623    624       idx  = idy = 0;  625       for  ( Int_t  i=1;i<n;i++) {  626         ixdi =  XtoSVG (xw[i]);  627         iydi =  YtoSVG (yw[i]);  628         ix   = ixdi - ixd0;  629         iy   = iydi - iyd0;  630         ixd0 = ixdi;  631         iyd0 = iydi;  632          if ( ix && iy) {  633             if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  634             if ( idy ) {  MovePS (0,idy); idy = 0; }  635             MovePS (ix,iy);  636         }  else   if  ( ix ) {  637             if ( idy )  {  MovePS (0,idy); idy = 0;}  638             if ( ! idx  ) {  idx  = ix;}  639             else   if (  TMath :: Sign (ix, idx ) == ix )        idx  += ix;  640             else  {  MovePS ( idx ,0);   idx   = ix;}  641         }  else   if ( iy ) {  642             if (  idx  ) {  MovePS ( idx ,0);  idx  = 0;}  643             if ( !idy) { idy = iy;}  644             else   if (  TMath :: Sign (iy,idy) == iy)         idy += iy;  645             else  {  MovePS (0,idy);    idy  = iy;}  646         }  647      }  648       if  ( idx )  MovePS ( idx ,0);  649       if  (idy)  MovePS (0,idy);  650    651       if  (nn > 0 ) {  652          if  (xw[0] == xw[n-1] && yw[0] == yw[n-1])  PrintFast (1, ""z"" );  653          PrintFast (21, ""\"" fill=\""none\"" stroke="" );  654          SetColor (fLineColor);  655          if (fLineWidth > 1.) {  656             PrintFast (15, "" stroke-width=\"""" );  657             WriteInteger ( Int_t (fLineWidth), 0);  658             PrintFast (1, ""\"""" );  659         }  660          if  (fLineStyle == 2) {  661             PrintFast (23, "" stroke-dasharray=\""3,3\"""" );  662         }  else   if  (fLineStyle == 3) {  663             PrintFast (23, "" stroke-dasharray=\""1,4\"""" );  664         }  else   if  (fLineStyle == 4) {  665             PrintFast (27, "" stroke-dasharray=\""3,4,1,4\"""" );  666         }  667          PrintFast (2, ""/>"" );  668      }  else  {  669          PrintFast (8, ""z\"" fill="" );  670          if  (fais == 0) {  671             PrintFast (14, ""\""none\"" stroke="" );  672             SetColor (fFillColor);  673   ///      } else if (fais == 3 || fais == 2) {   674   ///        if (fasi > 0 && fasi < 26) {   675   ///           Put SVG patterns here   676          }  else  {  677             SetColor (fFillColor);  678         }  679          PrintFast (2, ""/>"" );  680      }  681  }  682    683   //______________________________________________________________________________   684   void   TSVG :: Initialize ()  685  {  686      // Initialize the SVG file. The main task of the function is to ouput the   687       // SVG header file which consist in <title>, <desc> and <defs>. The   688       // HeaderPS provided by the user program is written in the <defs> part.   689     690      // Title   691       PrintStr ( ""<title>@"" );  692      PrintStr ( GetName ());  693      PrintStr ( ""@"" );  694      PrintStr ( ""</title>@"" );  695    696      // Description   697       PrintStr ( ""<desc>@"" );  698      PrintFast (22, ""Creator: ROOT Version "" );  699      PrintStr ( gROOT ->GetVersion());  700      PrintStr ( ""@"" );  701      PrintFast (14, ""CreationDate: "" );  702      TDatime  t;  703      PrintStr (t. AsString ());  704      //Check a special header is defined in the current style   705       Int_t  nh =  strlen ( gStyle ->GetHeaderPS());  706      if  (nh) {  707         PrintFast (nh, gStyle ->GetHeaderPS());  708     }  709      PrintStr ( ""</desc>@"" );  710    711      // Definitions   712       PrintStr ( ""<defs>@"" );  713      PrintStr ( ""</defs>@"" );  714    715  }  716    717   //______________________________________________________________________________   718   void   TSVG :: MovePS ( Int_t  ix,  Int_t  iy)  719  {  720      // Move to a new position (ix, iy). The move is done in relative coordinates   721       // which allows to have short numbers which decrease the size of the file.   722       // This function use the full power of the SVG's paths by using the   723       // horizontal and vertical move whenever it is possible.   724     725      if  (ix != 0 && iy != 0)  {  726         PrintFast (1, ""l"" );  727         WriteInteger (ix, 0);  728         PrintFast (1, "","" );  729         WriteInteger (iy, 0);  730     }  else   if  (ix != 0)  {  731         PrintFast (1, ""h"" );  732         WriteInteger (ix, 0);  733     }  else   if  (iy != 0)  {  734         PrintFast (1, ""v"" );  735         WriteInteger (iy, 0);  736     }  737  }  738    739   //______________________________________________________________________________   740   void   TSVG :: NewPage ()  741  {  742      // Start the SVG page. This function initialize the pad conversion   743       // coefficients and ouput the <svg> directive which is close later in the   744       // the function Close.   745     746      // Compute pad conversion coefficients   747       if  ( gPad ) {  748         Double_t  ww   =  gPad -> GetWw ();  749         Double_t  wh   =  gPad -> GetWh ();  750        fYsize        = fXsize*wh/ww;  751     }  else  {  752        fYsize = 27;  753     }  754    755      // <svg> directive. It defines the viewBox.   756       if (!fBoundingBox) {  757         PrintStr ( ""@<svg viewBox=\""0 0"" );  758         WriteInteger (CMtoSVG(fXsize));  759        fYsizeSVG = CMtoSVG(fYsize);  760         WriteInteger (fYsizeSVG);  761         PrintStr ( ""\"" xmlns=\""http://www.w3.org/2000/svg\"">"" );  762         PrintStr ( ""@"" );  763         Initialize ();  764        fBoundingBox  =  kTRUE ;  765     }  766  }  767    768   //______________________________________________________________________________   769   void   TSVG :: Range ( Float_t   xsize ,  Float_t   ysize )  770  {  771      // Set the range for the paper in centimetres   772     773      Float_t  xps, yps, xncm, yncm, dxwn, dywn, xwkwn, ywkwn, xymax;  774    775     fXsize =  xsize ;  776     fYsize =  ysize ;  777    778     xps =  xsize ;  779     yps =  ysize ;  780    781      if (  xsize  <= xps &&  ysize  < yps) {  782         if  ( xps > yps ) xymax = xps;  783         else              xymax = yps;  784        xncm  =  xsize /xymax;  785        yncm  =  ysize /xymax;  786        dxwn  = ((xps/xymax)-xncm)/2;  787        dywn  = ((yps/xymax)-yncm)/2;  788     }  else  {  789         if  (xps/yps < 1) xwkwn = xps/yps;  790         else              xwkwn = 1;  791         if  (yps/xps < 1) ywkwn = yps/xps;  792         else              ywkwn = 1;  793    794         if  ( xsize  <  ysize )  {  795           xncm = ywkwn* xsize / ysize ;  796           yncm = ywkwn;  797           dxwn = (xwkwn-xncm)/2;  798           dywn = 0;  799            if ( dxwn < 0) {  800              xncm = xwkwn;  801              dxwn = 0;  802              yncm = xwkwn* ysize / xsize ;  803              dywn = (ywkwn-yncm)/2;  804           }  805        }  else  {  806           xncm = xwkwn;  807           yncm = xwkwn* ysize / xsize ;  808           dxwn = 0;  809           dywn = (ywkwn-yncm)/2;  810            if ( dywn < 0) {  811              yncm = ywkwn;  812              dywn = 0;  813              xncm = ywkwn* xsize / ysize ;  814              dxwn = (xwkwn-xncm)/2;  815           }  816        }  817     }  818     fRange =  kTRUE ;  819  }  820    821   //______________________________________________________________________________   822   void   TSVG :: SetFillColor (  Color_t   cindex  )  823  {  824      // Set color index for fill areas   825     826     fFillColor =  cindex ;  827      if  ( gStyle ->GetFillColor() <= 0)  cindex  = 0;  828  }  829    830   //______________________________________________________________________________   831   void   TSVG :: SetLineColor (  Color_t   cindex  )  832  {  833      // Set color index for lines   834     835     fLineColor =  cindex ;  836  }  837    838   //______________________________________________________________________________   839   void   TSVG :: SetLineStyle ( Style_t  linestyle)  840  {  841      // Change the line style   842       //   843       // linestyle = 2 dashed   844       //           = 3 dotted   845       //           = 4 dash-dotted   846       //           = else solid (1 in is used most of the time)   847     848     fLineStyle = linestyle;  849  }  850    851   //______________________________________________________________________________   852   void   TSVG :: SetLineWidth ( Width_t  linewidth)  853  {  854      // Set the lines width.   855     856     fLineWidth = linewidth;  857  }  858    859   //______________________________________________________________________________   860   void   TSVG :: SetMarkerColor (  Color_t   cindex  )  861  {  862      // Set color index for markers.   863     864     fMarkerColor =  cindex ;  865  }  866    867   //______________________________________________________________________________   868   void   TSVG :: SetColor ( Int_t   color )  869  {  870      // Set color with its color index   871     872      if  ( color  < 0)  color  = 0;  873      TColor  * col  =  gROOT -> GetColor ( color );  874      if  ( col ) {  875         SetColor ( col -> GetRed (),  col -> GetGreen (),  col -> GetBlue ());  876     }  else  {  877         SetColor (1., 1., 1.);  878     }  879  }  880    881   //______________________________________________________________________________   882   void   TSVG :: SetColor ( Float_t  r,  Float_t  g,  Float_t  b)  883  {  884      // Set color with its R G B components   885       //   886       //  r: % of red in [0,1]   887       //  g: % of green in [0,1]   888       //  b: % of blue in [0,1]   889     890      if  (r <= 0. && g <= 0. && b <= 0. ) {  891         PrintFast (7, ""\""black\"""" );  892     }  else   if  (r >= 1. && g >= 1. && b >= 1. ) {  893         PrintFast (7, ""\""white\"""" );  894     }  else  {  895         char   str [12];  896        sprintf( str , ""\""#%2.2x%2.2x%2.2x\"""" , Int_t (255.*r)  897                                          , Int_t (255.*g)  898                                          , Int_t (255.*b));  899         PrintStr ( str );  900     }  901  }  902    903   //______________________________________________________________________________   904   void   TSVG :: SetTextColor (  Color_t   cindex  )  905  {  906      // Set color index for text   907     908     fTextColor =  cindex ;  909  }  910    911   //______________________________________________________________________________   912   void   TSVG :: Text ( Double_t  xx,  Double_t  yy,  const   char  *chars)  913  {  914      // Draw text   915       //   916       // xx: x position of the text   917       // yy: y position of the text   918       // chars: text to be drawn   919     920      static   const   char  *fontFamily[] = {  921      ""Times"" ,  ""Times"" ,  ""Times"" ,  922      ""Helvetica"" ,  ""Helvetica"" ,  ""Helvetica"" ,  ""Helvetica"" ,  923      ""Courier"" ,  ""Courier"" ,  ""Courier"" ,  ""Courier"" ,  924      ""Symbol"" , ""Times"" ,  ""ZapfDingbats"" };  925    926      static   const   char  *fontWeight[] = {  927      ""normal"" ,  ""bold"" ,  ""bold"" ,  928      ""normal"" ,  ""normal"" ,  ""bold"" ,  ""bold"" ,  929      ""normal"" ,  ""normal"" ,  ""bold"" ,  ""bold"" ,  930      ""normal"" , ""normal"" ,  ""normal"" };  931    932      static   const   char  *fontStyle[] = {  933      ""italic"" ,  ""normal"" ,  ""italic"" ,  934      ""normal"" ,  ""oblique"" ,  ""normal"" ,  ""oblique"" ,  935      ""normal"" ,  ""oblique"" ,  ""normal"" ,  ""oblique"" ,  936      ""normal"" , ""normal"" ,  ""normal"" };  937    938      Int_t  ix    =  XtoSVG (xx);  939      Int_t  iy    =  YtoSVG (yy);  940      Int_t   txalh  = fTextAlign/10;  941      if  ( txalh  <1)  txalh  = 1;  if  ( txalh  > 3)  txalh  = 3;  942      Int_t   txalv  = fTextAlign%10;  943      if  ( txalv  <1)  txalv  = 1;  if  ( txalv  > 3)  txalv  = 3;  944    945      Double_t      wh = ( Double_t ) gPad -> XtoPixel ( gPad -> GetX2 ());  946      Double_t      hh = ( Double_t ) gPad -> YtoPixel ( gPad -> GetY1 ());  947      Float_t   fontrap  = 1.09;  //scale down compared to X11   948       Float_t   ftsize ;  949    950      Int_t   font   =  abs (fTextFont)/10;  951      Int_t  ifont =  font -1;  952      if  ( font  > 42 ||  font  < 1)  font  = 1;  953      if  (wh < hh) {  954         ftsize  = fTextSize*fXsize* gPad ->GetAbsWNDC();  955     }  else  {  956         ftsize  = fTextSize*fYsize* gPad ->GetAbsHNDC();  957     }  958    959      Int_t   fontsize  = CMtoSVG( ftsize / fontrap );  960      if (  fontsize  <= 0)  return ;  961    962      if  ( txalv  == 3) iy = iy+ fontsize ;  963      if  ( txalv  == 2) iy = iy+( fontsize /2);  964    965      if  (fTextAngle != 0.) {  966         PrintFast (21, ""<g transform=\""rotate("" );  967         WriteInteger (- Int_t (fTextAngle), 0);  968         PrintFast (1, "","" );  969         WriteInteger (ix, 0);  970         PrintFast (1, "","" );  971         WriteInteger (iy, 0);  972         PrintFast (3, "")\"">"" );  973     }  974    975      PrintFast (9, ""<text x=\"""" );  976      WriteInteger (ix, 0);  977      PrintFast (5, ""\"" y=\"""" );  978      WriteInteger (iy, 0);  979      PrintFast (1, ""\"""" );  980      if  ( txalh  == 2) {  981         PrintFast (21, "" text-anchor=\""middle\"""" );  982     }  else   if  ( txalh  == 3) {  983         PrintFast (18, "" text-anchor=\""end\"""" );  984     }  985      PrintFast (6, "" fill="" );  986      SetColor ( Int_t (fTextColor));  987      PrintFast (12, "" font-size=\"""" );  988      WriteInteger ( fontsize , 0);  989      PrintFast (15, ""\"" font-family=\"""" );  990      PrintStr (fontFamily[ifont]);  991      if  ( strcmp (fontWeight[ifont], ""normal"" )) {  992         PrintFast (15, ""\"" font-weight=\"""" );  993         PrintStr (fontWeight[ifont]);  994     }  995      if  ( strcmp (fontStyle[ifont], ""normal"" )) {  996         PrintFast (14, ""\"" font-style=\"""" );  997         PrintStr (fontStyle[ifont]);  998     }  999      PrintFast (2, ""\"">"" );  1000      if  ( font  == 12 && chars[0] >=  '\xA3'  && chars[0] <=  '\xF2' ) {  1001         char   str [8];  1002        sprintf( str , ""&#x%2.2x;"" , chars[0] & 255);  1003         PrintStr ( str );  1004     }  else  {  1005         PrintStr (chars);  1006     }  1007      PrintFast (7, ""</text>"" );  1008    1009      if  (fTextAngle != 0.)  PrintFast (4, ""</g>"" );  1010  }  1011    1012   //______________________________________________________________________________   1013   void   TSVG :: TextNDC ( Double_t  u,  Double_t  v,  const   char  *chars)  1014  {  1015      // Write a string of characters in NDC   1016     1017      Double_t  x =  gPad -> GetX1 () + u*( gPad -> GetX2 () -  gPad -> GetX1 ());  1018      Double_t  y =  gPad -> GetY1 () + v*( gPad -> GetY2 () -  gPad -> GetY1 ());  1019      Text (x, y, chars);  1020  }  1021    1022   //______________________________________________________________________________   1023   Int_t   TSVG :: UtoSVG ( Double_t  u)  1024  {  1025      // Convert U from NDC coordinate to SVG   1026     1027      Double_t  cm = fXsize*( gPad ->GetAbsXlowNDC() + u* gPad ->GetAbsWNDC());  1028      return   Int_t (0.5 + 72*cm/2.54);  1029  }  1030    1031   //______________________________________________________________________________   1032   Int_t   TSVG :: VtoSVG ( Double_t  v)  1033  {  1034      // Convert V from NDC coordinate to SVG   1035     1036      Double_t  cm = fYsize*( gPad ->GetAbsYlowNDC() + v* gPad ->GetAbsHNDC());  1037      return   Int_t (0.5 + 72*cm/2.54);  1038  }  1039    1040   //______________________________________________________________________________   1041   Int_t   TSVG :: XtoSVG ( Double_t  x)  1042  {  1043      // Convert X from world coordinate to SVG   1044     1045      Double_t  u = (x -  gPad -> GetX1 ())/( gPad -> GetX2 () -  gPad -> GetX1 ());  1046      return    UtoSVG (u);  1047  }  1048    1049   //______________________________________________________________________________   1050   Int_t   TSVG :: YtoSVG ( Double_t  y)  1051  {  1052      // Convert Y from world coordinate to SVG   1053     1054      Double_t  v = (y -  gPad -> GetY1 ())/( gPad -> GetY2 () -  gPad -> GetY1 ());  1055      return   fYsizeSVG- VtoSVG (v);  1056  }  1057    1058   //______________________________________________________________________________   1059   void   TSVG :: CellArrayBegin ( Int_t ,  Int_t ,  Double_t ,  Double_t ,  Double_t ,  1060                             Double_t )  1061  {  1062      Warning ( ""TSVG::CellArrayBegin"" ,  ""not yet implemented"" );  1063  }  1064    1065   //______________________________________________________________________________   1066   void   TSVG :: CellArrayFill ( Int_t ,  Int_t ,  Int_t )  1067  {  1068      Warning ( ""TSVG::CellArrayFill"" ,  ""not yet implemented"" );  1069  }  1070    1071   //______________________________________________________________________________   1072   void   TSVG :: CellArrayEnd ()  1073  {  1074      Warning ( ""TSVG::CellArrayEnd"" ,  ""not yet implemented"" );  1075  }  1076    1077   //______________________________________________________________________________   1078   void   TSVG :: DrawPolyMarker ( Int_t ,  Float_t  *,  Float_t  *)  1079  {  1080      Warning ( ""TSVG::DrawPolyMarker"" ,  ""not yet implemented"" );  1081  }  1082    1083   //______________________________________________________________________________   1084   void   TSVG :: DrawPolyMarker ( Int_t ,  Double_t  *,  Double_t  *)  1085  {  1086      Warning ( ""TSVG::DrawPolyMarker"" ,  ""not yet implemented"" );  1087  }  1088    1089   //______________________________________________________________________________   1090   void   TSVG :: DrawPS ( Int_t ,  Float_t  *,  Float_t  *)  1091  {  1092      Warning ( ""TSVG::DrawPS"" ,  ""not yet implemented"" );  1093  }  1094              [   source navigation   ]   [   identifier search   ]   [   freetext search   ]   [   file search   ]   [   repository   ]       This page was automatically generated by the   LXR engine . Visit the  LXR main site  for more information.   This version by  Torre Wenaus ."
GX251-66-7974031	"A Tec hnical Journal f or PDA De velop ers  PDA DEVELOPERS Volume 4.5  Sept/Oct 1996 $13.95 US  $14.95 Canada  Newton Internet Enabler (NIE) An easy-to-use client proto c lient The AP I Explained  The HP OmniGO 100 The definitive review A Compression Tool Compression Express Options App  Pilot Conduits Conduits The Definitive Guide  Plus Psion OPL Localization Informed Filler Review And the usual suspects   PDA Solutions Exhibition September 14, 1996  Inland Meeting & Exposition Center  Westmont, IL, 20 minutes from Chicago's O'Har e Airpor t  The PDA Solutions Exhibition is the only event where you can find out how to harness the new, exciting technology of PDAs and hand-held computers to boost your personal productivity and also implement a variety of corporate solutions. Come see the latest mobile assistants from Palm Computing, Psion, SONY, Apple Computer, Hewlett Packard, Motorola, Sharp and more.  Ke ynote Speaker  TM  Jeff Hawkins Vice President and Chief Technologist The Palm Computing Division of US Robotics Designer of the award-winning Palm Pilot and the Graffiti handwriting-recognition software.  Sponsors Psion, General Magic , Palm Computing, ARDIS, Apple , and HP.  Co-sponsors Geoworks, Pen Computing Magazine, In-Touch USA, Wright Strategies, and PDA Direct.  Conference Tracks  Getting the most out of your PDA  Psion, Palm Pilot, OmniGo, Newton, Magic Cap, HP Palmtops. Presented by leading experts in the field, including editors from Pen Computing Magazine.  Corporate solutions using hand-held mobile technologies, presented by key system integrators.  Vertical market applications using hand-held computers  Medical, Utilities, Financial Services, Global Positioning, Agriculture, and more.  Special topics, such as creating your own PDA-readable content, connecting to the Internet with PDAs, wireless Web access, and creating your own specialized applications programs for a PDA.  Cost The PDA Solutions Exhibition exhibits are open to the public at no charge. Registration for the full Solutions conference is $50 until September 8, $65 after that.  Exhibits 10,000 square feet full of PDA manufacturers, software vendors, wireless communications companies, systems integrators, and specialists in harnessing the power of hand-held computers. Come find out why PDAs are the most exciting segment of the computer industry.  Creative Digital Inc. 293 Corbett Avenue, San Francisco, CA 94114-1842 Call (415.621.4252), Fax (415.621.4922), E-mail (info@cdpubs.com), or Surf (http://www.cdpubs.com).   Contents  Regulars PDA News ..................................................... Steve Mann 2 New Technologies, Existing Carriers .... Andy Seybold 5 AT&T Wireless' Internet phone strategy.  Reviews Informed Filler for Newton ............... John Schettino 8 John raves about this high-quality forms product.  Newton User Interface Guidelines ........... Ken Knight 10 A review of one of Apple's first official Newton books.  The OmniGo 100 .......................................... Scott Sbihli 11 A hard-core Newton user tries a new device  and likes it!.  Features Getting Started Multi-Developer Magic Cap Projects ...... Bruce Tong 16 Tips and tricks for keeping your objects organized.  Express Option Modifier .............................. John Blue 19 An IZL program for changing OmniGo express options.  An OmniGo Compression Tool ....... Marcus Groeber 26 Psion OPL Localization .......................... Danile Pfund 17 A few simple steps to creating international Psion apps. Get maximum use out of your OminGo's limited RAM.  NIE Made Easy: The protoInetClient . Ray Rischpater 38 Making NIE-enabled Newton apps the easy way.  The NIE 1.0 API ...................................... John Schettino 41 John describes NIE's seamier side .  Extending Your Desktop With the Pilot .... Stu Slack 42 The definitive conduit-creation guide from the experts.  PDA Developers is copyright and trademarked by  Creative Digital Publishing Inc. 293 Corbet t Avenue 415.621.4252 info@cdpubs.com http://ww  San Francisco, C A 94114-1842  415.621.4922 (fax)  74774.50@compuserve.com w.cdpubs.c om  All rights reserved. All tr ademarks used in this maga zine are for editorial purposes only and to the benefit of the trademark owner, with no intention of infringing on that trademark. Editor and Publisher ............................................... Steve Mann Contributing Editors ..................................... John Sc hettino, ................ Brenda Holloway, Andy Seybold, Ray Rischp ater  PDA De velope rs (ISSN 1088-4149) is published bimonthly for $65 per year ($85 overseas) by Creative Digital Publishing, Inc., 293 Corbett Avenue, San Francisco, CA 94114-1842. Periodicals postage paid at San Francisco, CA. POSTMASTER: Send address changes to PDA De velopers, Creative Digital Publishing Inc., 293 Corbett Ave., San Francisco, CA 94114-1842. P DA DE VELOPER S  4.5  Sept/Oc t 1996  1   Regulars PDA News Steve Mann sem@cdpubs.com  browser that runs on the PocketNet Phone, and specifications for an HTML-like language called HDML for creating custom client applications that are compatible with the b rowser. For more information on Unwired Planet's technology, and their developer tools and services, check out http://www.uplanet.com. For more details on AT&T's announcements, see Andy Seybold's column on page 5.  U.S. Robotics Ships Pilot Development Tools In mid June, the Palm Computing subsidiar y of U.S. Robotics announced the availability of CodeWarrior for Pilot, a Pilot development environment based on Metrowerk's popular CodeWarrior 9.0 IDE. This first release runs only on Macintosh systems. Metrowerks has announced that CodeWarrior will b e available for Windows some time this fall. Priced at $299, CodeWarrior for Pilot does not include the full CodeWarrior suite of tools, but it does include a subscription for five releases of the environment, instead of CodeWarrior's usual three. In addition, Metrowerks is offering a special Pilot bundle, including CodeWarrior for Pilot, a Pilot 5000, and a debugger cable for $399, a savings of almost $300. For more information, contact Metrowerks at http:// www.metrowerks.com or 512.305.0400. Palm is also offering a similarly developer bundle, priced at $499, but it includes the Pilot conduit SDK, which requires Microsoft's Visual C++ 4.0. You can also buy the individual SDKs directly from Palm. Both the client and conduit SDKs are $99. For more information, contact U.S. Robotics at http://www.usr.com, devinfo@palm.com, 800.881.7256, 800.891.6342 ext. 203 (in Canada), or 408.848.5604.  PCS Deployment Gearing Up BellSouth Mobility, a subsidiar y of B ellSouth Corporation, announced on July 18 the deployment of PCS-1900 ser vices in North and South Carolina, and Eastern Tennessee. Using spectrum recently purchased during the FCC airwave auctions last year, BellSouth Mobility's offers three fixed-price monthly plans:  Personal ($26.95), including 45 call minutes, plus $.30 for each additional minute;  Performance ($44.95), including 120 call minutes, plus $.25 for each additional minute; and  Power ($89.95), including 360 cal l minutes, plus $.15 for each additional minute. Each plan includes a free first minute for incoming calls, no roaming charges, no peak/off-peak pricing differentials, voice mail, numeric paging, and call waiting, hold, and forwarding. A variety of lightweight BellSouth and Nokia handsets are available from BellSouth and selected retailers. Prices range from $125 to $200. For more information, contact BellSouth Mobility at 888.DCS.2001. PCS-1900 is a digital voice and data ser vice that is functionally, but not frequency-compatible with the GSM standard used in most parts of the world. It shouldn't be too long before it's possible to buy one handset that is both PCS and GSM compatible, and suitable for using throughout the world (assuming the carriers can build the infrastructure).  Psion Software PLC In July Psion announced the formation of a new corporate entity, Psion Software PLC. This new group's mission is to license its operating system and applications software. They w ill make available 16-bit EPOC< the operating system on their popular Psion 3a, and their upcoming EPOC/32, a port designed for 32-bit RISC processors. In related announcements, partners Advanced RISC Machines (ARM), Digital Semiconductor, and Cirrus Logic announced that EPOC/32 is being ported to ARM's StrongARM SA-110 chips (available from Digital Semiconductor) plus the new generation ARM7100, a socalled ""PDA on a chip."" Cirrus Logic is expected to provide a complete design solution, including an evaluation board, design database, and EPOC SDK. For more information, contact Psion Software PLC at +44.171.208.1800, or 415.373.3224, or Digital Semiconductor at http:// www.digital.com/info/semconductor.  Pac Bell Throw s Its Hat in the Ring Earlier this year, Pa cific Bell Mobile Services said it expects to deploy PCS-1900 services throughout its West Coast territories by early 1997. Their handsets will be built by Nokia and Ericcson and incorporate the GEOS operating system. In July, Phoenix Technologies PICO group announced PicoPAL, a software layer for personal communicators and Smart Phones running the GEOS operating system. Phoenix is a leading supplier of low-level OS components like ROM BIOSs, communications subsystems, and other system-level software products. Expect PicoPAL to be an integral part of the Pac Bell handsets when they become available.  General Magic After keeping quiet for a few months, General Magic burst forth with a deluge of announcements on June 25th. These announcements were designed to reveal the company's Internet, Web, and intranet strategies. They included the following:  General Magic has licensed Microsoft's Internet Explorer, and has signed up as an America Online developer. They expect to bundle an AOL client and IE in the forthcoming commercial release of Magic Cap for Windows, which will be some time in the second half of 1996.  The company announced the immediate availability of SoftModem, software that provides a robust set of data and fax modem functions on general-purpose microprocessors, independent of the operating systems. The 28.8 Kbps version of the software requires 64K RAM and 256K ROM. Licensing inquiries should be directed to Kendall Larsen at 408.774.4474.  Tabriz AgentWare and Tabriz Agent Tools, a deployment and developme nt environment for creating agent-based Internet solutions and services, is now available. Based on TeleScript, Tabriz includes persistence, mobile agent capabilities, built-in security, Java support, standard browser support, and a variety of other capabilities.  C TIA W ireless Apps Panel Finally, CTIA's Wireless Apps conference in Las Vegas (October 7-9, 1996) will feature a Smart Phone Executive Forum, hosted by Geoworks. The Forum w ill include two panel discussions: one on smart phone development architectures, a second on content and service aftermarkets for smart phones. For more information, contact CTIA at 202.785.0081.  AT&T Wireless Internet Phone Not to be outdone by a flurr y of Smart Phone announcements, AT&T Wireless Services in July announced the AT&T PocketNet Phone, an integrated cellular phone and ""wireless Internet appliance."" Costing about $500, and manufactured by PCSI of San Diego, this device uses CDPD services to provide text-only access to Internet services and a base set of business services like two-way messaging, airline and financial informat ion, spor ts scores, lo cal movie listings, and lottery results. In addition, corporate and independent Web developers can program the phone for remote wireless access to int ranets and custom twoway messaging applications using technology created by AT&T equity partner Unwired Planet. The technology includes a server that officiates between the wireless services and the wireline part of the Internet, a  2  P DA De velopers 4.5  Sept/Oct 1996    They announced the commercial availability of Presto!Links and Presto!Mail, Internet e-mail and web browsing solutions for Magic Cap devices. In a follow-up announcement on July 11, General Magic announced that Presto!Mail will be made available to all AT&T PersonaLink subscribers. AT&T intends to discontinue PersonaLink at the end of August.  Company Hewlett-Packard Apple Psion Sharp Sony Motorola Others Total  Percent 34% 18% 14% 12% 6% 4% 12% 100%  Units 175,000 92,500 72,000 61,500 31,000 20,500 61,500 514,000  A Newton-Only Store Down Under A new Newton-only store, Newton World, will b e opening shortly in Sydney, Australia. Newton World will have a retail storefront, but will also provide systems integration and software development services. In addition, they are aggressively putting together a distribution business that specializes in providing a full range of Newton hardware, software, and accessories to Newton resellers throughout Australia. For more information, or to discuss having Newton World handle your products, contact Newton World at +61.2.261.8685, +61.2.261.8689 (fax), or newtonworld@moreinfo.com.au.  Product Announcements F ormLogic 2.0 In mid June, Wright St rategies announced the third-quarter availability of FormLogic 2.0, the next generation of their mobile applications development environment. FormLogic 2.0 has three components: FLBuilder, FLServer, and FLEngine. FLBuilder uses a Visual Basic-like language to let developers create multi-page client applications, including communications links to corporate legacy systems. FLEngine executes the client application on a mobile device. Currently available for the Newton MessagePad, FLEngine will be available for other platforms. FLServer provides:  Transparent, real-time data exchange between mobile devices and enterprise data sources;  A transport-independent design that can be used with dial-up, LAN, TCP/IP, and wireless technologies;  Automatic software distribution capabilities and authenticationbased security; and  A complete administrative package based on a user/group model, including event logging, server configuration, and software component registration. Pricing varies, depending on installation size. Contact Wright Strategies at 619.551.6808 for more information.  A Newton-Only Store in Tokyo In mid July, Enfour, Inc. announced the opening of Japan's first Newton Only store, The Newton Shop, in the Ginza area of Tokyo. Announced at the same time that Apple debuted the Japanese version of the MessagePad 130, the Newton Shop carries a ful l line of Newton hardware and software, accessories, and offers a club credit card from Nippon Shimpan that provides Newton loss and damage insurance. The Newton Shop plans on positioning the Newton as a fashionable lifestyle accessory, not a toy for digital early adopters. The MessagePad 130 will b e bundled with a Japanese display and input solution from Enfour called UniFEP. It includes a Japaneselanguage user manual and a CD-ROM of related Windows and Mac software. In early August, Enfour announced the availability of HWCR, a kanji handwriting recognition package for the MessagePad 130. HWCR has full support for roman, hiragana, katakana, and most of the kanji alphabet. It also supports ink-text for delayed recognition. The Newton Shop can be reached at +81.3.5411.7738, +81.3.5474.8934 (fax), or richard@enfour.com.  AR DI S Wireless E-M ail for MessagePad 130 At MacWorld in Boston, ARDIS announced that River Run Software Group's Mail on the Run! electronic mail software now supports the Newton Messag ePad 130. Mail on the Run! provides access to indust rystandard Microsoft Mail and Lotus cc:Mail systems using the ARDIS wireless data network. NewtonSource, a retailer of Newton solutions, will b e offering a Mobile Mail bundle that includes ARDIS airtime, Mail on the Run!, a MessagePad 130, and a Motorola Personal Messenger 100D Wireless Modem Card. For more information contact NewtonSource at http:// www.newtonsource.com.  PDA Event World Market Strategies is sponsoring The Hand-Held and PDA Expo `96 on December 4-6 in San Mateo, CA. Billed as a ""strategic meeting of the minds designed to bring together customers and vendors to explore the functional asp ects of PDA technology,"" the Expo will focus on vertical markets, functional aspects of PDA technology, and corporate solutions. For more information contact World Market St rategies at 415.252.8008.  GEOS Developer Mailing List A new mailing list has been created specifically for the discussion of issues related to GEOS development. The list is not an official support forum from Geoworks, but it has the advantage of being accessible from any mail system that is capable of exchanging e-mail w ith the Internet. To subscribe to the list, send mail with any subject and the line ""subscribe geos-dev your@address.dom"" in the message body to ""majordomo@lifelike.com"" (on the same server, there is also an OmniGo list under the keyword ""ogo""). Alternatively, you can use ""subscribe geos-dev-digest"", which gives you all the contributions of a day in a single mail.  EnRoute i-net Also at MacWorld Boston, Netstrategy Software of Toronto announced EnRoute i-net, a commercial POP/SMTP Internet mail client for the Newton. In addition to supporting plain text messaging, EnRoute i-ne t also lets Newton users send Newton-native data like text, frames, books, and packages as MIME attachments. This provides seamless Newtonto-Newton and Newton-to-desktop transfers. Other features include scheduled connections, message filtering, group addressing , and a plugin architecture. Using Apple's recently released Newton Internet Enabler, EnRoute inet costs $69.95. Contact NetStrategy at 416.369.1996, 416.361.0451 (fax), or celso@netcom.ca for the closest retail outlet.  PDA Shipment Estimates Recently, as reported by NewtNews on the Internet, the Yankee Group estimated PDA unit shipments in the U.S. at about 514,000 units. They broke out the best sellers with these percentages:  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  3   W ireless Distributed Tr ansaction Systems In early August, ARDIS and Ta ctica Corp. announced Caprera, Tactica software that makes it possible to create distributed wireless transaction systems over the ARDIS data network. Caprera is programmable server software that gives client/server applications wireless access to corporate databases. Caprera is one of the first products to achieve ARDIS Level One certification. Tactica is now an authorized ARDIS Solution provider. The server is targeted at mobile and remote users of LAN-based, transaction-oriented applications such as field sales org anizations that must access customer data residing on a corporate le gacy system. It's appropriate for corporate developers and independent software vendors. For more information, contact Tactica at info@tactica.com or http://www.tactica.com.  IBM Global Uplink Update KABINDA, ZAIRE  In a move IBM offices are hailing as a major step in the company's ongoing worldwide telecommunications revolution, M'wana Ndeti, a member of Zaire's Bantu tribe, used an IBM global uplink network modem yesterday to cr ush a nut. Ndeti, who spent 20 minutes trying to open the nut by hand, easily cracked it open by smashing it repeatedly with the powerful modem. ""I could not crush the nut by myself,"" said the 47-year-old Ndeti, who added the savor y nut to a thick, peanut-based soup minutes later. ""With IBM's help, I was able to break it."" Ndeti discovered the nutbreaking, 28.8 V.34 modem yesterday, when IBM was shooting a commercial in his southwestern Zaire village. During a break in shooting, which shows African v illagers eagerly teleconferencing via computer with Japanese schoolchildren, Ndeti snuck onto the set and took the modem, which he b elieved would serve well as a ""smashing"" utensil. IBM officials were not surprised the longtime computer giant was able to provide Ndeti with practical solutions to his everyday problems. ""Our telecommunicat ions systems offer people all over the world global networking solutions that fit their specific needs,"" said Herbert Ross, IBM's director of marketing. ""Whether you're a nun cloistered in an Italian abbey or an Aborigine in Australia's Great Sandy Desert, IBM has the ideas to get you where you want to go today."" According to Ndeti, of the modem's many powerful features, most impressive was its hard plastic casing , which easily sustained several minutes of vigorous pounding against a large stone. ""I put the nut on a rock, and I hit it with the modem,"" Ndeti said. ""The modem did not break. It is a good modem."" Ndeti was so impressed with the modem that he purchase d a new, state-of- the-art IBM workstation, complete with a PowerPC 601 microprocessor, a quad-speed internal CD-ROM dr ive and three 16-bit Ethernet networking connectors. The tribesman has already made good use of the computer system, fashioning a g azelle trap out of its wires, a boat anchor out of the monitor, and a crude but effective weapon from its mouse. ""This is a good computer,"" said Ndeti, carving up a just-captured gazelle w ith the computer's flat, shar p internal processing device. ""I am using every part of it. I will cook this gazelle on the keyboard."" Hours later, Ndeti capped off his delicious gazelle dinner by smoking the computer's 200-page owner's manual. IBM spokespeople praised Ndeti's choice of computers. ""We are pleased that the Bantu people are turning to IBM for their business needs,"" said company CEO William Allaire. ""From Kansas City to Kinshasa, IBM is bringing the world closer together. Our cutting-edge technology is truly creating a global village."" Thanks for Stu Slack of The Windward Group for this contribution. Or iginal source unknown. Copyright 1996 by that original source. All rights reserved.  Psion Ex ternal Disk Drive In June, Purple Software announced the immediate availability of the Cyclone, a low-cost external disk drive for Psion hand-held computers, including the 3a and the WorkAbout. The Cyclone, which operates on five AA batteries or external power, includes Purple Software's File Manager software. It's advantages include:  It reads and writes standard PC-format floppy disks, making it possible to copy Psion software to floppy disks for backup purposes, and to transpor t data and programs to and from PC-based systems.  It's tightly integrated into the Psion environment. The disk appears as drive ""C:"", making it accessible anywhere you can access a Psion Flash SSD.  It makes it possible for developers to distribute their Psion software on floppy disk instead of Flash SSD, reducing their manufacturing costs. The Cyclone, which is available in almost 20 countries, retails for about $225. For more information, contact Purple Software at +44.171.387.7777 or purplesoft@cix.compulink.co.uk.  Sharp Zaurus Freeware ASM S DK In late July Palmware announced the impending release availability of a free SDK for developing Sharp Zaurus applications. PILI is a PC-based macro assembler that creates binaries for a virtual CPU interpreter. The binar y image is downloaded to the Zaurus for execution. Applications created with PILI cannot be commercially distributed, but they can be made available as freeware. Palmware is working on licensing details for commercial PILI-created applications. The PILI virtual CPU is a 32-bit architecture, with an 8K stack and 256 general-purpose registers. All registers can be used for all operations. Op codes include full arithmetic and bit operators, register manipulations, test, jumps, loops, and stack manipulations. There are macro-assembler library calls for more powerful functions like GUI operations, graphics, and basic input/output operations. For more information contact Palmware at 100014.1025@compuser ve.com.  In a move IBM offices are hailing as a major step in the company's ongoing worldwide telecommunications revolution, M'wana Ndeti, a member of Zaire's Bantu tribe, used an IBM global uplink network modem yesterday to crush a nut. 4 P DA De velopers 4.5  Sept/Oct 1996   New Technologies, Existing Carriers Andrew M. Se ybold  Wireless Internet Is Coming Most of the ar ticles you may read about the ""Wireless Internet"" and CDPD will feature AT&T Wireless as the lead player in this new combination of services. We have taken a different view of these announcements and our observations are as follows. The stor y begins with Unwired Planet, a company that was founded in 1994 as Libris. Its mission was, and is, to deliver an open platform for wireless Internet appliances. Unwired Planet's vision encompasses such devices as cellular phones and two-way pagers. On July 12, AT&T Wireless Services announced its ""Wireless Internet Appliance,"" the AT&T PocketNet Phone, and CDPD as the wireless data network of choice for these new phones. Unwired Planet announced its UP.Link platform and applications written in Unwired Planet's open language, Handheld Device Markup Language (HDML). Unwired Planet's UP.Link Browser is an HDML browser optimized for embedding into cellular phones and pagers. UP.Link is a middleware server that facilitates billing and optimizes communicat ions between wireline and wireless portions of the Internet. UP.Mail is a full-featured two-way paging service for the UP.Link platform.  Not To Be Confused with Web Browsing! Anyone who expects to find anything in this article about World Wide Web graphical image home page surfing with this software over a wireless network can stop reading! It is unfortunate that the word ""browser"" is used at all since ""browser"" has come to imply a graphics capability for the Web. Nor is it correct to discuss ""Web browsing,"" since the Unwired Planet software is about accessing specific information that resides on the Net or on other networks.  access their calendar, notes, and other information stored in the phone for recall. Which phone or system is best? We believe that the answer will depend upon the end-user community--who is using the device and for what pur pose--and it will depend upon users' perceptions of the availability of CDPD coverage as it is today and as it may be in the future. When the PocketNet Phone is w ithin range of a CDPD network, and the server side of the system has been set up to provide the types of information access required, we see it is a fast, efficient way to obtain timely and useful data in small doses. One of the most compelling demonstrations we saw was the ""find it"" capability of the system. We searched for a listing of movies close to our house. (This could just as easily have been food, lodging, gas stations, etc.) After entering our zip code, the system queried the Internet server and responded with a listing of four theaters within a short drive from our home. Scrolling through the listings provided additional information such as which movies were playing and their start times. Our first impression was that scrolling through a twenty-character by four-line screen would be a painful experience. However, when working with this type of information, it is easy to read, and moving forward and backward is a simple process to learn. Receiving e-mail is also easy, although we would not want to receive a document as large as a press release. It works well for short messaging. Composing messages takes some getting used to since each key on the keypad represents mult iple letters of the alphabet--2 is ABC, 3 is DEF, etc.--but it can be done. Since much of the ""intelligence"" of the system resides on servers and not on the phone, it is possible for menu-driven options and other shortcuts to be programmed to make it easier for the user to navigate within the system.  On the Other End The client/server model of compu ting is the key to the system. In this model, most of the intensive computing cycles are performed by the server, permitting the client to be the recipient of the information and not the engine behind obtaining it.  What This Really Is Phones and pagers that have been or will be enabled by Unwired Planet are not ""smart phones"" as we see them. Smart phones have a dedicated processor, an operating system, an onboard Personal Information Manager (PIM) for phone numbers and appointments, and some other bells and whistles. Phones that are enabled with Unwired Planet software become ""Information Terminals"" in the true sense of the term. They are not, at least in this generation, capable of storing large amounts of user data. AT&T does a credible job of explaining the differences between what has come to be known as a ""smart"" phone and what one market research firm has dubbed a ""Wireless Internet Terminal,"" or ""WIT."" Business Week insists on calling it an Internet appliance. AT&T's definition of what it has dubbed the ""PocketNet Phone"" includes the differences already mentioned as well as a price differential. PocketNet Phones w ill sell for around $500, while ""smart phones"" sell for between $1,000 and $2,000. The form factor also differs. Smart phones are bigger and bulkier than PocketNet Phones. The premise of the PocketNet Phone is that it is a voice phone into which a Net level of functionality has been integrated--such functionality being the ability to access computer information in a text format and display it on the same four or five-line by twenty-character screen used when making voice phone calls.  Multimedia/ Images  Bandwidth  It's the Network! Perhaps the best way to understand the difference between the two types of phones is to compare them when in and out of coverage. When both devices are within a coverage area, they can communicate over the network to send and receive data. When the PocketNet Phone is not within CDPD coverage, but is within AMPS coverage, it remains a voice phone but loses any and all ability to provide information. The PocketNet Phone can retain a smal l amount of information for future access, but it is not intended for use as a handheld personal information manager. On the other hand, anywhere a smart phone can communicate via voice, it can send and receive data. Of course, it will not be able to communicate when it is out of coverage, but users will still be able to  Text Figure 1 - AT&T's illustration of bandwidth vs. information format. An Internet-enabled phone is designed for text-based information. P DA DE VELOPER S  Information Format  4.5  Sept/Oc t 1996  5   The Unwired Planet model calls for a server between the c lient and the information ser ver. It is what UP refers to as a middleware server between the wireless Internet appliance and the server to be accessed. This middleware server provides several functions. In order of importance, to the network provider it is a real-time repository for transaction informat ion which becomes the input for any audit or billing system. (UP.Link supports multiple access control models--basic, premium, and pay-per-view.) It is also an interactive directory of available information and services, and it handles protocol translation and data compression functions to optimize the connection between the w ireline and wireless por tions of the network. The middleware server must be programmed to provide phone users with access to standard Internet sites. However, according to Unwired Planet, its Handheld Device Markup Language is a close cousin of HyperText Markup Language (HTML), the Internet programming language. Any programmer fluent in HTML should be able to quickly become fluent in HDML, and an application written in HDML will work over any UP-enabled wireless network and UP.Phones.   Access the latest airline travel information, such as flight arrival and departure times and airport weather and parking advisories, in any city. Automatically dial an airline reservation agent to arrange travel plans.  Obtain the latest ground-travel information, such as mass-transit schedules, fares, routes, for major cities.  C orpor ate Intr anet Applic ations  Use AT&T PocketNet Phone to check product inventory, price lists, order status, and deliver y schedules to close business in a fast, efficient manner while on the road. Select a company form or document and have it faxed to your customer for signature.  Stay up-to-date with company information and reduce your paper burden with quick a ccess to company bulletins or newsletters, directories, company meeting schedules, van pool schedules, and all network-resident corporate information. [Lunch menus on my cellular phone, hooray!]  Send urgent messages or scheduling information to remote workers such as photographers at the scene of breaking news. Reduce their equipment burden by sending the written information they need on a telephone rather than requiring them to carry a PC.  Track a package that's due to arrive from a major package carrier. Find out when it arrived at a central station, and when it will be delivered.  What AT&T Adds to the System AT&T is hoping that its new PocketNet Phones will help increase the acceptance and use of the CDPD network as it is today--an overlay of the analog cellular voice network. The AT&T announcement has sizzle, it has ""sex appeal,"" and anyone who tries one of these phones will initially be captivated by the speed and performance of the demos. AT&T is positioning PocketNet Phones for use with corporate intranets as well as with the Internet--a smart move on AT&T's part since we believe most use rs are initially more concerned about getting to their own corporate information than being able to find the closest movie theater. AT&T's press release provides insight into how it envisions these phones being used. Some of the applications discussed include:  Read and respond to your e-mail when a phone is more convenient than managing a laptop computer.  Access the latest financial news and recent stock quotations, find out the latest information about a particular company, then call a broker to initiate a transaction, all from the same phone, even when you're on the golf course or in a cab or restaurant.  Be on top of the latest weather conditions while on the road. Receive informat ion such as current conditions and travel advisories, temperature highs and lows, and five-day forecasts for most major destinations.  Look up names, phone numbers, and addresses for individuals and businesses wherever you go using a nationwide telephone directory.  Not A Very Compelling Story The above, w ith a minor editorial comment or two, is taken directly from the press material sent out by AT&T. Please remember that these phones display four lines of twenty characters each. It is difficult for us to keep this article upbeat when we read promotional material such as this. We want to keep it up beat because we believe that there is a ne ed for quick, easy access to information such as that provided by the Unwired Planet software system. We do not believe that wireless will have a one-size-fits-all device, just as it will not have a one-size-fits-all network. Unwired Planet has done a superb job of architecting a client/server model that provides information retrieval in devices that are not computer based. Further, UP understands the model of keeping the intensive computing at the server level, and has optimized the wireless data portion of its system for the best possible performance. We also believe that this model, when applied to short messaging in phones, pagers, and even over other two-way wireless networks has a realistic chance of becoming a successful standard. Our concerns lie with the marketing machine dr iven by AT&T's wireless division. Because this machine is a powerful one, with many creative folks driving  Figure 2 - HDML servers will be maintained by AT&T, net work providers, and corporate sites if desired.  6  P DA De velopers 4.5  Sept/Oct 1996   it, we are concerned that the tone of this announcement is one of hype that will set unrealistic expectations for the PocketNet Phone. AT&T's wireless division's similar marketing practices in the past have had a negative effect on the rate of acceptance of any and all forms of wireless data. If positioned properly, the PocketNet Phone should be an attractive option for many existing cell phone use rs. Kendra VanderMeulen, vice president and general manager of AT&T Wireless Ser vices, really hit the mark with her statement in the press release: ""The device makes a surgical strike into the Internet to extract the precise information you want, when you want it. The result: Individuals and organizations will exploit the true essence of the Internet--its core content--w ith speed and ease they've never experienced."" Yet in the balance of the p ress materials, AT&T appears to be positioning these devices to provide access to long documents and other such informat ion that will be painful to read on a four-line by twentycharacter screen. We hope that Ms. VanderMeulen's vision for the products is the one that sticks to the PR and advertising agencies' walls over the next few months.  Questions We do not question the technology. Unwired Planet has done a great job in providing the necessary tools to turn a voice phone into an information terminal. We do question whether the CDPD footprint is sufficiently robust at this stage in its deployme nt to satisfy PocketNet Phone users, and we wonder how long it w ill take before the enabling servers are installed by corporate MIS departments. We have no doubt that over time this technology will be important to certain segments of the market. Early adopters of these phones must have a clear understanding of the limitations they will face in coverage and in the amount of information that is practical to review on a PocketNet Phone. If they truly understand these limitations and sign up for the ser vice, they w ill most likely find it a great experience. Being able to access information on demand, within seconds, is a comp elling stor y.  The real issue is of how much value users will perceive these devices to be when they are out of a CDPD coverage area. Using CDPD for access, the sy stem's response t ime is impressive. If dial-up access over either analog or circuit-switched CDPD is required, we believe that the experience will be too painful for users to endure. While other CDPD service providers will be announcing agreements with Unwired Planet to provide services, at the time of this announcement, AT&T stands alone. AT&T presently covers sixteen areas with its own CDPD network and, with an ag reement from Ameritech, it can offer ser vice in six additional cities. AT&T states that it does not consider a market to be ""commercial"" until it has at least fifty p ercent of its cellular footprint CDPD-ready. As we go to press, AT&T claims to have 100-percent CDPD coverage in ten markets: Austin, Dallas, For t Lauderdale, Miami, Minneapolis, Pittsburg h, Portland, Salt Lake City, San Antonio, and Seattle. The other AT&T cities include Las Vegas, Minneapolis/St. Paul, New York/New Jersey, Oklahoma City, Sacramento, and Tulsa. According to the CDPD Forum's report card of the top fifty MSAs, forty markets offer at least core-level CDPD coverage, with most offering full coverage. A total of 57 of the top 100 markets have coverage. Conversely, 43 of the top 100 markets have no coverage. CDPD se rvice providers include AT&T Wireless, Bell Atlantic/Nynex, GTE, and Ameritech.  The Wireless Internet AT&T appears to be initiating a major push into wireless Internet activity. With the PocketNet Phone, it has a viable tool. If it keeps its marketing hype in check, AT&T should find an audience of users who will take to these phones and find them of value. However, if AT&T promises too much to too many, this new push will result in more unmet user expectations and yet another step back for wireless data. We hope for the good of all concerned (including the ""other"" wireless network providers) that AT&T will use this exciting new technology to grow its business and expand the overall perceived usefulness of wireless data.  1-2-3 Start Tracking  Bug Tracking the Macintosh Way  TestTrack is ready to use right out of the box-- simply install, add a few users, and start tracking. It's that easy.  ""I am managing over 300 bugs in four programs. Thank goodness I found your program!!! The next release will be organized."" Rick Shields, MedImage, Inc.  TestTrack is more than an easy-to-use bug tracking program--it's a powerful quality control tool for busy software developers:  er, Dear PDA Develop  Automate TestTrack automates the tedious and error-prone process of reporting and tracking bugs by hand. It also eliminates the need to create a custom solution using general purpose database tools such as 4DTM or FileMaker ProTM.  Communicate TestTrack links engineers, testers, managers, even tech writers together so no one falls out of the loop. Team members are notified automatically when defects are assigned to them, guaranteeing communication and ensuring efficient work flow.  Stay up to Date TestTrack lets any authorized user look up the current state of any defect at any time.  Analyze TestTrack makes reporting easy-- point, click, print and read. Customize reports to list what you want to see. Check the History Do you want to know who reported the most bugs, how many are still open, or how much time a user spent fixing bugs? This information and more is just a click or two away. How about a bug's history--who found, fixed, and verified it-- all of the details are available.  Filter out Noise Use TestTrack's powerful filtering feature to see only the information of interest to you. For example, create a filter to list only highpriority problems. Create another to list only feature requests for the next release.  you really have killer PDA app, do the next When you're developing oo? tools t time to build your Mac-based more of today's top and the tool more and Discover feature requests, o track their bugs, t developers are using stTrack. information--Te customer o om consultants t all PDA developers--fr Call Today-- for TestTrack is ideal e de velopers. ware and hardwar cial soft commer the Macintosh way! and start tracking To order 81 fax 513-683-17 513-683-6456 call om e-mail sales@seapine.c  Seapine Software, Inc. 1066 Seapine Ct. Maineville, Ohio 45039  For more information info@seapine.com http://www.seapine.com P DA DE VELOPER S  Seapine S S Software 4.5  Sept/Oc t 1996  7   Reviews Informed Filler for Newton John Schettino GTE Laborat ories, Inc. js12@gte.com Rating 3/4 out of 5 Pros Seamless desktop connectivity, powerful interface objects, large feature set. Cons Limited support for e-mail submission of records. Forms and records must be exchanged via direct connection. Price Informed Filler for Newton, including Informed Designer for Macintosh - $195 Informed Filler for Newton, including Informed Designer and Informed Manager for Macintosh - $390 Shana Corporation 9744 - 45th Avenue Edmonton, Alberta, Canada T6E 5C5 403.433.3690, 403.437.4381 (fax)  versions of the same form (for desktop and Newton) that are laid out differently but share fields. In this case you give each form the same identifier. Forms have a master page (things dr awn here appear on every page) and up to 99 body pages. Each page contains one or more objects that suppor t input. Each input object can also contain help text that the user can access while filling in the form. Newton forms can use the following objects: Fields are basic entr y boxes. They include text, number, date, time, telephone, and picture. For textual fields you can specify the font, size, style, and alignment. Check boxes These are standard Newton check boxes. The label is always to the right of the box, and is always displayed in 9-point Geneva. Radio buttons Radio Buttons are implemented for choice lists if the list of choices is small enough to display within the bounds of the object. If not, then the choice list is displayed as a pick list. The templates provided with the package provide pre-made radio button clusters for two to six choices. Tables Tables are multi-column and multi-row objects. Each row is edited via a detail view that is generated automatically by Informed Filler. The table may optionally include a title. Although you can define columns with different widths, they are displayed with equal widths on the Newton. The number of rows and columns is fixed in a table. Font, size, and style are not configurable for tables. Text Text is static text used for form labels. You have full control over the font, size, and style of the text. Graphics Graphics are not supported in Newton Filler, but are suppor ted in the Informe d Filler package. There is a powerful scripting system that you can use to add intelligence to a form's fields. Information can be extracted from other forms or from the owner informat ion of the Newton. A large suite of math, date, time, and string functions, plus basic conditionals, are provided. Some of these extended features are not supported, or are supported with restrictions, on the Newton. You use the portrait and landscape stationary files and drawing library to simplify creating forms correctly sized for a Newton. You select the desired orientation for the form by opening the corresponding stationar y file, then copy objects from the drawing library to quickly lay out the form. Editing Tool Bar Form Window Name from Newton Owner Information Current Date Current Time Town Pick List Table with two text fields and one pick list  Fields  I  f your business revolves around forms, the Informed suite of applications is for you. The Newton package consists of the Informed Filler for Newton application and a CD ROM containing the Macintosh-based Forms designer tool. A separate package, Informed Manager, is used to manage form definitions and filled-in forms on the Macintosh. The idea behind this product is that there are already thousands (if not millions) of forms used in all kinds of businesses. Insurance forms, invoices, orders, payme nts, requisitions, and so on. This suite of tools lets you define, on the Macintosh, complex forms with spreadsheet-style calculated fields. These forms are then downloaded to the Newton where they are filled in. Completed forms are uploaded back to the Macintosh for further processing .  Install The Newton package comes on a diskette and a CD ROM. You first install the Informed Designer package onto your Macintosh. A full installation uses about 25 MB of disk space. Then you install the Informed Filler for Newton diskette. This installs an updated version of Informed Designer on the Macintosh that contains Newton connection functions. It also installs example Newton-sized forms and some layout templates, and two Newton packages. To complete the suite, you instal l the Informed Manager software off the final diskette. Compounding this already long install process is the requirement that you reboot your Macintosh after each installer completes its job. 25 MB disk space and three reboots later, you're ready to install the form tool on the Newton. You install the packages on your Newton using the supplied package installer. The ""Informed Filler.pkg"" tool and the ""Filler Guide.pkg"" help book are each 185K.  Using Informed C reating F orms on the Macintosh Forms creation on a Macintosh is much simpler then forms creation on a Newton. Let's be honest: a large color or gray-scale monitor, full-sized keyboard, and mouse make laying out a form easy. On the Macintosh, you create forms using Informed Designer (two stationary files are included pre-sized to the MessagePad portrait and landscape orientations). Each form is assig ned a unique identifier for differentiating it from other f orms in the system. You can create two Figure 1 - Page 1 of an accident report. Form Layer/Page number  8  P DA De velopers 4.5  Sept/Oct 1996   Figures 1 and 2 show a completed two-page form as displayed by Informed Designer. The form has several input objects to let an officer gather details about the accident and the parties involved. Once finished, you install the form on the Newton. On the Newton you launch Informe d Filler f or Newton, Tap the form Tab, and then tap Receive. Transfer is done using a serial connection and is reasonably quick. This form took about 20 seconds to transfer.  Conclusions The Informed suite is a p owerful and flexible forms system. Informed for Newton supports multiple forms, excellent desktop connectivity, full Newton 2.0 user interface components, and routing features. The desktop suite of tools for creating forms and processing records is simple to use and quite powerful. This review only scratches the surface of its functionality. The scripting capabilities provide for form interactions, field validations, and very complex forms. Just about anything you can do with a desktop form can be reproduced in a Newton version. This tool could be greatly enhanced by supporting e-mail and wireless exchange of both new Form definitions and records. Even without these features this is a serious forms tool for Newton.  On the Newton When you start Informed Filler for Newton for the first time, it installs an example form. This is obviously a work-around, since you cannot delete all forms on the Newton. The default form is loaded and displayed. After downloading , Figure 3 shows page 1 of the Accident Report form filled out on the Newton. Entering information is simple. In addition to standard Newton pen input, the Filler also supports the external keyboard  the Tab key moves you through the form from left to right and top to bottom. By using pick lists, radio buttons, check boxes, and drawing fields, you can greatly reduce the amount of text entry required to complete a form. After creating one or more records, you can then upload them to Informed Manager for further processing. Tapping on the i displayed in a field's title (see Figure 3) opens a slip with the help text for that field. The Tab at the upper right-hand part of the screen is a form chooser. You can instal l a large number of forms on the Newton and quickly switch between them by tapping on this button. The Newton changes orientation to match the current Form. You can navigate to the next and previous records using the silkscreen arrows at the top of the screen. The Newton overview button displays an overview of all entered records. You can bulk-upload all unsent records from the overview.  Pages of Form Navigator  Form Chooser and Form Connection  i Indicates help text available Date and Time Pickers use Standard Newton 2.0 Date/Time Pickers  Town Pick List  On the Desktop To capture records back on the Macintosh you open the same form inside of Informed Manager. For my p olice report example, I created a combined form that places all the fields on one page (see Figure 4). As long as it has the same form identifier, Informed Manger accepts the data from the Newton in the new form. You then select the View, Receive From Newton... command and send the record form to Newton. Once uploaded, you can review, edit, and fur ther process the records in the Manager.  Record Navigation Route Actions include Print, Fax, Beam, Bail, About, Send to Destktop, Delete, and Clear  New Record  Figure 3 - Newton interface.  Newton Draw/Sketch Area  Figure 2 - Page 2 of the report.  Figure 4 - A completed form in the Manager. P DA DE VELOPER S  4.5  Sept/Oc t 1996  9   Newton User Interface Guidelines Ken Knight IA, Inc. knight@sphinx.biosci.wayne.edu Rating 1/2 (on a five-point scale) Pros A thoroug h set of guidelines for designing proper Newton user interfaces. Cons Coverage in some areas is not as complete as it could be. Some aspects of the user interface are still vague. Price $24.75 by Apple Computer, Inc. published Addison-Wesley Publishing Company, Inc. ISBN: 0-201-48838-8, Apple item T1986ZA 800.282.2732, 716.871.6555, 716.871.6511 (fax) 800.637.0029 (Canada)  Newton Software Interfaces The Newton's interface is still quite young . Whether it survives the test of time depends largely on how developers treat it. Apple's Newton User Interface Guidelines are meant to ensure that developer products follow the established Newton interface rules, while still allowing developers the freedom to expand the interface in new directions where appropriate. By using this book when designing a Newton program, you can guarantee that people who are comfortable w ith the Newton are also comfortable w ith your program. If you ignore what is presented in the book, you run the risk of losing customer support and creating headaches for yourself with unnecessary technical support and difficulty improving your product's usefulness over time. The Newton User Interface Guidelines cover a wide range of topics, including how and when to use certain Newton controls, view types, working with icons, data input and editing gestures, and more. Not only are issues of when to use an interface element examined, sometimes in great detail, but specific design considerations for the primar ily penbased Newton system are considered. For example, the guidelines recommend placing the primar y controls of an application at the bottom of its display, preventing the contents of a view from being unnecessarily obscured by a user's hand each time a primar y control is tapped. The book has some limitations. For example, the action button is dealt with in a cursor y fashion, which leaves unresolved whether it is acceptab le to extend the popup to include other action items besides ones with obvious communications aspects, duplications, and deletions. Is the action picker the right place to put actions to encrypt data or provide a set of filters for some type of dig ital processing? The answer to the former is probably yes, but the answer to the latter question, esp ecially if there are many processing options (say an application that does sound processing), is probably no. Another example involves using the status bar button versus an auxiliary button like those found in an outline in the Note Pad. Developers can reasonably infer that auxiliary buttons should only be used in specific cases, while status bar controls should be used if their functions are of a more general nature, but this is not actually stated in the book. While I have some complaints with the completeness of this reference, it's only the first edition and, like the Newton itself, will no doubt improve. Many ne w user interface issues have been raised with the introduction of PDAs. This book is a good place to start when building an interface for your software. Apple has not only authorized a printed edition of this tome, but has also placed DocViewer and Adobe Acrobat versions at their Newton developer web pages (http://devworld.apple.com/dev/newton/techinfo.html). These on-line versions are accessible to anyone who has Internet access. Although this book has some flaws, it should be read by e ver y Newton developer, from hobbyist to professional system integrator.  P  aying attention to interface design has a dramatic effect on the quality of any product. Consider for example the car. The place ment and use of the steering wheel, gas pedal, brakes, gauges, and clutch all fol low conventions that everyone understands. Imagine if every car model placed its controls in radically different pla ces, labeled them differently, and provided different responses for controls that are labeled the same. To say the least, driving would be more difficult and less enjoyable. On the other end of the spectrum, VCRs have user interfaces that people find intimidating and therefore tend not to use. Every VCR I've seen has different programming and setup me thods. Some are menubased and leave little room for interpretation. Others, though menubased, provide such a maze of options it's difficult to figure out how to create a program. There is no standardization. Directions are often confusing and leave a person wondering if their VCR is programmed correctly.  Software Interfaces  Computer programs fall somewhere in the middle of this spectrum. Some computer systems provide few standard user interface tools; others have considerably more. A well-designed user interface, especially one that follows the rules laid down by the computer system manufactures, attracts and keeps customers. One reason the Macintosh has done well over the years is that Apple created a powerful-yet-friendly interface and then provided developers with a set of guidelines to ensure that their programs use the interface to best advantage. A person using a Mac program expects certain things, such as the cut, copy, paste, and undo commands, to always operate the same way. Programs that do not follow the conventions for these commands, or omit them entirely, frustrate users. Contrast the situation on the Macintosh to that found in many Windows 3.x programs, which use many different conventions for similar tasks. Microsoft provided few guidelines for people to fol low. The user info@nsbasic.com www.nsbasic.co m experience suffers because of it. A good user interface must be consistent, provide Tel 416 264-5 clear and concise metho ds to accomplish tasks, and be Fax 416 264-5 flexible enoug h to allow for growth over time without sacrificing clarity. The Macintosh has managed this fairly well while other systems have had varying degrees of success. NS BASIC Corpora 77 Hill Crescen Toronto, Canada M 1J3  ... BASIC for the Newton NS BASIC is a complete implementation o which takes full advantage of the rich N e enviroment. Easy to use interactive envir develop and run your programs immediate Features         Lots of window objects Serial and IR Comms Indexed files Graphic and Scientific funct 240 page Handbook PC and Mac connectivity Callable from other applica Create your own packages  Requirements Any Newton 2.0 or 1.x device  $99. 0 plus 5.00 shipp  10  P DA De velopers 4.5  Sept/Oct 1996   The OmniGo 100 Scott Sbihli Procter & Gamble scotts6487@aol.com Rating (on a five-point scale) Pros Speed, Graffiti, price. Cons Some programs are not full-featured. Flimsy case. Price $349 (with 1 MB RAM), $49.95 (Bindery), $119.95 (Connectivity Kit) Hewlett-Packard 1000 N. E. Circle Blvd., Corvallis, OR 97330 541.715.2004, 800.443.1254, 541.715.5488 (fax)  icons which are single-click shortcuts to the built-in applications. One of the icons rotates the OmniGo's display 90 degrees letting you choose the device's orientation. The other half of the unit has a 67-key keypad that includes chicklet-style alphabetic, digit, punctuation, cursor control, navigation, and function keys. They're too small for touch typing, but any typist can enter data at a reasonable clip after a little practice. The right side of the keyboard sports a Type II PC Card slot. The left has a proprietary serial interface for connecting the OmniGo to a PC. My unit was the 1 MB version. It had around 410 KB free for my use. One characteristic of the OmniGo 100 I'm sure I dislike is its constant creaking. Like a 1984 Chrysler K car, this thing creaks and groans when you open it and hold it. Its case doesn't feel nearly as rugged as my Newton. I have no hard data to prove this, but if anyone is willing to lend me a Newton, an OmniGo, a pair of goggles, and a sledgehammer, I believe I could put together an experiment.  Consistency is Everything  P  erspective. The whole world is perspective (and reference points). Do you realize how poorly built a Chevette is if you've never driven or ridden in another car? I used to believe that Minute Maid frozen orange juice was the quintessential breakfast drink, until I stopped at a roadside stand in Orlando and had a huge glass of freshsqueezed orange juice for $1.00. Needless to say, my taste buds whimper each time I drink the frozen stuff. Going from the Newton to an OmniGo produced a similar experience. I'm not saying that the Newton is frozen OJ and the OmniGo fresh squeezed, but the Newton did g ive me a solid reference point, a perspective, for deciding which PDA features are most important. I've spent the last month living w ith an OmniGo and without my MessagePad 120. How did I fare?  The Form Factor Out of the box, the OmniGo 100 is decidedly smaller and lighter than the MessagePad 120. It's roughly the thickness and width of a Newton, but its length extends from the top of the Newton to the bottom of the Newton's screen. Unfortunately, the OmniGo is still a tight fit for a man's shirt pocket. The case is charcoal gray and feels slightly less sturdy than the Newton's tough shell. This PDA runs on two AA batteries and a single three-volt backup battery. An external power source isn't an option, unless HP's figured a way to run the unit on static electricity. The OmniGo opens like a paperback book with one half containing a 240 by 240 pixel, one-bit display (see Figure 1). The display opens all the way and folds back so the keyboard and screen are back to back. If you think the Newton has a cr amped screen, you're going to find the OmniGo positively tiny. On either side of the screen are permanent  The consistency of the OmniGo's application interfaces is impressive (see Figure 2). In the upper-left is the gadget for closing an application. In the upper-right, there are gadgets for scrolling up and down, for sw itching pages, or for switching pen mo des. There are five function keys in a tidy row at the bottom of the screen. You can either use the stylus to click a function-key button or press a corresponding key on the keyboard. These buttons are used within all OmniGo applications. They do things like start a new note, edit a database, or present a menu with a list of items. The utility button is in the lower-right corner of the screen. Depending on the currently running application, this button's menu controls application preferences, standard cut, copy, and paste functions, and print utilities. All of these design choices result in a PDA with a consistent interface between applications, and a reduced learning curve, where users spend less time figuring out each program. OmniGo printing is done using the unit's proprietary serial interface. All applications support printing through the utility menu. You set your default printer choice using a program's preferences menu. Choices includes LaserJet, InkJet, Epson 24 pin, IBM Proprinter 24 pin, and Canon BubbleJet printers. You can print both application-specific information and screen shots.  This PDA is Loaded OmniGo's standard list of software is imp ressive, giving it much more utility than the Newton out of the box. The OmniGo 100 uses a wellestablished operating system called GEOS. Graffiti, an excellent but overly-hyped set of handwriting-recognition algorithms, is integrated into GEOS. The OmniGo ROM includes an appointment book, a phone book, a note-taking program, a database, a new car, a program for jotting notes,  Figure 2 - The OmniGo's outstanding interface consistency. P DA DE VELOPER S  4.5  Sept/Oc t 1996  11   a financial program (Cash flows, amortization, and more), an HP 12C calculator emulator, a spreadsheet, a book reader, a world time program, a trip to the Caribbean, a stop watch program, and solitaire. (By the way, two things in the previous sentence you don't get with OmniGo; I included them to hold your attention.) Each of these applications does an average or better job at their task, but you may want to replace a few with third-party solutions. Documentation is also one of the OmniGo's strong points. The manual is a solid half-inch in thickness. If you own an HP calculator or printer, you know how copious the documentation that accompanies it is. The OmniGo is no exception. It's filled with screen shots and stepby-step instructions for using each program. Curiously the only thing missing is a set of OmniGo technical specification in the Appendices.  Gr affiti Graffiti has received many positive reviews. Originally designed to improve the Newton's handwriting recognition, Graffit i relies on your creating ea ch character the same way each time. Moreover, each character is created with a single stylus stroke. (For instance, the letter ""A"" is written with a stroke which lo oks like a carat (""^"").) Instead of having to recognize the first letter of the alphabet any number of ways in which a person can write it, Graffiti only works with one type of stroke. You would think Graffiti would do an excellent job recognizing handwriting. I had some significant problems getting the OmniGo to recognize certain characters. Graffiti supports the alphabet, numbers, punctuation, and other special keyboard characters, like """"and """". That's a lot of strokes; when different strokes have only minor variations, recognition can suffer. If you compare Graffiti's recognition to that of the original Newton recognition, Graffiti is a marked improvement. Graffiti is a modest improvement over the Newton's cur rent recognition algorithms, but I like the ability to write my characters any way I want. If you are willing to invest time in learning this alien-race alphabet, you can have recognition speeds far faster than the Newton.  ing appointments. You can set an alarm to remind you of an impending appointment. This alarm is flexible in one minute inter vals, with a fiveminute default One impressive feature that beats the Newton hands down is the OmniGo's week view. You can see all seven days of the week as well as twelve hours of the day. Each hour-long block with a scheduled event appears as a shaded block. The Newton attempts to show you information for each appointment  you can't get a very good overview of your week with the Newton. I much prefer seeing how busy I am during the whole week, even though I can't see exactly what things are scheduled. The to-do list shares numerous features with the Newton. Give the task a description, a start date, and a due date, and then set the priority. Unfortunately, the OmniGo treats the to-do list and schedule as separate items  you have to manually switch between their views. Another noticeable feature of the OmniGo's Appointment program is speed. (This applies to all OmniGo applications.) Switching between views is expedient, and editing appointments is quick. This feature is un-Newton-like and a pleasant surprise.  Phone Book Program The Phone Book shares some interface features with the Appointment Book. Unfortunately, the Phone Book is one of the OmniGo's weak points. The information it tracks includes a name, a ddress, home phone, work phone, fax number, company name, title, and the allinclusive ""Other"" category (see Figure 4). Phone Book is woefully inadequate given today's technological toys. Where are Cellular Phone, Pager, and School Phone? What about e-mail addresses? Even my mother has an e-mail account. These other contact points can't all be wedged into the ""Other"" categor y. With a Newton, you can add as many fields as you like and, more importantly, you can name the fields to suit your taste. I guess Hewlett Packard doesn't lie  it's a phone book and no more. Personally, I could never use it. I have too much information. Phone Book entries can be categorized and filed. Don't see a category that meets your needs? Make your own. I created a Volleybal l category to track all of the subs that I call. One nifty feature is the ability to choose the three Phone Book fields that the OmniGo displays. You can show Name, Address, and Home Phone (useful) or Fax, Title, and Category (not so useful). This feature is somewhat critical for the OmniGo since it only show three fields. The OmniGo lacks a business card or equivalent view that readily shows all of the data about a person. To switch between two listings, you must manually look at an entr y, page down to the second half of data, back out, and then select some one else.  Appointment Book/ To Do List The Appointment Book lets you to schedule your time and manage daily tasks (see Figure 3). At the top of the screen there are five tabs for five different appointment v iews. Appt displays daily appointments, ToDo shows daily tasks and Week, Month, and 4Month give different overviews of your schedule. The bottom of the screen also has five tabs for creating a new appointment, searching the database for an appointment, attaching a note to an appointment, showing today's agenda, and switching quickly to any day of the month. Appointment data includes a description of the meeting, and a star t and end time. Additionally you can make a me eting repeat at regular intervals including such odd times as every third 25th day of the month, or every other Wednesday. This give you great scheduling flexibility while saving time if you don't want to individually record oddly-repeat-  Note Sharing many qualities with an inexpensive word processor, the Note program supports justification, different type styles, two sizes of fonts,  Figure 3 - The Appointment Book shows a day's events.  Figure 4 - The Phone Book is one of OmniGo's major sore spots.  12  P DA De velopers 4.5  Sept/Oct 1996   digital ink, an eraser, and cut, copy, and paste. The screen is wide enough to show 28 columns with the larger f ont and 38 with the smaller (see Figure 5). Formal word processing is out, but it's very suitable for jotting d own small pieces of information. One of the OmniGo's most arresting features is speed and speed is what makes this applet valuable. If you know Graffit i, you should have no problems taking notes with reasonable alacrity. Pictures and diagrams require no processing after each shap e is drawn. If you click the Exit button in the upper-left corner of the Note's window, a Save dialog box appears. You can give your document a name and categorize it for future use. You are then sent back to the Note program's contents list to select a different note or create a new one.  Label Categor y Choice List Check Button  Static te Accepts Accepts Creates  xt for each record category selections from a user-defined set one choice from a pop-up list a non-mutually exclusive check box  Jot ter Jotter is an interesting program. It's similar to the Note application except that it holds exactl y one note of up to 20 pages. You can jot the note in text or digital ink for later recognition. Any page of the note may be ""stuck"" into another application. Not bad, but why do I need a separate application for small notes? Starting a note in the Note program isn't much of an inconvenience. While using Jotter I discovered an annoying limitation of the OmniGo. I was on vacation recently, playing cards with my parents. The OmniGo substituted as a pad of paper and pen for keeping score. After about two or three screens of ink, the PDA politely informed me that it had no more room for digital ink. I had very little data at that time.  The OmniGo vertical ly displays all of the fields you create. When you leave edit mode, you have to return to the database list, and select the newly created database to begin entering data. You can modify database records or the database structure at any time. The Database program is an interesting way to store user-defined data. It's a flat file database program, with no reporting capabilities, but I was able to make a more suitable version of the Phone Book application. In my version, I included all of the fields that the ROM-based Phone Book excludes. The Database program suffers the same display issues that the Phone program does: only three fields from a record can be displayed at a time (see Figure 6). Once again, my phone program is crippled, but this time from the screen size. Granted, I can define which fields I want displayed, but I certainly can't show name, address, phone, and fax at the same time. In combination with the OmniGo's Find feature, a business card view displaying all of the data from a record would be a valuable addition.  Financ e The Finance application included with the OmniGo includes a wealth of conversion and calculation utilities. To be honest, I don't know how to use some of them, and I'm sure that I probably won't need them on a daily basis, but here's a list:  Time Value of Money - Calculate loan amounts, payments, interest rate conversions, and amortizations.  Cash Flows - Useful for Internal Rate of Return (IRR), Net Present Value (NPV), Net Uniform Series (NUS), and Net Future Value (NFV).  Business Percentages - Calculate markup, margin, and percent changes.  Compound Interest - Determine investment appreciation.  Solver - Calculate the unknown value in an equation using an iterative process. It can also plot the result.  List Stats - Solve one and two-variable statistical models, fit a curve to data, forecast using ""what-if "" criteria, and graph data.  Conversion - Convert currency, length, volume, mass, area, and temperature. There are preferences for setting the notation of numbers: fixed point, engineering, or scientific, alo ng with the precision (see Figure 7).  Database When you think of databases, what do you think of? Oracle, dBase, gigabytes of data, volumes of documentation? Well this database's documentation is ten pages long. That should tell you something of its power. It also speaks volumes about how easy it is to use. To solve my problem of a grossly inadequate phone book program, I decided to use the Database program to create my own custom phone book. Starting the application displays a list of currently available databases, plus the number of records and the total byte count of the database. To make your personal database, either select New from the buttons at the bottom of the screen or choose Modify to alter an existing database. New brings up a blank screen with an Edit button at the bottom. Click on Edit to create a new field. Field choices include: Text Number Number +/Date Time Text Accepts only numbers Only numbers as well, but with arrows for incrementing/decrementing Date-formatted numbers Time-formatted numbers  Figure 5 - The Notepad organizes all notes in an alphabetized list.  Figure 6 - Create fl at file databases with the Database program. P DA DE VELOPER S  4.5  Sept/Oc t 1996  13   You can also set one of the calculations to the default start-up calculation. Finally, there is a setting for reporting ang les in either degrees, radians, or grads. One other interesting feature of the TVM, cash flow, stats, and solver calculations is the ability to save cases. You can input a set of data for a calculation, minus a piece of data you want to vary, and save it for later use. The OmniGo has an excellent set of financial utilities.  T he Ginsu Knives Included with all of the standard applications are three other programs: A calculator that is d ecidedly better than the one included with the Newton, a stop watch program, and a Solitaire game in case you are in a boring finance meeting. They're all fit programs, but I'd take the knives given a choice.  Conclusions Spreadsheets Spreadsheets. The g eneral, all-purpose, solves-everything, cures-anything application. You need one, OmniGo provides one. Spreadsheets can grow to a size of 64 rows by 64 columns (no Federal Budgets on this baby). However, other than the small sheet size, this application is extremely powerful  it's considerably more versatile and feature laden (sans graphing) than QuickFigure Pro, a third-par ty Newton spreadsheet. Here's a partial list of features:  Cells can contain labels, values, names, and functions. Names are particularly useful for creating formulas. Instead of using references such as ""C8"" or ""$D$3"", you can name a cell and use that name in a formula.  You can change the column width and align cell values left, right, and center.  You can insert and delete entire rows and columns.  Quickly entering data in a spreadsheet is cake. You can fill a row or column with a piece of data. You can also use a Fill Series command to load a range of cells with the days of the week, months, or numeric sequences.  Cell data can be protected to prevent accidental deletion or alteration.  You can also lock cells. In this case certain cells are shown permanently on-screen, while the user scrolls through the rest of the spreadsheet.  You can pre-d efine formulas and save them in a list for later insertion into a sheet.  There are almost 100 spreadsheet functions (see Figure 8). Besides the usual trig, stat, financial, and logical functions, there are cell informat ion, printing, and string manipulation functions. Cell information functions do things like count non-emp ty cells and check to see if a cell's contents are a number or a string. The printing functions return file names and the number of pages in a printed spreadsheet. The string functions do complex operations such as strip unprintable characters, convert strings to upper or lower case, and replace or repeat strings within a sheet. The OmniGo packs a wallop for its price. At less than half the cost a Newton MessagePad 130, but including most of the Newton's features, the OmniGo is a great buy. Unfortunately it isn't the quintessential PDA, but I don't think one exists yet. A number of the applications include features (such as the week overview in the Appointment Book) that the Newton just flat out misses. Speed is another plus for the OmniGo. It recognizes handwritten Graffiti characters as quickly as you can enter them. There is no lag. Launching applications is as quick. I find using the OmniGo enjoyable with this speed. It also makes me reluctant to go back to my MessagePad where I have to wait for everything to happen. I see that little light bulb at the top of the screen so much, I sometimes dream about it. My only hope is that Apple loses the squirrels and puts a real processor in the next Newton. The OmniGo does have some disadvantages. The phone book is abysmal considering the decade in which we live. As noted previously, if you take the time, you can construct a more suitable version w ith the database program. But why should I have to do that? HP made some physical design choices to save money. You have to decide if it's a good or bad thing. The OmniGo doesn't have an IR port. I don't miss it, but in the future when all desktop and laptop computers come standard with this features, I'll probably change my mind. The screen is smaller than Newton's and supports only one-bit graphics (unlike Magic Link), but I didn't buy this thing for image editing. The case's plastic feels cheap and the stylus broke the first week. Also, the OmniGo only runs on batteries  there is no power adapter port. Sound is limited to bleeps, blips, and bloops. You won't find any digital sound here (then again I'm not sure you really need it). All of this aside, OmniGo's $399 price is a steal for its features. If I were in the market for a PDA and price was a factor (isn't it always?) the additional $350 for a Newton isn't worth it. For org anizing your daily life, taking notes, and running mini-programs, the OmniGo is a superior product to Newton. If I get a pay raise next week or wake up one morning and realize I'm stuck in Bill Gates' body, I'd go for the Newton (Heck, maybe I'd buy Apple). It has a slightly more polished set of applications, an IR port, external power supply, and lots of shareware. The big question is: which company is going to introduce a next generation PDA with a bigger screen, faster processor and advanced built-in communications?  Figure 7 - OmniGo's strong suit is the Finance program.  Figure 8 - Each spreadsheet cell may contain a complex equation.  14  P DA De velopers 4.5  Sept/Oct 1996   Eessential OmniGo Accessories Scott Sbihli  Bookreader auto-detects all book format files on the OmniGo including the one you just installed. Happy Hypertexting.  Connectivity Pack Geoworks' Bindery 2.0 Digital Shakespeare. That's how you think of yourself. You wake up late at night w ith the plot of a most-excellent novel. Oh and by the way, you're a tree-hugger. So, how do you influence the masses with your symbolism, imagery, and philosophies without kil ling trees? You needn't look any farther than Geoworks' Bindery and its assorted utilities. The Bindery, Geoworks word processor, generates ""GPK"" files which can viewed on an OmniGo using the Bookreader. The Bookreader lets you to view multi-part files which contain text, graphics, and hyperlinks. Think of the Bookreader as a hypertext help program optimized to view long documents. It has facilities for scrolling through a long page, the ability to search for text, move forward and backward in a file, and show a history of pages you've viewed. Before I discuss the virtues of Bindery and related programs, I feel the need to vent slig htly about the environment in which Bindery r uns. It uses the GeoManager, which is essentially the Geoworks operating system. Granted, this OS is a nice piece of work. It has been well thought out and has an interface that is at least as good as Windows 3.1, if not more advanced in certain areas. My question is: WHY? Microsoft, Apple, and IBM pretty much own the whole OS market for PCs. Why do I need another OS for creating Bindery files? Why should I learn its interface? Geoworks should design the thing to run on Windows 95 and join the rest of the world. Bindery is a word processor not unlike the Windows 95 WordPad. It has all the basic features you'd expect in a word processor, plus some additional functions for handling graphics, setting up hyperlinks in documents, and designating graphics hot spots as hyperlinks. Import filters include Display Write, Microsoft Word, WordStar, WordPerfect, and RTF. Graphics themselves come from the other major application included with GeoManager, GeoDraw. GeoDraw can handle both vector-based and bit-mapped graphics. Outstanding features include object g rouping, multiple duplicating, skewing objects, gradient fills, splines, anchor points modification, Boolean draw modes, shading, and pattern fills. Import filters include BMP, CLP, GIF, PCX, and TIFF. GeoDraw is an excellent program. I just wish they would convert it to Windows or Mac. Once your tome is complete with graphics and hyperlinks, and it's been spell checked, you use the utility GEOS SDK Shipper to open your document and convert it into an OmniGo package. Finally, use the Installer application to transfer the package to the OmniGo. The No PDA is an island unto itself. It needs to be able to backup, restore, and exchange data with other computers. HP's Connectivity Pack for the OmniGo lets you do all that by connecting the OmniGo to a PC's serial port. The major options of this package are Hotsync, the Desktop PIM, export/impor t filters, and data restoration. The Connectivity Pack features are very similar to those available with the equivalent Newton software. Hotsync is the process of maintaining the same data on your PC as your OmniGo. The first time the Connectivity Pack is launched it asks you to do a Hotsync to get things going. The user's choice is either automatic or manual. Automatic Hotsyncs all of the data on the OmniGo and PC; manual lets you choose which files get synchronized. The Connectivity Pack uses time and date stamps to determine which files need to be in which place. Moreover, if a file is found in one place, but not the other, it is moved to the unit where it is missing. If a time and date stamp aren't sufficient for determining what to do (both PC and OmniGo have had their data altered), the Connectivity Pack goes so far as to compare individual records. Editing, creating, and deleting records w ith the Connectivity Pack is possible using the included PIM software. You may work with the records of the Appointment Book, Phone Book, and Notepad programs. Strangely all of the other applications are not directl y accessible or alterable w ithin the program. You can't look at, alter, or export spreadsheets, for example. Unfortunate. Nothing much needs to be said about export and import. Import interprets dBase, CSV, tab-delimited text, and the Phone Book, Notepad, and Appointme nt Book files of an HP 100LX or 200LX. If you import one of the first three types of files, the data can only be use d with the three supported applets in the Connectivity Pack and must be completely field-for-field compatible. Export filters include dBase, CSV, and tab-delimited text. The Connectivity Pack documentation is outstanding . Considering the relative simplicity of the utility, the manual is generous with descriptions, screen shots, and troublesho oting. It goes so far as to list the exact steps for removing the utility altogether. Kudos to the writers of the manual. The Connectivity Pack does its job and does it well. I hope a future release g ive users access to the other applications installed on the OmniGo and to third-party application data.  The Hand-held Systems Integrator Director y  100+ pages of profiles of systems integrators for all hand-held platforms, from low-end PDAs to high-end specialized terminals.  Extensive indices by platform, application area, and industry.  Separate sections for development tools and enabling technologies.  Hardware summaries of each of the popular hand-held devices.  Designed for anyone looking for hand-held solution providers or vertical market products.  A concise industry reference.  The Hand-held Systems Integrator Director y is updated twice a year. A single issue is $25 plus $5 shipping and handling ($7.50 outside North America). An annual subscription is $50/ $55 (includes shipping and handling). Major credit cards and US bank-drawn checks accepted. Call (415.621.4252), e-mail (hsid@cdpubs.com), fax (415.621.4922), or surf (www.cdpubs.com). P DA DE VELOPER S  4.5  Sept/Oc t 1996  15   Getting Started Multiple-Developer Magic Cap Projects Bruce Tong ZZTong@aol.com  I  t's not uncommon to see mult iple developers working on a sing le application in most segments of the computer industry. Application development for PDAs is typically different. Extensive class libraries and smaller applications with fewer requirements usually mean only one or two developers are needed. Unfortunately, because of this trend, the tools needed to support mult iple developers are usually an afterthought if they're even available. The good news for Magic Cap developers is that there are available tools. Even better, many of those tools are included on the CodeWarrior CDs or are freely available. What follows is a discussion of several issues surrounding multiple-developer efforts on Magic Cap applications.  One advantage of this approach occurs early on in the project  each scene can have its own entrance. This gets around the problem of being unable to develop deeply-nested scenes until the higher-level scenes are at least partially functional. However, this approach breaks down if one scene contains the majority of the functionality  you quickly get to the point where the small scenes are done and only one developer can work on the remaining scene. Another possible resource conflict emerges if several scenes have the same functionality. In this case, one developer locks many modules at once, preventing others from w riting code. One other thing to watch for when planning your module content is the hooks between the modules. For example, you might find it awkward to have view chains trailing back and forth from one ""Objects.Def "" file to another. Continuing on with the theme of org anizing the project by scene for example, you have to decide if ListViews are defined with the objects they summarize, or whether should they be grouped with the surrounding viewables in the scene in which the ListViews are presented. Either choice means b oth modules contain objects which refer to objects in the other module. A developer needs both modules to change this hook.  Images  Modules Large projects mean multiple definition and code modules. Multiple modules combined with multiple developers can lead to a configuration manageme nt nightmare that only a document control system can cleanly solve. There are several source code control solutions available for both the CodeWarrior Integrated Development Environment (CWIDE) and the Macintosh Programmer's Workshop (MPW). CodeManager can be purchased from Metrowerks, and Projector is included as an integral part of MPW.  N aming C onventions Small Magic Cap applications tend to place all of their object definitions in a single instance definition file named ""Objects.Def "". Of course, if you have multiple instance definition files, they must all have unique names. This is generally done by appending ""Objects.Def "" onto something descriptive. ""StudentObjects.Def "" and ""InstructorObjects.Def "" are both examples of this naming convention, which is also consistent with the way many of the MPW scripts are designed to work. If you use another naming convention, you'll find yourself fighting some of the MPW scripts and you'll have to modify any Makefile that MPW builds for you. By convention, class definition files end with a "".Def "" extension. This can be a little confusing at first since the instances definition files also end the same way. As with the instance file naming convention, the MPW scripts are designed with this convention in mind. You do not have to have a class definition file corresponding to each instance definition file, but you may find this helps keep things organized so you can intuitively know where each class is defined.  Images are central to the Magic Cap theme, and are easily converted by the Simulator into a form readily included in an object definition file. But these images tend to change over time and should be included in your document control solution. Unfortunately, applications such as SuperPaint don't know anything about source code control, and don't prevent developers from altering read-only designated PICT files. If you choose to use Projector, a handy trick for managing images is to copy them into a ResEdit file as a PICT resource. ResEdit warns developers if they're about to edit a file which Projector has marked as read-only. As an added bonus, ResEdit displays all of the PICT resources in a cataloglike fashion, so it's easy to locate the image you want.  Instance IDs It's a good idea to allocate blocks of instance IDs to each object definition file. This way developers do not have to check with each other when they need to create a new instance definition. Because a source code control system makes sure a module is being modified by one developer, they can safely create new objects within the allocated range. The MPW script ""GetUniqueInstanceID"" proves to be very valuable when a developer wants to create a new instance. In versions of the development environment prior to CodeWarrior 9, it returns the first unused ID g reater than the lowest used instance ID in the active file. As of CodeWarrior 9, this script searches through all ""Objects.Def "" files. If you plan to allocate ranges of IDs to each ""Objects.Def "" file, you may want to revert back to the old method. To do so, edit the script and change it to read: UnusedInstances ""{Active}"" -o > ""{Active}""  Module C ontent A significant challenge facing a development team involves deciding how the project's object definitions and code should be broken up over multiple modules. The goal is to organize the project into logical chunks and minimize resource conflicts. While there is no single best answer to this question, one possibility is to organize the project based on the application's scenes. In this case, each scene's object definitions are pla ced in a unique ""O bjects.Def "" file, and each scene's source code in its own "".c"" file.  This scr ipt calls an MPW tool named ""UnusedInstances"". This tool has several options which you can see by issuing this command while you're in the workshe et: UnusedInstances -h  Presently, the valid range for instance IDs is 1 - 9999. While this is plenty of IDs for even the largest of projects, choosing a range of values  A significant challenge facing a development team involves deciding how the project's object definitions and code should be broken up over multiple modules. 16 P DA De velopers 4.5  Sept/Oct 1996   for each instance definition module might be difficult if you're unsure how many objects you'll be creating in each module. To help manage these instance IDs, the ""Renumber"" MPW tool available at http:// www.spies.com/MagicCap/ is extremely valuable. Unfortunately, just like the Replace All option in the editor, changes to the instance IDs of any of your hooks aren't carried over into other definition files, so you have to manually change those references as well.  Psion OPL Localization Daniel Pfund pfund3@uni2a.unige.ch  Solid Code With multiple developers, it's less-likely any one developer knows ever ything about all aspects of the application. ""Intuition kills"" of bugs are less common, increasing the need for good diagnostics to be built into the application. A log file is a good way to accomplish this. It's also a good idea to write each method so it does its own parameters and derived values validation. As a project evolves, conditions change as to when and how methods are cal led. Moreover, while you may remember the last pla ce a specific ObjectID was validated, your co-workers are probably not as familiar with your code as you are. Consider the following code fragment which illustrates the use of important methods such as DirectID(), HasObject(), and Implements(), as well as how to put diagnostics into the log with DebugMessage(): /* Find the ObjectID of the current card */ currCard = DirectID( iCurrentCard ); /* Make sure the card exists */ if ( HasObject( currCard ) == false ) { DebugMessage((""myMethod()--currCard is bogus."")); PlaySound( iErrorSound ); return; } /* Make sure it's the type of card we want */ if ( Implements( currCard, myCard_ ) == false ) { DebugMessage((""myMethod()--currCard is not a myCard_"")); PlaySound( iErrorSound ); return; }  H  ave you ever wondered how you could distribute your p rograms to a wider audience? Apart from marketing and distribution problems, one key factor is program localization. Indeed, even though English is now the most common international language, you are simply not able to reach everyone with just an English program. If you've ever wondered how to localize your OPL programs without a hassle, read on. I cover all of the programming aspects you should be aware of. You'll see that it's extreme ly easy if you think about it from the star t.  Finding the Psion's Language First you to have to find out on which type of Psion (in a nationality sense) your program is running. This is the easy par t: Psion provides an operating system call that does just that. Here's some example code to show you how it works in OPL: i%=CALL($1B8B) /*GenGetLanguageCode*/ /* i% can take the following values: 00 01 02 03 04 05 06 07 08 09 10 11 */ Testing English - UK French - France German - Germany Spanish Italian Swedish Danish Norwegian Finnish English - USA French - Switzerland 12 13 14 15 16 17 18 19 20 21 22 23 German - Switzerland Portuguese Turkish Icelandic Russian Hungarian Dutch Flemish English - Australia English - New Zealand German - Austria French - Belgium  There is, of course, a price to pay for all this extra checking. Calls to each of these methods takes time and must go through the Dispatcher. Pre-processor directives to remove this code for a final build may be a nice compromise for applications which need to be optimized for execution speed. Another issue to watch is the use of indexicals. For example, in an application w ith several stacks of cards, the value of iCurrentCard may not always be a card from the stack with which you want to work. In this case, you need to locate the current card yourself. For example, change the first line of the above example to this: /* Find the ObjectID of the current card */ currCard = CurrentCard( myStackScene );  Finding the Psion's language is not everything; you should also let the user override their Psion's language. A lot of people have English Psions from UK because they are usually much less expensive than their local counterpart. Users can typically put up with the English programs. Although keyboard mapping was a problem some time ago, you can now use the excellent KbdMap shareware program to remap all your keys to whatever you choose. I let the user override the default by using an external file which contains the language code he or she wants to use. You can use other techniques, but this is a simple one. (All these examples come from my bank account tracking program called DPBank, which you can download from my home page or most other Psion FTP sites). Here's how the code above is expanded in my program: /* Attempt to find this file on any drive */ file$=fndfil$:("":\APP\DPBANK\LANGS.USR"") IF file$="""" /* File not found */ i%=CALL($1B8B) /*GenGetLanguageCode*/ IF i%<10 /*To make the lang$ string always a 2byte code*/ lang$=""0"" ENDIF lang$=lang$+GEN$(i%,2) /*If the user's Psion language is not yet supported */ IF NOT( LOC(""010208101123"",lang$) ) lang$=""01"" /*Default to UK*/ ENDIF /*Existing languages:  Conclusion It is possible to involve multiple developers simultaneously on a Magic Cap project. Useful tools exist and are readily available, although there is room for improvement. Successful coordination of the project depends primarily on two factors: project organization and developer discipline. Code and developer resource conflict issues are, for the most part, identical to those found in more traditional development efforts.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  17   01: UK 02: FRA 08: Norway 10: USA 11: CH ROM (->02) default to french if Suisse Romand 23: B FRA (->02) */ IF lang$=""11"" OR lang$=""23"" lang$=""02"" ENDIF ELSE /*Read User's choice*/ IOOPEN(i%,file$,$20) /*Open text file*/ IOREAD(i%,ADDR(lang$)+1,2) POKEB ADDR(lang$),2 /*Set LBC*/ IOCLOSE(i%) ENDIF  at means. I usually put the string's content in comments to the right of the line. For example: dINIT lang$:(29) /*""WARNING!""*/  This way it's very easy to maintain your program and even save space, since you can use the same string in several par ts of your program. You may also want to put some comments in the language file since your translator may not understand the exact context in which a sentence is used: words often have double meanings. Another important aspect is to always have the files up to date. I've had several problems when I changed, for example, the English file but forgot to update the French file. This is a real bug nest if you don't fully test your program in each language before each release.  The MENU Hotkeys Once you have the user's preferred language, you can either load an external OPO language file if your p rogram is big, or use it to vector into a specific language procedure (this requires that all languages are contained in one file, usually the same as the program). Of course, if you use an external file, you are responsible for checking for the file and taking appropriate measures if it doesn't exist. To add a final touch to each localization, it's a good idea to localize the Psion hotkeys for each action in your menu. This is a little more difficult than localizing standard strings since your main program cannot accommodate itself to various hotkeys dynamically. The trick around this is to use a hotkeys offset table: program the different menu actions in your local language and use a lookup table to vector into the appropriate action with the foreign languages. Sounds strange? Have a look at the code below: VECTOR LOC( lang$:(200),CHR$(key%) ) /*lookup table for Upper case hotkeys */ PROC lang$:(choice) VECTOR choice c1::,c2::,c3::,c4:: ENDV c1:: RETURN ""Hello!"" c2:: RETURN ""Goodbye"" c3:: RETURN ""Welcome back to DPBank"" c4:: RETURN ""Transaction:"" ENDP ua,ub,uc,ud,ue,uf,ug,uh,ui,uj,uk,ul,um un,uo,up,uq,ur,us,ut,uu,uv,uw,ux,uy,uz ENDV ua:: /*Auto descriptions maintenance*/ action for upper case ""A"" goes here ub:: /*Choice ""B"" from menu*/ put action here ...  Localizing Strings Once you have the appropriate language file loaded, it's simple to call the language procedure (I call it lang$:) with the number of the string you want it to return. For example:  Then, create the fol lowing lookup tables (lang$:(200) in the above example). For the original language, use ""abcdefghijklmnopqrstuvwxyz""  Notice the use of the VECTOR command. This command is highly efficient in OPL. It saves you a lot of precious space over a more traditional IF... ELSEIF... ELSEIF... ELSE... ENDIF sequence. Not convinced? Try to code the above with an IF statement and see how the two files differ in size. Of course, it isn't many bytes, but still I believe a byte counts a lot more on PDAs than on home PCs. You should strive to keep your program's memor y footprint low. The main advantag e to creating separate procedures for each language is that if you don't do the translations yourself, your external translator only ne eds to worry about one particular procedure. Also, he or she won't have to hunt through the whole program t rying to find strings to translate and risk missing some. Of course, the other advantage is that you only have one main program, and as a programmer you don't need to keep multiple copies of your source in various languages. The only drawback to this approach is the speed you lose because the OPL interpreter needs to load and unloa d the same procedure several times in a row (a dialog for example). If your program really comes to its knees, you can use some cache memory to attempt to speed it up. Although cache may seem very opportune, it's not a solution to everything. I've noticed that some programs run much faster with cache memory, but for others, it makes no difference. The only way to know is to t ry it with several cache sizes.  For another language, say French, use ""avcdm g i k eno frstuxpq ""  In the French version of the program, Psion-q for ""Quitter"" vectors into the same procedure as Psion-x for ""eXit"" in the English version because it takes the place of the ""x"" in the lookup table. I do a LOC using that string; LOC returns the position within the string, not the ASCII code for the located chara cter. It is a good idea to avoid using characters other than the normal 26 letters of the Roman alphabet. Numbers are bad  the French (for example) have to press the Shift key to get to the numbers and the case of the letter may influence your program's decisions. Ultimately, it's best to try the program directly on a foreign machine if you have access to one.  Conclusion In this article, I describe a simple but effective method for translating your OPL programs into other languages. As you can see, with a little programming effort, it's easy to translate a complete program in a few hours. All you need now are some translators.  Pr actic al C oding Tips When you create a fairly large program, you need to maintain it. When you look at the source, you'd like to know what the st ring you're looking  18  P DA De velopers 4.5  Sept/Oct 1996   Features Express Option Modifier John Blue jlblue@aol.com  I  n my ar ticle in the previous issue of PDA Developers, I talked about the Express Menu and described an IZL program to set up a cold OmniGo with a minimal Express Menu. The program was ver y static in that it provided only a predefined setup of my choosing. Once the program ran, the only way to modify the Express Options was to figure out which bits to flip on or off, convert the bits to a number, and edit the proper parameter line in the RAM-based ""NET.INI"" file. In this article I show how you can use IZL to help change the Express Menu's expressOptions parame ter within the [uiFeatures] section of the ""NET.INI"" file. I also point ou t some IZL features and quirks I ran into while developing the program.  Bits 15 through 11 are not used and should not b e set. What makes setting the expressOptions parameter cumbersome is that you must figure which bits to set, change the bit string to a decimal value, and place it in the correct spot within the ""NET.INI"" file. My IZL program, MINEXPME, helps manage all the details of the bit settings, converts them to a decimal value, and places the expressOptions parameter in the right place within ""NET.INI"". I use IZL to do the parameter setting because I have no other development system for the OmniGo. The only other way to create software is to use the GEOS SDK (which can require two PCs and wading through a CD that contains several megabytes of documentation). IZL, however, provides an on-board way to create programs to do things that are ""missing"" from the OmniGo.  Details of the Program. The main goal of the p rogram is to g rab the expressOptions parameter from the ""NET.INI"" file, display it in a usable form, provide a way for you to modify it, and put the new value back in the appropriate place. Before starting, I knew what I had to do to get the parameter to and from the file. I also knew what I needed to do to convert from a decimal value to a bit string representation and back. However, I did not know how I was going to present the parameter and let you modify it. A straightforward approa ch would have been to use a command line. This would entail asking questions as to what bits to set, getting the response, and pulling all the information together when finished. While this approa ch is doable, I picture having the ability to tap on any bit I want to modify at any time.  Too Many Parameters Within the ""NET.INI"" file there are many parameters that fall under a large number of section headers. Each of these parameters control some part of the GEOS operating system. The GEOS Software Development Kit (SDK) documentation lists 34 section headers or categories for the INI files. Listed under each category are many parameters defining the behavior for the category. Parameter values may be Booleans, numbers, strings, or lists. Further complicating things is that some numeric parame ter values are meaningful only if looked at as a bit-st ring representation. For example, the parameter expressOptions lists a number for its value; 11 of the number's 16 bits define the behavior for nine different Express Menu actions.  I Z L Objec ts IZL provides a way to present informat ion like parame ter bits as eventdriven objects; that's the underlying approach IZL takes as a language. All programs consist of controllable objects like buttons, frames, and labels. Button objects may have actions associated with them v ia functions. Other objects, like frames, have modifiers or properties that can be passed on to their children, which are also objects. For example, a frame can have modifiers like frame size, frame position, and frame child layout. IZL is not a full-blown, object-oriented language like Smalltalk, where all data types are objects and ever ything responds to messages sent to them. IZL limits its object orientation to interface construction and manipulation. It also lets you build hierarchies of interface objects for controlling one parent and affecting many children. In addition to interface objects, IZL has variables and functions (both built-in and user-defined) that you can use to control and respond to user events like pen taps. Variables can be strings, numbers, Booleans, and arrays of the basic types. You can also use arrays to control several similar IZL o bjects like buttons.  Express Menu Controlling Par ameters The Express Menu is controlled by one parameter (expressOptions) under the uiFeatures categor y and four parameters (floatingKeyboard, maxNumDirs, noSubMenus, and otherAppSubMenu) under the expressMenuControl category. For this article I concentrate on expressOptions. The expressOptions parameter is controlled by setting it to a value whose individual b its are on or off for a particular function. Below is a brief summary of the bits and their meaning. Read ""OmniGo Express Menu Setup"" in the July/August issue of PDA Developers for more detail on expressOptions and other Express Menu controlling parameters. Bit 10 = 1 Express Menu displays a list of the currently running applications. Bit 9 = 1 Express Menu displays all the applications in the ""\WORLD\DESK ACCESSORIES"" directory. Bit 8 = 1 Express Menu displays all the applications in the ""\WORLD"" director y. Bit 7 = 1 Express Menu displays a hierarchical list of the applications in sub-directories of the ""\WORLD"" directory. Bit 6 = 1 Express Menu displays a control panel area, for example, a link to the printer status window. Bit 5 = 1 Express Menu displays a list of DOS tasks accessible to the switcher. Bit 4 = 1 Express Menu displays a utilities panel. Bit 3 = 1 Express Menu displays an option to exit to DOS. Bits 2, 1, and 0 control the location of the Express Menu: 000 001 010 Display no Express Menu. Display the menu in upper left of the screen. Display the menu ""just below the bottom of the screen.""  But tons, Buttons, But tons The ability to create a series of buttons led me to design an interface with a button assigned to each bit. I created my interface first, experimenting with different approaches. The following is a result of the experimentation. While the code below is only an interface skeleton, doing no actual work, it does run. # Minimal Expert Mode Modifier interface skeleton variables; exp_bits = 11; expwrkstr = ""11111111111""; end; # Menu button setup menu_item menu_item menu_item menu_item save; display ""Save setup""; end; exp_reset; display ""Reset expressOptions""; end; about; Display ""About""; end; show_bits; Display expwrkstr; end;  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  19   # Interface frames frame userframe; hidden; vertical; hug_left; end; button params[exp_bits],userframe; display ""Parameter name""; end; frame aboutframe; hidden; vertical; center_h; center_v; char_size 30, 4; position 40,40; box; end; label info, aboutframe; display ""Minimal Express Option Modifier""; end; button about_ok, aboutframe; display ""Ok""; end; # frame for save file buttons frame saveframe; hidden; vertical; position 35, 40; box; end; label saving, saveframe; display ""Save expressOptions value?""; end; frame save_opts, saveframe; horizontal; end; button save_yes, save_opts; char_size 10,1; display "" Yes""; end; label filler, save_opts; display "" ""; end; button save_no, save_opts; char_size 10,1; display "" No""; end; # Frame & menu button functions function about; hide saveframe; hide userframe; show aboutframe; end; function about_ok; hide aboutframe; show userframe; end; function save; hide userframe; hide aboutframe; show saveframe; end; function save_no; hide saveframe; show userframe; end; function show_bits; hide aboutframe; hide saveframe; show userframe; end; function params; end; function exp_reset; call show_bits; end; function savexpopt; end; function save_yes; call savexpopt; hide saveframe; show userframe; end; function startup; show userframe; end;  This code allowed me to play with different layouts and frame sizes. I wouldn't say this is a perfect interface but it gets the job done. I'll leave the aesthetics to others to debate.  Walk Though the Fr ame Hier arc hy MINEXPME uses three interface frames. userframe contains the parameter bit control buttons. aboutframe contains the program title and an OK button. saveframe contains two children objects in a vertical layout: a label and a frame named save_opts. The save_opts fr ame is used to organize two buttons and a label in a horizontal layout. When the startup func tion is activated (startup is a special IZL function that is run before any user events are processed) it makes the userframe the active frame, displaying the parameter control buttons. Each button has a function with the same name. When a button is tapped, its function is run. Additionally, all the menu selections activate other functions.  Spec ial But ton C ase The par ameter buttons are a special case, because each of the eleven buttons activates the same function. The lines button params [exp_bits],userframe; display ""Parameter name""; end;  define an ar ray of buttons as children of the frame userframe. Each button is linked to the function params. This function figures out which button is tapped by looking at the special global IZL variable called invokersub. You can use invokersub to index mult iple arrays associated with a button. In this case, invokersub can have a value of zero to 10 (arrays are zero based). In the full program I link button zero to bit zero of the expressOptions parameter.  Hide and Show There are several functions that hide a frame while showing another. Since IZL is event driven, not hiding a frame while another frame is active can cause conflicts in code execution and make the interface look messy. Hiding a frame makes any child fr ames or buttons invisible and inaccessible. For example, if you tap the Save button, then the saveframe is displayed. If you decide to next tap the About button, the saveframe is hidden and the aboutframe is displayed. If this hide and show functionality is not put in the program, then the two frames are displayed simultaneously (see Figure 1).  Figure 1 - Overlapping frames.  20  P DA De velopers 4.5  Sept/Oct 1996   Difficult Interface Issue One of the difficulties I had to deal w ith creating this program was providing information before saving the expressOptions parameter to a file. I wanted to have the save_yes function display a message to a label area so you would know that something is happening while saving is selected (I felt this would be needed as saving takes longer than most people expect). I initially used a put statement to display a message in the filler area between the buttons. But nothing appeared when the program ran. Nothing appeared when I r an the program w ith the trace on either. This confused me, so I created a smaller example so I could concentrate on the actions involved. Here are two code examples that show some questionable actions by IZL (not doing what I would expect). # save interface skeleton number 1 menu_item save; display ""Save setup""; end; frame userframe; hidden; vertical; display ""user frame""; hug_left; end; frame saveframe; hidden; vertical; position 35, 40; box; end; label saving, saveframe; display ""Save expressOptions value?""; end; frame save_opts, saveframe; horizontal; end; button save_yes, save_opts; char_size 10,1; display "" Yes""; end; label filler, save_opts; display "" ""; end; button save_no, save_opts; char_size 10,1; display "" No""; end; function save; hide userframe; show saveframe; end; function save_no; hide saveframe; show userframe; end; variables; i = 0; end; function do_work; put filler, "" Working on stuff ""; i = 0; while i<30; i=i+1; end_while; put filler, "" Done working on stuff ""; end; function save_yes; call do_work; hide saveframe; show userframe; end; function startup; show userframe; end;  # save interface skeleton number 2 menu_item save; display ""Save setup""; end; frame userframe; hidden; vertical; display ""user frame""; hug_left; end; frame saveframe; hidden; vertical; position 35, 40; box; end; label saving, saveframe; display ""Save expressOptions value?""; end; frame save_opts, saveframe; horizontal; end; button save_yes, save_opts; char_size 10,1; display "" Yes""; end; label filler, save_opts; display "" ""; end; button save_no, save_opts; char_size 10,1; display "" No""; end; frame waitframe; hidden; vertical; position 35, 40; char_size 40, 4; box; end; label wait, waitframe; display ""Please wait""; end; function save; hide userframe; show saveframe; end; function save_no; hide saveframe; show userframe; end; variables; i = 0; end; function do_work; hide saveframe; show waitframe; i = 0; while i<30; i=i+1; end_while; hide waitframe; end;  The first example displays a basic userframe and one menu button to activate saveframe. I want to have saveframe have a message displayed after the save_yes button is tapped. However, the messages ("" Working on stuff "" and ""Done working on stuff "") do not get displayed. But, if you immediately re-select the save menu button again you see that the message ""Done working on stuff "" is now a part of the saveframe. This is confusing. Why does the filler message appear late? Does it require hiding the frame before any new things can be written? I decided to tr y another approach with another skeletal program: Figure 2 - The main window. P DA DE VELOPER S  4.5  Sept/Oc t 1996  21   function save_yes; call do_work; hide saveframe; show userframe; end; function startup; show userframe; end;  You must reboot the OmniGo by holding down the LEFTSHIFTON-NEXT keys at the same time in order for the changed expressOptions bits to take effect. Be sure to save the settings first. # Minimal Expert Mode Modifier  In this program I decided to hid e the saveframe while the work was being done. Unfortunately, this did not work either. It seems as if the frame control is running under a different processor thread than other code threads so that the work code gets executed, but the interface is not updated immediately, possibly delayed until a lower computing point (I am speculating here). Putting the tra ce on did not reveal any insight. At this time I still am tr ying to figure out how to make saveframe hide immediately when the ""Yes"" button is tapped. The above two samples indicate that something subtle is happening, and there is no clear explanation from the manuals to help. For the moment I decided to hold off on getting this part of the interface just right.  variables; # array of strings for on/off string values on_or_off[2] = ""off "", ""on ""; exp_bits=11; # number of parameters bits # variables for expressOptions exp_value exp_str = exp_found expwrkstr = 0; # expressOptions binary representation """"; # expressOptions bit string = FALSE(); # expressOptions found in NET.INI = """"; # working bit string  Instructions To use my final program, load in the source file. The program first reads the RAM based ""NET.INI"" (on the ""B:"" drive) file for the current value of expressOptions. Don't worry if the parameter does not exist in the ""NET.INI"" file  the program provide a default value of 0. The screen then displays all eleven bits as buttons with descriptors and the bit values (see Figure 2). Tapping on a button flips its value. The menu button at the bottom of the screen (the F2 button) contains four choices (see Figure 3): save the current bit setup, reset expressOptions to original settings, display some information about the program, and display the expressOptions bits as a binary string. ""Save setup"" displays another frame asking if it is OK to save the settings or cancel the saving p rocess. ""Reset expressOptions"" sets the expressOptions bits to the last values that were read in or saved. If you change some bits, save the settings, and change a few more, then decide to reset, you get the bits set from the last save and not from when the program started. The ""About"" command displays the program title with an OK button (see Figure 4). The last item, the bit representation of the expressOptions buttons, is some thing I used to help in debugging the program and decided to leave in. It demonstrates that even menu buttons can be written to after their initial creation (something I discovered by playing around with IZL  it's not mentioned in the manual). The program displays bits zero, one, and two individually even though all three together control the activation and placement of the Express Menu. I make them independently modifiable so you can experiment.  # display name of ini parameters plabnames[exp_bits]=""Express Menu Upper Left"", ""Exprees Menu Below Lower Left"", ""Bit 2 has no effect"", ""Show Exit to DOS"", ""Utilities Panel"", ""DOS Tasks List"", ""Control Panel Area"", ""Show World/Sub-Directory Apps"", ""Show World Directory Apps"", ""Show World/Desk Accessories Apps"", ""Show Running Apps""; ini_file = ""b:\geoworks\NET.INI""; # ini file to work on tmp_file = ""b:\geoworks\tmp.ini""; # temp working file i = 0; # scratch var str_len = 0; # string length end;  Figure 3 - The lone menu.  Figure 4 - The About window.  22  P DA De velopers 4.5  Sept/Oct 1996   # Menu button setup menu_item menu_item menu_item menu_item save; display ""Save setup""; end; exp_reset; display ""Reset expressOptions""; end; about; Display ""About""; end; show_bits; Display expwrkstr; end;  while i < exp_bits; put params[i], plabnames[i]&"" ""&on_or_off[VALUE(MID(expwrkstr,exp_bits-i-1,1))]; i = i + 1; end_while; put show_bits, expwrkstr; end; # # # # Handle selected parameter buttons note: IZL string LENGTH function is NOT zero based but IZL string MID function is.  # Interface frames frame userframe; hidden; vertical; hug_left; end; # # # # # # the array of the bit control buttons. Button x corrolates to bit x in the expressOptions value exp_str # & expwrkstr. This requires translation match. Strings are zero based accessed left to right (i.e.; the left most character is character number zero and the right most character is character number LENGTH(string)-1.  function params; # invoked when param button pressed # get value associated with object i = VALUE(MID(expwrkstr,exp_bits-invokersub-1,1)); # flip 0 to 1 or 1 to 0 # reflect new value i = (i + 1) % 2; # and store new value put invoker, plabnames[invokersub]&"" ""&on_or_off[i]; expwrkstr = LEFT(expwrkstr, exp_bits-invokersub-1) & STRING(i, 0) & RIGHT(expwrkstr, invokersub); put show_bits, expwrkstr; end; # # # # Reset the expressOptions values to those first read in on program start. If expressOptions has been saved then the old original value is gone.  button params[exp_bits],userframe; display "" ""; end; frame aboutframe; hidden; vertical; center_h; center_v; char_size 30, 4; position 40,40; box; end; label info, aboutframe; display ""Minimal Express Option Modifier""; end; button about_ok, aboutframe; display ""Ok""; end; frame saveframe; hidden; vertical; position 35, 40; box; end; label saving, saveframe; display ""Save expressOptions value?""; end; frame save_opts, saveframe; horizontal; end; button save_yes, save_opts; char_size 10,1; display "" Yes""; end; label filler, save_opts; display "" ""; end; button save_no, save_opts; char_size 10,1; display "" No""; end; # Frame & menu button functions function about; hide saveframe; hide userframe; show aboutframe; end; function about_ok; hide aboutframe; show userframe; end; function save; hide userframe; hide aboutframe; show saveframe; end; function save_no; hide saveframe; show userframe; end; # display parameter buttons' values and labels function show_bits; hide aboutframe; hide saveframe; show userframe; i=0; # zero based access to arrays  function exp_reset; expwrkstr = exp_str; call show_bits; end; # code to handle numeric conversions variables; digits = """"; # digits allowed in base digit_val = 0; # binary representation of single digit num_str = """"; # string representation of number num_value = 0; # binary representation of number index = 0; # pointer into num_str err_state = FALSE(); base = 0; # base of number end; # Convert string to a value # input parameters: # num_str = string needing conversion to a value. # digits = string of possible digits in num_str # base = base of num_str # out parameters: # num_value = value # err_state = TRUE() if there was a problem in function. # Code modified from HexCalc by Doug Taylor at the Ohio State University. function string2val; err_state = FALSE(); # remove control characters, make small case # characters upper case, & remove all leading # and trailing spaces.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  23   num_str = TRIM(UPPER(CLEAN(num_str))); num_value = 0; index = 0; while AND(index < LENGTH(num_str),err_state = FALSE()); if ISERR(FIND(MID(num_str,index,1),digits,0)); err_state = TRUE(); else; digit_val = FIND(MID(num_str,index,1),digits,0); if (32767 - digit_val)/base < num_value; err_state = TRUE(); else; num_value = (base * num_value) + digit_val; end_if; end_if; index = index + 1; end_while; end; # # # # # # # # # # # # Convert value to a string. . input parameters to the function: num_value = value needing conversion to a string digits = string of digit characters possible in num_str base = base of num_str err_state = error state from the string2val function. If using function independently from string2val then set err_state = FALSE() before calling. output parameters: num_str = string version of num_value Code modified from HexCalc by Doug Taylor at the Ohio State University.  function findvalue; found = FALSE(); open data_file, file_name; # open file get data_file, in_line; # grab a line # and start looping through file. while AND(bytesread <> 0, found=FALSE()); # parameter name not found on this line. if ISERR(FIND(param_str,in_line,0)); else; found = TRUE(); # parameter string found. Check for value. if ISERR(FIND(""="", in_line, 0)); # parameter string was not formed correctly # (no equal sign) so default the value to 0 value_str = ""0""; else; tmpval = LENGTH(in_line); tmpval2 = FIND(""="", in_line, 0); # grab the value from the middle of # the string, ignoring the # carriage return and a line feed at # the of the line. note that FIND is # zero based i.e.; the first character # is character zero value_str = MID (in_line, tmpval2+1, tmpval- tmpval2-3); end_if; end_if; get data_file, in_line; end_while; close data_file; end; # # # # # read RAM based NET.INI for expressOptions output parameters: exp_str = bit string representation of expressOptions exp_value = binary representation of expressOptions exp_found = TRUE() if expressOptions found  function val2string; num_str = """"; while AND(num_value > 0,err_state = FALSE()); digit_val = MOD(num_value,base); num_str = MID(digits,digit_val,1) & num_str; num_value = (num_value - digit_val) / base; end_while; end; # file handling variables variables; in_line = """"; # in file read line found = FALSE(); # flag signaling found parameter value param_str = """"; # parameter string to find value_str = """"; # value of parameter file_name = """"; # name of file tmpstr=""""; # tmp string tmpstr2=""""; # tmp string tmpstr3 = """"; # tmp str tmpval = 0; # tmp value tmpval2 = 0; # tmp value CrLf[2] = $13,10; # carriage return, line feed end; file data_file; end; # file object file data_file2; end; # file object # # # # # # # # # # This function tries to find a parameter string within a file & return its value. return input parameters: file_name = file to open for searching param_str = parameter value Output parameters: found = FALSE() if the param_str is not found, TRUE() if param_str if found value_str = the value of param_str  function getexpopt; param_str = ""expressOptions""; # Look for expressOptions file_name = ini_file; # open RAM based NET.INI call findvalue; exp_found = found; if found; # an expressOptions value is found num_str = value_str; digits = ""0123456789""; base = 10; call string2val; if err_state; # an error in string2val, default expressOptions exp_value = 0; # set to zero exp_str = ""00000000000""; # set to 11zero bits else; exp_value = num_value; digits = ""01""; base = 2; call val2string; exp_str = num_str; end_if;  24  P DA De velopers 4.5  Sept/Oct 1996   else; # not found in file, default expressOptions exp_value = 0; # set to zero exp_str = ""00000000000""; # set to eleven zero bits end_if; end; # save settings for expressOptions. function savexpopt; # convert expwrkstr to a value to write out num_str = expwrkstr; # setup for the call to string2val digits = ""01""; base = 2; call string2val; if err_state; # There was an error in conversion. # Default expressOptions to zero exp_value = 0; exp_str = ""00000000000""; expwrkstr = exp_str; else; # expressOptions working bit string converted ok. exp_value = num_value; exp_str = expwrkstr; end_if; # delete any previous tmpNET.INI files since # we want create a new one delete tmp_file; open data_file, ini_file; # open current NET.INI open data_file2, tmp_file; # open temp .ini file # start copy and check loop. get data_file, in_line; while bytesread <> 0; # was expressOptions originally found in ini file? if exp_found; if ISERR(FIND(""expressOptions"",in_line,0)); # expressOptions not found on this line put data_file2, in_line;. else; put data_file2, ""expressOptions = "" & STRING(exp_value, 0); put data_file2, CrLf; end_if; else; # not originally found so look for section header # under which to insert new expressOptions value # go ahead & write out the in_line put data_file2, in_line; if ISERR(FIND(""[uiFeatures]"",in_line,0)); # section header not found on this line else; # put in new expressOptions parameter # value after the section header put data_file2, ""expressOptions = "" & STRING(exp_value, 0); put data_file2, CrLf;  end_if; end_if; get data_file, in_line; # get the next line end_while; close data_file; close data_file2; delete ini_file; # remove old ini file copy tmp_file, ini_file; # put new ini in correct place delete tmp_file; # clean up # needs to be put in because of possible multiple saves # from one session. without it the save function puts # multiple copies of expressOptions line in the file exp_found = TRUE(); end; function save_yes; call savexpopt; hide saveframe; show userframe; end; function startup; show userframe; call getexpopt; # assign the bit value to the cooresponding buttons. # IZL string LENGTH function is NOT zero based but # IZL string MID function is.fill out the bit string # if it is less than exp_bits long exp_str=REPEAT(""0"",exp_bits-LENGTH(exp_str)) & exp_str; expwrkstr = exp_str; # setup working exp bit string call show_bits; # display the buttons with correct bit values end;  Strengths, Weaknesses and Assumptions For small utility programs, IZL works well for development on the OmniGo. For bigger programs, it is much easier to develop them on a machine with a bigger screen and keyboard. I started most of the code on the OmniGo, but for big edits I use my OmniBook 300 and download the programs to the OmniGo. I then use the OmniGo along with OgEdit by R.C. Schuler (schuler@usa.net) for debugging edits. IZL does not have the interface polish like programs developed with the GEOS SDK, but it has enoug h functions to create usable interfaces. It is slow when reading and writing the ""NET.INI"" file and can make you wonder if anything is happening. The fol lowing are some assumptions I used when creating this program:  The program does not control any Express Menu options outside the expressOptions parameter. It would be unwieldy to create an IZL program to modify all ""NET.INI"" parameters.  There is no file error checking  the program does not look at the special global IZL variable ERROR_CODE to check file opens and closes.  There can o nly be one expressOptions line in ""NET.INI"". Although I have used multiple expressOptions in the ""NET.INI"" file, with the second one se eming to take precedence, this program reads only the first occurrence within the file.  The ""NET.INI"" file must be on the B: drive. I also used a convention of capitalizing the built in IZL functions for readability. They don't have to be upper case.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  25   A Simple OmniGo File Compression Tool Marcus Groeber 100712.270@compuserve.com  press data stored in memory buffers as well as in files. While comp ressing memor y buffers is probably the method of choice for integrating compression into application data formats, other programs' files are probably best compressed from one file to another.  M  emor y is always a limiting factor on small devices like Hewlett Packard's OmniGo. While efficient data compression techniques are common practice on desktop machines, they are still not found in PDAs too often. Apart from the lack of CPU horsepower, one reason for this may be the problem of presenting compression functions to the user in a way that they can easily handle them. This ar ticle describes an attempt to simply solve this problem by using the OmniGo's b uilt-in resources as much as possible.  All Files Are Not Equal While experimenting w ith the compression library, I found that its performance both in compression ratio and speed is only slightly worse than PKZIP 1.1, which seems good enough for general purpose compression on small CPUs. That was the good news. Passing the handle of a source and destination file to the library and leaving all the work to the system routines also seemed easy at first, but it turns that there is more work involved if you want to handle any type of file. From a GEOS perspective, files fall into two groups: true GEOS files, which can have long names, tokens (indicating creator and file type), comments, and other extended attributes, and native DOS files, which are restricted to the set of attributes offered by DOS (date, time, and a few of flags). On the other hand, GEOS uses a plain D OS file system as a host  it must add a header to any true GEOS file to store the extended attributes. This header is part of the DOS content of the file, but the system does not treat it as part of the GEOS file content. Consequently, when opening the file w ith the GEOS FileOpen function, the header with all its vital information is not directly accessible, and is lost during compression. Thinking about it a bit, I realized that any standard GEOS filetransfer applications would have the same problem, but they somehow manage to transfer GEOS files including their headers. A little disassembly of the PCCOM library in the areas close to the FileOpen function revealed that the most significant bit of the FileAccessFlags record passed to FileOpen (which should not normally be set) contains an undocumented flag that, if set, forces the system to access the file in native mode. In other words, it treats the header as additional data in the beginning of the file. Together with the documented ability to create a file in nat ive DOS mode, I could now compress all files identically and look at them using the same methods as any DOS-based application. You should keep in mind that this flag is probably left undocumented for a good reason: accessing GEOS files in native mode can make an application dependent on the way GEOS files are stored in the host file system. It's not certain that every file system designed for GEOS will give you full access to all extended attributes through native files. (A file system can easily store additional attributes in a director y structure, where they belong, instead of in the file.)  Design Goals There is a design feature of the OmniGo that make implementing a compression program rather straightforward: its internal structure is fairly close to a typical PC with 576K of base memory and a little over 400K for a RAM disk with a standard DOS file system. On the other hand, most of the file system is hidden from the end user by restricting application data storage to a single directory (""\GEOWORKS\DOCUMENT""). Any new program is free to break this rule, but with the limited amount of free storage, this is not likely to become common practice. The basic idea behind the program is to let the user selectively compress and decompress individual data files created by other applications. Decisions about which files should be stored in compressed or expanded form are left entirely to the user. (In the application, I use the word ""Packing"" instead of ""Compression"" because it fits more easily underneath an icon and onto a menu button.) The application presents a simple two-box model similar to the one used by the standard Transfer application: the user interface consists of two identical file lists, one showing uncompressed files and one showing files that are archived in comp ressed form (see Figure 1). Two menu buttons, ""Pack"" and ""Unpack"", in the function bar at the lower edg e of the screen, move files from the upper to the lower list (where they are compressed) and vice versa (where they are uncomp ressed). There can only be either a compressed or an uncompressed version of a file.  Getting Started - Sleuthing When I started thinking about a simple data compression tool, I decided that it should use the compression functions already offered by the GEOS operating system. This way, I could avoid reimplementing one of the numerous LZ-some thing compression algorithms already available. Even though the SDK does not mention them, the presence of such functions is clearly indicated by a library called ""COMPRESS.GEO"" (its long name is ""PKware Comp ression Library""), which is part of every version of GEOS 2.x I have seen so far, including the one on the OmniGo. Since the SDK documentation is not very helpful as to the contents of this library, I began a process that most GEOS programmers sooner or later become familiar with: trying to piece together the bits of information that are available. Browsing over the contents of the ""\PCGEOS\INCLUDE"" subdirectory of the OmniGo SDK (always a good idea if the official documentation leaves you with questions), I came across two useful files: ""COMPRESS.H"", which defines the C interface to the comp ression library, and ""LDF\COMPRESS.LDF"", which is necessary to link the library to applications. These files first appeared in the OmniGo version of the SDK. Perhaps Geoworks plans to document the library in the future. Even though ""COMPRESS.H"" contains nothing but declarations, the names of arguments and option flags tell you most of what there is to know about using the library. The remaining pieces of the puzzle, like the interpretation of the return value, can be found in the ""COMPRESS.DEF"" file, which specifies the ESP (assembly language) interface of the library. Even if you're planning to write your application in GOC, it can sometimes be helpful to look at the "".DEF"" files because they are often quite thoroughly commented. From the various files I learned that the compress librar y can com-  Figure 1 - The compression tool main window.  26  P DA De velopers 4.5  Sept/Oct 1996   A Rose by Any Other Name To avoid having to deal with creating subdirectories to hold compressed versions of files, I decided to store the compressed files in the same director y and under the same name as their uncomp ressed originals, but marked with a special file t ype. That should ensure that other applications do not confuse them with their own files. There is one exception to this rule which is too common to be ignored: the database librar y that maintains ""DB"" files, which are used by most of the OmniGo's built-in applications. Unfortunately, this library doesn't care if a file is native. If it encounters a file with the name of the database it wants to open, it overwrites this file unconditionally if it does not contain a valid database file structure. The only way to avoid this is to add a distinctive suffix (""(p)"" for packed) to the compressed name of any file with a name that could indicate a DOS file. Having source and destination file in the same directory requires using an intermediary file name for one of the files during compression and decompression. It turns out that this is also useful for speeding up director y searches. For files with long names, GEOS relies on a special relationship between the DOS file name and the long GEOS name. By assigning the file a well-defined GEOS-style temporar y name before compressing it, the program can later unpack the file (whose header contains the temp orary name used prior to compression) into a DOS file with a suitable name, and then rename it to its proper name, leaving the task of finding a new name for the DOS file to the system. (I just have to make sure I use a temporary file name that yields identical DOS and GEOS names, so it can be applied to both file types without having to distinguish any further.) Storing the compressed file as a replacement for the original means that I ultimately have to delete the source file. This imposes a special responsibility on the error checking of the previous steps. If anything goes wrong that might indicate a failure, or if the size reported by the compression librar y appears to be inconsistent with the true file size, I abort the operation and try to restore everything to its original state.   HINT_FILE_SELECTOR_SHOW_FILE_SIZE makes sure that the lists show file sizes as well as their names and modification dates.  HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW set to four tells them to show no more than four files each, which means that both lists together fill the screen just nicely.  HINT_MINIMIZE_CHILD_SPACING makes the A-Z selection bar disappear, providing space for at least one additional file name. This last item is not mentioned in the SDK and has to be figured out by inspired guessing. ( This is another strong argument for a yet-to-bewritten GEOS visual UI designer.)  Fast Flicker-Free Files After implementing the file selectors, I noticed that every time a file was compressed or decompressing, the file lists updated their contents at least three times each. The reason was pretty clear: every change in the file system (for example, creating or deleting a file) causes the affected file selectors to rescan their directory and redraw themselves. Normally, this a good thing because it keeps the file lists current without requiring any work on my part. In this case, the result is annoying. The messag e MSG_GEN_FILE_SELECTOR_SUSPEND lo oked helpful. It's described as a message that keeps the file selector quiet during mult iple sequential changes. It took me a few days and a number of Swat sessions to figure out the correct way to deliver this message to make sure that the file selector is suspended during the deliver y of the change notifications:  Pass the SUSPEND message to the file selector using a direct @call before any file operation. This makes sure that updates are suspended before the program continues.  Perform the file operations.  @send the END_SUSPEND message to the file selector using the forceQueue option. This makes sure that it is placed into the message queue after all the notifications.  Making a Choice The first major task of the program is to present two lists of file names to the use r. Most of the functionality I need is already provided by the GEOS GenFileSelector object class, so the obvious solution is to arrange two file selectors in the application's main screen (a GenPrimary object), each picking a suitable selection of the files in the ""\DOCUMENT"" directory. The choice of selection rules for compressed files is straightforward. All compressed files are stored as GEOS files with my application's token specified as Creator. I simply use the attribute ATTR_GEN_FILE_SELECTOR_CREATOR_MATCH with the appropriate token to pick all the compressed files. The uncompressed selector is a bit trickier. It's supposed to display all the available files, with the exception of files stored in ROM. They can be excluded by showing only those files that have the FA_ARCHIVE attribute set. (The more obvious choice of excluding FA_READ_ONLY files y ields no v isible result.) In addition, compressed files should not appear in the uncompressed list. To do this, I need to exclude all the files having my creator token. This can't be done using predefined selection methods. In this case, the SDK is helpful: ""APPL\SDK_C\FSFILTER"" contains a complete sample for defining a custom filter function in C. This filter, which is called once for every file in the list, decides whether to include the current file in the list based on any criteria defined in the C code. Adapting this code is simple, althoug h the compiler complains about a ""Suspicious pointer conversion"" when passing the address of the callback function  the system hea der files incorrectly d eclare the function protot ype without the _pascal keyword, which is required to pass arguments in the correct order. To get maximum use out of the limited OmniGo screen space, I customize the selectors w ith a few more ATTRs and HINTs (ATTRs that may or may not be honored by the current user interface):  Preparing for Localization Since the OmniGo comes in versions for different countries, it would be nice to make this program easily adaptable to foreign languages. This is not too hard, keeping in mind the most important rule for writing translatable GEOS applications: ""Beware of string constants."" Using the ResEdit tool that comes with the SDK, any text stored in object resources can be edited even without having access to the source code. On the other hand, all hard-coded string constants are there to stay. This is not a problem for things like menu names or dialog box items, because their VisMonikers are stored in translatable form anyway. But it means that error messages and other language-dependant text parts have to be stored in chunks, which means they cannot be accessed directly using pointers without locking down their memory blocks first. Error messages are displayed in a routine named UserStandardDialogOptr(), which is specifically designed to take pointers to translatable resources rather than normal strings. To make it usable with routines like sprintf that take a C pointer, the blo ck it resides in is locked in memor y so that the chunk's address can be turned into a pointer using LMemDeref(). Don't forget to unlock the block again after using it.  The Wish List The complete source code for the main compression/decompression program is at the end of this article. In its current version, it's suitable for compressing databases and spreadsheets. There is still plenty of room for improvement.  The program can only deal with files in the ""DOCUMENT"" directory. It cannot handle files stored on SRAM cards.  A more compatible way of handling extended attributes would be to retrieve them using documented GEOS functions and to store them in a data block at the beginning of the compressed file.  Error checking could be further improved by running a checksum over the uncompressed file. P DA DE VELOPER S  4.5  Sept/Oc t 1996  27    When working with database files, there is nothing that prevents a user from creating a new (empty) copy of a database while another version is stored in compressed state. In such a situation, there is no way to look at the comp ressed version to see what it contains without removing the uncompressed file.  dLite  A Different Approach The fact that the OmniGo really is a DOS-based machine can also be exploited in a different way by using standard DOS file compression technology. One program that seems to be particularly suitable for the OmniGo is Rainer Schuetze's resident decompressor dLite, a $20 shareware program. The program, which has a memor y footprint of only about 12 K, provides completely transparent decompression, but it cannot compress files on the fly. In other words, files must be packed with a separate tool before downloading them to the OmniGo, and they lose their compression as soon as any data is written to them. This makes the program especially suited for compressing reference informat ion as well as program files (because dLite is operating in between DOS and GEOS, it can decompress files of any type). For example, the size of the CompuServe client for GEOS (normally more than 300K) can be halved using dLite, while keeping the decompression process completely invisible to the user. You can include the dLite startup command (""DLITE /I /F+"") in the ""AUTOEXEC.BAT"" file on the OmniGo's RAM disk. It is then loaded when you restart the OmniGo using Shift-On-Next. It should be possible to use other compression tools in a similar way. For debugging a setup of this kind, it can be quite useful to install an additional program (like OGTEXT or OGTMODE) to enable the text mode on the OmniGo to see any messages displayed during startup. The complete source code for CompTool, including the ""GP "" and ""MAK"" files can be found on the source code disk for this issue of PDA Developers. *********************************************************************** * PROJECT: CompTool * FILE: CompTool.goc * AUTHOR: Marcus Grber ***********************************************************************/ @include   #include   #include   #include   #define TEMPNAME ""COMPTOOL.000"" #define SUFFIX "" (p)"" /* Undocumented FileOpen flag forcing Geos files to open * as native files, for access to their file header: */ #define _FILE_FORCE_NATIVE 0x80 ************************************************************************** * Class & Message Definitions **************************************************************************/ @class CompToolProcessClass, GenProcessClass; @message void MSG_CTPROC_COMP_TRIGGER(); @message void MSG_CTPROC_DECOMP_TRIGGER(); @endc; @class @endc; CompToolFileSelectorClass, GenFileSelectorClass;  @start Interface; @object CompToolAppClass CompToolApp = { GI_visMoniker = @list{ @TextMoniker }; GI_comp = @CompToolPrimary; gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = @CompToolPrimary; } @object GenPrimaryClass CompToolPrimary = { GI_comp = @DataArea,@CompTrigger,@DecompTrigger; HINT_CENTER_CHILDREN_HORIZONTALLY; } @object GenInteractionClass DataArea = { GI_comp = @UnpackedSel,@PackedSel; HINT_ORIENT_CHILDREN_VERTICALLY; } @object CompToolFileSelectorClass UnpackedSel = { GI_visMoniker = ""Unpacked:""; GFSI_fileCriteria = FSFC_GEOS_NON_EXECUTABLES | FSFC_GEOS_EXECUTABLES | FSFC_NON_GEOS_FILES | FSFC_FILE_FILTER | FSFC_FILTER_IS_C; GFSI_attrs = FSA_HAS_FILE_LIST; ATTR_GEN_PATH_DATA = {SP_DOCUMENT,{"".""}}; ATTR_GEN_FILE_SELECTOR_FILE_ATTR = {FA_ARCHIVE, FA_SUBDIR | FA_HIDDEN | FA_SYSTEM | FA_READ_ONLY}; HINT_FILE_SELECTOR_SHOW_FILE_SIZE; HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW = 4; HINT_PLACE_MONIKER_ABOVE; HINT_MINIMIZE_CHILD_SPACING; } @object GenFileSelectorClass PackedSel = { GI_visMoniker = ""Packed:""; GFSI_fileCriteria = FSFC_GEOS_NON_EXECUTABLES; GFSI_attrs = FSA_HAS_FILE_LIST; ATTR_GEN_PATH_DATA = {SP_DOCUMENT,"".""}; ATTR_GEN_FILE_SELECTOR_CREATOR_MATCH = {{""CMPT""},16424}; HINT_FILE_SELECTOR_SHOW_FILE_SIZE; HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW = 4; HINT_PLACE_MONIKER_ABOVE; HINT_MINIMIZE_CHILD_SPACING; } @object GenTriggerClass CompTrigger = { GI_visMoniker = ""Pack""; GTI_destination = process; GTI_actionMsg = MSG_CTPROC_COMP_TRIGGER; HINT_SEEK_MENU_BAR; HINT_SEEK_SLOT = 0; } @object GenTriggerClass DecompTrigger = { GI_visMoniker = ""Unpack""; GTI_destination = process; GTI_actionMsg = MSG_CTPROC_DECOMP_TRIGGER; HINT_SEEK_MENU_BAR; HINT_SEEK_SLOT = 1; } @visMoniker TextMoniker = ""Compression Tool""; /* All program messages are stored in chunks, so the application can be translated without having to modify the source code: */  @class CompToolAppClass, GenApplicationClass; @endc; ************************************************************************** * UI Objects **************************************************************************/  28  P DA De velopers 4.5  Sept/Oct 1996   @chunk char textCompress[] = ""packed""; @chunk char textUncompress[] = ""unpacked""; @chunk char err0[] = ""File successfully \1.""; @chunk char err1[] = ""File to be \1 couldn't be opened or renamed.""; @chunk char err2[] = ""Destination file couldn't be created.""; @chunk char err3[] = ""No file selected to be \1.""; @chunk char err4[] = ""Error writing destination file. Memory full?""; @chunk char freeSpace[] = ""Unpacked: (%ldKb free)""; @end Interface; *********************************************************************** * Various routines and declarations ***********************************************************************/ const GeodeToken ourToken={{""CMPT""},16424}; const FileExtAttrDesc filterAttrs[] = {{ FEA_CREATOR, 0, sizeof(GeodeToken), NULL }, { FEA_END_OF_LIST, 0, 0, NULL}}; #define #define #define #define #define COMP_ERR_NONE COMP_ERR_SOURCE COMP_ERR_DEST COMP_ERR_NO_FILE COMP_ERR_WRITE 0 1 2 3 4  /* Close files */ FileClose(dst,FILE_NO_ERRORS); FileClose(src,FILE_NO_ERRORS); /* * * * * * This error checking not completely bullet-proof, but there seems to be no way of distinguishing between an error and destination size that is a multiple of 65536 when CompressDecompress() returns zero. In addition, a memory-full condition sometimes seems to go undetected. */  if(size==0 || (word)size!=ret) { FileDelete(dstName); /* remove invalid dest file */ FileRename(TEMPNAME,fname); /* undo renaming */ return COMP_ERR_WRITE; } /* Remove source file */ FileDelete(TEMPNAME); return COMP_ERR_NONE; } word DecompressFile(char *fname) { FileHandle src,dst; word ret; dword size; char dstName[FILE_LONGNAME_BUFFER_SIZE]; word len=strlen(fname); strcpy(dstName,fname); if(len>=4 && strcmp(dstName+len-4,SUFFIX)==0) dstName[len-4]=0; /* Open source file */ src = FileOpen(fname, FILE_ACCESS_R|FILE_DENY_W); if(!src) return COMP_ERR_SOURCE; /* Create destination file, fail if already exists */ dst = FileCreate(TEMPNAME, FCF_NATIVE|FILE_CREATE_ONLY|FILE_ACCESS_W|FILE_DENY_RW, FILE_ATTR_NORMAL); if(!dst) { FileClose(src,FILE_NO_ERRORS); FileRename(TEMPNAME,fname); return COMP_ERR_DEST; } /* Do all the work... */ ret = CompressDecompress( CLF_DECOMPRESS, src,NULL,0,dst,NULL ); size = FileSize(dst); /* size of destination file */ /* Close files */ FileClose(dst,FILE_NO_ERRORS); FileClose(src,FILE_NO_ERRORS); if(size==0||(word)size!=ret)/* see CompressFile() */ { FileDelete(TEMPNAME);/* remove invalid dest file */ return COMP_ERR_WRITE; } /* Remove source if same name as destination * (rename shouldn't fail). */ if(strcmp(fname,dstName)==0) FileDelete(fname);  const optr errorMsg[] = {@err0,@err1,@err2,@err3,@err4}; /* Pack/unpack a file in current working directory. The * resulting file is in the same place w/same name as * the original file: */ word CompressFile(char *fname) { FileHandle src,dst; word ret; dword size; char dstName[FILE_LONGNAME_BUFFER_SIZE]; strcpy(dstName,fname); if(strlen(dstName)<=12) strcat(dstName,SUFFIX); if(FileRename(fname,TEMPNAME)) return COMP_ERR_SOURCE; /* Open source file */ src = FileOpen(TEMPNAME, _FILE_FORCE_NATIVE|FILE_ACCESS_R|FILE_DENY_W); if(!src) return COMP_ERR_SOURCE; /* Create destination file, fail if already exists */ dst = FileCreate(dstName, FILE_CREATE_ONLY|FILE_ACCESS_W|FILE_DENY_RW, FILE_ATTR_NORMAL); if(!dst) { FileClose(src,FILE_NO_ERRORS); FileRename(TEMPNAME,fname); /* undo renaming */ return COMP_ERR_DEST; } FileSetHandleExtAttributes( dst,FEA_CREATOR,&ourToken,sizeof(ourToken)); /* Do all the work... */ ret = CompressDecompress( 0, src,NULL,0,dst,NULL ); size = FileSize(dst); /* size of destination file */  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  29   /* Rename destination file to its proper name. */ if(FileRename(TEMPNAME,dstName)) { if(strcmp(fname,dstName)!=0) FileDelete(TEMPNAME); return COMP_ERR_DEST; } /* Remove source if name is different from * destination . (This allows a graceful abort if * renaming fails because a file with * the original name already exists.) */ if(strcmp(fname,dstName)!=0) FileDelete(fname); return COMP_ERR_NONE; } /* Pack/unpack a file based on current selection in the UnpackedSel or PackedSel list: */ void ConvertAction(Boolean comp) { DiskHandle srcHandle; char srcPath[PATH_BUFFER_SIZE],*err; char fname[FILE_LONGNAME_BUFFER_SIZE]; dword ret; optr srcObj; /* * * * Suspend file selectors updates - @call makes sure that this message is delivered immediately, so it becomes effective before any notifications of file system changes arrive: */  PackedSel::MSG_GEN_FILE_SELECTOR_END_SUSPEND(); @send,forceQueue UnpackedSel::MSG_GEN_FILE_SELECTOR_END_SUSPEND(); } /* Update free space display for doc drive in moniker * of file selector showing names of unpacked files: */ void UpdateFreeSpace(void) { char buf[80]; dword free = DiskGetVolumeFreeSpace(SP_DOCUMENT); MemLock(OptrToHandle(@freeSpace)); sprintf(buf,LMemDeref(@freeSpace),free/1024); MemUnlock(OptrToHandle(@freeSpace)); @callUnpackedSel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT( buf, VUM_DELAYED_VIA_UI_QUEUE); } /* filter routine implements a kind of ""inverted * ATTR_GEN_FILE_SELECTOR_CREATOR_MATCH"", i.e. it * includes all files except those with ""our"" token: */ Boolean _pascal CompToolFilterRoutine(optr oself, FileEnumCallbackData *fecd, word frame) { GeodeToken *tok = FileEnumLocateAttr(fecd, FEA_CREATOR, NULL); return memcmp( tok,&ourToken,sizeof(GeodeToken))? FALSE:TRUE; } *********************************************************************** * Method definitions for object classes ***********************************************************************/ @classdecl CompToolProcessClass, neverSaved; @method CompToolProcessClass, MSG_CTPROC_COMP_TRIGGER { ConvertAction(TRUE); /* compress selected file */ UpdateFreeSpace(); /* show new free space */ } @method CompToolProcessClass, MSG_CTPROC_DECOMP_TRIGGER { ConvertAction(FALSE); /* decompress selected file */ UpdateFreeSpace(); /* show new free space */ } @classdecl CompToolAppClass; @method CompToolAppClass, MSG_META_GAINED_TARGET_EXCL { @callsuper(); /* better safe than sorry */ UpdateFreeSpace(); /* something may have changed */ } @classdecl CompToolFileSelectorClass; @method CompToolFileSelectorClass, MSG_GEN_FILE_SELECTOR_GET_FILTER_ROUTINE { /* This line causes ""Suspicious pointer conversion"" * with the OmniGo SDK, because the type of the * callback routine is incorrectly declared * without the ""_pascal"" keyword in gfselc.goh: */ static GenFileSelectorFilterRoutine *filterRoutine = CompToolFilterRoutine; /* see FSFILTER sample in SDK... */ filter->filterRoutine = filterRoutine; filter->filterAttrs = filterAttrs; }  @call PackedSel::MSG_GEN_FILE_SELECTOR_SUSPEND(); @call UnpackedSel::MSG_GEN_FILE_SELECTOR_SUSPEND(); srcObj = comp? @UnpackedSel:@PackedSel; ret = @call srcObj::MSG_GEN_FILE_SELECTOR_GET_SELECTION (fname); /* get current selection */ if( GFS_GET_ENTRY_FLAGS(ret) & GFSEF_NO_ENTRIES ) ret = COMP_ERR_NO_FILE; /* no file: abort */ else { @call srcObj::MSG_GEN_PATH_GET( srcPath,sizeof(srcPath)); srcHandle = @call srcObj::MSG_GEN_PATH_GET_DISK_HANDLE(); /* Set working directory to avoid path names... */ FileSetCurrentPath(srcHandle,srcPath); @call CompToolApp::MSG_GEN_APPLICATION_MARK_BUSY(); if(comp) ret = CompressFile(fname); else ret = DecompressFile(fname); @call CompToolApp:: MSG_GEN_APPLICATION_MARK_NOT_BUSY(); } UserStandardDialogOptr( 0, 0, 0, comp? @textCompress:@textUncompress, errorMsg[ret], ( (ret? CDT_ERROR:CDT_NOTIFICATION) << CDBF_DIALOG_TYPE_OFFSET)|(GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET )); /* Make sure updates are resumed after all messages currently in queue (especially file system notifications) have been dealt with: */ @send,forceQueue  30  P DA De velopers 4.5  Sept/Oct 1996   NIE Made Easy: The protoInetClient Ray Rischpater AllPen Software, Inc. dove@allpen.com hile Newton has long had support for AppleTalk networks, TCP/IP support has been lacking. Fortunately, Apple has reversed this trend with the Newton Internet Enabler (NIE), giving the Newton access to the Internet and TCP/IP intranets. In this article, I review TCP/IP fundamentals and describe a proto you can use to speed the development of your NIE-capable applications.  W TCP/IP  during run time. These port numbers are often referred to as ephemeral ports, as they are short-lived. Applications may listen on ports, awaiting connections, or initiate a connection to a remote port. The former are called servers, the latter clients. There are application-sp ecific protocols used by these applications to carr y their data between client and server. These protocols include the Domain Name Service protocol (DNS), which I discuss shortly, along with protocols for mail (POP and SMTP), file transfer (FTP), and many others.  The Newton Internet Enabler The NIE, which requires Newton OS 2.0, is an implementation of a TCP stack, including TCP, UDP, and IP, along with SLIP and PPP protocols for serial and modem connections. In addition, the NIE also has:  A link layer manager, capable of conditioning a serial channel to accept a link by exchanging strings v ia an expect/response mechanism, and capable of shar ing the link with multiple applications;  A Domain Name Resolver (DNR), implementing the Domain Name Service for the conversion of symbolic host names to their IP addresses and the reverse;  A setup application to enter the details of connecting to an Internet Service Provider (ISP); and  An interface to TCP and UDP via NewtonScript endpoints. While not necessarily part of a traditional TCP/IP implementation, the first two items are found in most TCP/IP implementations. They make software development significantly easier. The link layer manager has an API of global functions for selecting an ISP, establishing a link, and releasing a link once the connection is complete. The API is asynchronous, so your application can do other tasks while a link is being created or destroyed. In addition, your application can receive status v ia a callback method which is called periodically during the course of an operation. The DNR is a bare-bones Domain Name Service client. It's capable of finding an IP address for a host name or the reverse, a mail server's IP address, or the name of a particular host. If you need more robust services for domain management, you need to write your own DNS client. Like the link layer manager, its operations are asynchronous. As part of the NIE, an Internet Setup application is included so that users can enter the details of establishing a connection w ith their ISP. The Internet Setup application is only required while a Newton is being set up to access a network (entering the required phone number, SLIP or PPP, any scr ipting necessary to connect with the service, and so forth). Once a Newton is set up, the Internet Setup application can be removed to recover the memory it uses. The fa ct that the NIE's interface to TCP/IP endpoints is v ia the standard protoBasicEndpoint makes using the endpoints extremely easy for programmers already proficient with Newton communicat ions programming. The NIE includes some text files which contain constant function declarations for various NIE endpoint.  Developed in the sixties, seventies, and early eighties, TCP/IP is the generic name for a suite of network protocols. TCP/IP quickly became the reference for other network protocols, and the de facto standard for what is now the Internet. The suite has been adopted worldwide, with implementations available for almost every operating system. TCP/IP takes its name from two of its most-used components, TCP and IP. The protocol is packet-based, with data being broken up into little packets before being sent and reassembled on the receiving end. TCP/IP is an open protocol, with public standards and public implementations. The TCP/IP protocols are organized as a stack of protocols, each protocol building on the functionalit y and features of the protocols below it (this is why you often hear implementations referred to as stacks). At the bottom of the stack is the physical layer, such as a serial or Ethernet cable, responsible for carrying the raw bits between devices. Above this is the link layer, responsible for the transport of datagrams across the physical layer. PPP and SLIP are link-layer protocols, encapsulat ing the higher-level protocols so they may be carried across a serial cable. PPP (the Point-to-Point Protocol) is a well-defined standard for encapsulating IP and other protocols for transport across circuitswitched links such as modems and serial cables from one point to another. SLIP, the Serial Line Internet Protocol, is essentially a simpler way to do the same thing, with far fewer f eatures than PPP. Above these layers is the first real protocol belonging to the stack, the Internet Protocol (IP). This protocol provides mult iplexing and demultiplexing of the protocols above IP, along with pa cket assembly and disassembly. Additionally, it provides addressing for all hosts on an Internet. Hosts are addressed using a thirty-two bit integer (commonly called the IP Address), divided up into eight-bit chunks separated by decimal points. Part of this number indicates a destination network, while the remainder indicates a destination host on the target network. The number of bits use d for each vary from site to site, so the entire IP address is always used to refer to a host. You never use the IP protocol directly, but use its features with both UDP and TCP. The remaining protocols rely upon IP to carry data. The first two, ICMP and IGMP, are used to control routing, connectivity, and groups of Internet hosts. More important us are TCP and UDP. UDP, the User Datagram Protocol, is the protocol closest to IP. A connectionless, unreliable protocol, each output operation produces exactly one UDP datagram, which in turn generates one IP datagram. While UDP does not provide guaranteed deliver y or a retry mechanism, it does provide a checksum on the data being sent, assuring that if data arrives at its destination it is free from errors. TCP, the Transmission Control Protocol, uses IP to carry a reliable byte stream between two Internet nodes. A connection-oriented protocol, it also provides the reliability one would expect in a byte stream, including checksums to ensure data integrity, retries for lost packets, and similar features. TCP is analogous to Apple's ADSP protocol in its characteristics, although the implementation is naturally different. TCP/IP uses sixteen-bit port numbers to multiplex connections and identify client applications. Some port numbers, used by servers, are fixed and referred to as well-known ports (for example, HTTP servers use port 80). Well-known ports, which range from one and 1023, are assigned by the Internet Assigned Numbers Authority. Other port numbers are dynamically assigned by the appropriate protocol stack  The protoInetClient protoInetClient is a simple proto designed to hide the details of the NIE and the protoBasicEndpoint in client applications. The interface to the protoInetClient is deceptively simple:  Include the text files provided with the NIE, and the protoInetClient file, in your project file.  Create a frame inheriting from the protoInetClient with slots indicating the type of transport (TCP or UDP), along with the destination port and address.  Call :Open() to establish the link and connect the endpoint. Pass a callback specification (identical to those detailed in the Communicat ions part of the Newton Programmer's Guide) whose completionScript is called when the connection is made.  Use the endpoint returned in your completionScript to perform the input and output required by your application. P DA DE 4.5  Sept/Oc t 1996  VELOPER S  31    When complete, call :Close() on the endpoint to close and destroy the endpoint and release the underlying link layer. The protoInetClient handles the link layer and DNR if required. Once the link is established, it instantiates, binds, and connects your endpoint, so that your application can focus on the TCP/IP communications as a whole. When complete, the proto disconnects, unbinds, and disposes of the endpoint, and releases the link on your application's behalf. When instantiating a protoInetClient, you need to provide informat ion in the following slots:  fTransport, which contains either kTCP or kUDP indicating whether the endpoint is to provide TCP or UDP services;  fDestinationAddress, either a string containing a remote host name, or an array of four integers indicating an IP address;  fDestinationPort, the destination port number;  fSourcePort, an optional source port number; and  fStatusProto, the proto for a status view to b e used in notifying users regarding the status of communicat ions.  if inAction='connect then begin gState:='linking; fStatusView:={ _proto: if fStatusProto then fStatusProto else GetLayout(""protoInetStatusTemplate"")}; InetGrabLink(nil, self, 'mGrabCb); end else gState:=nil; end;  Next, call InetGrabLink() to request the link indicated by the user. InetGrabLink() uses the same arguments as InetCon nectionSlip(). Unlike the latter function, however, the callback is invoked multiple times, and takes three arguments:  The link ID in use;  The cur rent status of the link as a status frame; and  An error code or nil if no error occurs. Acquiring a link can take a relat ively long period of time, as the device may have to dial a modem, execute a chat script to reach a PPP or SLIP stream, and then continue. Because of these potential delays, InetGrabLink() invokes a callback periodically to notify the user of the current progress in establishing the link. You need to create a status template for this callback to present to the user. The status slip can contain anything you find appropriate, as long as it inherits from the protoInetStatusTemplate supplied with the NIE. If you do not provide a status slip to the link layer manager, it generates one based on the protoInetStatusTemplate. In your callback, you can use the NIE function InetDisplayStatus() to keep the user appraised of status: mGrabCb:=func(inLinkID, inStat, inErr) begin fLinkID:=inLinkID; if inErr then begin :mNotifyError(""InetGrabLink"", inErr); gState:=nil; end else begin InetDisplayStatus(inLinkID, fStatusView, inStat); if inStat.linkStatus='connected then begin gState:='linked; InetDisplayStatus(inLinkID, fStatusView, nil); fStatusView:=Nil; /* DNS Stuff shown below goes here */ end; end; end  Connecting the protoInetClient C onnec ting the Link L ayer Before a TCP or UDP endpoint can be used, the link layer must be initialized and a link established: 1. Give the user an oppor tunity to select a link by calling InetOpenConnectionSlip(). 2. Call InetGrabLink() to request a link from the system. Pass a callback that is used to notify you of the stat us of the link establishment. In your callback, call InetDisplayStatus() to notify the user of this progress. 3. Once the link is established, use NIE endpoints like you would in any other application. Alternatively, use InetGetLinkStatus() to determine the current status of the link. 5. Call InetReleaseLink() to relinquish your link after disconnecting your endpoints. Recall that the link manager routines are all asynchronous. They all take a context and a method name (represented as a symbol) in addition to other arguments; the method is invoked when the call is complete. The InetConnectionSlip() method presents the user with a slip for selecting their ISP if no link is currently active. This slip allows them to select their current emp orium and indicate which ISP should be used. You pass three arguments to InetConnectionSlip():  The initial ID of the link to be offered (or nil to have the system select one for you);  A context frame to receive the callback message; and  A symbol representing the method to be invoked on the callback. Once the user makes a selection, the callback is invoked with a single argument. This argument may be either nil (indicating that the connection is to be aborted) or 'connect. If a link is active, the slip is not displayed, the existing link is used, and the callback is immediately invoked with the 'connect symbol. For example: Open:=func(inCallbackSpec) begin if gState then return; gState:='choosing; InetOpenConnectionSlip(nil, self, 'mConnectSlipCb); gCallbackSpecs:=Clone({}); gCallbackSpecs.fOpen:=inCallbackSpec; end; mConnectSlipCb:=func(inAction) begin  InetDisplayStatus() is like a Swiss Army knife  you can use it to do many things. Regardless of the result you desire, pass the current link ID, a reference to your status v iew, and a reference to the status frame your callback receives. The function shows or hides the status dialog and updates the status indicator with the text of the current status as indicated by the incoming arguments. Table 1 on the next page shows the relationship between the arguments to InetDisplayStatus() and the resulting actions taken.  32  P DA De velopers 4.5  Sept/Oct 1996   Determining a Remote Address If you're writing a general-purpose application, you probably need to know how to use the NIE's Domain Name Resolver. It uses DNS to convert human-readable host names such as ""CDPUBS.COM"" to its Internet address equivalent, a four-byte address. In addition to host name conversion, you can also find a mail server's name or address given a host name. The DNR also provides asynchronous processing. When issuing a request, you pass the data for your request along with a context frame and method identifier, and await your callback's invocation indicating the result of your query. You access the DNR functions using the following global functions:  DNSGetAddressFromName(), which converts a st ring host name to its IP equivalent;  DNSGetMailAddressFromName(), which finds the IP address for a mail server given a host name;  DNSGetMailServerFromName(), which returns the name of the mail server given a host name;  DNSGetNameFromAddress(), which returns a host name given the IP address; and  DNSCancelRequests(), which cancels all requests associated with a specific context frame. The first four functions each require three arguments: the key for the data to be retrieved, the client context, and a symbol denoting the callback. The cancellat ion function takes only a client context and callback symbol. All callba cks but the cancellation callback are invoked with a results array and result code. The results array contains an array of result frames, containing one or more of the following slots:  type, the result type (one of kDNSAddressType or kDNSDomainType);  resultDomainName, a string containing the result ing domain name; and  resultIPAddress, an array containing the four-byte IP address. The protoInetClient uses the DNR to determine the appropriate IP address from the incoming host name as needed using the following: ... if ClassOf(fDestinationAddress)='string then DNSGetAddressFromName( fDestinationAddress, self, 'mDNSResultCb); else begin fDestAddrAsArray=fDestinationAddress; :mInstantiateAndBind(); end; ...  mDNSResultCb:=func(inResultArr, inResultCode) begin local myAddrFrame; local myHandyAddresses:=Clone([]); if inResultCode then begin print(""DNS lookup failed due to "" && inResultCode); call gCallbackSpecs.fOpen with ( nil, nil, inResultCode); end else if Length(inResultArr)=0 then begin print(""DNS lookup failed - returned no addresses!""); call gCallbackSpecs.fOpen with (nil, nil, -8007); end else begin fDestAddrAsArray:=inResultArr[0].resultIPAddress; :mInstantiateAndBind(); end; end;  C onnec ting an Endpoint Once the link layer is established, your ap plication can use TCP or UDP endpoints. The interface to these endpoints is identical to the interface used with other kinds of endpoints: you indicate the type of endpoint desired via a service class option, set other appropriate options, and then instantiate, bind, and connect your endpoint. This endpoint started life in the method :mInstantiateAndBind(): mInstantiateAndBind:=func() begin gEndpoint :={ _proto: protoBasicEndpoint, _parent: self, gState: nil, ExceptionHandler:func(inExp) begin local myErr; if HasSlot(inExp, 'error) then myErr:= inExp.error; else if HasSlot(inExp.data, 'errorCode) then myErr:= inExp.data.errorCode; if myErr<>kCancellationException then :Notify(kNotifyAlert, kAppName, ""Something bad happened - "" & myErr); :mTearDown(self); end, EventHandler:func(inEvent) begin if inEvent.eventCode= kCommToolEventDisconnected then begin :Notify(kNotifyAlert, kAppName, ""The other side has disconnected."" & myErr); :mTearDown(self); end else print(""An event we didn't expect ("" & inEvent.eventCode & "") occurred.""); end, };  Second Argument (view template) nil Template of a status view A currently shown status template  Third Argument (status) nil Status frame (non-nil) nil  Results  Returns a reference to a default status view, and opens the view for you. Uses the template as the status view and and displays the status. The status view is closed and destroyed.  Table 1 - InetDisplayStatus () arguments and results.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  33   try myErr:=gEndpoint :Instantiate(gEndpoint, call kGetEndpointConfigOptions with (fLinkID, fTransport)); onexception |evt| do begin :mNotifyError(""Instantiate"", 0); return; end; if myErr then begin :mNotifyError(""Instantiate"", myErr); return; end; myEp.gState:='instantiated; local myPortOpt; if fTransport=kUDP then begin // Assign an ephmereal. Hope it's not used. if NOT fPort then fPort=Random(1024, 65535); myPortOpt:=call kINetBindOptions with (0, fPort); end; try myErr=gEndpoint:Bind( myPortOpt, { _parent: self, async: true, CompletionScript: mBindCb, } ); onexception |evt| do begin :mNotifyError(""Bind"", 0); :mTearDown(); return;  end; if myErr then begin :mNotifyError(""Bind"", myErr); :mTearDown(); return; end; end  The only surprises here are two constant compile-time functions used to generate the various arguments  kGetEndpointConfigOptions and kINetBindOptions. The NIE has several compile-time functions that aren't well documented in the NIE manual, but can make your life significantly easier. They are listed in Table 2 for your reference. kGetEndpointConfigOptions generates the three options necessary to select the NIE's C tool. The options are used to request the NIE via the 'inet option, specify the link to be used with the 'ilid option, and indicate the desired transport via the 'itsv option. kINetBindOptions specifies the local (source) port your application is using. Most standard Internet applications have a wellknown port, where client applications can find them. This port is listened to by servers; also, clients can specify that port as the destination port and use a randomly assigned port for their source port. If you're writing a client application, you probably don't need to specify the local port, unless you're using UDP. protoInetClient makes up a local port if you don't pick one for UDP endpoints, but you run the risk of col liding with another port in use by the NIE  the port assig nment algorithm I use isn't very robust. kINetBindOptions creates an 'ilpt option frame with the desired local port. Note that protoInetClient invokes Bind() asynchronously. When it's complete, notification is provided via the invocation of :mBindCb():  Function kNumtoHostAddr kHostAddrToNum kIsIPAddr  Arguments inAddrArr inAddrStr inAddrStr  Purpose Turns an address into a string in the form ""a.b.c.d"" Turns a string address in the form a.b.c.d to the four-byte IP address. Examines the incoming string and tries to see if it's an IP address in the form :a.b.c.d"". Right now it's not very robust, so use it with caution. Creates an options array for use when an NIE endpoint is instantiated. Creates an options array for use when an NIE endpoint is bound. Creates an options array for use when an NIE TCP endpoint is connected. Finds the error number associated with an exception. Looks up a string associated with the NIE error code indicated. Creates an options array for use with a UDP endpoint when data is to be output.  kGetEndpointConfigOptions kINetBindOptions kTCPConnectOptions kGetExceptionError kGetInetErrorStr kUDPPutBytesOptions  inLinkID inProtocol inLocalPort inUseDefaultPort inRemoteAddrArr inRemotePort inExp inErr inAddrArr inPort  Table 2 - NI E constant functions defined by include files.  34  P DA De velopers 4.5  Sept/Oct 1996   mBindCb:=func(inEp, inOpt, inRes) begin if inRes then begin :mTearDown(inEp); if inRes<>kCancellationException then :mNotifyError(inRes); end else begin inEp.gState:='bound; local myConnOpt; if fTransport=kTCP then myConnOpt:=call kTCPConnectOptions with (fDestAddrAsArray, fDestinationPort); try inEp:Connect(myConnOpt, { _parent: self, async: true, CompletionScript: mConnectCb, } ); onexception |evt| do begin :mNotifyError(""Bind"", 0); :mTearDown(); return; end; if myErr then begin :mNotifyError(""Bind"", myErr); :mTearDown(); return; end; end; end;  If you're using UDP, your arguments to Connect() are somewhat different. Rather than passing a destination port and socket, you pass nothing. Although the endpoint interface is a connection-oriented API, the UDP interface itself is connectionless. When using UDP, you can also pass the destination port and address to your endpoint's Output() me thod, so that one UDP endpoint can contact many UDP servers.  Input and Output with the NIE Get ting Input If you've worked with Newton communications before, using NIE should be easy. Your applications should post an input specification and wait for data to come to your application. For example, here's a primitive input specification for a Newton ""Telnet"" server which provides access to a NewtonScript interpreter over TCP: local myExcludeStr:=kUnicodeLF & kUnicodeBS; local myInputSpec:={ form: 'string, termination: {endSequence: unicodeCR}, inputScript: func(inEp, inData, inTerm, inOpt) begin local myCodeBlock, myResult; StrFilter(inData, myUnicodeLFStr, 'rejectAll); try myCodeBlock:=Compile(inData); onexception |evt| do :mOutput(""An error occurred compiling your code"" & kUnicodeCR & kUnicodeLF); try myResult:=SPrintObject(call myCodeBlock with ()); onexception |evt| do :mOutput(""An error occurred executing your code"" & kUnicodeCR & kUnicodeLF) if myResult then :mOutput(myResult & kUnicodeCR & kUnicodeLF); end, completionScript: func(inEp, inOpt, inRes) begin if inRes<>kCancellationException then begin print(""Input spec saw error "" & inRes); :mTearDown(inEp); end; end, }; gEndpoint:SetInputSpec(myInputSpec);  Note that I could use Listen() here if I want the application to sit on a local port waiting for an incoming request. Since the application is a client application, I use Connect() to connect the endpoint to the remote server, indicating the ser ver's destination address and port. The connection callback is about what you'd expect: mConnectCb:=func(inEp, inOpt, inRes) begin if inRes then begin :mTearDown(inEp); if inRes<>kCancellationException then :mNotifyError(inRes); end else begin inEp.gState:='connected; inEp.Close:=func() begin if kDebugOn then print(""Close""); :mTearDown(self); end; gCallbackSpecs.fOpen:?CompletionScript( inEp, nil, nil); end; end  At this point, control is passed to the application, and you can exchange data freely w ith the server you've contacted.  This code builds an input specification which looks for strings ending in carriage returns. When it receives one, it attemp ts to compile the string into NewtonScript code and execute that code, outputting the result with the output function I describe shortly. If you're learning Newton from a streams-based OS such as UNIX, you probably need a bit of background on input specifications. Rather than using tradit ional input streams, the Newton OS uses input sp ecifications, which describe the format of the information your application expects to receive. You build an input specification (or input spec for short) using data such as the class of the incoming data, its length or an array of possible termination characters which mark the end of an input operation, and how long the OS should wait for input or communications flags which denote the end of input. The spec is used by the Newton OS to wait f or input on your application's behalf while the application is running. Once the conditions are met, the program's InputScript is invoked to pass you the input. If the input spec is never satisfied, the P DA DE 4.5  Sept/Oc t 1996  VELOPER S  35   CompletionScript may be invoked to notify you of this condition. (This happens if you're expecting data in a window of time, or if the endpoint is closed while you're expecting input.) Your application can switch between active input specs by using the endpoint method SetInputSpec(), which sets the endpoint's input specification to a specific frame. Using mult iple input specifications makes writing state machines very easy. When planning a new application, take pains to be sure you develop a good state machine to represent input. The effort you put in during the design phase is repaid a thousand fold when your application's communications code is almost entirely an array of input specifications and their scripts. If you're new to working w ith state machines and communications, check out the Newton DTS sample CommsFSM, which has enough to get you started. Unfortunately, the input specification mechanism makes p orting code some what difficult, since many legacy applications hide their state machines behind a streams-oriented communications interface. If you're porting code, be prepared to have a good grasp of the underlying data protocol, and represent the protocol as a state machine using (possibly mult iple) input specifications. At all costs avoid the temptation of simulating a stream with an endpoint  it's overly expensive and you almost never need the true functionality of a byte stream. If you use UDP, you need to know the port from w hich your application receives its data. Also, odds are that you'll want to receive entire packets. Here's a simple example of how to do that: local myInputSpec:={ form: 'string, termination: {useEOP: true}, rcvFlags: kPacket, rcvOptions: { label: ""iuss"", type: 'option, opCode: opGetCurrent, result: nil, form: 'template, data: { arglist: [ [ 0,0,0,0 ], // Host address 0, // Host port ], typelist: [ 'struct, ['array, 'byte, 4], ], }, inputScript: func(inEp, inData, inTerm, inOpt) begin // Do something with the data end, completionScript: func(inEp, inOpt, inRes) begin if inRes<>-16005 then begin print(""Input spec saw error "" & inRes); :mTearDown(inEp); end; end, }; gEndpoint:SetInputSpec(myInputSpec);  As with all things, there's an exception in receiving data that you should know about. The TCP protocol supports the notion of expedited data, which is sent out-of-band at a higher priority than other data. When using a TCP endpoint, data sent with the expedited bit asserted isn't passed to your application via normal means. Rather, it's sent as an event to your endpoint's event handler. Here's a trivial example of an event handler: EventHandler:func(inEvent) begin if inEvent.eventCode=kCommToolEventDisconnected then begin :Notify(kNotifyAlert, kAppName, ""The other side has disconnected."" & myErr); :mTearDown(self); end else if inEvent.eventCode=kEventToolSpecific then print(""Expedited data! The byte was"" & inEvent.data); else print(""An event we didn't expect ("" & inEvent.eventCode & "") occurred.""); end,  Outputting Data Outputting data is no more difficult than it is with any other endpoint. You construct an object with your outgoing data and use the endpoint's Output() metho d to send the data: mOutput:=func(inStr) begin try local myErr:=gEndpoint:Output(inStr, nil, nil); onexception |evt| do begin :Notify(kNotifyAlert, kAppName, ""Something bad happened on Output - "" & myErr); :mTearDown(); end; if myErr then begin :Notify(kNotifyAlert, kAppName, ""Something bad happened on Output - "" & myErr); :mTearDown(gEndpoint); end; end;  When calling Output() you can also specify an ar ray of options and an output specification frame. For example, when you send UDP packets, you need to include the kPacket and kEOF flags in the sendFlags slot of your output specification, specify a destination address and port, and use one cal l to Output() to send your entire packet: try gEndpoint:Output(""Hello world!"", call kUDPPutBytesOptions with ( fDestAddrAsArray, fDestinationPort), { async: nil, sendFlags: kPacket+kEOF, }); onexception |evt| do /* Traditional error handling here! */  The inOpt argument to the inputScript contains the options array w ith the sender's IP address and port, which you can use to resp ond to the sender. Note that the termination specification indicates that Newton should be looking for the end-of-packet identifier, and the receive flags indicate that you expect an entire packet.  As another example, consider sending expedited data over TCP. You need to send each byte independently and use the expedited option:  36  P DA De velopers 4.5  Sept/Oct 1996   local myOpt:={ label: ""iexp"", type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { argList: [ 15, // expiditedData byte ], typelist: [ 'struct, 'byte, ], }, } try gEndpoint:Output("""", myOpt, nil); onexception |evt| do /* Traditional error handling here! */  mDisconnectCb:=func(inEp, inOpt, inRes) begin try inEp:Unbind({ _parent: self, async:true, completionScript:func(inEp, inOpt, inRes) begin :mUnbindCb(inEp, inOpt, inRes); end; } ); onexception |evt| do nil; end; /* and the other callbacks look similar...*/  Tearing Down and Cleaning Up C losing the Endpoint When a user calls the Close() method of an endpoint created by the protoInetClient, the endpoint is disconnected, unbound, disposed, and the link layer manager releases the link in use. NIE endpoint teardown is accomplished in a manner identical to that of other endpoints: /* Endpoint's Close() method calls :mTearDown(self) */ mTearDown:=func(inEp) begin if inEp.gState=nil then begin print(""We do nothing.""); end else if inEp.gState='instantiated then begin :mUnBindCb(inEp, inOpt, inErr); end else if inEp.gState='bound then begin :mDisconnectCb(inEp, inOpt, inErr); end else if inEp.gState='listening then begin inEp:Cancel( { async: true, completionScript:func(inEp, inOpt, inErr) :mDisconnectCb(inEp, inOpt, inErr) }); end else if inEp.gState='connected then begin inEp:mDisconnect(); end else if kDebugOn then print( ""Endpoint is already closing!""); end  Two things are worth noting here. First of all, there is an internal state variable to determine the current operation. It's best if you merge your application's communications state machine with the state machine you developed for handling input when you wrote your protocol engine. It makes the code clearer to readers, and easier to maintain. Secondly (and this may seem a bit odd), be sure you wrap the endpoint's teardown metho ds in exception handlers. Your endpoint may be torn down after some thing bad has already happened to an open connection. In addition, it prevents uncaught exceptions from scaring your users.  Releasing the Link Since the link layer manager tracks link usage using reference counts, it's imperative that you release the link when you're done using an endpoint. The Newton keeps the link active as long as other applications may be using a NIE endpoint, and then shuts down the link itself. (It's also a good idea to release the link if your application has a period of inactivity  running a modem can cause a large battery drain.) Releasing the link is simple; call InetReleaseLink() with the same arguments you called InetGrabLink(): mUnbindCb:=func(inEp, inOpt, inErr) begin local i; try inEp:Dispose(); onexception |evt| do nil; gState:='stopping; InetReleaseLink(fLinkID, self, 'mReleaseCb); end; mReleaseCB:=func(inLinkID, inStat, inErr) begin if inErr then begin :mNotifyError(""InetReleaseLink"", inErr); gState:=nil; gEndpoints:=nil; gCallbackSpecs.fStop:?CompletionScript( self, nil, inErr); gCallbackSpecs:=nil; end else begin if inStat.linkStatus='idle then begin InetDisplayStatus(inLinkID, fStatusView, nil); gState:=nil; gEndpoints:=nil; gCallbackSpecs.fClose:?CompletionScript( nil, nil, nil); end; end; end P DA DE VELOPER S  4.5  Sept/Oc t 1996  37   InetReleaseLink() requires three arguments  the link ID, a reference to a status v iew if appropriate, and what to put into the status view (or nil to conceal it entirely). Be sure your application has the same number of InetGrabLink()and InetReleaseLink() calls. It's embarrassing to leave the link open, or clo bber it for another application.  The NIE 1.0 API John Schettino GTE Laboratories, Inc. js12@gte.com  Some Thoughts On Software Quality & Support When developing your application, you're going to need to do testing. There are a few areas with the NIE where testing is more important than you might think:  Be sure you  Test all exce  Verify your application product, so issues. check all b oundary conditions. ption and event handlers. software with multiple servers (or clients, if your is a server), ISPs, and modems if it's a commercial you can warn your customers about compatibility  N  When developing an intranet application, consider yourself lucky. You're working w ith an application in a comparatively known space. If you're developing an application for the Internet, however, make sure you schedule what may seem like an inordinate amount of testing time. The Internet is one big distributed system. You'll see a lot of failures you don't expect. Unfortunately, not all of them will be yours: I can think of a few late nights I've spent tracing failures which turned out to be routing, not application failures. Support for applications using the NIE is another area you need to be prepared for. Although the NIE provides one of the best environments for setting up ISPs I've ever seen, it's by no means clear to all users. You're likely to receive calls about modems and ISPs you've never heard of, along with questions like ""Will it work with my shell account?"". The Internet is probab ly a new thing to many of your users. You need to be prepared to make their initial experience with it as pleasant and painless as possible.  ewton has been on the Internet in one form or another for a few years now. Getting connected usually entails baroque UNIX shell dial-ups followed by Telnet sessions. While this method works (as is evident in both the LunaSuite and GoFetch transports), the user setup is difficult and the connection tenuous at best. The Newton Internet Enabler (NIE) provides a direct network connect between the Newton and an Internet Service Provider (ISP) using either PPP or SLIP dial-up protocols. Once connected, you have a direct connection to the net as a first-class computing device. You can open sockets to as many addresses and ports as you like, accept and send UDP packets, and even listen for connections. In this article I present an overview of the NIE API and show how you can use the NetTest sample application to quickly write an NIEenabled application.  NIE API The NIE consists of three distinct components: the Inet tool, the Link Controller, and Domain Name Service. The Inet tool, which provides the majority of the actual socket communications capabilities neatly disguised as our old friend a communications endpoint, is at the top layer. Once you've connected you can (for the most part) think of a TCP/IP socket as a very reliable serial endpoint connection. Bravo. Above that (meaning you need to deal with this before getting connected) is the Link Controller. This is where you initiate and drop connections to the Net. Finally, there are several functions to translate Internet name-based addresses (such as ""WWW.YAHOO.COM"") into an actual IP address (four numbers separated by p eriods, as in 205.216.146.70).  Link C ontroller  Get ting C onnec ted  Putting It All Together If you're new to Newton communications programming, this article is probably a bit overwhelming. On the other hand, if you've been developing Newton applications with communications for a while, there shouldn't be all that much new material. The important points you should remember when writing an Internet-enabled application are:  The NIE endpoints are exactl y like any other child of protoBasicEndpoint.  The NIE provides global functions for link layer establishment and teardown.  The NIE provides global functions for Domain Name Resolution.  The NIE's APIs are all asynchronous. If you keep these points firmly in hand, you can't go too far astray. If you're new to Newton development, it's b est to develop a few communicating applications before you start that killer application. Like many things, Newton software development (and understanding the communications APIs in particular) gets easier with practice. Regardless of your background, the NIE is something that Newton developers have been waiting for. It's now up to us to help bring the promise of the Newton OS to the Internet. The source code f or NIE Ray's proto can be found on the source code disk for this issue of PDA Developers.  The first thing the Newton must do to use Internet services is to get wired in to the net. Once this is done, the Newton is just another node on the net with an IP address. The Link Controller initiates and destroys this link. There are thirteen functions relating to the Link Controller, but only three do the most common tasks. The first step in the connection process is to let the user review and modify their configuration options. The InetOpenConnectionSlip() function presents a standard NIE connection slip to the user and calls a supplied cal lback once it is dismissed: InetOpenConnectionSlip (link, context, callback)  Further Reading Apple Computer, Inc. 1995. Ne wton Programmers Guide: Communications. Apple Computer, Inc. Cupertino, CA. Apple Computer, Inc. 1995. Newton Internet Enabler. Apple Computer, Inc. Cupertino, CA. Stevens, W. Richard. 1994. TCP/IP Illustrated. 3 volumes. AddisonWesley Publishing, Menlo Park, CA.  If the Newton is already connected it does not open the slip, it just calls the callback method. The function itself returns nil if the Newton is already connected, or the open slip view if it is not. The link ID is supplied in link. This ID can either be nil, to use the default user-specified ID, or the value returned by InetAdd NewLinkEntry() (you almost always use the default). The context and callback parameters are usually your application's frame, and a symbol for the method defined in that frame. The callback method is called with three parame ters (link, status, and error) once the connection slip is dismissed. The link parameter is the same as used in the InetOpenConnectionSlip() call. The status parameter is a frame containing a single slot named linkStatus. If the value of linkStatus is 'connect then you should proceed with the connection. The error parameter is either nil for success or an error code indicating the error condition. Assuming that the user wants to proceed with the connection, the next step is to g rab a link by calling InetGrabLink: InetGrabLink (link, context, callback)  38  P DA De velopers 4.5  Sept/Oct 1996   This is where your Newton gets plugged into the Internet. As in the previous function, you can call InetGrabLink even if your Newton is already connected, in which case it just calls the callback with a 'connected value in the linkStatus slot of the status frame. callback is called at several points in the connection process, so that you can provide feedback (and a means of canceling the operation) to the use r. The actual connection can take several seconds. The status usually proceeds through the fol lowing steps: 'idle 'initializing 'connecting 'login 'connected link not established initial setup preceding a connection dialing up the ISP connected to ISP, executing login script link made and ready to use  The next step is to use the Bind() endpoint method to bind that endpoint to a local TCP/IP address and port. When making an outgoing connection, this can be a dynamically-allocated local port. These options get a local port: [{ label: ""ilpt"", // set the local port type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { arglist: [0, true, ], typelist: [ 'struct,'short,'boolean, ],},},]  During this connection process you can use InetDisplayStatus()to display the connection progress. This function can use a view of your own design (based on a protoStatusTemplate) or it can create a floating slip containing a text display area and a stop button for you. Once the status is 'connected, you can use the link to create one or more sockets. When you're done with the link you use InetReleaseLink() to drop the link: InetReleaseLink (link, context, callback)  Finally, you're ready to connect to the TCP/IP service. These services reside at known IP addresses and ports. For example, to bind to the Yahoo web server you'd use ""WWW.YAHOO.COM"" at port 80. You use the DNS service to convert that address into the needed numbers. Use the Connect() endpoint method to make the connection, supplying these options: [{ label: ""itrs"", type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { arglist: [addr1, addr2, addr3, addr4, portNo], typelist: [ 'struct, 'byte, 'byte, 'byte, 'byte, 'short,],},},];  Based on the user preferences this may or may not actually disconnect the Newton from the Internet. It's important to note that the context supplied here should be the same as that used in the InetGrabLink() call.  Using a Soc ket When They C all it an Endpoint The NIE uses standard Newton endpoints to establish the actual Internet connections. This is both a very cool thing and a bit confusing for those of us with UNIX socket programming backgrounds. Depending on the type of connection you're making (TCP or UDP) and if you're initiating the connection or waiting for a connection, you've got more or less work to do. Let's look a the simple case of making an outgoing TCP connection. You use the familiar Instatiate() method on your endpoint, supplying the following options: [ { label: ""inet"", type: 'service, opCode: opSetRequired, result: nil, }, { label: ""ilid"", type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { arglist: [ link, ], typelist: [ 'struct, ulong, ],},}, { label: ""itsv"", type: 'option, opCode: opSetRequired, result: nil, form: 'template, data: { arglist: [ protocol, ], typelist: [ 'struct, 'ulong, ],},},]  addr1..addr4 and portNo values correspond to the four segments of the target Internet address and the port number to connect to. Once this connection is established you send and receive information over the endpoint as usual. To disconnect an endpoint you use the standard Disconnect(), Unbind(), and Dispose() methods.  Domain N ame Service How do you find the know the host name (80 for HTTP). This functions, but by far FromName(): actual IP address for your service? Usually you (""WWW.YAHOO.COM"") and the port number is where the DNS comes in. There are four DNS the one you use most is DNSGetAddress-  DNSGetAddressFromName (hostname, context, callback)  hostname is the host name you're looking up, context and callback are used for the callback as in the Link Controller. The callback func tion takes two par ameters. The first is an array of fr ames containing addresses that can be used for the host name. The second is the result code or nil for no error. A typical callback function just extracts the desired address: func(results, error) begin if error or length(results) < 1 then begin // handle error return; end; // save the resolved address hostIpAddr := results[0].resultIPAddress; end;  The v alue in hostIpAddr is an array of four numbers, corresponding to the IP address f or the host.  The ""inet"" option identifies this as an Internet endpoint, ""ilid"" specifies the link ID, and the ""itsv"" option identifies the protocol to use. The protocol is 1 for TCP and 2 for UDP.  A Brief Word From our Sponsor You have total control over how your NIE-enabled application does things, but there are a few very useful tools that you should look at before you begin coding everything from scratch. I'm talking about the ""Developer Goodies"" portion of the NIE distribution. P DA DE VELOPER S  4.5  Sept/Oc t 1996  39   The FSM proto has been expanded to support NIE, and is also an excellent source of example code showing how the various func tions are used. NetTest is a fully functioning application that you can use to hack your way to an NIE application in short order. There are also some serious memory limitations when using the NIE. On a MessagePad 120 you can expect to just barely get one endpoint connected with all instal led packages and extensions. You should also avoid attempting to use any of the DNS functions with an active endpoint.  This handler collects messages and appends then to the SmartString until a message containing ""End"" is received. Once that happens the entire message is processed in the method named processISPMessage(). This hand ler also strips out blank lines.  A Simple Protocol This issue's source code disk includes a custom application that uses simple commands to manipulate a telephony application that can make calls, conference calls, select an active call, and generally act like a PBX. The Newton application sends messages to initiate these actions, and receives status messages from the UNIX application indicating the current call status. It uses these messages to draw a visual representation of the current calls that the user can manipulate to merge calls, break conferences, and so on. The protocol is summarized below:  Building an NIE Application Quickly NetTest is a sample application that creates an endpoint connection (either TCP or UDP) to any host and port. Once connected you can enter in some text and send it through the endpoint. Any incoming text is displayed in a text window. You can hack this application to quickly implement many text-based NIE applications. I used it to quickly implement an application that uses a TCP endpoint to communicate with a custom UNIX application. NetTest implements all of the necessary goodies to get you connected. Once connected, you can send text messages and process incoming messages by modify ing just a few key methods. Two slots are used for outgoing and incoming text.  New ton C lient Messages Here are the messages that can be sent from the Newton client to the UNIX server: Dial   Drop   Merge     Split   Select   Transfer     Place a call to   Hang up the call using   Merge calls represented by   and   Split the call represented by   from its conference Make the call represented by   the active call, put others on hold Transfer the call in   to   End the session  Sending Messages To send a message using the NetTest project, simply place the desired text string into the slot named fDataStream, then call :Msend(). A CR and LF are appended to the message and then it is sent out the connected endpoint.  Processing Inc oming Messages Incoming messages are placed into a SmartString in the slot named fReceiveBuffer. As each message is received a method named MPutDataInReceivedArea() is called with the string. All you need to do is modify this method to examine the string to see what was received. Here's my modified handler: func(str) begin // fill up THE buffer until protocol-specific string // is reached. For us the is the word ""End"" if not call kViewIsOpenFunc with (fAppBase) then return; if fReceiveBuffer = nil then :MResetReceiveBuffer(); // is it the end-of-message line? // if so, don't add to the buffer, just process it if StrEqual(str, """" & UnicodeCR) then return; if StrEqual(str, ""End"" & UnicodeCR) then begin SmartStop(fReceiveBuffer, fReceiveBufferLen); self:processISPMessage(); end else begin // append this line to the current message buffer if fReceiveBufferLen < kMaxReceiveBufferSize then fReceiveBufferLen := SmartConcat( fReceiveBuffer,fReceiveBufferLen,str); else begin if not fBufFullNotified then begin :MNotify(""Receive buffer overflow.""); fBufFullNotified := true; end; end; end; end  Bye  U N I X Server Messages This is the current call state, as a flattened graph. State Active Call   id   Name ... End  There are zero or more lines of the form: id   Name  If   is not zero, then the next lines specify the group. This indicates that a new call has become the active call. Select Active Call   End  This indicates a client message was not processed: Error End  When the user performs some action that requires sending one of the client messages, the text is placed into the fDataStream slot and then :MSend() is called. When messages are received from the Unix server, processISPMessage() is called to process them once the ""End"" text is received. Here's the processISPMessage() handler:  40  P DA De velopers 4.5  Sept/Oct 1996   func() begin local myAccessor, theMessageHdr, theWords, aWord, activeCall; // tokenize the data by line myAccessor := StrTokenize(fReceiveBuffer, $\n); // get first line theMessageHdr := call myAccessor with (); :MPutDataInStatusArea(""Message: "" & theMessageHdr); if BeginsWith(theMessageHdr,""State"") then begin phoneDisplay:updateState(myAccessor); end; else if BeginsWith(theMessageHdr, ""Select"") then begin // Next line says which call is active theMessageHdr := call myAccessor with (); theWords := StrTokenize(theMessageHdr, $ ); call theWords with (); // discard word 1 activeCall := floor(StringToNumber(call theWords with ())); if activeCall > 0 then buttonArea:InitClusterValue(activeCall); else buttonArea:InitClusterValue(nil); end; else if BeginsWith(theMessageHdr, ""Error"") then nil; // some illegal request was made :MResetReceiveBuffer(); RefreshViews(); end  I use the very powerful StrTokenize() function to parse the SmartString into lines and words. The first line of the message is tested to see which of the server messages was received. If it was the ""Select"" message, the entire message is handed to phoneDisplay:updateState(), which updates the client display. Also, the id of the selected call is extracted and an appropriate radio button is enabled. If an ""Error"" message is received, it's simply discarded. Once the message is processed, the NetTest method :MReset ReceiveBuffer() is called to clear the received text buffer for the next message. This application (at least the communications portion) was implemented in a matter of hours by building on top of NetTest. Many UNIX TCP/IP services such as NNTP (net news), SMTP/POP (e-mail), and HTTP (world wide web) use similar text-based protocols. NetTest could be used to implement basic applications that work with these servers, or (as I did here) to implement custom client applications for the Newton.  Snowboard on the Internet NIE gives Newton the capability to play on the Internet. How it will play remains to be seen. I've used it to make a custom application (this is where Newton and NIE can really shine). You can use a Newton as one heck of a nice Internet appliance if you do all of the interface on the Newton and just send simple text messages to a UNIX, Mac, or NTbased server sitting on the Internet. The complexit y of TCP/IP programming is hidden pretty well by the NIE. Although there are a lot of functions, you can use the sample applications or the FSM protos to build the tedious connection/tear down code and really focus your efforts on the application itself. Fun times ahead.  Figure 2 - The Pilot Inventory application.  Figure 1 - Inventory on the PC - the main form. P DA DE VELOPER S  4.5  Sept/Oc t 1996  41   Extending Your Desktop With the Pilot Stu Slack The Windward Group slack@wwg.com  U.S.       Robotics markets its Pilot as a desktop extension, letting you take information from your p ersonal or office computer with you wherever you go. There are many p otential applications for this device, including:   Reads the Windows Registry and finds all the conduits listed in the Pilot Desktop section,  Enumerates the databases on the Pilot and creates a list of databases that reside on the Pilot, and  Determines which databases on the Pilot have a corresponding conduit. If there are databases without conduits, these are put into the list of databases to be backed up using the backup conduit. After HotSync builds its internal list of conduits (including all the standard Pilot application's conduits, backup conduit, install conduit, and third-party conduits), it's ready to start the synchronization process. For each conduit in turn, HotSync loads the conduit in memor y, choreographs the synchronization process, and then unloads the conduit.  A car dealer's vehicle database, Inventor y control, Golf score cards, A data-monitoring device, or A time-tracking tool.  C onduit Responsibilities A conduit's responsibilities during synchronization really depend on your requirements. Your sync logic can be simple or very complex. Minimally, a conduit that s upports record-level synchronization must:  Open both databases for modify access;  Determine which records are added, deleted, or modified on both platforms and use this information to perform the synchronization;  Convert data between local and remote formats (for example, resolving byte-format differences between Intel and Motorola microprocessors  the Pilot uses a Motorola microprocessor);  Create and/or delete local and remote records; and  Write information to the Sync Log, if appropriate. This log file collects useful information such as record counts and detailed descriptions of what was synched. To facilitate synchronization, the Pilot and PC databases both need information about the record operations since the last sync. During synchronization, the conduit compares each Pilot record against the corresponding PC record and decides how to proceed with this information. See the ""Synchronization Algorithm"" section of the Palm OS Conduit De velope r's Guide for a description of the possible synchronization cases and actions you should take.  One common aspect of all these applications is the ability to change data while in the field, and then merge those changes with the information on your desktop machine, preferably without losing any of the changes in the process. This intelligent merg ing of separate databases is referred to as synchronization. One of the Pilot's notable features is its one-touch synchronization, using the HotSync application. U.S. Robotics' HotSync application provides a uniform method for transferring information between the desktop and the Pilot. However, HotSync doesn't know anything about the data it moves. Rather, HotSync relies on conduits to do the dirty work. A conduit is a Windows DLL that you build to interface your application to the Pilot. It's responsible for reading and writing both the local (PC) and remote (Pilot) databases, and for doing any data transformations or field valuemappings required to accurately move data between the two systems. HotSync provides a number of services that help your conduit perform these tasks. Once you decide to create an application that extends your desktop in this way, there are many implications. These issues relate to data manageme nt in your desktop application and your Pilot application, as well as in your conduit. In this article I look at all of these issues, demonstrate how to write a Pilot application (in particular, the database manageme nt logic), and how to write a related conduit.  Example Application Pilot Conduits Synchronization is the process of merging two databases: one on a PC and one on a Pilot. The HotSync application manages this process, and calls on conduits to perform the actual data manipulation for each database that is synchronized. There is one conduit for each unique pair of PC and Pilot applications. Synchronization operations differ based on the type of usage you expect for your application. For example, if you have data that is going to change in only one place at a time (that is, the data changes on the PC or on the Pilot, but not on both at the same time), then you can synchronize using a simple file-copy approach. Such a conduit is fairly trivial. If, on the other hand, you expect data to change on both systems between synchronization operations, then you need to provide recordlevel synchronization, and you need to keep track of changes on a record-by-record basis. The Palm OS provides tools for you to do this in your Pilot application. It's up to you to maintain appropriate information in your desktop database. In order to illustrate the issues I discuss in this ar ticle, I have written a simple inventory control application. You can use this application in two ways: to provide price and availability information to a customer, and to field check and update the actual inventor y against what's in the database. In order to keep this application straightforward, I make two simplifying assumptions: the chara cter data is all stored in fixed-length fields, and the application does not support categories. The entire inventory application has three parts:  The PC application, shown in Figure 1;  The matching Pilot application, shown in Figure 2; and  The conduit. Both the PC and Pilot applications intentionally have similar user interface and data formats. The same group of users use both the desktop and the Pilot application. By making the interfaces and functions similar, they are not confused when they move from system to system.  The ABCs of HotSync When you press the HotSync button on the Pilot's cradle, an interrupt is generated which takes the Pilot out of sleep mode and into HotSync initiation mode. The Pilot then sends wake-up packets at two-second intervals until the HotSync application on the desktop acknowledges the Pilot's wake-up call, or until a time-out occurs. When the HotSync application recognizes the wake-up packet, the initiation process starts. HotSync does the following before it starts the synchronization process:  PC Applic ation The PC application (see Figure 1) is a dialog-based MFC application that lets you add, delete, and update records. Althoug h I don't talk in detail about the code, I refer to it when discussing the conduit and its logic to determine which records to synchronize.  Pilot Applic ation I wrote the Pilot application (see Figure 2) in C using CodeWarrior for Pilot (also referred to as the Pilot SDK) available from U.S. Robotics.  42  P DA De velopers 4.5  Sept/Oct 1996   The UI design is similar to the PC application, but the internals are completely different. I describe this application in more detail because it demonstrates some of the data management techniques that are important when developing Pilot applications.  Pilot Data Management The Pilot Data Manager, the Pilot's equivalent of a file system, is an integral part of the Palm OS. It maintains records on the Pilot in noncontiguous, non-volatile memory, relieving you of the burden of keeping track of record positions in memory. The Data Manager keeps track of records using record IDs that are assigned by the operating system. Every record on a Pilot has a unique record ID. The record ID is ver y important to the synchronizat ion process: it's used to identify matching records on the PC and Pilot. Databases are divided into two parts (se e Figure 3): the database header and the record information. The database header contains general information about the database, such as database name and number of records in the database. The database record info area contains a row for each record. Each row has four fields: Record ID The unique ID assigned by the Pilot Data Manager when the record is created. Cat The category that the record belongs to. My inventory control application does not implement categorized records, but this field can be used for a note-taking application, for example, to classify the notes into specific groups. The Pilot has built-in operating system suppor t for these categories. Attr The attributes of the record, set by you or by the Data Manager. The standard att ributes are Modified, Deleted, Archived, and New. Your PC database should have a matching field, so that your conduit can determine the status o f corresponding records, and take the appropriate action during synchronization. LocalID This is the local ID of the memory chunk allocated for the record. Local IDs lets the Data Manager store records anywhere on the memor y card. When accessing the record, the Data Manager does a simple offset calculation to obtain the record's handle, which it uses to access the record. There are two ways to open a database. You can use the Data Manager's DmOpenDatabaseByTypeCreator or DmOpenDatabase functions. I used the first function because Inventory stores all  of its data in a single database, tied to my application's creator ID. With more than one database, I have to use the DmOpenDatabase function, which uses a Database ID to identify the database to open. You can find the Database ID by calling DmFindDatabase. When you delete a record using the DmDeleteRecord function, the Data Manager doesn't actually delete the record. Instead, it marks the record Deleted using the appropriate record attribute. As a result, your conduit can identify records that are to be deleted from one database or the other. For more details about the specifics of the Data Manager, see ""The Data Manager"" in the Pilot SDK documentation.  Inventory's Database In order to demonstrate working with the Data Manager, I include two important functions from the Pilot application here: NewRecord, which creates new records, and DeleteRecord, which deletes a record from the Pilot database. The NewRecord function allo cates a new database record using DmNewRecord. Since I use only fixed-length fields, I can just use the size of the InvItem structure as the size of a new record. I then lock the returned handle to get a pointer to the new record. /************************************************** * NewRecord **************************************************/ Boolean NewRecord(DmOpenRef dbRef, InvItemPtr pSrcItem, UInt *index) { int size = 0; ULong offset; VoidHand hRecord; InvItemPtr pInvItem; Boolean bRes = true; // Allocate a new data chunk. hRecord = DmNewRecord( dbRef, index, (ULong)sizeof(InvItem) ); if( !hRecord ) { FrmAlert (DeviceFullAlert); return false; } pInvItem = MemHandleLock( hRecord ); // Write the record's contents if( pInvItem ) { offset = 0; DmStrCopy( pInvItem, 0, pSrcItem->m_szItem ); offset += MAX_ITEM; DmStrCopy( pInvItem, offset, pSrcItem->m_szDesc ); offset += MAX_DESC; DmWrite( pInvItem, offset, &pSrcItem->m_nStock, sizeof(int) ); offset += sizeof(int); DmWrite( pInvItem, offset, &pSrcItem->m_dPrice, sizeof(double) ); MemPtrUnlock( pInvItem ); // The ""dirty"" flag is set in DmReleaseRecord DmReleaseRecord( dbRef, *index, true ); } else bRes = false; return bRes; }  Figure 3 - A typical Pilot database l ayout. P DA DE VELOPER S  4.5  Sept/Oc t 1996  43   To write to database memory, you must use Data Manager functions like DmStrCopy and DmWrite. To use these functions, you must maintain an offset from the start of your record to write the data. As you can see, after I call DmStrCopy, I increment the offset by the number of bytes written. After unlocking the record, I use DmReleaseRecord to set the record's dirty flag. When deleting records in a Pilot application that has a sister application on the desktop, you do not want to physically delete records when the user presses the delete key. Instead, you should mark the record for deletion using DmDeleteRecord. Once you delete the record, it's gone from the user's view, but still in the database until the next sync operation. The following code fragment shows how to delete a record from a Pilot database. /************************************************** * DeleteRecord **************************************************/ DeleteRecord( int nRec ) { VoidHand hRec; hRec = DmQueryRecord( InventoryDB, CurrentRec ); if( hRec ) DmDeleteRecord( InventoryDB, CurrentRec ); }  access individual records. This structure enables the SyncManager to access any record, regardless of its layout. It is up to you to interpret the record's contents when using a record-oriented cal l. struct CRawRecordInfo { BYTE m_FileHandle; // From OpenDatabase() DWORD m_RecId; // Record ID WORD m_RecIndex; // Index of record BYTE m_Attribs; // Attributes short m_CatId; // Category int m_ConduitId; // Conduit ID DWORD m_RecSize; // Max records size WORD m_TotalBytes; // Num bytes read/written BYTE * m_pBytes; // Data };  You should always use the DmQueryRecord function and check the returned handle before calling any other Data Manager function. Deleted records return a NULL hRec. Note that there is a Data Manager function, DmRemoveRecord, that removes a record completely from a Pilot database, rather than marking it for deletion as discussed here.  The m_pBytes member variable is a pointer to the raw bytes in the record. The SyncManager sends this data to your conduit's conversion routine during synchronizat ion. The m_FileHandle is the database handle; it must be set to the value returned by SyncOpenDB. See the Conduit SDK for a more detailed description of this structure and its use. You can scan a database for modified records by calling the SyncManager's SyncReadNextModifiedRecord function. SyncManager uses the ""dirty"" bit in each record's attribute field to determine which records have been mo dified. You are responsible for maintaining the dirty bit in your Pilot application. Set it when you modify a record and clear it after you perform a sync.  C onduit Entry P oints Your conduit must export several C entry point functions so the HotSync application can retrieve information from your conduit and initiate the synchronization process. The list ing below shows the minimum conduit interface needed to get started. // InvCond.cpp : Defines the conduit init routines #include #include #include #include #include #include ""stdafx.h"" ""resource.h""   ""SyncMgr.h"" ""InvDll.h"" ""InvCond.h""  Writing Your Conduit A conduit is a Microsoft MFC Extension DLL that is loaded by the HotSync application when needed. To create a conduit, you need the Conduit SDK, available from US Robotics, and Microsoft Visual C++ (version 4.0 or b etter). The best way to create your DLL is to use the MFC AppWizard. Start by selecting File/New from MSVC, then select Project Workspace from the New dialog. Next, select MFC AppWizard (DLL), fill in the project name and select the Create button. This brings you to the MFC AppWizard dialog (see Figure 4). Under the question ""What type of DLL would you like to create?"" select MFC Extension DLL, then click the finish button. MSVC creates a skeleton DLL from which you can build your conduit.  The SyncM anager DLL The SyncManager DLL provides services that let your conduit set up and do a synchronization. It establishes and maintains the data pipeline between the PC and Pilot and handles database and record operations on the Pilot. The SyncManager provides three main categories of services: session-oriented, file-oriented, and record-oriented. The session-oriented services provide routines for initializing memor y and resources for use by your conduit during the sync process. You must call SyncRegisterConduit before calling any other SyncManager functions, and clean up using the SyncUnRegisterConduit function after your conduit is finished. The file-oriented services provide an API for Pilot database operations such as open, close, create, and delete databases. There are also functions for getting information from a database, such as the database's application information blo ck (AppInfo) which stores application-specific information in the database. The SyncOpenDB call opens a database on the Pilot and returns the database's file handle. You must use this handle when accessing Pilot records using the SyncManager's record-oriented services. The SyncManager's record-oriented services, such as reading, writing, and deleting records, provide the interface for working w ith database contents. These functions use a CRawRecordInfo structure to  Figure 4 - The MFC AppWizard Dialog  44  P DA De velopers 4.5  Sept/Oct 1996   #ifdef _DEBUG #define new DEBUG_NEW #undef THIS_FILE static char THIS_FILE[] = __FILE__; #endif static AFX_EXTENSION_MODULE InvCondDLL = { NULL, NULL }; HINSTANCE myInst; /***************************************** * DllMain *****************************************/ extern ""C"" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) { if (dwReason == DLL_PROCESS_ATTACH) { // Extension DLL one-time initialization AfxInitExtensionModule(InvCondDLL, hInstance); myInst = hInstance; // Insert this DLL into the resource chain new CDynLinkLibrary(InvCondDLL); } else if (dwReason == DLL_PROCESS_DETACH) { // Cleanup the DLL! AfxTermExtensionModule( InvCondDLL ); } return 1; // ok } /***************************************** * OpenConduit *****************************************/ ExportFunc long OpenConduit(PROGRESSFN pFn, CSyncProperties& rProps) { long retval = -1; if (pFn) { CInvConduit* pConduit; pConduit = new CInvConduit(pFn, rProps ); if (pConduit) { retval = pConduit->StartSync(); delete pConduit; } } return(retval); } /***************************************** * GetConduitName *****************************************/ ExportFunc long GetConduitName(char* pszName, WORD nLen) { long retval = -1; if (::LoadString(myInst, IDS_COND_NAME, pszName, nLen)) retval = 0; return retval; } /***************************************** * GetConduitVersion *****************************************/ ExportFunc DWORD GetConduitVersion() { return 0x00000101; }  The first function in the listing is DllMain, the main function that is called when the DLL is loaded by the system. If there are any application initialization tasks that need to be performed, do them here when the DLL_PROCESS_ATTACH flag is set in the dwReason parameter. Similarly, perform application cleanup tasks when the DLL_PRO-CESS_DETACH flag is set.  Informational Func tions Your conduit must expor t two functions that allow the SyncManager to interrogate your conduit during startup processing:  GetConduitName - This function lets the SyncManager obtain your conduit's name. HotSync uses this name in its progress dialog, for example.  GetConduitVersion - This function lets the SyncManager get version information from your conduit. HotSync queries each conduit for its version number, and does not loa d the conduit if it gets an incorrect version number. This lets HotSync manage enhancements to the HotSync application and conduits. Once HotSync loads your conduit's DLL into memory and determines that it's the correct version, it invokes your conduit by calling its OpenConduit entr y point.  The OpenC onduit Func tion HotSync calls OpenConduit in order to start the actual synchronization. HotSync passes two par ameters to this function. The first parameter, PROGRESSFN, is a pointer to a progress function. This function is reserved for future use. The second parameter identifies a CSyncProperties st ructure. This important structure contains informat ion, such as the local and remote database names, that you need when synching. class CSyncProperties { public: eSyncTypes m_SyncType; // Fast/Slow char m_PathName[BIG_PATH]; // Full path char m_LocalName[BIG_PATH]; // File name char m_UserName[BIG_PATH]; // User char* m_RemoteName[DB_NAMELEN]; // Remote DB names CDbList* m_RemoteDbList[DB_NAMELEN]; // Remote DB list int m_ nRemoteCount; // Num Remote DBs CSyncLog* m_pSyncLog; // sync log DWORD m_Creator; // Creator ID WORD m_CardNo; // DB's card num DWORD m_DbType; // DB Type (DATA) DWORD m_AppInfoSize; // convenience DWORD m_SortInfoSize; // convenience eFirstSync m_FirstDevice; // Dev first sync eConnType m_Connection; // Transfer medium }; ExportFunc long OpenConduit(PROGRESSFN pFn, CSyncProperties& rProps) { long retval = -1; if (pFn) { CInvConduit* pConduit; pConduit = new CInvConduit(pFn, rProps ); if (pConduit) { retval = pConduit->StartSync(); delete pConduit; } } return(retval); } P DA DE VELOPER S  4.5  Sept/Oc t 1996  45   In my Inventory example, OpenConduit instantiates a CInvConduit object which also takes the progress function pointer and CSyncProperties reference. I implement all the conduit synchronization code in this object only to isolate the synchronization code from the rest. (You can w rite the whole sync logic in C func tions that are cal led directly from OpenConduit.) After instantiating the conduit object, I call StartSync and the real action begins. When StartSync returns, Inventory is done with its part of the HotSync and the SyncManager destroys the conduit object.  Implementation of the Inventory Conduit Figure 6 shows the relationships between the Inventory conduit's classes and the local and remote databases. The conduit accesses the remote database, called InvDB, using SyncManager functions. The CommandServer is a DLL loaded by HotSync; it provides communications services such as reading physical records over the serial connection between the Pilot and the PC, to the SyncManager. The Inventor y conduit contains classes and their supporting members. The base class, called Cconduit, is responsible for setting up and controlling the synchronization and implementing common functions such as byte conversion routines. The derived class, CInv-Conduit, contains the interfaces that are needed to deal with inventoryspecific tasks such as reading and writing inventory records. class CConduit { public: CConduit( PROGRESSFN fFn, CSyncProperties &rProps ); // Public access CString &GetName() {return m_csName;} void SetName( const char *szName ) { m_csName = szName; } // Overridables virtual long StartSync(); virtual long ObtainLocalTable() {return CONDERR_BAD_LOCAL_TABLES; } virtual long ObtainRemoteTable() { return CONDERR_BAD_REMOTE_TABLES; } virtual void UpdateLocalTable() {}; // Support one or more of these sync types: virtual long DoFastSync(){return CONDERR_UNSUP_TYPE;} virtual long DoSlowSync(){return CONDERR_UNSUP_TYPE;} virtual long DoPilotToPCSync(){return CONDERR_UNSUP_TYPE;} virtual long DoPCToPilotSync(){return CONDERR_UNSUP_TYPE;}  The Window s Registry In order f or HotSync to call your conduit, you must have a properlyformatted entry in the Windows Registry (see Figure 5). All third-par ty conduits need to be included in the registry under the ""HKEY_CURRENT_USER/Software/Palm Computing/Pilot Desktop"" tree. HotSync looks for your conduit in the ""ApplicationN key"", where ""N"" is a consecutive non-negative number. When installing your conduit, you must find the last ""ApplicationN"" entr y and include yours after the last entry you find. In Figure 5 the Inventor y conduit is under the ""Application0"" key since there are no other third-party conduits installed. It is important that the ""Creator"" field contains your Pilot application database's creator ID. HotSync uses this creator ID to match-up your conduit to your Pilot database. If your Pilot database and the Creator ID don't match, HotSync assumes that the Pilot database should be included in the list of databases to be backed up using the backup conduit. On the Pilot, you set the creator ID when you create the database using the DmCreateDB function. The ""Priority"" entry determines the order in which the conduit is loaded. Using this field, you can affect the order in which HotSync executes the conduits. This is handy, for example, if you need to ensure that the Datebook conduit is executed before your conduit. ""Priority"" ranges from 0, the highest priority, to 4, the lowest. The default is 2. Note that more than one conduit can have the same priority value. The other Registry entries are fully described in the Palm OS Conduit SDK documentation.  Figure 5 - The Pilot Tree of the Windows Registry.  Figure 6 - Context diagram for Inventory conduit.  46  P DA De velopers 4.5  Sept/Oct 1996   protected: BOOL IsCommsError( long lErr ); void WriteByteStream( BYTE *pbDest, const char *pStr, int &iPos ); [... More ...] int ReadByteStream( char *pDest, const BYTE *pbSrc ); [... More ...] // Protected Variables PROGRESSFN m_pfnProgress; CSyncProperties &m_rSyncProps; BYTE m_hRemoteDB; fstream m_File; private: CString m_csName; };  case ePCtoHH: retval = DoPCToPilotSync(); break; case eHHtoPC: retval = DoPilotToPCSync(); break; } // Reset all status flags on the Remote size. SyncResetSyncFlags( m_hRemoteDB ); if (!IsCommsError(retval)) SyncCloseDB(m_hRemoteDB); // Update the local table UpdateLocalTable(); if (retval) syncFinishCode = slSyncAborted; // Notify the log that a sync has ended if (m_rSyncProps.m_pSyncLog) m_rSyncProps.m_pSyncLog->AddEntry( m_csName, syncFinishCode); if (!IsCommsError(retval)) SyncUnRegisterConduit(conduitHandle); return(retval);  Start Your S ync The CConduit::StartSync function is responsible for setting up and doing the sync. It first tells the SyncManager DLL, by calling the SyncRegisterConduit function, that it plans to talk to the Pilot. I instruct the SyncManager to append a ""Sync Started"" message to the Sync Log. You can use the log file to display other messages pertinent to the HotSync, such as start and end messages and failure messages if something goes awry. Since CInvConduit is derived from CConduit, it needs to override many of the functions called by StartSync. long CConduit::StartSync() { long retval; CONDHANDLE conduitHandle = (CONDHANDLE)0; Activity syncFinishCode = slSyncFinished; // Register this conduit with SyncMgr.DLL for // communication to HH if (retval = SyncRegisterConduit(conduitHandle)) return(retval); // Notify the log that a sync is about to begin if (m_rSyncProps.m_pSyncLog) m_rSyncProps.m_pSyncLog->AddEntry( m_csName, slSyncStarted); // Open the Remote Database retval = ObtainRemoteTable(); if( retval != CONDERR_NONE ) return retval; // Open PC tables and load local records && local // categories. retval = ObtainLocalTable(); if( retval != CONDERR_NONE ) return retval; // Synchronize the records - depends on the sync type // Note: Not all need to be supported. switch( m_rSyncProps.m_SyncType ) { case eFast: retval = DoFastSync(); break; case eSlow: retval = DoSlowSync(); break; }  Next, the conduit must open the local and remote databases. The local database is a simple linked list of CInventoryRec structures which are maintained by the CRecordList class. The OpenLocalTable function reads all of the local records into memory. I do this in order to minimize the duration of the synchronization session, thereby conserving Pilot battery life. long CInvConduit::ObtainLocalTable() { long retval = CONDERR_NONE; CString dataFile(m_rSyncProps.m_PathName); dataFile += m_rSyncProps.m_LocalName; m_File.open( dataFile, ios::binary|ios::in ); if( m_File.is_open() ) m_listRecs.ReadFromDisk( m_File ); else retval = CONDERR_BAD_LOCAL_TABLES; m_File.close(); return retval; }  The ObtainRemoteTable function opens the remote database on the Pilot, using SyncOpenDB. If the remote database does not exist (like when synching for the first time without previously running Inventory), I create a database using SyncCreateDB. You should use the information contained in the SyncProperties structure passed into your DLL to set information, such as the creator ID in the CDbCreateDB st ructure passed to SyncCre ateDB. Once the database has been successfully created, I store the file handle in the conduit's m_hRemoteDB member variable.  P DA DE  VELOPER S  4.5  Sept/Oc t 1996  47   long CInvConduit::ObtainRemoteTable() { long retval = CONDERR_BAD_REMOTE_TABLES; // Call into SyncManager.DLL to open Remote DB retval = SyncOpenDB( m_rSyncProps.m_RemoteName[0], 0, m_hRemoteDB); // Create the remote database if it's not there if (retval == SYNCERR_FILE_NOT_FOUND && m_rSyncProps.m_SyncType != eHHtoPC) { CDbCreateDB dbInfo; memset(&dbInfo, 0, sizeof(dbInfo)); dbInfo.m_Creator = m_rSyncProps.m_Creator; dbInfo.m_Flags = eRecord; dbInfo.m_CardNo = ( (BYTE)m_rSyncProps.m_CardNo; dbInfo.m_Type = m_rSyncProps.m_DbType; strcat( dbInfo.m_Name, m_rSyncProps.m_RemoteName[0]); if (!(retval = SyncCreateDB(dbInfo))) m_hRemoteDB = dbInfo.m_FileHandle; } return(retval); }  // Normal termination when EOF on Pilot is // encountered. Anything else is error to return. if( err && err!=SYNCERR_FILE_NOT_FOUND ) lRet = err; else { wireRec.m_FileHandle = m_hRemoteDB; // Now go through all modified records (new/delete) // on the local side and perform actions to the // remote side. for( inx=0; inx m_wStatus&fldStatusDELETE) == fldStatusDELETE ) DeleteRecs( *pLocalRec, inx, TRUE ); // Else if new record, add to remote side else if( (pLocalRec-> m_wStatus&fldStatusADD)== fldStatusADD ) { ConvertRec( wireRec, *pLocalRec ); err = SyncWriteRec( wireRec ); if( err == SYNCERR_NONE ) { pLocalRec->m_nRecId = wireRec.m_RecId; pLocalRec->SetStatus(fldStatusNONE); } else { lRet = err; break; } } } } } // Done - cleanup if( wireRec.m_TotalBytes > 0 && wireRec.m_pBytes ) delete [] wireRec.m_pBytes; // Purge all remote deleted records SyncPurgeDeletedRecs( m_hRemoteDB ); // Purge all local deleted records m_listRecs.PurgeDeletedRecs(); return lRet; }  Once I open (or create) the local and remote databases, I call DoFastSync in order to synchronize the two databases. The base CConduit class determines which virtual function to call by checking the SyncProperties m_SyncType member. This field indicates the type of sync: slow, fast, or overwrite. See the Palm OS Conduit SDK documentation for a complete explanation of each sync type. Here, I implemented only the fast sync logic. long CInvConduit::DoFastSync() { long err = SYNCERR_NONE; long lRet = SYNCERR_NONE; WORD wRecCnt; // Get number of recs in remote DB SyncGetDBRecordCount( m_hRemoteDB, wRecCnt ); CRawRecordInfo wireRec; CInventoryRec remoteRec; // Setup the record for retrieving record over wire memset(&wireRec, 0, sizeof(wireRec)); wireRec.m_FileHandle = m_hRemoteDB; // remote handle wireRec.m_RecId = 0; // Record ID wireRec.m_RecIndex = 0; wireRec.m_pBytes = (BYTE *)new char [sizeof(CInventoryRec)]; wireRec.m_TotalBytes = sizeof(remoteRec); // Loop over all the records on the Remote side and // perform the synchronization logic on each one. int inx = 0; while(err == SYNCERR_NONE) { if( (err = SyncReadNextModifiedRec(wireRec) ) != SYNCERR_NONE ) break; ConvertRec( remoteRec, wireRec ); PerformPilotToPCRecSync( remoteRec ); }  This function takes a two-step approach to synchronizing the records. First, the conduit iterates over all the remote records and acts on them, then iterates over the local records to do the same. While iterating over the records on the local or remote side, you may encounter deleted records. Be careful how you implement the record deletion function to avoid changing record indexes while in the iteration loop. I avoid this problem by marking records for deletion (instead of physically deleting them), then performing cleanup after the iteration is complete. SyncPurgeDeletedRecs purges records marked for deletion on the remote database, and m_listRecs.PurgeDeletedRecs does the same on the local database.  48  P DA De velopers 4.5  Sept/Oct 1996   When iterating over the records on the remote side, the conduit reads each record using SyncReadNextModifiedRec. The ConvertRec function reformats each record so that it can be recognized by the PC. For the remote records, I call PerformPilotToPCRecSync, which adds and deletes records on the local side as appropriate. void CInvConduit::PerformPilotToPCRecSync ( CInventoryRec &rRemoteRec ) { int nIndex; // Try to find the remote record BOOL bExists = m_listRecs.FindRecById( RemoteRec.m_nRecId, nIndex ); // If doesn't exist, then add it - but don't want to // add deleted recs. if( !bExists && (rRemoteRec.m_wStatus&fldStatusDELETE) != fldStatusDELETE ) { m_listRecs.AddRec( rRemoteRec ); } else { // If exists but remote rec marked for deletion, // then delete from local and remote sides. if( (rRemoteRec.m_wStatus&fldStatusDELETE) == fldStatusDELETE ) { DeleteRecs( rRemoteRec, nIndex ); }}}  ConvertRec does these tasks for the Inventory conduit. // Convert record REMOTE-->LOCAL void CInvConduit::ConvertRec( CInventoryRec &rDestRec, CRawRecordInfo &rWireRec ) { // Set record id rDestRec.m_nRecId = rWireRec.m_RecId; // Set the status for the record rDestRec.SetStatus(fldStatusNONE); if (rWireRec.m_Attribs & DELETE_BIT) // Delete flag rDestRec.SetStatus(fldStatusDELETE); else if (rWireRec.m_Attribs & DIRTY_BIT) rDestRec.SetStatus(fldStatusUPDATE); // If remote rec is not marked as deleted, then // convert the rest of record if( !(rWireRec.m_Attribs&DELETE_BIT) ) { const BYTE *pBuff = (const BYTE *) rWireRec.m_pBytes; int nPos = 0; WORD wUnits; double dPrice; // Use a utility function to read the ""stream"" // into the inventory record. pBuff += ReadByteStream( rDestRec.m_szName, pBuff, MAX_NAME_LEN ); pBuff += ReadByteStream( rDestRec.m_szDesc, pBuff, MAX_DESC_LEN ); pBuff += ReadByteStream( wUnits, pBuff ); rDestRec.m_nUnits = wUnits; *(double *)&dPrice = *pBuff; rDestRec.m_dPrice = dPrice; } } // Convert record LOCAL-->REMOTE void CInvConduit::ConvertRec( CRawRecordInfo &rWireRec, CInventoryRec &rSrcRec ) { BYTE *pBuff = (BYTE *)rWireRec.m_pBytes; int nPos = 0; WriteByteStream( pBuff, rSrcRec.m_szName, MAX_NAME_LEN, nPos ); WriteByteStream( pBuff, rSrcRec.m_szDesc, MAX_DESC_LEN, nPos ); WriteByteStream( pBuff,(WORD)rSrcRec.m_nUnits,nPos); *(double *)&pBuff[nPos] = rSrcRec.m_dPrice; }  If I find a record in the Pilot database that does not exist in the local database (and it's not mar ked deleted), I need to add the record to the local database using m_listRecs.AddRec. Similarly, records marked as Deleted on the Pilot need to be deleted from the PC. The DeleteRecs function does this. // Marks records for deletion on remote and local sides. void CInvConduit::DeleteRecs( CInventoryRec &rRec, int nIndex, BOOL bDelRemote ) { long err; CRawRecordInfo rawRecInfo; memset(&rawRecInfo, 0, sizeof(rawRecInfo)); rawRecInfo.m_FileHandle = m_hRemoteDB; rawRecInfo.m_RecId = rRec.m_nRecId; // Delete from local database m_listRecs.MarkDeletedAtIndex( nIndex ); // Should I mark remote record for deletion also? if( bDelRemote ) err = SyncDeleteRec( rawRecInfo ); }  Conclusion While Pilot applications merit a lot of attention, they are only truly useful when married to an appropriate desktop application. You can effect that marriage by creating a custom conduit that synchronizes the data between your Pilot and PC applications. As the Pilot becomes more prevalent in the market, there will be more and more opportunities to develop truly connected applications that extend the user's desktop into the field. Using the information in this article, coupled with the Palm OS Conduit SDK, you are now equipped to take advantage of those opportunities. The source code for Stu's sample Pilot application and conduit can be found on the source code disk for this issue o f PDA Developers. P DA DE 4.5  Sept/Oc t 1996  The second iteration loop is very similar to the first, except it iterates over all records on the local size and adds and deletes records on the remote side as appropriate. An important part of synchronization is the conversion between the raw record stream coming off the wire (and contained in CRawRec-ordInfo) into a record recognized by the conduit (CInventory-Rec). There are generally three types of conversions that you may need to support, depending on the data types in your records:  Byte swapping between Intel and Motorola formats,  Date conversions, and  Adding or removing carriage returns in strings.  VELOPER S  49   ONE-STOP PDA DEVELOPER SHOPPING The Magazine  PDA DEVELOPE  RSTM  PDA D  EVE LOP ER S  Source Code Disk  PDA Developers provides in-depth technical information about developing PDA software, focusing on Newton, Psion, GEOS, Magic Cap, and Hewlett Packard devices. Each issue includes news and announcements, programming tips and techniques, product reviews and previews, and programs with in-depth developer descriptions. For all technical levels. North America: $65. Overseas: $85. No shipping and handling. Ultimate New ton Debugger  Each issue of the PDA Developers source code disk includes the text of each ar ticle, the source code for each program in the issue, plus developer-oriented freeware, shareware, and goodies. For subscribers that receive just the disks, we include a Common Ground image of the printed issue. Available in Mac and Windows versions. $50 with a printed subscription. North America: $65. Overseas: $80. No shipping and handling.  V  IEW FRAM ETM  PDA Developers CD The cross-platform CD-ROM contains the slides from most of the presentations from the PDA Developers East `95 and PDA Developers West `96 conferences. Keynotes by industry pioneers and leaders, plus PDF-formatted versions of the GEOS 2.1 SDK documentation, the Magic Cap 1.5 developer docs, and much more. Essential for PDA developers. Cross-platform CD: $40. PDA Developers subscribers: $30.  ViewFrame is a Newton-resident debugger and browser that lets you do things you can't even do with the Inspector. Browse an application's complete object space, examining and modifying almost all objects in that space in multiple formats. See more things, more clearly and easily, than you can with the Inspector, without tying up the serial port. New version 1.2. Mac or Windows disk: $90. PDA Developers subscribers: $80. Ma c/New ton IR  GizmoBeam  TM  Mic roWaveTM  DOS/Newton I R  GizmoBeam is a device driver for beaming between Mac programs and Newtons. It includes Think C and Metrowerks sample source and detailed documentation. Requires knowledge of Macintosh Device Manager and Serial Device Drivers, plus CE-IR2, 3, or 4 hardware. Distribution licenses extra. Mac 5-user SDK: $200. PDA Developers subscr ibers: $175.  MicroWave is a linkable library for beaming between Newtons and D OS-based hardware. It includes a C header file, Microsoft and Borland libraries, three samples with full source code, and documentation. Requires CE-IR2, 3, or 4 hardware. Distribution licenses extra. DOS 5-user SDK: $200. PDA Developers subscribers: $175.  Prices are for a sing le-seat S DK and a five-user distribution license.  R agoutTM (Ragu')  The Ultimate Soup Utilit y Designed for Newton developers, consultants, and power users, Ragout lets you:  Create, delete, copy, and move soups.  Add and remove soup indices.  Create, delete, copy, move, view, and edit soup entries, and change slot data types at any depth. Mac or Windows disk: $55. PDA  Create multiple copies of an entry for sizing soups.  Move to the first and last entries, forward and backward one or N entries, go to a specific tagged entry, or search for an entry by index value.  Fax and print soup information and entry details, and beam soup entries. Developers subscribers: $50.  Shipping and handling - $7.50 in North Americ a, $12.50 elsewhere. CA residents add 8.5% sales tax. We accept major credit cards and US bank-drawn checks. Sorry, no POs.  Creative Digital Inc. 293 Corbett Avenue SanFrancisco, CA 94114 http://www.cdpubs.com   All Dog, no Fleas. cdi@cdpubs.com  74774.50@compuserve.com  415.621.4252 415.621.4922 (fax)   PDA Developers North September 11-13, 1996  Inland Meeting & Exposition Center  Westmont, IL, 20 minutes from Chicago's O'Har e Airpor t  Ke ynote Speakers Charles Davies , Technical Director, The Psion Group. Har el Kodesh, General Manager, Microsoft's Consumer Appliance Group. Grov er Right , Vice President, Geow orks. Kheng Jo-Khaw , General Manager, HP APCD. J anne Jormalainen , Engineering Director, Nokia. Steve Schr amm , Vice President & GM, General Magic . Gar y Gebhar dt , Channel Strategy Manager, ARDIS.  Sponsors Psion, General Magic, U.S. Robotics/Palm Computing, ARDIS, Apple Computer, Hewlett-Packard.  Co-sponsors Geoworks, Pen Computing Magazine, InTouch USA, Wright Strategies, and PDA Direct.  TM  Half-Day Introductor y Programming Courses Psion, Magic Cap, Pilot, GEOS, Newton, PenRight!, and FormLogic .  Conference Tracks The Companies The Technologies The key platform manufacturers summarize their products, markets, and future directions. Lead engineers from the platform creators summarize their key technologies, operating system advantages, and how they expect their technologies to evolve in the near future. Real Programmers Developers and system integrators talk about their products, the business of software development, and the technical and business challenges they face. Wireless Representatives from the major wireless product and service providers talk about their products and services and how developers can incorporate them into PDA products. Advanced Topics Speech recognition, smart phones, future CPU architectures, and lots more. Tools All kinds of tools  for developers, system integrators, and technically-savvy end users.  Cost $450 until Sept 8, $500 after that. Includes breakfast and lunch all three days. Includes full registration f or PDA Solutions Exhibition on Saturday, September, 14, 1996.  Exhibits 8000 square feet, with ridiculously low exhibitor rates. Contact us for details.  If You Are At All Serious About Hand-held Computing, You Can't Afford Not To Attend PDA Developers North. Creative Digital Inc . 293 Corbett Avenue, San Francisco, CA 94114-1842 Call (415.621.4252), Fax (415.621.4922), E-mail ( info@cdpubs.com), or Surf (http://www.cdpubs.com)."
GX040-04-1919175	"Grace User's Guide (for Grace-5.1.7)    by the Grace Team 16.03.2002      This document explains the usage of    Grace , a WYSIWYG 2D plotting tool for numerical data.       1.   Introduction      1.1   What is Grace?   1.2   Copyright statement       2.   Installation guide      2.1   Installing from sources   2.2   Binary installation   2.3   Alternative packaging schemes (RPM, ...)       3.   Getting started      3.1   General concepts   3.2   Invocation   3.3   Customization       4.   Guide to the graphical user interface      4.1   GUI controls   4.2   The main window   4.3   File menu    4.4   Edit menu    4.5   Data menu    4.6   Plot menu    4.7   View menu    4.8   Window menu    4.9   Help menu        5.   Command interpreter       5.1   General notes   5.2   Definitions   5.3   Variables   5.4   Numerical operators and functions   5.5   Procedures   5.6   Device parameters   5.7   Flow control   5.8   Declarations   5.9   Graph properties   5.10   Set properties       6.   Advanced topics      6.1   Fonts   6.2   Interaction with other applications   6.3   FFTW tuning   6.4   DL modules        7.   References      7.1   Typesetting   7.2   Device-specific limitations   7.3   Device-specific settings   7.4   Dates in Grace    7.5   Xmgr to Grace migration guide        1.   Introduction      1.1   What is Grace?        Grace is a WYSIWYG tool to make two-dimensional plots of numerical data. It runs under various (if not all) flavors of Unix with X11 and M*tif (LessTif or Motif). It also runs under VMS, OS/2, and Windows (95/98/NT/2000). Its capabilities are roughly similar to GUI-based programs like Sigmaplot or Microcal Origin plus script-based tools like Gnuplot or Genplot. Its strength lies in the fact that it combines the convenience of a graphical user interface with the power of a scripting language which enables it to do sophisticated calculations or perform automated tasks.   Grace is derived from Xmgr (a.k.a. ACE/gr), originally written by Paul Turner.   From version number 4.00, the development was taken over by a team of volunteers under the coordination of Evgeny Stambulchik. You can get the newest information about Grace and download the latest version at the   Grace home page .   When its copyright was changed to GPL, the name was changed to Grace, which stands for ``GRaphing, Advanced Computation and Exploration of data'' or ``Grace Revamps ACE/gr''. The first version of Grace available is named 5.0.0, while the last public version of Xmgr has the version number 4.1.2.   Paul still maintains and develops a non-public version of Xmgr for internal use.    1.2   Copyright statement             Copyright (©) 1991-1995 Paul J Turner, Portland, OR Copyright (©) 1996-2002 Grace Development Team  Maintained by Evgeny Stambulchik                            All Rights Reserved  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.         For certain libraries required to build Grace (which are therefore even included in a suitable version) there may be different Copyright/License statements. Though their License may by chance match the one used for Grace, the Grace Copyright holders can not influence or change them.         Package   License   cephes library   Free   T1lib   LGPL   Xbae   BSD-like   Tab Widget   BSD-like            Licenses               2.   Installation guide         2.1   Installing from sources               Configuration         Requirements. Grace usually compiles out of the box in a regular Unix-like environment. You need an ANSI C compiler (gcc is just fine), the X11R5 or above libraries and headers, and an implementaion of the M*tif API, version 1.2 or above. If you want to compile your own changes to certain parts of Grace, you will need a parser generator ( yacc  or, better,  bison ).    Extra libraries. Some features will be available only if additional libraries are installed. Those are:     The JPEG backend needs the IJG's (  JPEG library ), version 6.x.    The PNG backend needs the (  libpng ) library (version 0.96 or above).    The PDF driver requires the PDFlib library of Thomas Merz to be installed, which is available  here , version 3.02 or above.    If your computer has the FFTW library installed when Grace is compiled, Grace will link itself to this, and drop all conventional FFT's and DFT's. All transforms will be routed through this package. Note that there is then no difference between pushing the ""FFT"" button and the ""DFT"" button, except that FFT will complain if the length isn't a power of 2, and DFT will not.  For more information on this package, see the   FFTW Home page . In short, this package allows one to do non-power-of-2 length FFT's along with the normal ones.  It seems to work very efficiently for any set length which factors into 2^a 3^b 5^c 7^d for integer a, b, c, d. The great feature here is that set lengths which are powers of 10 (e.g. 1000, 10000) and integer multiples of these (500, 2000, 2500, 5000, etc.) can be computed with no significant penalty (maybe 20%) over power-of-2 transforms. Very often, real datasets come in these sizes, and not in powers of 2.    In order to read/write sets in the NetCDF data format, you will also need the   NetCDF libraries .        Decide whether you want to compile in a separate place (thus leaving the source tree pristine). You most probably would want it if compiling Grace for more than one OS and keeping the sources in a central shared (e.g. via NFS) location. If you don't need it, skip the rest of this paragraph and go right to the next step. Otherwise, assuming the sources are in  /usr/local/src/grace-x.y.z  and the compilation will be performed in  /tmp/grace-obj , do the following:    % mkdir /tmp/grace-obj   % cd /tmp/grace-obj   % /usr/local/src/grace-x.y.z/ac-tools/shtool mkshadow \     /usr/local/src/grace-x.y.z .                         The  configure  shell script attempts to guess correct values for various system-dependent variables used during compilation. It uses those values to create  Make.conf  in the top directory of the package. It also create  config.h  file containing system-dependent definitions. Finally, it creates a shell script  config.status  that you can run in the future to recreate the current configuration, a file  config.cache  that saves the results of its tests to speed up reconfiguring, and a file  config.log  containing compiler output (useful mainly for debugging  configure ). If at some point  config.cache  contains results you don't want to keep, you may remove or edit it.    Run  ./configure --help  to get list of additional switches specific to Grace    Run  ./configure <options> . Just an example:    % ./configure --enable-grace-home=/opt/grace      --with-extra-incpath=/usr/local/include:/opt/include \     --with-extra-ldpath=/usr/local/lib:/opt/lib --prefix=/usr                      would use  /usr/local/include  and  /opt/include  in addition to the default include path and  /usr/local/lib  and  /opt/lib  in addition to the default ld path. As well, all stuff would be put under the /opt/grace directory and soft links made to  /usr/bin ,  /usr/lib  and  /usr/include .  Note : If you change one of the  --with-extra-incpath  or  --with-extra-ldpath  options from one run of configure to another, remember to delete the  config.cache  file!!!          Compilation     Issue  make   If something goes wrong, try to see if the problem has been described already in the  Grace FAQ  (in the  doc  directory).          Testing           make tests   This will give you a slide show demonstrating some nice features of Grace.          Installation      make install     make links   The later (optional) step will make soft links from some files under the Grace home directory to the system-wide default locations (can be changed by the  --prefix  option during the configuration, see above).              2.2   Binary installation               Getting pre-built packages    Installation    Running tests        2.3   Alternative packaging schemes (RPM, ...)           Not written yet...     3.   Getting started        For a jump-in start, you can browse the demos (""Help/Examples"" menu tree). These are ordinary Grace projects, so you can play with them and modify them. Also, read the   Tutorial .   O.k. Here's a VERY quick introduction:     Start the GUI version: xmgrace (return).    Select/check the output medium and canvas size in File/Device Setup.    If needed, set the graph size ('Viewport' in Plot/Graph Appearance).    Load your data with Data/Import/ASCII. 'Load as': 'Single set' for two-column ASCII data, 'Block data' for multi-column ASCII data.    Adjust the scales, axis labels and tick marks in Plot/Axis properties. Acknowledge all changes with 'Apply'.    Adjust lines, symbols, legends in Plot/Set appearance.    Adjust titles, plot frame and legend display in Plot/Graph Appearance.    Data can be manipulated in Data/Transformations. To shift a data set by 20 to the left, e.g., in 'Evaluate Expression' select the same set on the left and the right, and say Formula: y=y-20. As you'll probably notice, Grace can do MUCH more than that. Explore at your leisure.    When you like your plot, select File/Print. That's it!        3.1   General concepts             Project files              A project file contains all information necessary to restore a plot created by Grace, as well as some of preferences. Each plot is represented on a single page, but may have an unlimited number of graphs.You create a project file of your current graph with File/Save,Save as.     Parameter files              A parameter file contains the detailed settings of your project. It can be used to transfer these settings to a different plot/project. You generate a parameter file with File/Save menu entry selected from the ""Plot/Graph appearance popup"". You can load the settings contained in a parameter file with File/Open.     Input File formats              Grace understands several input files formats. The most basic one is ASCII text files containing space and comma separated columns of data. The data fields can be either numeric (Fortran 'd' and 'D' exponent markers are supported) or alphanumeric (with or without quotes). Several calendar date formats are recognized automatically and you can specify your own reference for numeric dates formats. Grace also has a command language (see   command interpreter ), you can include commands in data files using lines having ""@"" as their first non-blank character. Depending on configuration, Grace can also read NetCDF files (see   configuration ).     Graphs              A graph consists of (every element is optional): a graph frame, axes, a title and a subtitle, a number of sets and additional annotative objects (time stamp string, text strings, lines, boxes and ellipses).   The graph type can be any of:        XY Graph    XY Chart    Polar Graph    Fixed Graph    Pie chart         Datasets              A dataset is a collection of points with x and y coordinates, up to four optional data values (which, depending on the set type, can be displayed as error bars or like) and one optional character string.     Sets              A set is a way of representing datasets. It consists of a pointer to a dataset plus a collection of parameters describing the visual appearance of the data (like color, line dash pattern etc).   The set type can be any of the following:          Set type   # of num. cols   Description   XY   2   An X-Y scatter and/or line plot, plus (optionally) an annotated value   XYDX   3   Same as XY, but with error bars (either one- or two-sided) along X axis   XYDY   3   Same as XYDX, but error bars are along Y axis   XYDXDX   4   Same as XYDX, but left and right error bars are defined separately   XYDYDY   4   Same as XYDXDX, but error bars are along Y axis   XYDXDY   4   Same as XY, but with X and Y error bars (either one- or two-sided)   XYDXDXDYDY   6   Same as XYDXDY, but left/right and upper/lower error bars are defined separately   BAR   2   Same as XY, but vertical bars are used instead of symbols   BARDY   3   Same as BAR, but with error bars (either one- or two-sided) along Y axis   BARDYDY   4   Same as BARDY, but lower and upper error bars are defined separately   XYHILO   5   Hi/Low/Open/Close plot   XYZ   3   Same as XY; makes no sense unless the annotated value is Z   XYR   3   X, Y, Radius. Only allowed in Fixed graphs   XYSIZE   3   Same as XY, but symbol size is variable   XYCOLOR   3   X, Y, color index (of the symbol fill)  XYCOLPAT   4   X, Y, color index, pattern index (currently used for Pie charts only)   XYVMAP   4   Vector map   XYBOXPLOT   6   Box plot (X, median, upper/lower limit, upper/lower whisker)                 Set types                   Not all set types, however, can be plotted on any graph type. The following table summarizes it:          Set type   XY Graph   XY Chart   Fixed   Polar   Pie   XY   +   +   +   +   +   XYDX   +   -   +   -   -   XYDY   +   +   +   -   -   XYDXDX   +   -   +   -   -   XYDYDY   +   +   +   -   -   XYDXDY   +   -   +   -   -   XYDXDXDYDY   +   -   +   -   -   BAR   +   +   +   -   -   BARDY   -   +   -   -   -   BARDYDY   -   +   -   -   -   XYHILO   +   -   -   -   -   XYZ   +   -   +   +   -   XYR   -   -   +   -   -   XYSIZE   +   +   +   +   -   XYCOLOR   +   +   +   +   +   XYCOLPAT   -   -   -   -   +   XYVMAP   +   -   +   -   -   XYBOXPLOT   +   -   -   -   -                 Graph/Set type connection                    Regions              Regions are sections of the graph defined by the interior or exterior of a polygon, or a half plane defined by a line. Regions are used to restrict data transformations to a geometric area occupied by region.     Real Time Input              Real Time Input refers to the ability Grace has to be fed in real time by an external program. The Grace process spawned by the driver program is a full featured Grace process: the user can interact using the GUI at the same time the program sends data and commands. The process will adapt itself to the incoming data rate.     Hotlinks              Hotlinks are sources containing varying data. Grace can be instructed a file or a pipe is a hotlink in which case it will provide specific commands to refresh the data on a mouse click (a later version will probably allow automatic refresh).     Devices            Grace allows the user to choose between several output devices to produce its graphics. The current list of supported devices is:        X11    PostScript (level 1 and level 2)    EPS (encapsulated PostScript)    Metafile (which is Grace format, used at the moment mostly for debugging purposes)    MIF (Maker Interchange Format used by FrameMaker)    SVG (Scalable Vector Graphics, a language for describing two-dimensional vector and mixed vector/raster graphics in XML)    PDF (depends on extra libraries, see   configuration )    PNM (portable anymap file format)    JPEG (depends on extra libraries, see   configuration )    PNG (depends on extra libraries, see   configuration )        Note that Grace no longer supports GIF due to the copyright policy of Unisys. Grace can also be instructed to launch conversion programs automatically based on file name. As an example you can produce MIF (FrameMaker Interchange Format) or Java applets using pstoedit, or almost any image format using the netpbm suite (see the   FAQ ).     Magic path            In many cases, when Grace needs to access a file given with a relative  pathname , it searches for the file along the following path:  ./pathname:./.grace/pathname:~/.grace/pathname:$GRACE_HOME/pathname     Dynamic modules            Grace can access external functions present in either system or third-party shared libraries or modules specially compiled for use with it. The term dynamic refers to the possibility Grace has to open the library at run time to find the code of the external function, there is no need to recompile Grace itself (the functions already compiled in Grace are ""statically linked"").     Coordinate frames             There are two types of coordinates in Grace: the  world coordinates  and the  viewport coordinates . Points of data sets are defined in the world coordinates. The viewport coordinates correspond to the image of the plot drawn on the canvas (or printed on, say, PS output page). The transformation converting the world coordinates into the viewport ones is determined by both the graph type and the axis scaling.   Actually, there is yet another level in the hierarchy of coordinates - the  device coordinates . However, you (as a user of Grace) should not worry about the latter. The mapping between the viewport coordinates and the device coordinates is always set in such a way that the origin of the viewport corresponds to the left bottom corner of the device page, the smallest of the device dimensions corresponds to one unit in the viewport coordinates. Oh, and the most important thing about the viewport -> device transformation is that it is homotetic, i.e. a square is guaranteed to remain a square, not a rectangle, a circle remains a circle (not an ellipse) etc.   3.2   Invocation            Operational mode             With respect to the user interface, there are three modes of operation that Grace can be invoked in. The full-featured GUI-based version is called  xmgrace . A batch-printing version is called  gracebat . A command-line interface mode is called  grace . Usually, a single executable is called in all cases, with two of the three files being (symbolic) links to a ""real"" one.    Command line options                 -autoscale  x|y|xy   Override any parameter file settings     -barebones  Turn off all toolbars     -batch  batch_file   Execute batch_file on start up     -block  block_data   Assume data file is block data     -bxy  x:y:etc.   Form a set from the current block data set using the current set type from columns given in the argument     -datehint  iso|european|us|days|seconds|nohint   Set the hint for dates analysis     -dpipe  descriptor   Read data from descriptor (anonymous pipe) on startup     -fixed  width   height   Set canvas size fixed to width*height     -free  Use free page layout     -graph  graph_number   Set the current graph number     -graphtype  graph_type   Set the type of the current graph     -hardcopy  No interactive session, just print and quit     -hdevice  hardcopy_device_name   Set default hardcopy device     -install  Install private colormap     -legend  load   Turn the graph legend on     -log  x|y|xy   Set the axis scaling of the current graph to logarithmic     -mono  Run Grace in monochrome mode (affects the display only)     -netcdf  file   Assume data  file  is in netCDF format. This option is present only if the netCDF support was compiled in     -netcdfxy  X_var   Y_var   If -netcdf was used previously, read from the netCDF file  X_var   Y_var  variables and create a set. If  X_var  name is ""null"" then load the index of Y to X. This option is present only if the netCDF support was compiled in       -noask  Assume the answer is yes to all requests - if the operation would overwrite a file, Grace will do so without prompting     -noinstall  Don't use private colormap     -noprint  In batch mode, do not print     -nosigcatch  Don't catch signals     -npipe  file   Read data from named pipe on startup     -nxy  nxy_file   Assume data file is in X Y1 Y2 Y3 ... format     -param  parameter_file   Load parameters from parameter_file to the current graph     -pexec  parameter_string   Interpret string as a parameter setting     -pipe  Read data from stdin on startup     -printfile  file  Save print output to file     -remove  Remove data file after read     -results  results_file   Write results of some data manipulations to results_file     -rvideo  Exchange the color indices for black and white     -saveall  save_file   Save all graphs to save_file     -seed  seed_value   Integer seed for random number generator     -source  disk|pipe   Source type of next data file     -timer  delay   Set allowed time slice for real time inputs to delay ms     -timestamp  Add timestamp to plot     -settype  xy|xydx|...   Set the type of the next data file     -version  Show the program version     -viewport  xmin ymin xmax ymax   Set the viewport for the current graph     -wd  directory   Set the working directory     -world  xmin ymin xmax ymax   Set the world coordinates for the current graph     -usage|-help  This message         3.3   Customization            Environment variables                GRACE_HOME  Set the location of Grace. This will be where help files, auxiliary programs, and examples are located. If you are unable to find the location of this directory, contact your system administrator.       GRACE_PRINT_CMD  Print command. If the variable is defined but is an empty string, ""Print to file"" will be selected as default.       GRACE_EDITOR  The editor used for manual editing of dataset values.       GRACE_HELPVIEWER  The HTML viewer for on-line browsing of help documents       GRACE_FFTW_WISDOM_FILE and GRACE_FFTW_RAM_WISDOM  These flags control behavior of the FFTW planner (see  FFTW tuning  for detailed info)            Init file          Upon start-up, Grace loads its init file,  gracerc . The file is searched for in the magic path (see  magic path ); once found, the rest of the path is ignored. It's recommended that in the  gracerc  file, one doesn't use statements which are part of a project file - such defaults, if needed, should be set in the default template (see   default template ).     Default template          Whenever a new project is started, Grace loads the default template,  templates/Default.agr . The file is searched for in the magic path (see    magic path ); once found, the rest of the path is ignored. It's recommended that in the default template, one doesn't use statements which are NOT part of a project file - such defaults, if needed, should be set in the  gracerc  (see   init file ).    X resources           The following Grace-specific X resource settings are supported:        XMgrace.invertDraw  Use GXinvert rather than GXxor for rubber-band lines. If the rubber-banding for zooms and lines, etc. doesn't appear on the canvas, set this resource to yes.      XMgrace.allowDoubleClick  When Yes, allow double clicks on the canvas to bring up various popups depending on  the location of the pointer when the double click occurs.      XMgrace.toolBar  Enables button toolbar      XMgrace.statusBar  Enables status bar      XMgrace.locatorBar  Enables locator bar          It is also possible to customize menus by assigning key accelerators to any item.   You'll need to derive the item's X resource name from the respective menu label, which is easily done following these rules:     All non-alphanumeric characters are skipped    Start with lower case; each new word (if any) continues from the capital letter    Add the item's type to the end - ""Menu"" for pulldown menus, ""Button"" for menu buttons.       For example, in order to make Grace popup the Non-linear curve fitting by pressing Control+F, you would add the following two lines   XMgrace*transformationsMenu.nonLinearCurveFittingButton.acceleratorText: Ctrl+F  XMgrace*transformationsMenu.nonLinearCurveFittingButton.accelerator: Ctrl<Key>f    to your  .Xresources  file (the file which is read when an X session starts; it could be  .Xdefaults ,  .Xsession  or some other file - ask your system administrator when in doubt).    Similarly, it may be desirable to alter default filename patterns of file selection dialogs. The recipe for the dialog's name is like for menu buttons outlined above, with ""Button"" being replaced with ""FSB"". E.g., to list all files in the ""Open project"" dialog (""File/Open...""), set the following resource:   XMgrace*openProjectFSB.pattern: *      4.   Guide to the graphical user interface        4.1   GUI controls          This section describes interface controls - basic building blocks, used in many popups.    File selection dialogs           Whenever the user is expected to provide a filename, either for reading in or writing some data, a file selection dialog is popped up. In addition to the standard entries (the directory and file lists and the filter entry), there is a pulldown menu for quick directory change to predefined locations (the current working directory, user's home directory and the file system root). Also, a ""Set as cwd"" button is there which allows to set any directory as you navigate through the directory tree as the current working directory (cwd). Once defined, it can be used in any other file selection dialog to switch to that directory quickly.     List selectors           Various selectors are available in several popups. They all display lists of objects (graphs, sets, ...) and can be used to perform simple operations on these objects (copying, deleting, ...). The operations are available from a popup menu that appears when pressing mouse button 3 on them. Depending on the required functionality, they may allow multiple choices or not. The following shortcuts are enabled (if the result of an action would contradict the list's selection policy, this would be ignored):     Ctrl+a select all    Ctrl+u unselect all    Ctrl+i invert selection         Graph selector             The operations that can be performed on graphs through the graph selector's popup menu are:     focus to    hide    show    duplicate    kill    swap    create new     All this operations are not available in every instance of the selector. For example in the ""read sets"" popup only one graph can be selected at a time, and the swap operation is disabled.   Double-clicking on a list entry will switch the focus to that graph.     Set selector             The operations that can be performed on sets through the set selector's popup menu are:     hide    show    bring to front    send to back    duplicate    kill    kill data    swap    edit     in spreadsheet (see  Spreadsheet data set editor )    in text editor        create new     by formula    in spreadsheet (see  Spreadsheet data set editor )    in text editor    from block data        pack all sets    selector operations     view set comments    show data-less    show hidden    select all    unselect all    invert selection    update           Double-clicking on a list entry will open the spreadsheet editor (see   Spreadsheet data set editor ) on the set data.      4.2   The main window             The canvas           Canvas hotkeys             When the pointer focus is on the canvas (where the graph is drawn), there are some shortcuts to activate several actions. They are:        Ctrl <Key>A: Autoscale the current graph    Ctrl <Key>D: Delete an object    Ctrl <Key>L: Move current graph legend    Ctrl <Key>M: Move an object    Ctrl <Key>T: Place timestamp    Ctrl <Key>U: Refresh hotlinks    Ctrl <Key>V: Set the viewport with mouse    Ctrl <Key>Z: Zoom    Ctrl Alt <Key>L: Draw a line    Ctrl Alt <Key>B: Draw a box    Ctrl Alt <Key>E: Draw an ellipse    Ctrl Alt <Key>T: Write a text string         Clicks and double clicks            A single click inside a graph switches focus to that graph. This is the default policy, but it can be changed from the ""Edit/Preferences"" popup.   Double clicking on parts of the canvas will invoke certain actions or raise some popups:        on a focus marker: move selected viewport corner     on an axis:  ""Plot/Axis properties"" popup    on a set:    ""Plot/Set appearance"" popup    on a legend: ""Plot/Graph appearance"" popup    on a (sub)title: ""Plot/Graph appearance"" popup    on an object (box, line, ...): a popup for editing properties of that object       The double clicking actions can be enabled/disabled from the ""Edit/Preferences"" popup.     Toolbar buttons          Along the left-hand side of the canvas (if shown) is the ToolBar. It is armed with several buttons to provide quick and easy access to the more commonly used Grace functions.           Draw : This will redraw the canvas and sets. Useful if ""Auto Redraw"" has been deselected in the Edit|Preferences dialog or after executing commands directly from the Window|Commands interpreter.          Lens : A zoom lens.  Click on the lens, then select the area of interest on the graph with the ""rubber band"".  The region enclosed by the rubber band will fill the entire graph.         AS : AutoScale.  Autoscales the graph to contain all data points of all visible (not hidden) sets.        Z/z :  Zoom in/out by 5%. The zoom percentage can be set in the Edit/Preferences dialog.     Arrows :  Scroll active graph by 5% in the arrow's direction.  The scroll percentage can be set in the Edit/Preferences dialog.        AutoT : AutoTick Axes.  This will find the optimum number of major and minor tick marks for both axes.     AutoO : Autoscale On set.  Click the  AutoO  button, then click on the graph near the set you wish to use for determining the autoscale boundaries of the graph.       ZX,ZY : Zoom along an axis.  These buttons work like the zoom lens above but are restricted to a single axis.      AX,AY : Autoscale one axis only.  The following buttons deal with the graph stack and there is a good example under Help/Examples/General Intro/World Stack.       Pu/Po : Push and pop the current world settings to/from the graph stack. When popping, makes the new stack top current.     PZ : Push before Zooming.  Functions as the zoom lens, but first pushes the current world settings to the stack.       Cy : Cycles through the stack settings of the active graph.  Each graph may have up to twenty layers on the stack.               Exit : Pretty obvious, eh?           4.3   File menu          The file menu contains all entries related to the input/output features of Grace.     New           Reset the state of Grace as if it had just started (one empty graph ranging from 0 to 1 along both axes). If some work has been done and not yet saved, a warning popup is displayed to allow canceling the operation.     Open           Open an existing   project file . A popup is displayed that allow to browse the file system.     Save           Save the current work in a project file, using the name that was used for the last open or save. If no name has been set (i.e., if the project has been created from scratch) act as   save as .     Save as           Save the current work in a project file with a new name. A popup allows to browse the file system and set the name, the format to use for saving data points (the default value is ""%16.8g""), and a textual description of the project. A warning is displayed if a file with the same name already exists.     Revert to saved           Abandon all modifications performed on the project since the last save. A confirmation popup is fired to allow the user canceling the operation.     Print setup           Set the properties of the printing device. Each device has its own set of specific options (see   Device-specific       settings ). According to the device, the output can be sent either directly to a printer or directed to a file. The global settings available for all devices are the sizing parameters. The size of the graph is fixed. Changing the 'Page' settings changes the size of the canvas underneath the graph. Switching between portrait and landscape rotates the canvas. Make sure the canvas size is large enough to hold your graph. Otherwise you get a 'Printout truncated' warning. If your canvas size cannot easily be changed because, for example, you want to print on letter size paper, you need to adjust the size of your graph ('Viewport' in Plot/Graph Appearance).     Print           Print the project using the current printer settings     Exit           Exit from Grace. If some work has been done and not saved, a warning popup will be displayed to allow the user to cancel the operation.      4.4   Edit menu            Data sets           Using the data set popup, you can view the properties of datasets. This include its type, length, associated comment and some statistics (min, max, mean, standard deviation). A horizontal scrollbar at the bottom allows to get the two last properties, they are not displayed by default. Also note that if you find some columns are too narrow to show all significant digits, you can drag the vertical rules using Shift+Button 2.   Using the menu on the top of this dialog, you can manipulate existing sets or add new ones. Among the most important entries in the menu, are options to create or modify a set using the spreadsheet data set editor (see   Spreadsheet data set editor ).     Spreadsheet data set editor            The dialog presents an editable matrix of numbers, corresponding to the data set being edited. The set type (and hence, the number of data columns) can be changed using the ""Type:"" selector. Clicking on a column label pops up a dialog allowing to adjust the column formatting. Clicking on the row labels toggles the respective row state (selected/unselected). The selected rows can be deleted via the dialog's ""Edit"" menu. Another entry in this menu lets you add a row; the place of the new row is determined by the row containing a cell with the keyboard focus on. As well, just typing in an empty cell will add one or several rows (filling the intermediate rows with zeros).   To resize columns, drag the vertical rules using Shift+Button 2.    Set operations           The set operations popup allows you to interact with sets as a whole. If you want to operate on the data ordering of the sets, you should use the   data set operations  popup from the Data menu. The popup allows you to select a source (one set within one graph) and a destination and perform some action upon them (copy, move, swap). This popup also give you a quick access to several graph and set selectors if you want to perform some other operation like hiding a graph or creating a new set from block data.     Arrange graphs           This entry fires up a popup to lay out several graphs in a regular grid given by  M  rows and  N  columns.    The graph selector at the top allows one to select a number of graphs the arrangement will operate on. If the number of selected graphs isn't equal to  M  times  N ,  new graphs may be created or extra graphs killed if needed. These options are  controlled by the respective checkboxes below the graph selector.   The order in which the matrix is filled in with the graphs can be selected (first horizontally then vertically or vise versa, with either of them inverted). Additionaly, one may choose to fill the matrix in the snake-like manner (adjacent ""strokes"" are anti-parallel).   The rest of the controls of the dialog window deal with the matrix spacing: left/right/top/bottom page offsets (in the viewport coordinates) and  relative  inter-cell distances, vertical and horizontal. Next to each of the vertical/horizontal spacing spinboxes, a ""Pack"" checkbox is found. Enabling it effectively sets the respective inter-cell distance to zero and alter axis tickmark settings such that only bottom/left-most tickmarks are visible.   If you don't want the regular layout this arrangement gives you, you can change it afterwards using the mouse (select a graph and double click on the focus marker, see   clicks and double clicks ).     Overlay graphs           You can overlay a graph on top of another one. The main use of this feature is to plot several curves using different scales on the same (apparently) graph. The main difficulty is to be sure you operate on the graph you want at all times (you can hide one for a moment if this becomes too difficult).     Autoscale           Using this entry, you can autoscale one graph or all graphs according to the specified sets only. This is useful if you need either to have truly comparable graphs despite every one contains data of different ranges, or if you want to focus your attention on one set only while it is displayed with other data in a complex graph.     Regions menu             Status              This small popup only displays the current state (type and whether it is active or not) of the existing regions.     Define              You can define a new region (or redefine an existing one), the allowed region types are:        Inside polygon    Outside polygon    Above line    Below line    Left of line    Right of line    In horizontal range    In vertical range    Out of horizontal range    Out of vertical range       A region can be either linked to the current graph only or to all graphs.     Clear              This kills a region.     Report on              This popup reports you which sets or points are inside or outside of a region.     Hot links           You can link a set to a file or a pipe using this feature. Once a link has been established, you can update it (i.e., read data again) by clicking on the update button. If you have specified a command (using Grace language) in the corresponding text field of the popup, it will be executed after each update. Note that you can use several commands separated by ';' characters.   Currently, only simple XY sets can be used for hotlinks.     Set locator fixed point           After having selected this menu entry, you can select a point on a graph that will be used as the origin of the locator display (just below the menu bar). The fixed point is taken into account only when the display type of the locator is set to [DX,DY].     Clear locator fixed point           This entry is provided to remove a fixed point set before and use the default again: point [0, 0].     Locator props           The locator props popup allows you to customize the display of the locator, mainly its type and the format and precision of the display. You can use all the formats that are allowed in the graphs scales.     Preferences           The preferences popup allows you to set miscellaneous properties of your Grace session, such as GUI behavior, cursor type, date reading hint and reference date used for calendar conversions.      4.5   Data menu            Data set operations           This popup gathers all operations that are related to the ordering of data points inside a set or between sets. If you want to operate on the sets as a whole, you should use the   set operations  popup from the Edit menu. You can sort according to any coordinate (X, Y, DX, ...) in ascending or descending order, reverse the order of the points, join several sets into one, split one set into several others of equal lengths, or drop a range of points from a set. The   set selector  of the popup shows the number of points in each set in square brackets like this: G0.S0[63], the points are numbered from 0 to n-1.     Transformations menu           The transformations sub-menu gives you access to all data-mining features of Grace.     Evaluate expression              Using evaluate expression allows you to create a set by applying an explicit formula to another set, or to parts of another set if you use regions restrictions.   All the classical mathematical functions are available (cos, sin, but also lgamma, j1, erf, ...). As usual all trigonometric functions use radians by default but you can specify a unit if you prefer to say cos (x rad) or sin (3 * y deg). For the full list of available numerical functions and operators, see  Operators and functions .   In the formula, you can use X, Y, Y1, ..., Y4 to denote any coordinate you like from the source set. An implicit loop will be used around your formula so if you say:                x = x - 4966.5                  you will shift all points of your set 4966.5 units to the left.   You can use more than one set in the same formula, like this:                y = y - 0.653 * sin (x deg) + s2.y                  which means you use both X and Y from the source set but also the Y coordinate of set 2. Beware that the loop is a simple loop over the indices, all the sets you use in such an hybrid expression should therefore have the same number of points and point i of one set should really be related to point i of the other set. If your sets do not follow these requirements, you should first homogenize them using  interpolation .     Histograms              The histograms popup allows you to compute either standard or cumulative histograms from the Y coordinates of your data. Optionally, the histograms can be normalized to 1 (hence producing a PDF (Probability Distribution Function).   The bins can be either a linear mesh defined by its min, max, and length values, or a mesh formed by abscissas of another set (in which case abscissas of the set must form a strictly monotonic array).     Fourier transforms              This popup is devoted to direct and inverse Fourier transforms. The default is to perform a direct transform on unfiltered data and to produce a set with the index as abscissa and magnitude as ordinate. You can filter the input data window through triangular, Hanning, Welch, Hamming, Blackman and Parzen filters. You can load magnitude, phase or coefficients and use either index, frequency or period as abscissas. You can choose between direct and inverse Fourier transforms. If you specify real input data, X is assumed to be equally spaced and ignored; if you specify complex input data X is taken as the real part and Y as the imaginary part.   If Grace was configured with the FFTW library (see   configuration ), then the DFT and FFT buttons really perform the same transform (so there is no speed-up in using FFT in this case). If you want Grace can to use FFTW  wisdom  files, you should set several   environment variables  to name them.     Running averages              The running average popup allows you to compute some values on a sliding window over your data. You choose both the value you need (average, median, minimum, maximum, standard deviation) and the length of the window and perform the operation. You can restrict the operation to the points belonging to (or outside of) a region.     Differences              The differences popup is used to compute approximations of the first derivative of a function with finite differences. The only choice (apart from the source set of course) is the type of differences to use: forward, backward or centered.     Seasonal differences              The seasonal differences popup is used to subtract data from a period to data of the preceding period (namely y[i] - y[i + period]). Beware that the period is entered in terms of index in the set and not in terms of abscissa!     Integration              The integration popup is used to compute the integral of a set and optionally to load it. The numerical value of the integral is shown in the text field after computation. Selecting ""cumulative sum"" in the choice item will create and load a new set with the integral and compute the end value, selecting ""sum only"" will only compute the end value.     Interpolation/Splines              This popup is used to interpolate a set on an array of alternative X coordinates. This is mainly used before performing some complex operations between two sets with the   evaluate          expression  popup.   The sampling array can be either a linear mesh defined by its min, max, and length values, or a mesh formed by abscissas of another set.    Several interpolation methods can be used: linear, spline or Akima spline.   Note that if the sampling mesh is not entirely within the source set X bounds, evaluation at the points beyond the bounds will be performed using interpolation parameters from the first (or the last) segment of the source set, which can be considered a primitive extrapolation. This behaviour can be disabled by checking the ""Strict"" option on the popup.   The abscissas of the set being interpolated must form a strictly monotonic array.     Regression              The regression popup can be used to fit a set against polynomials or some specific functions (y=A*x^B, y=A*exp(B*x), y=A+B*ln(x) and y=1/(A+Bx)) for which a simple transformation of input data can be used to apply linear regression formulas.   You can load either the fitted values, the residuals or the function itself. Choosing to load fitted values or residuals leads to a set of the same length and abscissas as the initial set. Choosing to load the function is almost similar to load the fitted values except that you choose yourself the boundaries and the number of points. This can be used for example to draw the curve outside of the data sample range or to produce an evenly spaced set from an irregular one.     Non-linear fit              The non linear fit popup can be used for functions outside of the simple regression methods scope. With this popup you provide the expression yourself using a0, a1, ..., a9 to denote the fit parameters (as an example you can say y = a0 * cos (a1 * x + a2)). You specify a tolerance, starting values and optional bounds and run several steps before loading the results.   The fit characteristics (number of parameters, formula, ...) can be saved in a file and retrieved as needed using the file menu of the popup.   In the ""Advanced"" tab, you can additionally apply a restriction to the set(s) to be fitted (thus ignoring points not satisfying the criteria), use one of preset weighting schemes or define your own, and choose whether to load the fitted values, the residuals or the function itself. Choosing to load fitted values or residuals leads to a set of the same length and abscissas as the initial set. Choosing to load the function is almost similar to load the fitted values except that you choose yourself the boundaries and the number of points. This can be used for example to draw the curve outside of the data sample range or to produce an evenly spaced set from an irregular one.     Correlation/covariance              This popup can be used to compute autocorrelation of one set or cross correlation between two sets. You only select the set (or sets) and specify the maximum lag. A check box allows one to evaluate covariance instead of correlation.     Digital filter              You can use a set as a weight to filter another set. Only the Y part and the length of the weighting set are important, the X part is ignored.     Linear convolution              The convolution popup is used to ... convolve two sets. You only select the sets and apply.     Geometric transforms              You can rotate, scale or translate sets using the geometric transformations popup. You specify the characteristics of each transform and the application order.     Sample points              This popup provides two sampling methods. The first one is to choose a starting point and a step, the second one is to select only the points that satisfy a boolean expression you specify.     Prune data              This popup is devoted to reducing huge sets (and then saving both computation time and disk space).   The interpolation method can be applied only to ordered sets: it is based on the assumption that if a real point and an interpolation based on neighboring points are closer than a specified threshold, then the point is redundant and can be eliminated.   The geometric methods (circle, ellipse, rectangle) can be applied to any set, they test each point in turn and keep only those that are not in the neighborhood of previous points.      Feature extraction           Given a set of curves in a graph, extract a feature from each curve and use the values of the feature to provide the Y values for a new curve.         Feature   Description   Y minimum   Minimum Y value of set   Y maximum   Maximum Y value of set   Y average   Average Y value of set   Y std. dev.   Standard deviation of Y values   Y median   Median Y value   X minimum   Minimum X value of set   X maximum   Maximum X value of set   X average   Average X value of set   X std. dev.   Standard deviation of X values   X median   Median X value   Frequency   Perform DFT (FFT if set length a power of 2) to find largest frequency component   Period   Inverse of above   Zero crossing   Time of the first zero crossing, + or - going   Rise time   Assume curve starts at the minimum and rises to the maximum, get time to go from 10% to 90% of rise. For single exponential curves, this is 2.2*time constant   Fall time   Assume curve starts at the maximum and drops to the minimum, get time to go from 90% to 10% of fall   Slope   Perform linear regression to obtain slope   Y intercept   Perform linear regression to obtain Y-intercept   Set length   Number of data points in set   Half maximal width   Assume curve starts from the minimum, rises to the maximum and drops to the minimum again. Determine the time for which the curve is elevated more than 50% of the maximum rise.   Barycenter X   Barycenter along X axis   Barycenter Y   Barycenter along Y axis   X (Y max)   X of Maximum Y   Y (X max)   Y of Maximum X   integral   cumulative sum                   Extractable features               Import menu             ASCII              Read new sets of data in a graph. A   graph selector  is used to specify the graph where the data should go (except when reading block data, which are copied to graphs later on).   Reading as ""Single set"" means that if the source contains only one column of numeric data, one set will be created using the indices (from 1 to the total number of points) as abscissas and read values as ordinates and that if the source contains more than one column of data, the first two numeric columns will be used. Reading as ""NXY"" means that the first numeric column will provide the abscissas and all remaining columns will provide the ordinates of several sets. Reading as ""Block data"" means all column will be read and stored and that another popup will allow to select the abscissas and ordinates at will. It should be noted that block data are stored as long as you do not override them by a new read. You can still retrieve data from a block long after having closed all popups, using the   set          selector .   The set type can be one of the predefined set presentation types (see   sets ).   The data source can be selected as ""Disk"" or ""Pipe"". In the first case the text in the ""Selection"" field is considered to be a file name (it can be automatically set by the file selector at the top of the popup). In the latter case the text is considered to be a command which is executed and should produce the data on its standard output. On systems that allows is, the command can be a complete sequence of programs glued together with pipes.   If the source contains date fields, they should be automatically detected. Several formats are recognized (see appendix   dates in grace ). Calendar dates are converted to numerical dates upon reading.   The ""Autoscale on read"" menu controls whether, upon reading in new sets, which axes of the graph should be autoscaled.     NetCDF              This entry exists only if Grace has been compiled with support for the NetCDF data format (see   configuration ).     Export menu             ASCII              Save data sets in a file. A   set          selector  is used to specify the set to be saved. The format to use for saving data points can be specified (the default value is ""%16.8g""). A warning is displayed if a file with the same name already exists.       4.6   Plot menu            Plot appearance           The plot appearance popup let you set the time stamp properties and the background color of the page. The color is used outside of graphs and also on graphs were no specific background color is set. The time stamp is updated every time the project is modified.     Graph appearance           The graph appearance popup can be displayed from both the plot menu and by double-clicking on a legend, title, or subtitle of a graph (see   Clicks and double clicks ). The graph selector at the top allows to choose the graph you want to operate on, it also allows certain common actions through its popup menu (see  graph selector ). Most of the actions can also be performed using the ""Edit"" menu available from the popup menubar. The main tab includes the properties you will need more often (title for example), and other tabs are used to fine tune some less frequently used options (fonts, sizes, colors, placements).   If you need special characters or special formatting in your title or subtitle, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!   You can save graph appearance parameters or retrieve settings previously saved via the ""File"" menu of this popup. In the ""Save parameters"" dialog, you can choose to save settings either for the current graph only or for all graphs.      Set appearance           The set appearance popup can be displayed from both the plot menu and by double-clicking anywhere in a graph (see   Clicks and double clicks ). The set selector at the top allows to choose the set you want to operate on, it also allows certain common actions through its popup menu (see  set selector ). The main tab gathers the properties you will need more often (line and symbol properties or legend string for example), and other tabs are used to fine tune some less frequently used options (drop lines, fill properties, annotated values and error bars properties for example).   You should note that despite the legend string related to  one  set is entered in the set appearance popup, this is not sufficient to display it. Displaying  all  legends is a graph level decision, so the toggle is in the main tab of the   graph appearance  popup.   If you need special characters or special formatting in your legend, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!     Axis properties           The axis properties popup can be displayed from both the ""Plot"" menu and by double-clicking exactly on an axis (see   Clicks and double clicks ). The pulldown menu at the top allows to select the axis you want to operate on. The ""Active"" toggle globally activates or deactivates the axis (all GUI elements are insensitive for deactivated axes). The start and stop fields depict the displayed range. Three types of scales are available: linear, logarithmic or reciprocal, and you can invert the axis (which normally increases from left to right and from bottom to top).  The main tab includes the properties you will need more often (axis label, tick spacing and format for example), and other tabs are used to fine tune some less frequently used options (fonts, sizes, colors, placements, stagger, grid lines, special ticks, ...).   If you need special characters or special formatting in your label, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!   Once you have set the options as you want, you can apply them. One useful feature is that you can set several axes at once with the bottom pulldown menu (current axis, all axes current graph, current axis all graphs, all axes all graphs). Beware that you always apply the properties of all tabs, not only the selected one.      4.7   View menu            Show locator bar           This toggle item shows or hides the locator below the menu bar.     Show status bar           This toggle item shows or hides the status string below the canvas.     Show tool bar           This toggle item shows or hides the tool bar at the left of the canvas.     Page setup           Set the properties of the display device. It is the same dialog as in   Print setup .     Redraw           This menu item triggers a redrawing of the canvas.     Update all           This menu item causes an update of all GUI controls. Usually, everything is updated automatically, unless one makes modifications by entering commands in the   Command  tool.       4.8   Window menu             Commands           Command driven version of the interface to Grace. Here, commands are typed at the ""Command:"" text item and executed when <Return> is pressed. The command will be parsed and executed, and the command line is placed in the history list. Items in the history list can be recalled by simply clicking on them with the left mouse button. For a reference on the Grace command interpreter, see   Command interpreter .    Point tracking           Not written yet...    Drawing objects           Not written yet...    Font tool           Not written yet...    Console           The console window displays errors and results of some numerical operations, e.g. nonlinear fit (see   Non-linear fit ). The window is popped up automatically whenever an error occurs or new result messages appear. This can be altered by checking the ""Options/Popup only on errors"" option.     4.9   Help menu            On context           Click on any element of the interface to get context-sensitive help on it. Only partially implemented at the moment.    User's guide           Browse the Grace user's guide.    Tutorial           Browse the Grace tutorial.    FAQ           Frequently Asked Questions with answers.    Changes           The list of changes during the Grace development.    Examples           The whole tree of submenus each loading a sample plot.    Comments           Use this to send your suggestions or bug reports.    License terms           Grace licensing terms will be displayed (GPL version 2).    About           A popup with basic info on the software, including some configuration details. More details can be found when running Grace with the ""-version"" command line flag.     5.   Command interpreter          5.1   General notes          The interpreter parses its input in a line-by-line manner. There may be several statements per line, separated by semicolon ( ; ). The maximal line length is 4 kbytes (hardcoded). The parser is case-insensitive and ignores lines beginning with the "" # "" sign.   5.2   Definitions               Name   Description   Examples   expr  Any numeric expression  1.5 + sin(2)   iexpr  Any expression that evaluates to an integer  25, 0.1 + 1.9, PI/asin(1)   nexpr  Non-negative iexpr  2 - 1   indx  Non-negative iexpr      qstr  Quoted string  ""a string""   vexpr  Vector expression  ""2*x""                         Basic types                  Expression   Description   Types   Example   GRAPH[ id ]  graph  id   indx  id   GRAPH[0]   G nn   graph  nn   nn : 0-99  G0                         Graph selections                  Expression   Description   Types   Example    graph .SETS[ id ]  set  id  in graph  graph indx  id , graphsel  graph   GRAPH[0].SETS[1]    graph .S nn   set  nn  in graph  graph nn : 0-99, graphsel  graph   G0.S1   SET[ id ]  set  id  in the current graph indx  id   SET[1]   S nn   set  nn  in the current graph nn : 0-99  S1   S   the last allocated set in the current graph -  S    S$  the active set in the current graph -  S$                         Set selections                  Expression   Description   Types   Example   R n   region  n   n : 0-4  R0                         Region selections                  Expression   Description   Types   Example   COLOR  ""colorname""   a mapped color  colorname   -  COLOR ""red""   COLOR  id   a mapped color with ID  id   nexpr  id   COLOR 2                         Color selections                  Expression   Description   Types   Example   PATTERN  id   pattern with ID  id   nexpr  id   PATTERN 1                         Pattern selections                  Expression   Description   Types   Example   X  the first column  -  X   Y  the second column  -  Y   Y n   ( n  + 2)-th column  n  = 0 - 4  Y3                         Data column selections             Not finished yet...   5.3   Variables                Variable   Description   datacolumn   data column of current set   set.datacolumn   data column of set   vvar   user-defined array   vvariable [i:j]   segment of a vector variable (elements from i-th to j-th inclusive, i <= j)                         Vector variables                    Variable   Description   vvariable[i]   i-th element of a vector variable   var   user-defined variable                         Scalar variables                 5.4   Numerical operators and functions           In numerical expressions, the infix format is used. Arguments of both operators and functions can be either scalars or vector arrays.          Operator   Description   +   addition   -   substraction   *   multiplication   /   division   %   modulus   ^   raising to power                         Arithmetic operators                    Operator   Description   AND or &&   logical AND   OR or ||   logical OR   NOT or !   logical NOT                         Logical operators                    Operator   Description   EQ or ==   equal   NE or !=   not equal   LT or <   less than   LE or <=   less than or equal   GT or >   greater than   GE or >=   greater than or equal                         Comparison operators                    Function   Description   abs(x)   absolute value   acos(x)   arccosine   acosh(x)   hyperbolic arccosine   asin(x)   arcsine   asinh(x)   hyperbolic arcsine   atan(x)   arctangent   atan2(y,x)   arc tangent of two variables   atanh(x)   hyperbolic arctangent   ceil(x)   greatest integer function   cos(x)   cosine   cosh(x)   hyperbolic cosine   exp(x)   e^x   fac(n)   factorial function, n!   floor(x)   least integer function   irand(n)   random integer less than n   ln(x)   natural log   log10(x)   log base 10   log2(x)   base 2 logarithm of x   maxof(x,y)   returns greater of x and y   mesh(n)   mesh array (0 ... n - 1)   mesh(x1, x2, n)   mesh array of n equally spaced points between x1 and x2 inclusive   minof(x,y)   returns lesser of x and y   mod(x,y)   mod function (also x % y)   pi   the PI constant   rand   pseudo random number distributed uniformly on (0.0,1.0)   rand(n)   array of n random numbers   rint(x)   round to closest integer   sin(x)   sine function   sinh(x)   hyperbolic sine   sqr(x)   x^2   sqrt(x)   x^0.5   tan(x)   tangent function   tanh(x)   hyperbolic tangent                         Functions                  Function   Description   chdtr(df, x)   chi-square distribution   chdtrc(v, x)   complemented Chi-square distribution   chdtri(df, y)   inverse of complemented Chi-square distribution   erf(x)   error function   erfc(x)   complement of error function   fdtr(df1, df2, x)   F distribution function   fdtrc(x)   complemented F distribution   fdtri(x)   inverse of complemented F distribution   gdtr(a, b, x)   gamma distribution function   gdtrc(a, b, x)   complemented gamma distribution function   ndtr(x)   Normal distribution function   ndtri(x)   inverse of Normal distribution function   norm(x)   gaussian density function   pdtr(k, m)   Poisson distribution   pdtrc(k, m)   complemented Poisson distribution   pdtri(k, y)   inverse Poisson distribution   rnorm(xbar,s)   pseudo random number distributed N(xbar,s)   stdtr(k, t)   Student's t distribution   stdtri(k, p)   functional inverse of Student's t distribution                         Statistical functions                  Function   Description   ai(x), bi(x)   Airy functions (two independent solutions of the differential equation  y''(x) = xy )   beta(x)   beta function   chi(x)   hyperbolic cosine integral   ci(x)   cosine integral   dawsn(x)   Dawson's integral   ellie(phi, m)   incomplete elliptic integral of the second kind   ellik(phi, m)   incomplete elliptic integral of the first kind   ellpe(m)   complete elliptic integral of the second kind   ellpk(m)   complete elliptic integral of the first kind   expn(n, x)   exponential integral   fresnlc(x)   cosine Fresnel integral   fresnls(x)   sine Fresnel integral   gamma(x)   gamma function   hyp2f1(a, b, c, x)   Gauss hyper-geometric function   hyperg(a, b, x)   confluent hyper-geometric function   i0e(x)   modified Bessel function of order zero, exponentially scaled   i1e(x)   modified Bessel function of order one, exponentially scaled   igam(a, x)   incomplete gamma integral   igamc(a, x)   complemented incomplete gamma integral   igami(a, p)   inverse of complemented incomplete gamma integral   incbet(a, b, x)   incomplete beta integral   incbi(a, b, y)   Inverse of incomplete beta integral   iv(v, x)   modified Bessel function of order v   jv(v, x)   Bessel function of order v   k0e(x)   modified Bessel function, third kind, order zero, exponentially scaled   k1e(x)   modified Bessel function, third kind, order one, exponentially scaled   kn(n, x)   modified Bessel function, third kind, integer order   lbeta(x)   natural log of |beta(x)|   lgamma(x)   log of gamma function   psi(x)   psi (digamma) function   rgamma(x)   reciprocal gamma function   shi(x)   hyperbolic sine integral   si(x)   sine integral   spence(x)   dilogarithm   struve(v, x)   Struve function   yv(v, x)   Bessel function of order v   zeta(x, q)   Riemann zeta function of two arguments   zetac(x)   Riemann zeta function                         Special math functions                    Function   Description   MIN(x)   min value of array x   MAX(x)   max value of array x   AVG(x)   average of array x   SD(x)   standard deviation of array x   SUM(x)   sum of all elements of array x                         Aggregate functions                   5.5   Procedures          Methods of directly manipulating the data corresponding to the Data|Transformation menu are described in table  transformations  .         Statement   Description   Types   Example   INTERPOLATE (set, mesh, method, strict)  interpolate  set  on a sampling  mesh  using  method .  strict  flag controls whether result should be bound within the source set  vexpr  mesh ,  method : one of LINEAR, SPLINE, and ASPLINE, onoff  strict   INTERPOLATE (S0, S1.X, ASPLINE, OFF)   HISTOGRAM (set, bins, cumulative, normalize)  calculate histogram of  set  on defined  bins .  cumulative  and  normalize  flags control whether to calculate cumulative and normalized (aka PDF) histograms, respectively. Data points are placed at upper limit of the bin  vexpr  bins , onoff  cumulative , onoff  normalize   HISTOGRAM (S0, MESH(0, 1, 11), OFF, ON)   XCOR (set1, set2, maxlag, covar)  calculate cross-correlation (or -covariance if the  covar  flag is set) of  set1  with  set2  with maximum lag  maxlag .  nexpr  maxlag , onoff  covar   XCOR (S0, S0, 50, OFF)   RESTRICT (set, restriction)  filter  set  according to logical  restriction . The original set will be overwritten  vexpr  restriction   RESTRICT (S0, x < 0)   RESTRICT (set, region, negate)  filter  set  by keeping only points lying inside/outside  region . The original set will be overwritten  onoff  negate RESTRICT (S0, x < 0)                         Transformations             Not finished yet...   5.6   Device parameters          For producing ""hard copy"", several parameters can be set via the command interpreter.  They are summarized in table   Device parameters .        Command   Description   PAGE SIZE xdim, ydim   set page dimensions (in pp) of all devices   PAGE RESIZE xdim, ydim   same as above plus rescale the current plot accordingly   DEVICE  ""devname""  PAGE SIZE xdim, ydim   set page dimensions (in pp) of device  devname    DEVICE  ""devname""  DPI dpi   set device's dpi (dots per pixel)   DEVICE  ""devname""  FONT onoff   enable/disable usage of built-in fonts for device  devname    DEVICE  ""devname""  FONT ANTIALIASING onoff   enable/disable font aliasing for device  devname    DEVICE  ""devname""  OP  ""options""    set device specific options (see   Device-specific settings )   HARDCOPY DEVICE  ""devname""    set device  devname  as current hardcopy device   PRINT TO  ""filename""    set print output to  filename  (but do not print)   PRINT TO DEVICE   set print output to hardcopy device (but do not print)                         Device parameters              5.7   Flow control               Statement   Description   Types   Example   PRINT  execute print job     PRINT   SLEEP  n   sleep for  n  seconds  expr  n   SLEEP(3)   EXIT( status )  cause normal program termination with exit status  status   iexpr  status   EXIT(0)   EXIT  cause normal program termination; same as EXIT(0)     EXIT   HELP  url   open a HTML document pointed to by  url   qstr  url   HELP ""doc/FAQ.html""   HELP  open User's Guide     HELP                         Flow control             5.8   Declarations          User-defined variables are set and used according to the syntax described in table   User variables .        Statement   Description   Types   Example   DEFINE  var   define new scalar variable  var      DEFINE myvar   DEFINE  vvar []  define new vector variable  vvar  of zero length     DEFINE myvvar[]   DEFINE  vvar [ n ]  define new vector variable  vvar  of length  n   nexpr  n   DEFINE myvvar[10]   CLEAR  var   undefine new variable  var  and deallocate associated storage     CLEAR myvar    vvar  LENGTH  n   reallocate vector variable  vvar   nexpr  n   myvvar LENGTH 25                         User variables             Not finished yet...   5.9   Graph properties        We divide the commands pertaining to the properties and appearance of graphs into those which directly manipulate the graphs and those that  affect the appearance of graph elements---the parameters that can appear in a Grace project file.   Command operations        General graph creation/annihilation and control commands appear in table   Graph operations .        Statement   Description   Types   Example   FOCUS  graph    Makes  graph  current and unhides it if necessary  graphsel  graph    FOCUS G0   KILL  graph    Kills  graph    graphsel  graph    KILL G0   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap )  Arrange existing graphs (or add extra if needed) to form an  nrows  by  ncols  matrix, leaving  offset  at each page edge with  hgap  and  vgap  relative horizontal and vertical spacings  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap   ARRANGE(2, 2, 0.1, 0.15, 0.2)   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap ,  hvinv ,  hinv ,  vinv )  Same as above, plus additional  hvinv ,  hinv , and  vinv  flags allowing to alter the order of the matrix filling  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap , onoff  hvinv ,  hinv ,  vinv   ARRANGE(2, 2, 0.1, 0.15, 0.2, ON, OFF, ON)   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap ,  hvinv ,  hinv ,  vinv ,  snake )  Same as above, plus additional  snake  flag allowing to fill the matrix in a snake-like fashion  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap , onoff  hvinv ,  hinv ,  vinv ,  snake   ARRANGE(2, 2, 0.1, 0.15, 0.2, ON, OFF, ON, ON)                         Graph operations             Parameter settings        Setting the active graph and its type is accomplished with the commands found in table   Graph selection parameters .        Statement   Description   Types   Example   WITH  graph    Makes  graph  current  graphsel  graph    WITH G0   TYPE  type    Sets  type  of current graph  graphtype  type   TYPE XY    graph  onoff  (De)Activates selected  graph    graphsel  graph , onoff   G0 ON    graph  HIDDEN onoff   Hides selected  graph    graphsel  graph , onoff   G1 HIDDEN TRUE    graph  TYPE  type    Sets  type  of  graph   graphsel  graph , graphtype  type    G0 TYPE XYDY                         Graph selection parameters             The axis range and scale of the current graph as well as its  location on the plot viewport are set with the commands listed in table  Axis parameters .     Statement   Description   Types   Example   WORLD XMIN  xmin    Sets minimum value of current graph's x axis to  xmin   expr  xmin    WORLD XMIN -10   WORLD XMAX  xmax    Sets maximum value of current graph's x axis to  xmin   expr  xmax    WORLD XMAX 22.5   WORLD YMIN  ymin    Sets minimum value of current graph's y axis to  ymin   expr  ymin    WORLD YMIN 0   WORLD YMAX  ymax    Sets maximum value of current graph's y axis to  ymax   expr  ymax    WORLD YMAX 1e4   VIEW XMIN  xmin    Sets left edge of current graph at x= xmin  in the viewport  expr  xmin  VIEW XMIN .2   VIEW XMAX  xmax    Sets right edge of current graph at x= xmax  in the viewport  expr  xmax  VIEW XMAX 1.0   VIEW YMIN  ymin    Sets bottom edge of current graph at y= ymin  in the viewport  expr  ymin  VIEW YMIN .25   VIEW YMAX  ymax    Sets top edge of current graph at y= ymax  in the viewport  expr  ymax  VIEW YMAX .75   XAXES SCALE  type    Set scaling of the x axes to  type   type : one of NORMAL, LOGARITHMIC, or RECIPROCAL   XAXES SCALE NORMAL   YAXES SCALE  type    Set scaling of the y axes to  type   type : one of NORMAL, LOGARITHMIC, or RECIPROCAL   YAXES SCALE LOGARITHMIC   XAXES INVERT onoff   If ON, draws xmin to xmax from right to left  onoff   XAXES INVERT OFF   YAXES INVERT onoff   If ON, draws ymin to ymax from top to bottom  onoff   YAXES INVERT OFF   AUTOSCALE ONREAD  type    Set automatic scaling on read according to  type   type : one of NONE, XAXES, YAXES, XYAXES   AUTOSCALE ONREAD NONE                         Axis parameters             The commands to set the appearance and textual content of titles and legends are given in table   Titles and legends .        Statement   Description   Types   Example   TITLE  title    Sets the title of current graph  qstr  title    TITLE ""Foo""   TITLE FONT  font    Selects font of title string  fontsel  font    TITLE FONT 1   TITLE SIZE  size    Sets size of title string  expr  size    TITLE SIZE 1.5   TITLE COLOR  color    Sets color of title string  colorsel  color    TITLE COLOR 1   SUBTITLE  subtitle    Sets the subtitle of current graph  qstr  subtitle    SUBTITLE ""Bar""   SUBTITLE FONT  font    Selects font of subtitle string  fontsel  font    SUBTITLE FONT ""Times-Italic""   SUBTITLE SIZE  size    Sets size of subtitle string  expr  size    SUBTITLE SIZE .60   SUBTITLE COLOR  color    Sets color of subtitle string  colorsel  color    SUBTITLE COLOR ""blue""   LEGEND onoff   Toggle legend display  onoff   LEGEND ON   LEGEND LOCTYPE  type    Posistion legend in  type  coordinates  type : either WORLD or VIEW   LEGEND LOCTYPE WORLD   LEGEND  xloc, yloc    Set location of legend box (upper left corner)  expr  xloc, yloc    LEGEND .5,.75   LEGEND FONT  font  Set legend font type  fontsel  font    LEGEND FONT ""Helvetica""   LEGEND CHAR SIZE  size    Sets size of legend label characters (1 is normal) expr  size    LEGEND CHAR SIZE .30   LEGEND  color  Set color of legend text  colorsel  color    LEGEND COLOR 1   LEGEND VGAP  gap    Sets vertical gap between legend entries  nexpr  gap    LEGEND VGAP 1   LEGEND HGAP  gap    Sets horizontal gap between symbol and description  nexpr  gap    LEGEND HGAP 4   LEGEND LENGTH  length  Sets  length  of legend nexpr  length    LEGEND LENGTH 5   LEGEND INVERT onoff   Determines relationship between order of sets and order of legend labels  onoff   LEGEND INVERT true   LEGEND BOX onoff   Determines if the legend bounding box is drawn  onoff   LEGEND BOX off   LEGEND BOX COLOR  color    Sets color of legend bounding box   colorsel  color   LEGEND BOX COLOR 1  LEGEND BOX PATTERN  pattern  Sets pattern of legend bounding box   patternsel  pattern   LEGEND BOX PATTERN 2  LEGEND BOX LINESTYLE  style  Sets line style of bounding box  nexpr  style   LEGEND BOX LINESTYLE 1   LEGEND BOX LINEWIDTH  width  Sets line width of bounding box nexpr  width   LEGEND BOX LINEWIDTH 2   LEGEND BOX FILL onoff   Determines if the legend bounding box is filled  onoff   LEGEND BOX FILL false   LEGEND BOX FILL COLOR  color    Sets color of legend box fill   colorsel  color   LEGEND BOX COLOR 3   LEGEND BOX FILL  pattern  Sets pattern of legend box fill  patternsel  pattern   LEGEND BOX FILL PATTERN 1                        Titles and legends             Not finished yet...   5.10   Set properties          Again, as with the graphs, we separate those parser commands that manipulate the data in a set from the commands that determine parameters---elements that are saved in a project file.    Commands        Operations for set I/O are summarized in table   Set input, output,  and creation .  (Note that this is incomplete  and only lists  input  commands at the moment.)        Statement   Description   Types   Example   READ  file    Reads  file  as a single set  qstr  file    READ ""foo.dat""   READ  settype   file    Reads  file  into a single set of type  settype   xytype  settype , qstr  file    READ xydy ""bar.dat""   READ NXY  file    Reads  file  as NXY data  qstr  file    READ NXY ""gad.dat""   READ BLOCK  file    Reads  file  as block data  qstr  file    READ BLOCK ""zooks.dat""   BLOCK  settype   columns    Forms a data set of type  settype  using  columns  from current block data file.  xytype  settype , qstr  columns    BLOCK xydxdy ""0:2:1:3""                         Set input, output,  and creation             The parser commands analogous to the Data|Data set operations dialogue can be found in table   Set operations .      Statement   Description   Types   Example   COPY  src  TO  dest    Copies  src  to  dest setsel  src,dest    COPY S0 TO S1   MOVE  src  TO  dest    Moves  src  to  dest   setsel  src,dest    MOVE G0.S0 TO G1.S0   SWAP  src  AND  dest    Interchanges  src  and  dest   setsel  src,dest    SWAP G0.S0 AND G0.S1   KILL  set    Kills  set    setsel  set    KILL G0.S0                         Set operations             Not Finished yet...    Parameter settings        Not written yet...    6.   Advanced topics           6.1   Fonts          For all devices, Grace uses Type1 fonts. Both PFA (ASCII) and PFB (binary) formats can be used.    Font configuration          The file responsible for the font configurations of Grace is  fonts/FontDataBase . The first line contains a positive integer specifying the number of fonts declared in that file. All remaining lines contain declarations of one font each, composed out of three fields:     Font name. The name will appear in the font selector controls. Also, backend devices that has built-in fonts, will be given the name as a font identifier.    Font fall-back. Grace will try to use this in case the real font is not found.    Font filename. The file with the font outline data.       Here is the default  FontDataBase  file:      14 Times-Roman             Times-Roman             n021003l.pfb Times-Italic            Times-Italic            n021023l.pfb Times-Bold              Times-Bold              n021004l.pfb Times-BoldItalic        Times-BoldItalic        n021024l.pfb Helvetica               Helvetica               n019003l.pfb Helvetica-Oblique       Helvetica-Oblique       n019023l.pfb Helvetica-Bold          Helvetica-Bold          n019004l.pfb Helvetica-BoldOblique   Helvetica-BoldOblique   n019024l.pfb Courier                 Courier                 n022003l.pfb Courier-Oblique         Courier-Oblique         n022023l.pfb Courier-Bold            Courier-Bold            n022004l.pfb Courier-BoldOblique     Courier-BoldOblique     n022024l.pfb Symbol                  Symbol                  s050000l.pfb ZapfDingbats            ZapfDingbats            d050000l.pfb                   Font data files        For text rastering, three types of files are used.      .pfa -/ .pfb -files: These contain the character outline descriptions. The files are assumed to be in the  fonts/type1  directory; these are the filenames specified in the  FontDataBase  configuration file.     .afm -files: These contain high-precision font metric descriptions as well as some extra information, such as kerning and ligature information for a particular font. It is assumed that the filename of a font metric file has same basename as the respective font outline file, but with the  .afm  extension; the metric files are expected to be found in the  fonts/type1  directory, too.     .enc -files: These contain encoding arrays in a special but simple form. They are only needed if someone wants to load a special encoding to re-encode a font. Their place is  fonts/enc        Custom fonts          It is possible to use custom fonts with Grace. One mostly needs to use extra fonts for the purpose of localization. For many European languages, the standard fonts supplied with Grace should contain all the characters needed, but encoding may have to be adjusted. This is done by putting a  Default.enc  file with proper encoding scheme into the  fonts/enc  directory. Grace comes with a few encoding files in the directory; more can be easily found on the Internet. (If the  Default.enc  file doesn't exist, the IsoLatin1 encoding will be used). Notice that for fonts having an encoding scheme in themselves (such as the Symbol font, and many nationalized fonts) the default encoding is ignored.   If you do need to use extra fonts, you should modify the  FontDataBase  file accordingly, obeying its format. However, if you are going to exchange Grace project files with other people who do not have the extra fonts configured, an important thing is to define reasonable fall-back font names.   For example, let us assume I use Hebrew fonts, and the configuration file has lines like these:          ... Courier-Hebrew              Courier                 courh___.pfa Courier-Hebrew-Oblique      Courier-Oblique         courho__.pfa     ...               My colleague, who lives in Russia, uses Cyrillic fonts with Grace configured like this:          ... Cronix-Courier              Courier                 croxc.pfb Cronix-Courier-Oblique      Courier-Oblique         croxco.pfb     ...               The font mapping information (Font name <-> Font fall-back) is stored in the Grace project files. Provided that all the localized fonts have English characters in the lower part of the ASCII table unmodified, I can send my friend files (with no Hebrew characters, of course) and be sure they render correctly on his computer.   Thus, with properly configured national fonts, you can make localized annotations for plots intended for internal use of your institution, while being able to exchange files with colleagues from abroad. People who ever tried to do this with MS Office applications should appreciate the flexibility :-).    6.2   Interaction with other applications            Using pipes            Using grace_np library          The grace_np library is a set of compiled functions that allows you to launch and drive a Grace subprocess from your C or Fortran application. Functions are provided to start the subprocess, to send it commands or data, to stop it or detach from it.        Function   Arguments   Description   int GraceOpenVA   (char * exe , int  buf_size , ...)  launch a Grace executable  exe  and open a communication channel with it using  buf_size  bytes for data buffering. The remaining NULL-terminated list of options is command line arguments passed to the Grace process   int GraceOpen   (int  buf_size )  equivalent to GraceOpenVA(""xmgrace"", buf_size, ""-noask"", NULL)   int GraceIsOpen   (void)   test if a Grace subprocess is currently connected   int GraceClose   (void)   close the communication channel and exit the Grace subprocess   int GraceClosePipe   (void)   close the communication channel and leave the Grace subprocess alone   int GraceFlush   (void)   flush all the data remaining in the buffer   int GracePrintf   (const char*  format , ...)  format a command and send it to the Grace subprocess   int GraceCommand   (const char*  cmd )  send an already formated command to the Grace subprocess   GraceErrorFunctionType GraceRegisterErrorFunction  (GraceErrorFunctionType  f )  register a user function  f  to display library errors                 grace_np library C functions.                  Function   Arguments   Description   integer GraceOpenF   (integer  buf_size )  launch a Grace subprocess and open a communication channel with it   integer GraceIsOpenF   (void)   test if a Grace subprocess is currently connected   integer GraceCloseF   (void)   close the communication channel and exit the Grace subprocess   integer GraceClosePipeF   (void)   close the communication channel and leave the Grace subprocess alone   integer GraceFlushF   (void)   flush all the data remaining in the buffer   integer GraceCommandF   (character*(*)  cmd )  send an already formatted command to the Grace subprocess   GraceFortranFunctionType GraceRegisterErrorFunctionF  (GraceFortranFunctionType  f )  register a user function  f  to display library errors                 grace_np library F77 functions.               There is no fortran equivalent for the GracePrintf function, you should format all the data and commands yourself before sending them with GraceCommandF.   The Grace subprocess listen for the commands you send and interpret them as if they were given in a batch file. You can send any command you like (redraw, autoscale, ...). If you want to send data, you should include them in a command like ""g0.s0 point 3.5, 4.2"".   Apart from the fact it monitors the data sent via an anonymous pipe, the Grace subprocess is a normal process. You can interact with it through the GUI. Note that no error can be sent back to the parent process. If your application send erroneous commands, an error popup will be displayed by the subprocess.   If you exit the subprocess while the parent process is still using it, the broken pipe will be detected. An error code will be returned to every further call to the library (but you can still start a new process if you want to manage this situation).   Here is an example use of the library, you will find this program in the distribution.         #include <stdlib.h> #include <stdio.h> #include <unistd.h> #include <grace_np.h>  #ifndef EXIT_SUCCESS #  define EXIT_SUCCESS 0 #endif  #ifndef EXIT_FAILURE #  define EXIT_FAILURE -1 #endif  void my_error_function(const char *msg) {     fprintf(stderr, ""library message: \""%s\""\n"", msg); }  int main(int argc, char* argv[]) {     int i;      GraceRegisterErrorFunction(my_error_function);      /* Start Grace with a buffer size of 2048 and open the pipe */     if (GraceOpen(2048) == -1) {         fprintf(stderr, ""Can't run Grace. \n"");         exit(EXIT_FAILURE);     }          /* Send some initialization commands to Grace */     GracePrintf(""world xmax 100"");     GracePrintf(""world ymax 10000"");     GracePrintf(""xaxis tick major 20"");     GracePrintf(""xaxis tick minor 10"");     GracePrintf(""yaxis tick major 2000"");     GracePrintf(""yaxis tick minor 1000"");     GracePrintf(""s0 on"");     GracePrintf(""s0 symbol 1"");     GracePrintf(""s0 symbol size 0.3"");     GracePrintf(""s0 symbol fill pattern 1"");     GracePrintf(""s1 on"");     GracePrintf(""s1 symbol 1"");     GracePrintf(""s1 symbol size 0.3"");     GracePrintf(""s1 symbol fill pattern 1"");      /* Display sample data */     for (i = 1; i <= 100 && GraceIsOpen(); i++) {         GracePrintf(""g0.s0 point %d, %d"", i, i);         GracePrintf(""g0.s1 point %d, %d"", i, i * i);         /* Update the Grace display after every ten steps */         if (i % 10 == 0) {             GracePrintf(""redraw"");             /* Wait a second, just to simulate some time needed for                calculations. Your real application shouldn't wait. */             sleep(1);         }     }      if (GraceIsOpen()) {         /* Tell Grace to save the data */         GracePrintf(""saveall \""sample.agr\"""");          /* Flush the output buffer and close Grace */         GraceClose();          /* We are done */         exit(EXIT_SUCCESS);     } else {         exit(EXIT_FAILURE);     } }             6.3   FFTW tuning          When the FFTW capabilities are compiled in, Grace looks at two environment variables to decide what to do with the FFTW 'wisdom' capabilities.  First, a quick summary of what this is. The FFTW package is capable of adaptively determining the most efficient factorization of a set to give the fastest computation.  It can store these factorizations as 'wisdom', so that if a transform of a given size is to be repeated, it is does not have to re-adapt.  The good news is that this seems to work very well.  The bad news is that, the first time a transform of a given size is computed, if it is not a sub-multiple of one already known, it takes a LONG time (seconds to minutes).   The first environment variable is GRACE_FFTW_WISDOM_FILE. If this is set to the name of a file which can be read and written (e.g., $HOME/.grace_fftw_wisdom) then Grace will automatically create this file (if needed) and maintain it. If the file is read-only, it will be read, but not updated with new wisdom. If the symbol GRACE_FFTW_WISDOM_FILE either doesn't exist, or evaluates to an empty string, Grace will drop the use of wisdom, and will use the fftw estimator (FFTW_ESTIMATE flag sent to the planner) to guess a good factorization, instead of adaptively determining it.   The second variable is GRACE_FFTW_RAM_WISDOM. If this variable is defined to be non-zero, and GRACE_FFTW_WISDOM_FILE variable is not defined (or is an empty string), Grace will use wisdom internally, but maintain no persistent cache of it. This will result in very slow execution times the first time a transform is executed after Grace is started, but very fast repeats. I am not sure why anyone would want to use wisdom without writing it to disk, but if you do, you can use this flag to enable it.       6.4   DL modules           Grace can access external functions present in either system or third-party shared libraries or modules specially compiled for use with Grace.    Function types        One must make sure, however, that the external function is of one of supported by Grace types:     Grace type   Description   f_of_i   a function of 1  int  variable   f_of_d   a function of 1  double  variable   f_of_nn   a function of 2  int  parameters   f_of_nd   a function of 1  int  parameter and 1  double  variable   f_of_dd   a function of 2  double  variables   f_of_nnd   a function of 2  int  parameters and 1  double  variable   f_of_ppd   a function of 2  double  parameters and 1  double  variable   f_of_pppd   a function of 3  double  parameters and 1  double  variable                                     Grace types for external functions             The return values of functions are assumed to be of the  double  type.   Note, that there is no difference from the point of view of function prototype between parameters and variables; the difference is in the way Grace treats them - an attempt to use a vector expression as a parameter argument will result in a parse error.   Let us consider few examples.    Examples           Caution: the examples provided below (paths and compiler flags) are valid for Linux/ELF with gcc. On other operating systems, you may need to refer to compiler/linker manuals or ask a guru.    Example 1           Suppose I want to use function  pow(x,y)  from the Un*x math library (libm). Of course, you can use the ""^"" operator defined in the Grace language, but here, for the sake of example, we want to access the function directly.   The command to make it accessible by Grace is   USE ""pow"" TYPE f_of_dd FROM ""/usr/lib/libm.so""      Try to plot y = pow(x,2) and y = x^2 graphs (using, for example, ""create new -> Formula"" from any   set        selector ) and compare.    Example 2           Now, let us try to write a function ourselves. We will define function  my_function  which simply returns its (second) argument multiplied by integer parameter transferred as the first argument.   In a text editor, type in the following C code and save it as ""my_func.c"":                double my_function (int n, double x)        {            double retval;            retval = (double) n * x;            return (retval);        }                  OK, now compile it:                $gcc -c -fPIC my_func.c        $gcc -shared my_func.o -o /tmp/my_func.so                  (You may strip it to save some disk space):                $strip /tmp/my_func.so                  That's all! Ready to make it visible to Grace as ""myf"" - we are too lazy to type the very long string ""my_function"" many times.      USE ""my_function"" TYPE f_of_nd FROM ""/tmp/my_func.so"" ALIAS ""myf""        Example 3           A more serious example. There is a special third-party library available on your system which includes a very important for you yet very difficult-to-program from the scratch function that you want to use with Grace.  But, the function prototype is NOT one of any predefined   types .  The solution is to write a simple function wrapper. Here is how:   Suppose, the name of the library is ""special_lib"" and the function you are interested in is called ""special_func"" and according to the library manual, should be accessed as  void special_func(double *input, double *output, int parameter) . The wrapper would look like this:                double my_wrapper(int n, double x)        {            extern void special_func(double *x, double *y, int n);            double retval;            (void) special_func(&x, &retval, n);            return (retval);        }                  Compile it:                $gcc -c -fPIC my_wrap.c        $gcc -shared my_wrap.o -o /tmp/my_wrap.so -lspecial_lib -lblas        $strip /tmp/my_wrap.so                  Note that I added  -lblas  assuming that the special_lib library uses some functions from the BLAS. Generally, you have to add  all  libraries which your module depends on (and all libraries those libraries rely upon etc.), as if you wanted to compile a plain executable.   Fine, make Grace aware of the new function      USE ""my_wrapper"" TYPE f_of_nd FROM ""/tmp/my_wrap.so"" ALIAS ""special_func""      so we can use it with its original name.    Example 4           An example of using Fortran modules.   Here we will try to achieve the same functionality as in Example 2, but with the help of F77.                DOUBLE PRECISION FUNCTION MYFUNC (N, X)        IMPLICIT NONE        INTEGER N        DOUBLE PRECISION X C        MYFUNC = N * X C        RETURN        END                  As opposite to C, there is no way to call such a function from Grace directly - the problem is that in Fortran all arguments to a function (or subroutine) are passed by reference. So, we need a wrapper:                double myfunc_wrapper(int n, double x)        {            extern double myfunc_(int *, double *);            double retval;            retval = myfunc_(&n, &x);            return (retval);        }                  Note that most of f77 compilers by default add underscore to the function names and convert all names to the lower case, hence I refer to the Fortran function  MYFUNC  from my C wrapper as  myfunc_ , but in your case it can be different!   Let us compile the whole stuff:                $g77 -c -fPIC myfunc.f        $gcc -c -fPIC myfunc_wrap.c        $gcc -shared myfunc.o myfunc_wrap.o -o /tmp/myfunc.so -lf2c -lm        $strip /tmp/myfunc.so                  And finally, inform Grace about this new function:      USE ""myfunc_wrapper"" TYPE f_of_nd FROM ""/tmp/myfunc.so"" ALIAS ""myfunc""       Operating system issues              OS/2              In general the method outlined in the examples above can be used on OS/2, too. However you have to create a DLL (Dynamic Link Library) which is a bit more tricky on OS/2 than on most Un*x systems. Since Grace was ported by using EMX we also use it to create the examples; however other development environments should work as well (ensure to use the _System calling convention!). We refer to Example 2 only. Example 1 might demonstrate that DLLs can have their entry points (i.e. exported functions) callable via ordinals only, so you might not know how to access a specific function without some research. First compile the source from Example 2 to ""my_func.obj""      gcc -Zomf -Zmt -c my_func.c -o my_func.obj      Then you need to create a linker definition file ""my_func.def"" which contains some basic info about the DLL and declares the exported functions.                  LIBRARY my_func INITINSTANCE TERMINSTANCE          CODE LOADONCALL          DATA LOADONCALL MULTIPLE NONSHARED          DESCRIPTION 'This is a test DLL: my_func.dll'          EXPORTS          my_function                    (don't forget about the 8 characters limit on the DLL name!). Finally link the DLL:      gcc my_func.obj my_func.def -o my_func.dll -Zdll -Zno-rte -Zmt -Zomf      (check out the EMX documentation about the compiler/linker flags used here!) To use this new library function within Grace you may either put the DLL in the LIBPATH and use the short form:      USE ""my_function"" TYPE f_of_nd FROM ""my_func"" ALIAS ""myf""      or put it in an arbitrary path which you need to specify explicitly then:      USE ""my_function"" TYPE f_of_nd FROM ""e:/foo/my_func.dll"" ALIAS ""myf""      (as for most system-APIs you may use the Un*x-like forward slashs within the path!)    7.   References           7.1   Typesetting          Grace permits quite complex typesetting on a per string basis. Any string displayed (titles, legends, tick marks,...) may contain special control codes to display subscripts, change fonts within the string etc.         Control code   Description   \f{x}   switch to font named ""x""   \f{n}   switch to font number n   \f{}   return to original font   \R{x}   switch to color named ""x""   \R{n}   switch to color number n   \R{}   return to original color   \#{x}   treat ""x"" (must be of even length) as list of hexadecimal char codes   \t{xx xy yx yy}   apply transformation matrix   \t{}   reset transformation matrix   \z{x}   zoom x times   \z{}   return to original zoom   \r{x}   rotate by x degrees   \l{x}   slant by factor x   \v{x}   shift vertically by x   \v{}   return to unshifted baseline   \V{x}   shift baseline by x   \V{}   reset baseline   \h{x}   horizontal shift by x   \n   new line   \u   begin underline   \U   stop underline   \o   begin overline   \O   stop overline   \Fk   enable kerning   \FK   disable kerning   \Fl   enable ligatures   \FL   disable ligatures   \m{n}   mark current position as n   \M{n}   return to saved position n   \dl   LtoR substring direction   \dr   RtoL substring direction   \dL   LtoR text advancing   \dR   RtoL text advancing   \x   switch to Symbol font (same as \f{Symbol})   \+   increase size (same as \z{1.19} ; 1.19 = sqrt(sqrt(2)))   \-   decrease size (same as \z{0.84} ; 0.84 = 1/sqrt(sqrt(2)))   \s   begin subscripting (same as \v{-0.4}\z{0.71})   \S   begin superscripting (same as \v{0.6}\z{0.71})   \T{xx xy yx yy}   same as \t{}\t{xx xy yx yy}   \Z{x}   absolute zoom x times (same as \z{}\z{x})   \q   make font oblique (same as \l{0.25})   \Q   undo oblique (same as \l{-0.25})   \N   return to normal style (same as \v{}\t{})   \\   print \   \n   switch to font number n (0-9) (deprecated)   \c   begin using upper 128 characters of set (deprecated)   \C   stop using upper 128 characters of set (deprecated)                                     Control codes.              Example:   F\sX\N(\xe\f{}) = sin(\xe\f{})\#{b7}e\S-X\N\#{b7}cos(\xe\f{})    prints roughly                           -x        F (e) = sin(e)·e  ·cos(e)         x                using string's initial font and e prints as epsilon from the Symbol font.   NOTE: Characters from the upper half of the char table can be entered directly from the keyboard, using appropriate  xmodmap(1)  settings, or with the help of the font tool (""Window/Font tool"").       7.2   Device-specific limitations           Grace can output plots using several device backends. The list of available devices can be seen (among other stuff) by specifying the ""-version"" command line switch.     X11, PostScript and EPS are full-featured devices    Raster drivers (PNM/JPEG/PNG):     only even-odd fill rule is supported    patterned lines are not implemented        PDF driver:     patterned fills are not implemented    bitmapped text strings are not transparent        MIF driver: the driver is a brand new one and still in beta test     some of patterned fills not implemented    bitmapped text strings not implemented        SVG driver: the driver is a brand new one and still in beta test     patterned fills not implemented    bitmapped text strings not implemented                7.3   Device-specific settings           Some of the output devices accept several configuration options. You can set the options by passing a respective string to the interpreter using the ""DEVICE  ""devname""  OP  ""options"" "" command (see  Device parameters ). A few options can be passed in one command, separated by commas.          Command   Description   grayscale   set grayscale output   color   set color output   level1   use only PS Level 1 subset of commands   level2   use also PS Level 2 commands if needed   docdata:7bit   the document data is 7bit clean   docdata:8bit   the document data is 8bit clean   docdata:binary   the document data may be binary   xoffset: x    set page offset in X direction  x  pp   yoffset: y    set page offset in Y direction  y  pp   mediafeed:auto   default input tray   mediafeed:match   select input with media matching page dimensions   mediafeed:manual   manual media feed   hwresolution:on   set hardware resolution   hwresolution:off   do not set hardware resolution                   PostScript driver options                    Command   Description   grayscale   set grayscale output   color   set color output   level1   use only PS Level 1 subset of commands   level2   use also PS Level 2 commands if needed   bbox:tight   enable ""tight"" bounding box   bbox:page   bounding box coincides with page dimensions                   EPS driver options                    Command   Description   PDF1.2   set compatibility mode to PDF-1.2   PDF1.3   set compatibility mode to PDF-1.3   compression:value   set compression level (0 - 9)                   PDF driver options                    Command   Description   format:pbm   output in PBM format   format:pgm   output in PGM format   format:ppm   output in PPM format   rawbits:on   ""rawbits"" (binary) output   rawbits:off   ASCII output                   PNM driver options                    Command   Description   grayscale   set grayscale output   color   set color output   optimize:on/off   enable/disable optimization   quality:value   set compression quality (0 - 100)   smoothing:value   set smoothing (0 - 100)   baseline:on/off   do/don't force baseline output   progressive:on/off   do/don't output in progressive format   dct:ifast   use fast integer DCT method   dct:islow   use slow integer DCT method   dct:float   use floating-point DCT method                   JPEG driver options                    Command   Description   interlaced:on   make interlaced image   interlaced:off   don't make interlaced image   transparent:on   produce transparent image   transparent:off   don't produce transparent image   compression:value   set compression level (0 - 9)                   PNG driver options                   7.4   Dates in Grace           We use two calendars in Grace: the one that was established in 532 by Denys and lasted until 1582, and the one that was created by Luigi Lilio (Alyosius Lilius) and Christoph Klau (Christophorus Clavius) for pope Gregorius XIII. Both use the same months (they were introduced under emperor Augustus, a few years after Julian calendar introduction, both Julius and Augustus were honored by a month being named after each one).   The leap years occurred regularly in Denys's calendar: once every four years, there is no year 0 in this calendar (the leap year -1 was just before year 1). This calendar was not compliant with earth motion and the dates were slowly shifting with regard to astronomical events.   This was corrected in 1582 by introducing Gregorian calendar. First a ten days shift was introduced to reset correct dates (Thursday October the 4th was followed by Friday October the 15th). The rules for leap years were also changed: three leap years are removed every four centuries. These years are those that are multiple of 100 but not multiple of 400: 1700, 1800, and 1900 were not leap years, but 1600 and 2000 were (will be) leap years.   We still use Gregorian calendar today, but we now have several time scales for increased accuracy. The International Atomic Time (TAI) is a linear scale: the best scale to use for scientific reference. The Coordinated Universal Time (UTC, often confused with Greenwich Mean Time) is a legal time that is almost synchronized with earth motion. However, since the earth is slightly slowing down, leap seconds are introduced from time to time in UTC (about one second every 18 months). UTC is not a continuous scale ! When a leap second is introduced by International Earth Rotation Service, this is published in advance and the legal time sequence is as follows: 23:59:59 followed one second later by 23:59:60 followed one second later by 00:00:00. At the time of this writing (1999-01-05) the difference between TAI and UTC was 32 seconds, and the last leap second was introduced in 1998-12-31.   These calendars allow to represent any date from the mist of the past to the fog of the future, but they are not convenient for computation. Another time scale is possible: counting only the days from a reference. Such a time scale was introduced by Joseph-Juste Scaliger (Josephus Justus Scaliger) in 1583. He decided to use ""-4713-01-01T12:00:00"" as a reference date because it was at the same time a Monday, first of January of a leap year, there was an exact number of 19 years Meton cycle between this date and year 1 (for Easter computation), and it was at the beginning of a 15 years  Roman indiction  cycle. The day number counted from this reference is traditionally called  Julian day , but it has really nothing to do with the Julian calendar.   Grace stores dates internally as reals numbers counted from a reference date. The default reference date is the one chosen by Scaliger, it is a classical reference for astronomical events. It can modified for a single session using the   Edit->Preferences  popup of the GUI. If you often work with a specific reference date you can set it for every sessions with a REFERENCE DATE command in your configuration file (see   Default template ).   The following date formats are supported (hour, minutes and seconds are always optional):       iso8601  : 1999-12-31T23:59:59.999   european : 31/12/1999 23:59:59.999 or 31/12/99 23:59:59.999   us       : 12/31/1999 23:59:59.999 or 12/31/99 23:59:59.999   Julian   : 123456.789       One should be aware that Grace does not allow to put a space in one data column as spaces are used to separate fields. You should always use another separator (:/.- or better T) between date and time in data files. The GUI, the batch language and the command line flags do not have this limitation, you can use spaces there without any problem. The T separator comes from the ISO8601 standard. Grace support its use also in european and us formats.   You can also provide a hint about the format (""ISO8601"", ""european"", ""us"") using the -datehint command line flag or the ref name=""Edit->Preferences"" id=""preferences""> popup of the GUI. The formats are tried in the following order: first the hint given by the user, then iso, european and us (there is no ambiguity between calendar formats and numerical formats and therefore no order is specified for them). The separators between various fields can be any characters in the set: "" :/.-T"" (one or more spaces act as one separator, other characters can not be repeated, the T separator is allowed only between date and time, mainly for iso8601), so the string ""1999-12 31:23/59"" is allowed (but not recommended).  The '-' character is used both as a separator (it is traditionally used in iso8601 format) and as the unary minus (for dates in the far past or for numerical dates). By default years are left untouched, so 99 is a date far away in the past. This behavior can be changed with the   Edit->preferences  popup, or with the  DATE WRAP on  and  DATE WRAP YEAR year  commands. Suppose for example that the wrap year is chosen as 1950, if the year is between 0 and 99 and is written with two or less digits, it is mapped to the present era as follows:   range [00 ; 49] is mapped to [2000 ; 2049]   range [50 ; 99] is mapped to [1950 ; 1999]   with a wrap year set to 1970, the mapping would have been:   range [00 ; 69] is mapped to [2000 ; 2069]   range [70 ; 99] is mapped to [1970 ; 1999]   this is reasonably Y2K compliant and is consistent with current use.  Specifying year 1 is still possible using more than two digits as follows: ""0001-03-04"" is unambiguously March the 4th, year 1. The inverse transform is applied for dates written by Grace, for example as tick labels. Using two digits only for years is not recommended, we introduce a  wrap year + 100  bug here so this feature should be removed at some point in the future ...   The date scanner can be used either for Denys's and Gregorian calendars. Inexistent dates are detected, they include year 0, dates between 1582-10-05 and 1582-10-14, February 29th of non leap years, months below 1 or above 12, ...  the scanner does not take into account leap seconds: you can think it works only in International Atomic Time (TAI) and not in Coordinated Unified Time (UTC). If you find yourself in a situation were you need UTC, a very precise scale, and should take into account leap seconds ... you should convert your data yourself (for example using International Atomic Time). But if you bother with that you probably already know what to do.     7.5   Xmgr to Grace migration guide           This is a very brief guide describing problems and workarounds for reading in project files saved with Xmgr. You should read the docs or just play with Grace to test new features and controls.        Grace must be explicitly told the version number of the software used to create a file. You can manually put ""@version VERSIONID"" string at the beginning of the file. The VERSIONID is built as MAJOR_REV*10000 + MINOR_REV*100 + PATCHLEVEL; so 40101 corresponds to xmgr-4.1.1. Projects saved with Xmgr-4.1.2 do NOT need the above, since they already have the version string in them. If you have no idea what version of Xmgr your file was created with, try some. In most cases, 40102 would do the trick.      The above relates to the ASCII projects only. The old binary projects (saved with xmgr-4.0.*) are not automatically converted anymore. An input filter must be defined to make the conversion work on-the-fly. Add the following line to  /.gracerc or the system-wide $GRACE_HOME/gracerc resource file: DEFINE IFILTER ""grconvert %s -"" MAGIC ""00000031"" See docs for more info on the I/O filters.      Documentation on the script language is severely lacking still.      Grace is WYSIWYG. Xmgr was not. Many changes required to achieve the WYSIWYG'ness led to the situation when graphs with objects carefully aligned under Xmgr may not look so under Grace. Grace tries its best to compensate for the differences, but sometimes you may have to adjust such graphs manually.      A lot of symbol types (all except *real* symbols) are removed. ""Location *"" types can be replaced (with much higher comfort) by A(nnotating)values. ""Impulse *"", ""Histogram *"" and ""Stair steps *"" effects can be achieved using the connecting line parameters (Type, Drop lines). ""Dot"" symbol is removed as well; use the filled circle symbol of the zero size with no outline to get the same effect.      Default page layout switched from free (allowing to resize canvas with mouse) to fixed. For the old behavior, put ""PAGE LAYOUT FREE"" in the Grace resource file or use the ""-free"" command line switch.  The use of the ""free"" page layout is in general deprecated, though.       System (shell) variables GR_* renamed to GRACE_*      Smith plots don't work now. They'll be put back soon."
GX230-67-13156712	"SAND92-2291 Unlimited Release Printed December 1992 Updated March 17, 1997  Distribution Category UC-705  APREPRO: An Algebraic Preprocessor for Parameterizing Finite Element Analyses Gregory D. Sjaardema Solid and Structural Mechanics Department Sandia National Laboratories Albuquerque, New Mexico 87185  Abstract Aprepro is an algebraic preprocessor that reads a file containing both general text and algebraic, string, or conditional expressions. It interprets the expressions and outputs them to the output file along with the general text. The syntax used in Aprepro is such that all expressions between the delimiters { and } are evaluated and all other text is simply echoed to the output file. Aprepro contains several mathematical functions, string functions, and flow control constructs. In addition, functions are included that, with some additional files, implement a units conversion system and a material database lookup system. Aprepro was written primarily to simplify the preparation of parameterized input files for finite element analyses at Sandia National Laboratories; however, it can process any text file that does not use the characters { }.   Intentionally Left Blank  4   Contents 1 Introduction ........................................................................................................ 2 Syntax .................................................................................................................. 3 Operators ............................................................................................................ 3.1 Arithmetic Operators .................................................................................... 3.2 Assignment Operators ................................................................................... 3.3 Relational Operators ..................................................................................... 3.4 Boolean Operators ........................................................................................ 3.5 String Operators ............................................................................................ 4 Predefined Variables .......................................................................................... 5 Functions ............................................................................................................. 5.1 Mathematical Functions ................................................................................ 5.2 String Functions ............................................................................................ 5.3 Additional Functions ..................................................................................... 6 Units Conversion System ................................................................................... 6.1 Introduction ................................................................................................... 6.2 Units Conversion Implementation ................................................................ 6.3 Usage ............................................................................................................. 6.4 Additional Comments ................................................................................... 7 Material Database Access System .................................................................... 7.1 Overview of the MATS System .................................................................... 7.2 Implementation of the Material Database Access Routines ......................... 7.3 Code Template Files: .................................................................................... 7.4 Material Files: ............................................................................................... 7.5 Additional Comments ................................................................................... 8 Error, Warning, and Informational Messages ................................................ 9 Examples ............................................................................................................. 9.1 Mesh Generation Input File .......................................................................... 9.2 Macro Examples ........................................................................................... 9.3 Command Line Variable Assignment ........................................................... 9.4 Loop Example ............................................................................................... 9.5 Units and Material Database Access Example ............................................. 10 References ........................................................................................................... A Execution ............................................................................................................. B Unit System Defined Variables ......................................................................... 7 9 13 13 14 14 14 15 17 19 19 21 22 25 25 26 28 30 33 33 35 35 37 38 41 43 43 44 44 45 45 49 51 53  5   Tables Table Table Table Table Table Table Table Table Table Table 1. 2. 3. 4. 5. 6. 7. 8: 9: 10: Arithmetic Operators ...........................................................................13 Assignment Operators..........................................................................14 Relational Operators ............................................................................14 Logical Operators.................................................................................15 Predefined Variables ............................................................................17 Effect of various output format specifications .....................................17 Mathematical Functions .......................................................................19 Units Systems and Corresponding Output Format--Metric .................25 Units Systems and Corresponding Output Format--English ...............26 Defined Units Variables.......................................................................53  Figures Figure 1. Schematic of Proposed MATS Database System ................................34  6   1 Introduction Aprepro is an algebraic preprocessor that reads a file containing both general text and algebraic expressions. It echoes the general text to the output file, along with the results of the algebraic expressions. The syntax used in Aprepro is such that all expressions between the delimiters { and } are evaluated and all other text is simply echoed to the output file. For example, if the following lines are input to Aprepro $ Rad = {Rad = 12.0} Point 1 {x1 = Rad * sind(30.)} Point 2 {x1 + 10.0} {y1} {y1 = Rad * cosd(30.)}  The output would look like: $ Rad = 12 Point 1 Point 2 6 16 10.39230485 10.39230485  In this example, the algebraic expressions are specified by surrounding them with { and }, and the functions sind() and cosd() calculate the sine and cosine of an angle given in degrees. Aprepro has been used extensively in the past two years to prepare parameterized files for finite element analyses using the Sandia National Laboratories SEACAS system1. The recent addition of the units conversion capability and the material database access routines have greatly increased the usability of Aprepro. Aprepro can also be used for non-finite element applications such as a powerful calculator and a general text processor for any file that does not use the delimiters { and }. Aprepro is written in the C language. The BISON2 and FLEX3 programs are used to generate the parsing and lexical analysis subroutines, respectively. The initial implementation of Aprepro was based on the mfcalc example in the BISON manual. Aprepro has been ported to several UNIX systems including Hewlett Packard HP-UX, Cray Research Unicos, Sun Microsystems SunOS, Tenon MachTen, Digital Equipment Ultrix; and to non-UNIX systems including VAX VMS, Macintosh, and Amiga. The         remainder of this document is organized as follows: Section 2 documents the syntax recognized by Aprepro, Sections 3, 4, and 5 describe the operators, predefined variables, and functions, Section 6 describes the units conversion system, Section 7 describes the material database support routines, Section 8 describes the error messages output from Aprepro, and Section 9 presents some examples of Aprepro usage. Appendix A documents the command line options for Aprepro, and Appendix B lists the defined units abbreviations.  7   Intentionally Left Blank  8   2 Syntax Aprepro is in one of two states while it is processing an input file, either echoing or parsing. In the echoing state, Aprepro echoes every character that it reads to the output file. If it reads the character {, it enters the parsing state. In the parsing state, Aprepro reads characters from the input file and identifies the characters as tokens which can be function names, variables, numbers, operators, or delimiters. When Aprepro encounters the character }, it tries to interpret the tokens as an algebraic, string, or conditional expression; if it is successful, it prints the value to the output file; if it cannot evaluate the expression, it prints the message: Aprepro: ERR: parse error (filename, line line#)  to the terminal* and prints the value 0 to the output file. The rules that Aprepro uses when identifying functions, variables, numbers, operators, delimiters, and expressions are described below:  Functions: Function names are sequences of letters and digits and underscores (_) that begin with a letter. The function's arguments are enclosed in parentheses. For example, in the line atan2(a,1.0), atan2 is the function name, and a and 1.0 are the arguments. See section 5 on page 19 for a list of the available functions and their arguments.  Variables: A variable is a name that references a numeric or string value. A variable is defined by giving it a name and assigning it a value. For example, the expression a = 1.0 defines the variable a with the numeric value 1.0; the expression b= ""A string"" defines the variable b with the value ""A string"". Variable names are sequences of letters, digits, and underscores (_) that begin with either a letter or an underscore. Variable names cannot match any function name and they are case-sensitive, that is, abc_de and AbC_dE are two distinct variable names. A few variables are predefined, these are listed in section 4 on page 17. Any variable that is not defined is equal to 0. A warning message is output to the terminal if an undefined variable is used, or if a previously defined variable is redefined.  Numbers: Numbers can be integers like 1234, decimal numbers like 1.234, or in scientific notation like 1.234E-26. All numbers are stored internally as floating point numbers.  Strings: Strings are sequences of numbers, characters, and symbols that are delimited by either single quotes ('this is a string') or double quotes (""this is another string""). Strings that are delimited by one type of quote can include * Error messages are printed to standard error. On UNIX systems they can be redirected to a file using your shells redirection syntax. See the man page for your shell for more information.  If the variable name begins with an underscore, no warning is output when the variable is redefined. Warnings can be turned off with the -W or +warning option.  9   the other type of quote. For example, {'This is a valid ""string""'}. Strings delimited by single quotes can span multiple lines; strings delimited by double quotes must terminate on a single line or a parsing error message will be issued.  Operators: Operators are any of the symbols defined in section 3 on page 13. Examples are + (addition), - (subtraction), * (multiplication), / (division), = (assignment), and ^ (exponentiation)  Delimiters: The delimiters recognized by Aprepro are: the comma (,) which separates arguments in function lists, the left curly brace ({) which begins an expression, the right curly brace (}) which ends an expression, the left parenthesis ( which begins a function argument list, the right parenthesis ) which ends a function argument list, the single quote (') which delimits a multi-line string, and the double quote ("") which delimits a single-line string.  Expressions: An expression consists of any combination of numeric and string constants, variables, operators, and functions. Four types of expressions are recognized in Aprepro: algebraic, string, relational, and conditional.  Algebraic Expressions: Almost any valid FORTRAN or C algebraic expression can be recognized and evaluated by Aprepro. An expression of the form a=b+10/ 37.5 will evaluate the expression on the right-hand-side of the equals sign, print the value to the output file, and assign the value to the variable a. An expression of the form b+10/37.5 will evaluate the expression and print the value to the output file. If you want to assign a value to a variable without printing the result, the expression must be inside an ECHO(ON|OFF) block (see page 23). Variables can also be set on the command line prior to reading any input files using the 'var=val' syntax. An example of this usage is given in section 9.2 on page 44. Only a single expression is allowed within the { } delimiters. For example, {x = sqrt(y^2 + sin(z))}, {x=y=z}, and {x=y} {a=z} are valid expressions, but {x=y a=z} is invalid because it contains two expressions within a single set of delimiters.  String Expressions: Aprepro has very limited string support. The only supported operations are assigning a variable equal to a string (a = ""This is a string"") or a function that returns a string, and concatenating two strings into another string (a = ""Hello"" // "" "" // ""World"").  Relational Expressions: Relational expressions are expressions that return the result of comparing two expressions. A relational expression is either true or false. Relational expressions can only be used on the left-hand side of a conditional expression. A relational expression is simply two expressions of any kind separated by a relational operator (See ""Relational Operators"" on page 14.)  Conditional Expressions: Aprepro recognizes a conditional expression of the form: relational_expression ? true_exp : false_exp  where relational_expression can be any valid relational expression, and true_exp  10   and false_exp are two algebraic expressions. If the relational expression is true, then the result of true_exp is returned, otherwise the result of false_exp is returned. For example, if the following command were entered: a = (sind(20.0) > cosd(20.0) ? 1 : -1)  then, a would be assigned the value -1 since the relational expression to the left of the question mark is false. Both true_exp and false_exp are always evaluated prior to evaluating the relational expression. Therefore, you should not write an equation such as sind(20.0*a)>cosd(20.0*a) ? a=sind(20.0) : a=cosd(20.0)  since the value of a can change during the evaluation of the expression. Instead, this equation should be written as: a = (sind(20.0*a)>cosd(20.0*a) ? sind(20.0) : cosd(20.0))  11   12   3 Operators The operators recognized by Aprepro are listed below. The letters a and b can represent variables, numbers, functions, or expressions unless otherwise noted. The tables below also list the precedence and associativity of the operators. Precedence defines the order in which operations should be performed. For example, in the expression: 3*4+6/2  the multiplications and divisions are performed first, followed by the addition because multiplication and division have higher precedence than addition. The precedence is listed from 1 to 14 with 1 being the lowest precedence and 14 being the highest. Associativity defines which side of the expressions should be simplified first. For example the expression: 3 + 4 + 5 would be evaluated as (3 + 4) + 5 for left associativity, the expression a = b / c would be evaluated as a = (b / c) for right associativity.  3.1 Arithmetic Operators Arithmetic operators combine two or more algebraic expressions into a single algebraic expression. These have obvious meanings except for the pre- and post- increment and Table 1. Syntax a+b a-b a*b, a~b a/b a^b, a**b a%b ++a, a++ --a, a--  Arithmetic Operators Description Addition Subtraction Multiplication Division Exponentiation. Modulus, (remainder) Pre- and Post-increment a Pre- and Post-decrement a. Precedence 9 9 10 10 12 10 13 13 Associativity left left left left right left left left  decrement operators. The pre-increment and pre-decrement operators first increment or decrement the value of the variable and then return the value. For example, if a = 1, then b=++a will set both b and a equal to 2. The post-increment and post-decrement operators first return the value of the variable and then increment or decrement the variable. For example, if a = 1, then b=a++ will set b equal to 1 and a equal to 2. The modulus operator % calculates the integer remainder. That is both expressions are truncated an integer value and then the remainder calculated. See the fmod function in section 5.1 on page 19 for the  13   calculation of the floating point remainder. The tilde character ~ is used as a synonym for multiplication to improve the aesthetics of the unit conversion system (see section 6 on page 25). It is more natural for some users to type 12~metre than 12*metre.  3.2 Assignment Operators Assignment operators combine a variable and an algebraic expression into a single algebraic expression, and also set the variable equal to the algebraic expression. Only variables can be specified on the left-hand-side of the equal sign. Table 2. Syntax a=b a+=b a-=b a*=b a/=b a^=b a**=b  Assignment Operators Description The value of 'a' is set equal to 'b' The value of `a` is set equal to a + b The value of `a` is set equal to a - b The value of `a` is set equal to a * b The value of `a` is set equal to a / b The value of `a` is set equal to a b  Precedence 1 2 2 3 3 4 4  Associativity right right right right right right right  The value of `a` is set equal to a b  3.3 Relational Operators Relational operators combine two algebraic expressions into a single relational expression. Relational expressions and operators can only be used before the question mark (?) in a conditional expression. Table 3. Syntax a b a <= b a >= b a == b a != b  Relational Operators Description true if `a` is less than `b` true if `a` is greater than `b` true if `a` is less than or equal to `b` true if `a` is greater than or equal to `b` true if `a` is equal to `b` true if `a` is not equal to `b` Precedence 8 8 8 8 8 8 Associativity left left left left left left  3.4 Boolean Operators Boolean operators combine one or more relational expressions into a single relational expression. If la and lb are two relational expressions, then:  14   Table 4. Syntax la || lb la && lb !la  Logical Operators Description true if either `la` or `lb` are true. true if both `la` and `lb` are true. true if `la` is false. Precedence 6 7 11 Associativity left left left  3.5 String Operators The only supported string operator at this time is string concatenation which is denoted by //. If a = ""Hello"" and b = ""World"", then: c = a // "" "" // b  sets c equal to ""Hello World"". Concatenation has precedence 14 and left associativity.  15   16   4 Predefined Variables A few commonly used variables are predefined in Aprepro. These are listed below. The default output format is specified as a C language format string, see your C language documentation for more information. The default format and comment variables are defined with a leading underscore in their name so they can be redefined without generating an error message. Table 5. Name PI PI_2 SQRT2 DEG RAD E GAMMA PHI VERSION _FORMAT _C_ 1  Predefined Variables Value 3.14159265358979323846 1.57079632679489661923 1.41421356237309504880 57.2957795130823208768 0.01745329251994329576 2.71828182845904523536 0.57721566490153286060 1.61803398874989484820 Varies, string value ""%.10g"" ""$"" Description  /2 2 180 /  degrees per radian  / 180 radians per degree base of natural logarithm euler-mascheroni constant1 golden ratio ( 5 + 1 ) / 2 current version of Aprepro default output format default comment character  1 1 The euler-mascheroni constant is defined as the limit of 1 + -- + ... + --  log s as s s 2 approaches infinity.  Note that the output format is used to output both integers and floating point numbers. Therefore, it should use the %g format descriptor which will use either the decimal (%d), exponential (%e), or float (%f) format, whichever is shorter, with insignificant zeros suppressed. The table below illustrates the effect of different format specifications on the output of the variable PI and the value 1.0 . See the documentation of your C compiler for more information. For most cases, the default value is sufficient. Table 6. Format %.10g %.10e %.10f  Effect of various output format specifications PI Output 3.141592654 3.1415926536e+00 3.1415926536 1.0 Output 1 1.0000000000e+00 1.0000000000  17   Table 6. Format %.10d  Effect of various output format specifications PI Output 1413754136 1.0 Output 0000000000  The comment character should be set to the character that the program which will read the processed file uses as a comment character. The default value of ""$"" is the comment character used by the SEACAS codes at Sandia National Laboratories. The -c command line option* automatically changes the value of the comment variable to match the character specified on the command line.  * See appendix A on page 51.  18   5 Functions Several mathematical and string functions are implemented in Aprepro. To cause a function to be used, you enter the name of the function followed by a list of zero or more arguments in parentheses. For example sqrt(min(a,b*3))  uses the two functions sqrt() and min(). The arguments a and b*3 are passed to min(). The result is then passed as an argument to sqrt(). The functions in Aprepro are listed below along with the number of arguments and a short description of their effect.  5.1 Mathematical Functions The following mathematical functions are available in Aprepro. Table 7. Syntax abs(x) acos(x) acosd(x) acosh(x) asin(x) asind(x) asinh(x) atan(x) atan2(y,x) atan2d(x) atand(y,x) atanh(x) ceil(x) cos(x) cosd(x) cosh(x) d2r(x) dim(x,y) dist(x1,y1, x2,y2)  Mathematical Functions Description Calculates the absolute value of x. x Calculates the inverse cosine of x, returns radians Calculates the inverse cosine of x, returns degrees Calculates the inverse hyperbolic cosine of x Calculates the inverse sine of x, returns radians Calculates the inverse sine of x, returns degrees Calculates the inverse hyperbolic sine of x Calculates the inverse tangent of x, returns radians Calculates the inverse tangent of y/x, returns radians Calculates the inverse tangent of x, returns degrees Calculates the inverse tangent of y/x, returns degrees Calculates the inverse hyperbolic tangent of x Calculates the smallest integer not less than x Calculate the cosine of x, with x in radians Calculate the cosine of x, with x in degrees Calculates the hyperbolic cosine of x Converts degrees to radians. Calculates x - min(x,y). Calculates ( ( x1  x2 ) + ( y1  y2 ) ) 2 2  19   Table 7. Syntax exp(x) floor(x)  Mathematical Functions Description Calculates e (Exponential) Calculates the largest integer not greater than x. Calculates the floating-point remainder of x/y. Calculates x 2 + y 2 Calculates the integer part of x truncated toward 0. Calculates log (  ( x ) ) Calculates the natural (base e) logarithm of x. Calculates log(1+x) Calculates the base 10 logarithm of x. Calculates the maximum of x and y. Calculates the minimum of x and y. Calculates r  cos ( a ) , a is in degrees Calculates r  sin ( a ) , a is in degrees Converts radians to degrees. Calculates a random number between xl and xh. Calculates x  sgn ( y ) Calculates the sine of x, with x in radians. Calculates the sine of x, with x in degrees. Calculates the hyperbolic sine of x Calculates the square root of x. Calculates the tangent of x, with x in radians. Calculates the tangent of x, with x in radians. Calculates the hyperbolic tangent of x. Calculates the julian day corresponding to mm/dd/yy. Calculates the julian day corresponding to mm/dd/yy at hh:mm:ss i j Calculates the angle between the vector x 1 ^ + y 1 ^ and x 2 ^ + y 2 ^ . returns radians. i j i j Calculates the angle between the vector x 1 ^ + y 1 ^ and x 2 ^ + y 2 ^ . returns degrees. i j x  fmod(x,y) hypot(x,y) int(x), [x] lgamma(x) ln(x), log(x) logp1(x) log10(x) max(x,y) min(x,y) polarX(r,a) polarY(r,a) r2d(x) rand(xl,xh) sign(x,y) sin(x) sind(x) sinh(x) sqrt(x) tan(x) tand(x) tanh(x) julday(mm, dd, yy) juldayhms(mm, dd, yy, hh, mm, ss) Vangle(x1,y1, Vangled(x1,y1, x2,y2) x2,y2)  20   5.2 String Functions A few useful string functions are available: tolower(svar) toupper(svar) tostring(x) execute(svar) Translates all uppercase characters in svar to lowercase. It modifies svar and returns the resulting string. Translates all lowercase character in svar to uppercase. It modifies svar and returns the resulting string. Returns a string representation of the numerical varaible x. The variable x is unchanged. svar is parsed and executed as if it were a line read from the input file. For example, if svar = ""b=sqrt(25.0)"", then {execute(svar)} returns the value 5 and sets b = 5. The expression svar is enclosed in delimiters prior to being executed and it must be a valid expression or an error message will be printed. Similar to execute(svar), except that svar is not enclosed in delimiters prior to being executed. For example, if svar = ""Point {1+5} {sqrt(5)} {sqrt(6)}"", then {rescan(svar)} would print: Point 6 2.236067977 2.449489743. The difference between execute(sv1) and rescan(sv2) is that sv1 must be a valid expression, but sv2 can contain zero or more expressions. Returns a string containing the value of the environment variable svar. If the environment variable is not defined, an empty string is returned. Returns a string containing the nth word of svar. The words are separated by one or more of the characters in the string variable del Returns the number of words in svar. Words are separated by one or more of the characters in the string variable del Returns a double-precision floating-point number equal to the value represented by the character string pointed to by svar. Outputs the string svar to stderr and then terminates the code with an error exit status.  rescan(svar)  getenv(svar) get_word(n,svar,del) word_count(svar,del) strtod(svar) error(svar)  The following example shows the use of some of the string functions. The lines beginning with the string ""Output>"" show the output from Aprepro resulting from entering the previous line. {t1 = ""ATAN2""} {t2 = ""(0, -1)""} Output> ATAN2 (0, -1) {t3 = tolower(t1//t2)} Output> atan2(0, -1) ...The variable t3 is equal to the string atan2(0, -1) {execute(t3)} Output> 3.141592654 ...The result is the same as executing {atan2(0, -1)}  21   This is admittedly a very contrived example; however, it does illustrate the workings of several of the functions. In the first example, an expression is constructed by concatenating two strings together and converting the resulting string to lowercase. This string is then executed and simply prints the result of evaluating the expression. The following example uses the rescan function to illustrate a basic macro capability in Aprepro. The example calculates the coordinates of eleven points (Point1 ... Point11) equally spaced about the circumference of a 180 degree arc of radius 10. {ECHO(OFF)}{num = 0} {rad = 10} {nintv = 10} {nloop = nintv + 1} {line = 'Define {""Point""//tostring(++num)}, {polarX(rad, (num1) * 180/nintv)} {polarY(rad, (num-1)*180/nintv)}'} {ECHO(ON)} {loop(nloop)} {rescan(line)} {endloop}  Output: Define Define Define Define Define Define Define Define Define Define Define Point1, Point2, Point3, Point4, Point5, Point6, Point7, Point8, Point9, Point10, Point11, 10 0 9.510565163 3.090169944 8.090169944 5.877852523 5.877852523 8.090169944 3.090169944 9.510565163 6.123233765e-16 10 -3.090169944 9.510565163 -5.877852523 8.090169944 -8.090169944 5.877852523 -9.510565163 3.090169944 -10 1.224646753e-15  Note the use of the ECHO(OFF|ON) block* to suppress output during the initialization phase, and the loop construct to automatically repeat the rescan line. The variable num is converted to a string after it is incremented and then concatenated to build the name of the point. In the definition of the variable line, single quotes are first used since this is a multi-line string; double quotes are then used to embed another string within the first string. To modify this example to calculate the coordinates of 101 points rather than eleven, the only change necessary would be to set {nintv=100}.  5.3 Additional Functions  File Inclusion: Aprepro can read input from multiple files using the include() and cinclude() functions. If a line of the form: {include(""filename"")} {include(string_variable)}  is read, Aprepro will open and begin reading from the file filename. A string variable can be used as the argument instead of a literal string value. When the end * Described in section 5.3 on page 22  Described in section 5.3 on page 22  22   of the file is reached, it will be closed and Aprepro will continue reading from the previous file. The difference between include and cinclude is that if filename does not exist, include will terminate Aprepro with a fatal error, but cinclude will just write a warning message and continue with the current file. The cinclude function can be thought of as a conditional include, that is, include the file if it exists. Multiple include files are allowed and an included file can also include additional files. Approximately 16 levels of file inclusion can be used. This option can be used to set variables globally in several files. For example, if two or more input files share common points or dimensions, those dimensions can be set in one file that is included in the other files. If ECHO(OFF) is in effect during in an included file, ECHO(ON) will automatically be executed at the end of the file.  Conditionals: Portions of an input file can be conditionally processed through the use of the {Ifdef(variable)} or {Ifndef(variable)} constructs. The syntax is: {Ifdef(variable)} ...Lines processed if 'variable' {Else} ...Lines processed if 'variable' {Endif} {Ifndef(variable)} ...Lines processed if 'variable' {Else} ...Lines processed if 'variable' {Endif} is not equal to 0 is equal to 0 or undefined  is equal to 0 or undefined is not equal to 0  The {Else} is optional. Note that if variable is undefined, its value is equal to zero. Ifdef constructs can be nested up to approximately 16 levels. A warning message will be printed if improper nesting is detected. {Ifdef(variable)}, {Ifndef(variable)}, {Else}, and {Endif} are the only text parsed on a line. Text following these on the same line is ignored.  Loops: Repeated processing of a group of lines can be controlled with the {loop(control)}, {endloop} commands. The syntax is: {loop(variable)} ...Process these lines 'variable' times {endloop}  Loops can be nested. A numerical variable or constant must be specified as the loop control specifier. You cannot use an algebraic expression such as {loop(3+5)}.  ECHO: The printing of lines to the output file can be controlled through the use of the {ECHO(OFF)} and {ECHO(ON)} commands. The syntax is: {ECHO(OFF)}  23   ...These lines will be processed, but not printed to output {ECHO(ON)} ...These lines will be both processed and printed to output. ECHO will automatically be turned on at the end of an included file. The commands ECHO and NOECHO are synonyms for ECHO(ON) and ECHO(OFF).   VERBATIM: The printing of all lines to the output file without processing can be controlled through the use of the {VERBATIM(ON)} {VERBATIM(OFF)} command. The syntax is: {VERBATIM(ON)} ...These lines will be printed to output, but not processed {VERBATIM(OFF)} ...These lines will be printed to output and processed  NOTE: there is a major difference between the ECHO/NOECHO commands, the Ifdef/Endif commands, and the VERBATIM(ON|OFF) commands: ECHO(ON|OFF) Ifdef/Endif VERBATIM(ON|OFF) Lines processed, but not printed if ECHO(OFF) Lines not processed or printed if in Ifndef block Lines not processed, but are printed   Output File Specification: The output function can be used to change the file to which Aprepro is outputting the processed data. The syntax is: output(""filename""), where filename is the name of the new output file. A string variable can be used as the function argument.The previous output file is closed. An error message is written and the code terminates if the file cannot be opened.  24   6 Units Conversion System Although great effort has been expended to ensure that the units conversion system is accurate and consistent, the author does not make any warranty expressed or implied, or assume any liability or responsibility for the use of this software. If any errors are discovered in this software, please contact the author.  6.1 Introduction The units conversion system in Aprepro is implemented as a set of files that define several variables that are abbreviations for unit quantities. For example, if the output format for the current unit system was inches, the variable foot would have the value 12. Therefore, an expression such as 8*foot would be equal to 96 which is the number of inches in 8 feet*. Files have been defined for seven consistent units systems including four metric based systems: si, cgs, cgs-ev, and shock; and three english-based systems: in-lbf-s, ft-lbf-s, and ft-lbm-s. The output units for these unit systems are shown in Table 8 (metric) and Table 9 (english). A list of the defined units abbreviations is given in Table 10. In addition to the definition of the conversion factors, several string variables are also defined which describe the output format of the current units system. For example, the string variable dout defines the output format for density units. For the in-lbf-sec units system, dout = ""lbf-sec^2/in^4"" which is the output format for densities in this system. The string variables can be used to document the Aprepro output. The string variable names are listed in the last column of Table 8 and Table 9. Table 8: Units Systems and Corresponding Output Format--Metric Quantity Length Mass Time Temp. Velocity Accel. Force Volume Density si metre kilogram second kelvin metre/sec metre/sec^2 newton metre^3 kg/m^3 cgs centimetre gram second kelvin cm/sec cm/sec^2 dyne cm^3 g/cc cgs-ev centimetre gram second eV cm/sec cm/sec^2 dyne cm^3 g/cc shock centimetre gram micro-sec kelvin cm/usec cm/usec^2 g-cm/usec^2 cm^3 g/cc string lout mout tout Tout vout aout fout Vout dout  * This can also be written as 8~foot since the symbol ~ has been defined to be the multiplication operator.  25   Table 8: Units Systems and Corresponding Output Format--Metric Quantity Energy Power Pressure joule watt pascal si erg erg/sec dyne/cm^2 cgs cgs-ev erg erg/sec dyne/cm^2 shock g-cm^2/usec^3 g-cm^2/usec^4 Mbar string eout Pout pout  Table 9: Units Systems and Corresponding Output Format--English Quantity Length Mass Time Temp. Velocity Accel. Force Volume Density Energy Power Pressure in-lbf-s inch lbf-sec^2/in second rankine inch/sec inch/sec^2 pound-force inch^3 lbf-sec^2/in^4 inch-lbf inch-lbf/sec lbf/in^2 ft-lbf-s foot slug second rankine foot/sec foot/sec^2 pound-force foot^3 slug/ft^3 foot-lbf foot-lbf/sec lbf/ft^2 ft-lbm-s foot pound-mass second rankine foot/sec foot/sec^2 poundal foot^3 lbm/ft^3 ft-poundal ft-poundal/sec poundal/ft^2 string lout mout tout Tout vout aout fout Vout dout eout Pout pout  The units definitions are accessed through the Units function in Aprepro: {Units(""unit_system"")}  where unit_system is one of the strings listed in the first row of the previous two tables. This will search the standard locations on your system for the correct files to include.  6.2 Units Conversion Implementation The units conversion system in Aprepro is implemented simply as a set of files that are selectively included by a function call in Aprepro. There are two types of files used. The first file type is a header file which defines the base units (metre, second, kg, radian, and kelvin) in terms of the desired output formats, and the output format string variables (lout, mout, ...). There is a different header file for each unit system. The in-lbf-s header file is shown below as an example: {_C_} This is the in-lbf-s units file: inch, sec, lbf  26   {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_} {_C_}  Outputs: Time: Length: Accel: Mass: Force: Velocity: Volume: Density: Energy: Power: Pressure: Temp: Angular: 1 1 1 1 1 meter second kg kelvin radian = = = = =  {tout {lout {aout {mout {fout {vout {Vout {dout {eout {Pout {pout {Tout {Aout {m = {sec {kg = {degK {rad  = = = = = = = = = = = = =  ""second""} ""inch""} ""in/sec^2""} ""lbf-sec^2/in""} ""lbf""} ""in/sec""} ""in^3""} ""lbf-sec^2/in^4""} ""inch-lbf""} ""inch-lbf / sec""} ""psi""} ""degR""} ""radian""}  1 / 2.54e-2} {lout} = 1} {tout} 1/4.5359237e-1/(9.806650*m/sec^2)} {mout} = 1.8} {Tout} = 1} {Aout}  Note that this file defines the output units string variables at the top of the file and then defines the base units in terms of the output units at the bottom of the file. This is the only file that must be created to implement a new units system. The name of the header file matches the name of the units system and it must be all lowercase. The second file is called the conversion file. different units in terms of the base units. This new unit abbreviation to the system unless a the files must be modified. A short excerpt of {_C_}{_C_}{_C_} {_C_} 1 Meter= {_C_} 1 cm = {_C_} 1 mm = {_C_} 1 um = {_C_} 1 km = {_C_} 1 foot = {_C_} 1 mile = {_C_} 1 yard = {_C_} 1 inch = {_C_} 1 mil =  This file contains the equations defining the is the only file that must be changed to add a new base unit is added, in which case all of this file is shown below:  Length (L) {meter = metre = m} {lout} {cm = centimeter = centimetre {mm = millimeter = millimetre {um = micrometer = micrometre {km = kilometer = kilometre = {ft = foot = .3048 * m} {lout} {mi = mile = ft * 5280} {lout} {yd = yard = ft * 3} {lout} {in = inch = ft / 12} {lout} {mil = inch / 1000} {lout}  = m / 100} = m / 1000} = m / 1e6} 1000 * m}  {lout} {lout} {lout} {lout}  This segment is the portion of the conversion file which defines the length conversions. The expression {_C_} at the beginning of each line of the header and conversion files is a string variable that is given the current value of the comment character. In this way, the files can be written in a generic format that can be used as input for several codes. Each expression in the file defines a unit abbreviation in terms of a previously defined unit. For example, the third line of the file defines the abbreviations cm, centimeter, and centimetre in terms of the metre which is a base unit. The eighth line of the file defines the abbreviations mile and mi in terms of the foot which is earlier defined in terms of the meter. For ease of  27   verification of the units files, they are written in such a way that the output is somewhat self-explanatory, for example, if the SI system is being used, the above lines would result in the following output: $$$ $1 $1 $1 $1 $1 $1 $1 $1 $1 $1 Length (L) Meter cm mm um km foot mile yard inch mil = = = = = = = = = = 1 meter 0.01 meter 0.001 meter 1e-06 meter 1000 meter 0.3048 meter 1609.344 meter 0.9144 meter 0.0254 meter 2.54e-05 meter  which is more understandable than if a bunch of numbers were output. The conversion expressions in this file were obtained from References 6, 7, 8, and 9. When Aprepro processes the function call {Units(""unit_system"")}, it first searches for the requested header file (which has the same name as the unit system) in the directories defined by the environment variable MATSPATH or the default location if MATSPATH is not defined. The first matching file is used. It then searches for the conversion file in the same directories. Units files other than those currently supported can be used by modifying the environment variable MATSPATH. For example the following C-shell command will cause Aprepro to first search the current directory, then your mats subdirectory, and finally the default units directory for the specified units system files: setenv MATSPATH "".:~/:/usr/local/eng_sci/mats""  The units files must be in a directory called units under the directories specified in the MATSPATH environment variable*. Therefore, it is possible to have a personal copy of a header file to define a new unit system and still use the global conversion file. The units conversion files are in the SEACAS1 code management system which is maintained by CVS10. CVS maintains a complete change log and the history of previous changes so that traceability is maintained.  6.3 Usage The following example illustrates the basic usage of the units conversion utility in Aprepro. $ Aprepro Units Utility Example $ {ECHO(OFF)} ...Turn off echoing of the conversion factors $ {Units(""shock"")} ...Select the shock units system $ NOTE: Dimensions - {lout}, {mout}, {dout}, {pout}  * This is done so that the entire system (units conversion and material database access routines) can use a single environment variable.  28   ...This will document what quantities are used in the file after it is run through Aprepro $ {len1 = 10.0 * inch} ...Define a length in an english unit (inches) $ {len2 = 12.0~inch} ... ~ is synonym for * (multiplication) Material 1, Elastic Youngs Modulus = Yield Stress = ...Define the density and End Point 100 {0.0} Point 110 {len1} Point 120 {len1} Point 130 {0.0} Plastic, {1890~kgpm3} $ {dout} {28.3e6~psi} {30~ksi} material parameters in whatever units they are available {0.0} {0.0} {len2} {len1}  The output from this example input file is: $ Aprepro ($Revision: 1.36 $) Fri Oct 23 13:32:42 1992 ...QA header written by Aprepro $ Aprepro Units Utility Example $ NOTE: Dimensions - cm, gram, g/cc, Mbar ...The documentation of what quantities this file uses $ 25.4 $ 30.48 Material 1, Elastic Plastic, 1.89 $ g/cc Youngs Modulus = 1.951216314 Yield Stress = 0.002068427188 ...All material parameters are now in consistent units End Point 100 0 0 Point 110 25.4 0 Point 120 25.4 30.48 Point 130 0 25.4 ...Lengths have all been converted to centimetres  The same input file can be used to output in SI units simply by changing Units command from shock to si. The output in SI units is: $ Aprepro ($Revision: 1.36 $) Fri Oct 23 13:33:22 1992 $ Aprepro Units Utility Example $ NOTE: Dimensions - meter, kilogram, kg/m^3, Pa ...Quantities are now output in standard SI units $ $ 0.254 $ 0.3048 Material 1, Elastic Youngs Modulus = Yield Stress = End Point 100 0 0 Point 110 0.254 Plastic, 1890 $ kg/m^3 1.951216314e+11 206842718.8  0  29   Point 120 0.254 0.3048 Point 130 0 0.254 ...Lengths have all been converted to metres  6.4 Additional Comments A few additional comments and warnings on the use of the units system are detailed below.  Omitting the {ECHO(OFF)} line prior to the {Units(""unit_system"")} function will print out the contents of the units header and conversion files. Each line in the output will be preceded by the current comment character which is $ by default. A few lines from the in-lbf-s units file are shown below: $ Aprepro ($Revision: 1.36 $) Fri Oct 23 13:35:02 1992 $ This is the in-lbf-s units file: inch, sec, lbf $ Outputs: $ Time: second $ Length: inch $ Accel: in/sec^2 $ Mass: lbf-sec^2/in $ Force: lbf $ Velocity: in/sec $ Volume: in^3 $ Density: lbf-sec^2/in^4 $ Energy: inch-lbf $ Power: inch-lbf / sec $ Pressure: psi $ Temp: degR $ Angular: radian $ $ 1 meter = 39.37007874 inch $ 1 second = 1 second $ 1 kg = 0.005710147155 lbf-sec^2/in $ 1 kelvin = 1.8 degR $ 1 radian = 1 radian ..... $$$ Acceleration (L/T^2) $ Grav. Accel. = 386.0885827 in/sec^2 $ $$$ Force (ML/T^2) $ 1 Newton = 0.2248089431 lbf $ 1 dyne = 2.248089431e-06 lbf $ 1 lbf = 1 lbf $ 1 kip = 1000 lbf ......  The comment character can be changed by invoking Aprepro with the -c option. For example aprepro -c# input_file output_file will change the comment character at the beginning of the lines to #. (See Appendix A on page 51 for a de-  scription of the command options.)  The temperature conversions are only valid for relative temperatures, for example, 100~degC is equal to 180~degF, not 212~degF.  30    Since several variables are defined in the units system, it is possible to redefine one of the variable names in your input file. If the Aprepro warning messages are turned off, you will not be notified of the variable redefinition and erroneous results may occur. Therefore, you should not turn off Aprepro warning messages while using the units system, and you should investigate all redefined variable messages to ensure that you are getting the results you expect.  31   32   7 Material Database Access System The material database access system has been implemented in Aprepro to facilitate the inclusion of material property data in finite element input data files. It consists of a few functions in Aprepro and a specified directory structure of files that contain material property data for each material in the system and template files for each material model in each analysis code. The template files format the data from the material property files into the correct format for the analysis codes. The material database access system is part of a larger material database system called MATS which is being developed at Sandia National Laboratories, New Mexico.  7.1 Overview of the MATS System MATS is a series of programs and datafiles which provides the analyst with a simple method  for retrieving material data from a database and inserting it into an input file for an analysis. The basic MATS system consists of the algebraic preprocessing code Aprepro, a set of template files for each material model in each analysis code, and a set of material database files for each material of interest. The full-featured MATS system would also include a database processor which would take raw test data and/or data from other sources, and provide the user with tools to process the data. After the user is satisfied with the fit of the data to the constitutive model that will be used, the data would be written to a datafile that could be used by the basic MATS system. Figure 1. shows a schematic representation of the proposed MATS system. It consists of three major sections:  Database Preprocessor: The database processor would be a tool which would take the raw test data and convert it into the correct format for the MATS database. Note that for nonlinear materials, this is not a simple conversion that can be performed automatically. The database processor should provide a highly interactive environment including tools such as multiple curve fitting options, filtering capabilities, options to work with portions of curves, curve editing capabilities, etc.  Material: The material datafiles would be stored in this section. Each major material group (for example, steel, aluminum, foam) would be a separate subdirectory under this section. These subdirectories would contain material files for each supported material of this type. For example, the aluminum subdirectory would have a material file for 6061-T6 aluminum which would contain the material data used in structural and thermal analysis codes. For example, yield stress, density, thermal conductivity, and specific heat.  Code: Code template files (which will be described later) would be stored in this section. Each supported code would have a separate subdirectory under this section. These subdirectories would contain a template file for each constitutive model supported by the analysis code. For example, the PRONTO2D subdirectory  33   would have templates for the Elastic, Elastic/Plastic, Johnson-Cook, Low Density Foam, and other constitutive models. Material data would be written into the database using the database processor, a simple text editor, or a stand-alone program written specifically for that function. Although the schematic only shows a single database structure, MATS will be written to search in several user-defined locations for the database information. This will allow userspecific, group-specific, and global databases to be developed. If an analyst develops personal datafiles for certain materials, MATS can be instructed to first look for the data in the personal datafiles. If it is found, that data will be used, if it is not found, MATS will continue to search all databases specified by the user until the data is found, or all of the specified databases have been searched.  DataBase Processor  Commercial Data Raw Test Data Steel 4340 6061 T6 1-5 lb 304 Generic 40-50 lb  MATS Material  Aluminum Foam  PRONTO  Elastic Material 1 EPDATA  Elas/Plas Material 2 EOS  Code  COYOTE CTH  Figure 1.  Schematic of Proposed MATS Database System  The remainder of this section will concentrate on the Aprepro interface routines to the material database system. Documentation of the overall MATS system will be published as soon as the system is developed and implemented.  34   7.2 Implementation of the Material Database Access Routines The material database routines are accessed from within Aprepro using a command of the form: {Material(mat_id, ""Mat_Type"", ""Mat_Name"", ""Model_Type"", ""Code"")} This accesses the material database for the specific material Mat_Name which is a Mat_Type material and formats it in a form suitable for the Model_Type constitutive model in the code Code. For example, to use OFHC Copper with the Johnson-Cook constitutive model11 in the PRONTO2D Code, the command would be: {Material(10,""Copper"",""OFHC Copper"",""Johnson-Cook"",""Pronto2d"")}  All strings are converted to lowercase so that the user only has to worry about the correct spelling. Aprepro manipulates this line into four commands which load the correct material database file and the correct template file. The example command produces a command which has the effect of: {_material_model = ""johnson_cook""} {include($MATS/material/copper/ofhc_copper)} {include($MATS/code/pronto2d/johnson-cook)} {material_model = "" ""}  where $MATS is a symbolic variable that points to the The symbolic variable can specify multiple locations are to permit private databases to be searched prior to or database. The mechanism for doing this is to define the list of colon separated directories. For example,  location of the material database. searched in a user-specified order instead of searching the default MATS environment variable as a  setenv MATS ~/mats:/department/mats:/global/mats  In many analyses, the analyst may want to modify some of the material properties specified in the material database file. For example, only a portion of a material may be explicitly modeled and therefore, the density of the modeled portion must be increased to maintain the correct mass of the body. In this case, the following commands would be used: {Material(mat_id, ""Mat_Type"", ""Mat_Name"", ""Model_Type"", ""DEFER"")} {Density = 20000 * kg/m^3} $ User-specified density {Material(mat_id, ""DEFER"", ""Mat_Name"", ""Model_Type"", ""Code"")}  This sequence of commands is manipulated into a series of commands which have the effect of first processing the material definition file, then allowing the user to modify any of the material parameters, and then formatting the data as specified in the template file for the specified code.  7.3 Code Template Files: Each code, or ""code family"", has its own set of template files which extract and format the information in the material database into a code-readable format. For example, prototype  35   template files for use in PRONTO and SANTOS are shown below for the Elastic and Johnson Cook material models. Material {_matid}, Elastic, {_Density} Youngs Modulus = {_Youngs_Modulus} Poissons Ratio = {_Poissons_Ratio} End {_C_} {dout} {_C_} {pout} {_C_} (no-dimen)  Material {_matid}, Johnson Cook, {_Density} {_C_} {dout} Youngs Modulus = {_Youngs_Modulus} {_C_} {pout} Poissons Ratio = {_Poissons_Ratio} {_C_} (no-dimen) Yield Stress = {_Yield_Stress} {_C_} {pout} Hardening Constant = {_Hardening_Constant} {_C_} {pout} Hardening Exponent = {_Hardening_Exponent} {_C_} (no-dimen) RhoCv = {_RhoCv} {_C_} {pout}/{Tout} Rate Constant = {_Rate_Constant} {_C_} (no-dimen) Thermal Exponent = {_Thermal_Exponent} {_C_} (no-dimen) Ref Temperature = {_Reference_Temperature}{_C_} {Tout} Melt Temperature = {_Melt_Temperature} {_C_} {Tout} End  The variable names (enclosed in {}) are defined with leading underscores to reduce the redefined variable warning messages which would occur for multiple uses of the material command in a single Aprepro execution. If a new, or modified, constitutive model is developed, we do not have to develop an entire new branch of the material database tree. Instead, only a new template file is created and, possibly, a few constants added to the material database. For example, if the Johnson-Cook damage model is implemented, the template file could look like: Material {matid}, JC Damage, {Density} Youngs Modulus = {Youngs_Modulus} Poissons Ratio = {Poissons_Ratio} Yield Stress = {Yield_Stress} Hardening Constant = {Hardening_Constant} Hardening Exponent = {Hardening_Exponent} RhoCV = {RhoCv} $ OR: {Density * Cv} ? Rate Constant = {Rate_Constant} Thermal Exponent = {Thermal_Exponent} Ref Temperature = {Reference_Temperature} Melt Temperature = {Melt_Temperature} D1 = {D1}, D2 = {D2}, D3 = {D3}, D4 = {D4}, D5 = {D5} End  where the name in the first line of the template has been changed and the 5 constants at the end of the template have been added. These constants would then need to be added to the material files.  36   7.4 Material Files: A prototype material database file is shown below. Note that the file can be divided into several sections delineating the Physical, Mechanical, and Thermal properties, for example. $ {ECHO(OFF)} Material Data File for Material -- {Material = ""OFHC Copper""} ...NOTE: These data are for example only, DO NOT USE ------ Physical Properties {_Density = 8960 *kg / m^3} ------ Mechanical Properties {_Youngs_Modulus = E = 124 * GPa} {_Poissons_Ratio = nu = 0.34} {_Shear_Modulus = E/2/(1+nu)} {_Bulk_Modulus = E/3/(1-2*nu)} {_Yield_Stress = 450000 * psi} ------ Thermal Properties {_Conductivity = k = 386 * W / m / degK} {_Specific_Heat = Cp = 383 * J / kg / degK} {_Diffusivity = k / Density / Cp} {_Volume_Expansion = 5.0e-5 / degK} {_Melt_Temperature = 1356 * degK} ------- Johnson Cook Specific Properties {_t = (_material_model==""johnson_cook"" || _material_model==""jc_damage"")?1:0} {ifdef(_t)} {_Yield_Stress = 90 * MPa} {_Hardening_Constant = 292 * MPa} {_Hardening_Exponent = 0.31} ...Several other constants {endif} -------- Temperature_Dependent_Material Model Specific Properties (_t = (_material_model == ""ep_temperature_dependent"")?1:0} {ifdef(_t)} {C1 = ""<< >>"" {C2 = ""<< >>"" ...The above two lines will output the message << > to the output file if they are referenced {endif} ...Other Models and Information  The material template files can have place holders for all of the information needed for the currently existing material models; if the information does not exist, the constant is set to output a warning message to the user of the information. See for example the entry for the constants C1 and C2 in the ep_temperature_dependent material block. Many of the materials that are typically used in analyses have properties that vary depending on the temperature and/or strain rates expected in the analysis. This can be handled in a way similar to that shown in the following example which illustrates temperature-dependent material properties: {NOECHO}  37   {range1 = (temp > {range2 = (temp > {range3 = (temp > {range4 = (temp > {ECHO} {ifdef(range1)} {_Linear_Expansion {endif} {ifdef(range2)} {_Linear_Expansion {endif} {ifdef(range3)} {_Linear_Expansion {endif} {ifdef(range4)} {_Linear_Expansion {endif}  0 100 200 300  && && && &&  temp temp temp temp  <= <= <= <=  100 200 300 400  ) ) ) )  ? ? ? ?  1 1 1 1  : : : :  0} 0} 0} 0}  = 1.0e-9 / degK}  = 2.0e-9 / degK}  = 3.0e-9 / degK}  = 4.0e-9 / degK}  In this example, the Linear Expansion Coefficient is set to a different value according to the expected temperature in the analysis*.  7.5 Additional Comments The material database access routines are somewhat experimental at this time. They have primarily been implemented to provide an experimental testbed for implementing the MATS material database system. It is expected that the basic functionality documented in this report will remain stable; however, additional functions may be added if the need arises. The following list provides some additional information relating to the material database access routines specifically, and to the MATS system in general.  Material property data is not and will not be distributed with Aprepro. It is the end users responsibility to provide this data in the form required by Aprepro if the database access functionality is desired. The primary reason for doing this is that the analyst should not treat this function as a black box in which appropriate material data automagically appear as the result of a simple command. Rather, it should be treated as a means of efficiently accessing (and converting to the correct units) the data that the analyst has previously collected and verified.  A units conversion system (see section 6 on page 25) must be specified prior to accessing any data in the material database.  The material database access routines do not verify the consistency of the material database. Procedures are needed to determine whether the data in the material databases are consistent. For example, is Poissons Ratio less than 0.5? Are the units set correctly?, etc.? This should be a separate program so that data can be entered using different programs and then checked for consistency.  *The mechanism for doing this is not very clean and will probably be changed in the future. This example is used just to show the concept.  38    Since several references may be used within a single material file and similar references will be used in several material files, there should be a reference list that will cross reference an abbreviation in the material file to the full bibliographical citation for the reference. A typical reference in a material file could look like: $ {Yield_Stress = 145e3*psi} $ Ref: GRJ:9  which would signify that the data were found on page 9 in the document GRJ which is an abbreviation for some report reference list.  39   40   8 Error, Warning, and Informational Messages Several error, warning, and informational messages will be printed by Aprepro if certain conditions are encountered during the parsing of an input file. The messages are of the form: Aprepro: Type: Message (file, line line#)  Where Type is ERR for an error message, WARN for a warning message, or INFO for an informational message; Message is an explanation of the problem, file is the filename being processed at the time of the message, and line# is the number of the line within that file. Error messages are always output, Warning messages are output by default and can be turned off by using the -W or +warning command option, and Informational messages are turned off by default and can be turned on by using the -M or +message command option. (See section A on page 51.)  Error Messages  Aprepro: ERR: parse error (file, line line#) An unrecognized or illformed expression has been entered. Parsing of the file continues following this expression.  Aprepro: ERR: Can't open 'file': No such file or directory The  file specified in the include command cannot be found or does not exist. Aprepro will terminate processing following this error message.  Aprepro: ERR: Can't open 'file': Permission denied The file specified  in the include or output command could not be opened due to insufficient permission. Aprepro will terminate processing following this error message.  Aprepro: ERR: Improperly Nested ifdef/ifndef statements (file, line line#) An invalid ifdef/ifndef block has been detected. Typically this is caused by an extra endif or else statement.  Aprepro: ERR:  An expression tried to divide by zero. The expression is given the value of the dividend and parsing continues. Zero divisor (file, line line#)   Aprepro: ERR: Units File not found The units system specified in the Units  command could not be found. This could be due to a misspelling of the units system name, or an incorrectly installed units system.  Aprepro: ERR: unit file found, no conversion file  The units system  has been incorrectly installed or is not available.  Aprepro: ERR: Error locating material model  The specified material  model datafile could not be found.  Aprepro: ERR: function (file, line line#) DOMAIN error: Argument out of domain The arithmetic function function has been passed an invalid  41   argument. For example, the above error would be printed for each of the expressions: {sqrt(-1.0)} {log(0.0)} {asin(1.1)}  since the arguments are out of the valid domain for the function. The value returned by the function following an error is system-dependent. See the function's man page on your system for more information.  Warning Messages  Aprepro: WARN: Undefined variable 'variable' (file, line line#) A variable is used in an expression before it has been defined. The variable is set equal to zero or the null string ("""") and parsing continues.  Aprepro: WARN: Variable 'variable' redefined (file, line line#) A previously defined variable is being set equal to a new value.  Informational Messages  Aprepro: INFO: Included File: 'filename' (file, line line#) The file filename is being included at line line# of file file. This message will also be printed during the execution of a loop block since temporary files are used to implement the looping function, and during the execution of the units conversion and material database access routines.  42   9 Examples 9.1 Mesh Generation Input File The first example shown in this section is the point definition portion of an input file for a mesh generation code. First, the locations of the arc center points 1, 2, and 5 are specified. Then, the radius of each arc is defined ({Rad1}, {Rad2}, and {Rad5}). Note that the lines are started with a dollar sign, which is a comment character to the mesh generation code. Following this, the locations of points 10, 20, 30, 40, and 50 are defined in algebraic terms. Then, the points for the inner wall are defined simply by subtracting the wall thickness from the radius values. Title Example for Aprepro $ Center Points Point 1 {x1 = 6.31952E+01} {y1 = 7.57774E+01} Point 2 {x2 = 0.00000E+00} {y2 = -3.55000E+01} Point 5 {x5 = 0.00000E+00} {y5 = 3.62966E+01} $ Wth = {Wth = 3.0} ...Wall thickness $ Rad5 = {Rad5 = 207.00} $ Rad2 = {Rad2 = 203.2236} $ Rad1 = {Rad1 = Rad2 - dist(x1,y1; x2,y2)} $ Angle between Points 2 and 1: {Th12 = atan2d((y1-y2),(x1-x2))} Point 10 0.00 {y5 - Rad5} Point 20 {x20 = x1+Rad1} {y5-sqrt(Rad5^2-x20^2)} Point 30 {x20} {y1} Point 40 {x1+Rad1*cosd(Th12)} {y1+Rad1*sind(Th12)} Point 50 0.00 {y2 + Rad2} $ Inner Wall (3 mm thick) $ {Rad5 -= Wth} $ {Rad2 -= Wth} $ {Rad1 -= Wth} ...Rad1, Rad2, and Rad5 are reduced by the wall thickness Point 110 0.00 {y5 - Rad5} Point 120 {x20 = x1+Rad1} {y5-sqrt(Rad5^2-x20^2)} Point 130 {x20} {y1} Point 140 {x1+Rad1*cosd(Th12)} {y1+Rad1*sind(Th12)} Point 150 0.00 {y2 + Rad2}  The output obtained from processing the above input file by Aprepro is shown below. Title Example $ Center Point Point Point $ Rad5 = $ Rad2 = $ Rad1 = $ Angle for Aprepro Points 1 63.1952 2 0 5 0 207 203.2236 75.2537088 between Points 2 and 1:  75.7774 -35.5 36.2966  60.40745947  43   Point 10 0.00 Point 20 138.4489088 Point 30 138.4489088 Point 40 100.3576382 Point 50 0.00 $ Inner Wall (3 mm thick) $ 204 $ 200.2236 $ 72.2537088 Point 110 0.00 Point 120 135.4489088 Point 130 135.4489088 Point 140 98.87615226 Point 150 0.00  -170.7034 -117.5893956 75.7774 141.214957 167.7236  -167.7034 -116.2471416 75.7774 138.6062794 164.7236  9.2 Macro Examples Aprepro can also be used as a simple macro definition program. For example, a mesh input file may have many lines with the same number of intervals. If those lines are defined using a variable name for the number of intervals, then preprocessing the file with Aprepro will set all of the intervals to the same value, and simply changing one value will change them all. The following input file fragment illustrates this $ {intA line 10 line 20 line 30 line 40 = 11} str 10 str 20 str 30 str 40 {intB 20 0 30 0 40 0 10 0 = int(intA / 2)} {intA} {intB} {intA} {intB}  Which when processed looks like: $ 11 line line line line 5 10 20 30 40 str str str str 10 20 30 40 20 30 40 10 0 0 0 0 11 5 11 5  9.3 Command Line Variable Assignment This example illustrates the use of assigning variables on the command line. While generating a complicated 2D or 3D mesh, it is often necessary to reposition the mesh using GREPOS. If the following file called shift.grp is created: Offset X {xshift} Y {yshift} Exit  then, the mesh can be repositioned simply by typing: Aprepro xshift=100.0 yshift=-200.0 shift.grp temp.grp Grepos input.mesh output.mesh temp.grp  44   9.4 Loop Example This example illustrates the use of the loop construct to print a table of sines and cosines from 0 to 90 degrees in 5 degree increments. Input: $ Test looping - print sin, cos from 0 to 90 by 5 {angle = -5} {Loop(19)} {angle += 5} {sind(angle)} {cosd(angle)} {EndLoop}  Output: $ -5 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 Test looping - print sin, cos from 0 to 90 by 5 0 0.08715574275 0.1736481777 0.2588190451 0.3420201433 0.4226182617 0.5 0.5735764364 0.6427876097 0.7071067812 0.7660444431 0.8191520443 0.8660254038 0.906307787 0.9396926208 0.9659258263 0.984807753 0.9961946981 1 1 0.9961946981 0.984807753 0.9659258263 0.9396926208 0.906307787 0.8660254038 0.8191520443 0.7660444431 0.7071067812 0.6427876097 0.5735764364 0.5 0.4226182617 0.3420201433 0.2588190451 0.1736481777 0.08715574275 6.123233765e-17  9.5 Units and Material Database Access Example This example illustrates the use of the units system and the material database access routines. The material data shown in this example are for illustrative purposes only and may not represent actual material data. This example also illustrates the use of the ifdef blocks to control processing of selected lines. This file was used as an input file for two analyses in which the mesh for one analysis was a subset of the other analysis. Materials 15 and 16 only appeared in the larger analysis and there were a few changes in boundary condition numbering between the two analyses. The example is annotated to explain some of the constructs used. Note that all of the dimensions in the file have unit identifiers so the unit system of the analysis can be changed simply by picking a new unit system in the Units() command. {ECHO(OFF)}{Units(""si"")} ...Specify the Units system Title Units and Material Database Access Example $ {InitVel = -sqrt(2.0 * ga * 500~foot)}  45   ...Velocity is for a 500 foot drop$ $ {Code = ""Pronto3D""} $ {ConstitModel = ""JC Damage""} ...The constitutive model used for all of the materials can now be changed simply by changing this line. $ $ NOTE: dimensions - {lout}, {mout}, {dout}, {pout} ...Echo the output units types to document processed file $ $ {den_17 = (3.125~lbm) / (2.758e-4~metre^3)} $ {den_18 = (1.000~lbm) / (8.747e-5~metre^3)} ...The densities of materials 17 and 18 are modified to get the correct mass for the model $ Control Information: Termination Time {ttime = 1.0~millisecond} Plot Time {ttime / 20} Output Time {ttime / 200} Write Restart {ttime / 10} ...Want 20 plot steps, 200 output steps, and 10 restart steps written during the analysis $ Boundary Conditions: No Displacement Y 10 {ifdef(LARGE_MODEL)} Rigid Surface 1600 {-1.85206e-1~meter} 0.0 0.0,1.0 0.0 0.0 Rigid Surface 1601 {-1.85206e-1~meter} 0.0 0.0,1.0 0.0 0.0 Rigid Surface 1602 {-1.85206e-1~meter} 0.0 0.0,1.0 0.0 0.0 {else} Rigid Surface 400 {-1.56e-1~meter} 0.0 0.0,1.0 0.0 0.0 Rigid Surface 410 {-1.56e-1~meter} 0.0 0.0,1.0 0.0 0.0 Rigid Surface 602 {-1.56e-1~meter} 0.0 0.0,1.0 0.0 0.0 {endif} ...Numbering of boundary conditions changes depending on which mesh is used in the analysis. LARGE_MODEL is defined when full analysis is run. Initial Velocity Material 5 {InitVel} Initial Velocity Material 6 {InitVel} Initial Velocity Material 8 {InitVel} Initial Velocity Material 9 {InitVel} Initial Velocity Material 10 {InitVel} {ifdef(LARGE_MODEL)} Initial Velocity Material 15 {InitVel} Initial Velocity Material 16 {InitVel} {endif} ...Materials 15 and 16 only appear in the large model Initial Velocity Material 17 {InitVel} Initial Velocity Material 18 {InitVel} ...All of the material parameters are defined below. {Material( 5, ""Aluminum"", ""6061-T6"", ConstitModel, Code)} {Material( 6, ""HE"", ""PBX-9502"",ConstitModel, Code)} {Material( 8, ""Aluminum"", ""6061-T6"", ConstitModel, Code)} {Material( 9, ""Plastic"", ""Lexan"", ConstitModel, Code)} {Material(10, ""Aluminum"", ""6061-T6"", ConstitModel, Code)} {ifdef(NOT_DEFINED)} {Material(15, ""Steel"", ""13-8 H1100"", ConstitModel, Code)} {Material(16, ""Aluminum"", ""6061-T6"", ConstitModel, Code)}  46   {endif} {Material(17, ""Aluminum"", ""6061-T6"", ConstitModel, {_Density = den_17} {Material(17, ""DEFER"", ""6061-T6"", ConstitModel, {Material(18, ""Aluminum"", ""6061-T6"", ConstitModel, {_Density = den_18} {Material(18, ""DEFER"", ""6061-T6"", ConstitModel, ...Use all of the database properties for materials 17 and 18, execpt we calculated densities to get the correct mass in the model  ""DEFER"")} Code)} ""DEFER"")} Code)} need to use the  Portions of the output of this example are shown below: $ Aprepro ($Revision: 1.36 $) Mon Oct 26 14:15:15 1992 Title Units and Material Database Access Example $ -54.67235974 $ Pronto3D $ JC Damage $ $ NOTE: dimensions - meter, kilogram, kg/m^3, Pa $ $ 5139.507456 $ 5185.690751 $ Control Information: Termination Time 0.001 Plot Time 5e-05 Output Time 5e-06 Write Restart 0.0001 $ Boundary Conditions: No Displacement Y 10 Rigid Surface 400 -0.156 0.0 0.0,1.0 0.0 0.0 Rigid Surface 410 -0.156 0.0 0.0,1.0 0.0 0.0 Rigid Surface 602 -0.156 0.0 0.0,1.0 0.0 0.0 Initial Velocity Material 5 -54.67235974 Initial Velocity Material 6 -54.67235974 Initial Velocity Material 8 -54.67235974 Initial Velocity Material 9 -54.67235974 Initial Velocity Material 10 -54.67235974 Initial Velocity Material 17 -54.67235974 Initial Velocity Material 18 -54.67235974 $ 6061-T6 Aluminum Material 5, JC Damage, 2703.78448$ kg/m^3 Youngs Modulus= 6.894792943e+10$ Pa Poissons Ratio= 0.3157962771$ dimensionless Yield Stress= 324053592.8$ Pa Hardening Constant= 113763495.3$ Pa Hardening Exponent= 0.42$ dimensionless RhoCv= 2423039.586$ Pa/degK Rate Constant= 0.002$ dimensionless Thermal Exponent= 1.34$ dimensionless Ref Temperature= 38.88888889$ degK Melt Temperature= 670$ degK  47   D1 = -0.77, D2 = 1.45, D3 = -0.47, D4 = 0, D5 = 1.6 $ all dimensionless End  $ PBX 9502 (95% TATB, 5% Kel-F 800), Dobratz Material 6, JC Damage, 1895$ kg/m^3 Youngs Modulus= 6894757.293$ Pa Poissons Ratio= 0$ dimensionless Yield Stress= 6894757.293$ Pa Hardening Constant= 113763495.3$ Pa Hardening Exponent= 0.42$ dimensionless RhoCv= 2423039.586$ Pa/degK Rate Constant= 0.002$ dimensionless Thermal Exponent= 1.34$ dimensionless Ref Temperature= 38.88888889$ degK Melt Temperature= 670$ degK D1 = -0.77, D2 = 1.45, D3 = -0.47, D4 = 0, D5 = 1.6 $ all dimensionless End ...Rest of lines not shown  48   10 References 1  G. D. Sjaardema, ""Overview of the Sandia National Laboratories Engineering Analysis Code Access System,"" SAND92-2292, Sandia National Laboratories, Albuquerque, NM, January 1993. C. Donnelly and R. Stallman, ""BISON--The YACC-compatible Parser Generator,"" Free Software Foundation, Inc., 675 Mass Ave., Cambridge, MA, 02139, June 1992. Bison Version 1.19. V. Paxson, J. Poskanzer, and K. Gong, ""FLEX--Fast Lexical Analyzer Generator,"", Free Software Foundation, Inc., 675 Mass Ave., Cambridge, MA 02139, June 1989. Flex Version 2.3.6. G. D. Sjaardema, ""GREPOS: A GENESIS Database Repositioning Program,"" SAND90-0566, Sandia National Laboratories, Albuquerque, NM, April 1990. G. D. Sjaardema and S. W. Attaway, ""Proposed Specification for MATS,"" memo to Distribution, dated January 6, 1992, Sandia National Laboratories, Albuquerque, NM. F. W. Walker, J. R. Parrington, and F. Feiner, ""Nuclides and Isotopes, 14th Edition,"" General Electric Corporation, San Jose, California, 1989. J. C. Jaeger and N. G. W. Cook, Fundamentals of Rock Mechanics, Third Edition, Chapman and Hall Publishers, London, 1979. T. W. Lambe and R. V. Whitman, Soil Mechanics, John Wiley & Sons, New York, New York, 1969. G. R. Simpson, ""Units Computer Program"", copyright 1987. B. Berliner, ""CVS II: Parallelizing Software Development,"" USENIX article, Winter, 1990, Washington, D.C. G. R. Johnson and W. H. Cook, ""A Constitutive Model and Data for Metals Subjected to Large Strains, High Strain Rates, and High Temperatures,"" Proceedings of Seventh International Symposium on Ballistics, The Hague, The Netherlands, pp. 541-548, April 1983.  2  3  4  5  6  7  8  9  10  11  49   50   A Execution Aprepro is executed with the command: aprepro [-dsvieWM] [-c'char'] [var=val] [input_file] [output_file]  The effect of the parameters are: -v prints the code name and version to the terminal. (+version) -d  prints the name and value of each variable defined in the input file to the terminal at the end of the run. See SYNTAX for a description of defining and using variables. (+debug) prints statistics on hash table granularity at end of run. Primarily used for aprepro development. (+statistics)  -s  -c 'char'sets the comment character that Aprepro writes in front of the version string and other specific output lines to the first character of 'char' (+comment 'char') -i puts aprepro into interactive mode in which there is no buffering of output. This is useful when aprepro is used as a pipe for another code. (+interactive) if this is enabled, aprepro will exit when any of the strings EXIT, Exit, exit, QUIT, Quit, or quit are entered. Otherwise, aprepro will exit at end of file. (+exit_on) print a summary of the aprepro command line and the valid options. (+help) do not print warning messages such as redefined variables and undefined variables. (+nowarning) do print informational messages such as notification of included files. (+message) sets the variable `var` equal to the value `val`: This lets you dynamically set the value of a variable and change it between runs without editing the input file. Multiple `var=val` pairs can be specified on the command line. The command line definition of a variable does not override the definition of the same variable in the input file. specifies the file that contains the input to Aprepro. If this parameter is omitted, Aprepro will run interactively.  -e  -h -W -M var=val  input_file  output_file specifies the file that Aprepro will write the processed data to. If this parameter is omitted, Aprepro will write the data to the terminal. (stdout)  The +options at the end of the parameter descriptions are optional long-options that can be specified instead of the short options. For example, the following two lines are equivalent: aprepro +debug +nowarning +statistics +comment # aprepro -dWsc#  Note that the short options can be concatenated.  51   52   B Unit System Defined Variables In the following list, the first column defines the unit variables that are defined in the Aprepro unit system and the second column is a short description of the unit. All units are defined in terms of the five SI Base Units metre (length), second (time), kilogram (mass), temperature (kelvin), and radian (angle)*. The lightly shaded rows delineate the type of unit variable and the base quantities used to define it where L is length, T is time, M is mass, and t is temperature. For example density is defined in terms of M/L^3 which is mass/ length^3. Table 10: Defined Units Variables  Abbreviation Length m, meter, metre cm, centimeter, centimetre mm, millimeter, millimetre um, micrometer, micrometre km, kilometer, kilometre in, inch ft, foot yd, yard mi, mile mil Time second, sec usec, microsecond msec, millisecond minute hr, hour day  Description [L] Metre (base unit) Metre / 100 Metre / 1,000 Metre / 1,000,000 Metre * 1,000 Inch Foot Yard Mile Mil (inch/1000) [T] Second (base unit) Second / 1,000,000 Second / 1,000 Minute Hour Day  * The radian is actually a SI Supplementary Unit since it has not been decided whether it is a Base Unit or a Derived Unit. There are three other SI Base Units, the candela, ampere, and mole, but they are not yet used in the Aprepro units system.  53   Table 10: Defined Units Variables  Abbreviation yr, year decade century Velocity mph kph mps kps fps ips Acceleration ga Mass kg g, gram lbm slug lbfs2pin Density gpcc kgpm3 lbfs2pin4 lbmpin3 lbmpft3 slugpft3 Force N, newton  Description Year = 365.25 days 10 Years 100 Years [L/T] Miles per hour Kilometres per hour Metre per second Kilometre per second Foot per second Inch per second [L/T^2] Gravitational acceleration [M] Kilogram (base unit) Gram Pound (mass) Slug Lbf-sec^2/in [M/L^3] Gram / cm^3 Kilogram / m^3 Lbf-sec^2 / in^4 Lbm / in^3 Lbm / ft^3 Slug / ft^3 [ML/T^2] Newton = 1 kg-m/sec^2  54   Table 10: Defined Units Variables  Abbreviation dyne gf kgf lbf kip pdl, poundal ounce Energy J, joule ftlbf erg calorie Btu therm tonTNT kwh Power W, watt Hp Temperature degK, kelvin degC degF degR, rankine eV Pressure Pa, pascal  Description Dyne = newton/10,000 Gram (force) Kilogram (force) Pound (force) Kilopound (force) Poundal Ounce = lbf / 16 [ML^2/T^2] Joule = 1 newton-metre Foot-lbf Erg = 1e-7 joule International Table Calorie International Table Btu EEC therm Energy in 1 ton TNT Kilowatt hour [ML^2/T^3] Watt = 1 joule / second Elec. Horsepower (746 W) [t] Kelvin (Base Unit) Degree Celsius Degree Fahrenheit Degree Rankine Electron Volt [M/L/T^2] Pascal = 1 newton / metre^2  55   Table 10: Defined Units Variables  Abbreviation MPa GPa bar kbar Mbar atm torr mHg mmHg inHg inH2O ftH2O psi ksi psf Volume liter gal, gallon Angular rad rev deg, degree arcmin arcsec grade  Description Megapascal Gigapascal Bar Kilobar Megabar Standard atmosphere Torr = 1 mmHg Metre of mercury Millimetre of mercury Inch of mercury Inch of water Foot of water Pound per square inch Kilo-pound per square inch Pound per square foot [L^3] Metre^3 / 1000 Gallon (U.S.)  Radian (base unit) Full circle = 360 degree Degree Arc minute = 1/60 degree Arc second = 1/360 degree Grade = 0.9 degree  56   57   Distribution 1 1 1 1 1 13 50 1 1 1 1 1 15 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 15 13 1400 1401 1402 1403 1404 1425 1425 1431 1431 1431 1432 1433 1434 1500 1501 1502 1503 1504 1511 1511 1511 1511 1511 1511 1511 1511 1512 1513 1513 1513 1513 1513 1551 1552 1553 1554 1561 1562 E. J. Barsis J. R. Asay S. S. Dosanjh G. S. Davidson J. A. Ang J. H. Biffle & staff M. K. Smith J. M. McGlaun K. G. Budge J. S. Peery W. T. Brown J. W. Swegle D. R. Martinez & staff D. J. McCloskey C. W. Peterson P. J. Hommert L. W. Davison D. J. McCloskey, actg J. S. Rottler D. K. Gartling M. W. Glass P. L. Hopkins M. J. Martinez P. A. Sackinger P. R. Schunk J. D. Zepper A. C. Ratzel R. D. Skocypec R. G. Baca B. L. Bainbridge R. E. Hogan, Jr. J. L. Moya W. P. Wolfe C. E. Hailey W. L. Hermina W. H. Rutledge H. S. Morgan & staff R. K. Thomas & staff  10 1 1 1 1 1 1 1 5 1 10 1 6 1 1 1 5  1562 1832 2565 6313 6411 6423 6513 6522 7141 7151 7613-2 8523-2 8741 8742 8742 8742 8743  G. D. Sjaardema J. M. Ramage S. T. Montgomery J. Jung A. S. Benjamin J. F. Dempsey D. S. Oscar J. D. Miller Technical Library Technical Publications Document Processing for DOE/OSTI Central Technical Files G. A. Benedetti & staff M. R. Birnbaum J. J. Dike L. I. Weingarten M. L. Callabresi & staff  58"
GX171-49-3838048	"Migrating to ANSI/ISO C++          Introduction   Compiling RogueWave Libraries       Report Additional Issues     Support for Cfront Codes       Compiling old STL   KAI C++ Home     Language Differences   Compiling GNU C++ codes       KAI Home     Library Differences   Compiling old  KCC codes   Contact KAI++             Introduction -- Keeping Up with the Evolution of C++    When you first compile an existing code with  KAI C++  (KCC), you may be shocked at the number of error messages that it generates. In most cases, the problem is the rapid evolution of the C++ language and the fact that KAI C++ tracks this rapid evolution. In general, the designers of C++ have tried to accommodate backwards compatibility to older versions, but in some cases doing so was judged awkward or contradictory.    With KAI C++, sometimes it is sufficient to use the command-line switch  --cfront_3.0  to get the old Cfront behavior. Usually, however, you must make minor changes to your code to bring it up to date with important changes in the language. With a little practice it is possible to modify codes so that they compile under both the old and new rules.  In our experience, the changes take little time, and have the benefit of making the code suitable for more modern C++ compilers. The rest of this document summarize the most common compatibility problems and how to quickly fix them.    The scope of this document is limited to difficulties in migrating existing codes. New C++ language features that you might want to use in new codes are desribed  elsewhere . We also recommend that you look at the  ISO December 1996 Working Paper  when you encounter compilation difficulties, particularly when diagnosing library problems.     Report Additional Issues    If you encounter additional problems in porting your Cfront or GNU C++ code to ISO C++, or porting old STL codes, please  let us know  so we can add that problem to this list, allowing others to learn from your experience.     Support for Cfront and ISO Codes    KAI C++ Version 3.3  supports both the ISO Draft Standard rules and Cfront rules. For brevity, the former will be referred to as ``ISO rules'', though it should always be remembered that the current ISO document is still a draft and subject to some change.    By default, KAI C++ parses according to the ISO rules. The command-line switch  --cfront_3.0  forces Cfront 3.0 rules. The Cfront rules are essentially those of the Annotated Reference Manual (ARM), except that a few obscure Cfront bugs are duplicated.    The combined standard template library and its runtime support code that ships with KAI C++ is distinctly ISO, though with some extensions that support Cfront codes.     Dealing with Language Differences        Basic Approach      Overload resolution      New keywords            bool, false, true        explicit        typename          Implicit use of keyword typename     Scope of for loops      Binding references to temporaries      Lifetime of temporaries       Basic Approach    There are many features in ISO C++, beyond what is the ARM. Most of these new features, such as run-time type information (RTTI), are upward compatible with Cfront. This section concerns the few features that are not upward compatible.    KAI C++  tries hard to be permissive when it comes to language differences between ISO and Cfront. As long as there is no fundamental incompatibility, it tends to allow Cfront code, even in ISO mode. Such permissiveness can be turned off with the command-line switch  --strict .    Overload resolution    ISO and Cfront rules differ on resolution of overloaded functions. Cfront's rules for overload resolution allowed for some fine shades of overload resolution, at the expense of complicated rules. The simpler (and saner) ISO rules disallow some of these fine shades. The most common problem that users encounter is demonstrated by program  overload.C . When compiled by  KAI C++  (without the cfront_3.0 switch),  KAI C++  will object:               ""overload.C"", line 12: error: more than one operator ""[]"" matches these                   operands:                     built-in operator ""pointer-to-object[integer]""                     function ""Vec::operator[](unsigned int)""                     operand types are: Vec [ int ]              v[0] = 1;               ^    By the ISO rules,  KAI C++  finds two matches because there are two possible ""conversion sequences"", and each involves a different parameter. The two matches are described below with references to the relevant sections of the ISO Working Paper.        A: (13.3.3.1.2)    To parameter 0 (which is  v ), apply the user-defined   conversion: sequence  Vec --> int* . This conversion   allows built-in operator  pointer[integer]  to match.    B: (13.3.3.1.1)    To parameter 1 (which is  0 ), apply the standard   conversion sequence  int --> unsigned int . This conversion   allows function  Vec::operator[]  to match.     Under the ARM (Cfront) rules, match B wins since it involves only standard conversions. However, The ISO rules are different (13.3.3). For a match to win, it must have ""better"" conversion sequences for each parameter than the losing match. So we have:        For parameter 0, Match B is ""better"" than A since B requires   no conversion of parameter 0.    For parameter 1, Match A is ""better"" than B since A requires   no conversion.     Thus neither match is better than the other and there is an ambiguity.    So this leaves the question of how to change the code to make it acceptable to ISO C++ compilers. The probably intent was to have match B win. To do this, remove the need for the conversion ( int --> unsigned int ) by making the actual parameter  unsigned . E.g.:                  v[0u] = 1;    The overload problem is not specific to the operators in the example. However, there are so many Cfront codes that have problems only with operator[] that  KAI C++  comes with an option to deal with it while otherwise in ISO mode. The option  --special_subscript_cost  causes the overload resolution algorithm to give special weighting to operator[] and avoid the aforementioned problems. For example,             KCC --special_subscript_cost overload.C    will compile  overload.C .    New keywords    The ISO rules add some new keywords. Even in Cfront mode,  KAI C++  recognizes these keywords:         dynamic_cast        catch     const_cast        mutable           namespace               reinterpret_cast        static_cast        throw     try     typeid            using             wchar_t          This should not be a problem unless an old code uses one of these keywords as an identifier. These keywords are now recognized by a wide variety of C++ compilers, it is worth your time to change obsolescent uses of these as identifiers.    Keywords listed below are given special treatment, because they are very recent or their new usage would break common practice in old codes.        bool, false, true      These keywords are not recognized in Cfront mode, because many old   codes have  #define  or  typedef  for   these keywords, particularly for  false  and  true .   To enable the boolean type in Cfront mode, use the command-line switch    --bool .    explicit      The keyword  explicit  is not recognized in Cfront   mode. To enable it, use the option  --explicit .    typename      The keyword  typename  is not recognized in Cfront   mode. To enable it, use the option  --typename . See   also the discussion of  --no_implicit_typename     .     Implicit use of keyword typename    ISO recently introduced a keyword  typename . Its use is required inside templates for certain contexts by the ISO rules, as demonstrated by  typename.C . However, it is so recent that very few codes use it. Therefore, by default,  KAI C++  infers where the keyword  typename  should have been used. To turn off this inference, use the option:             --no_implicit_typename    The option  --strict  also turns off the inference. If you want strict ISO except for  typename , use the options  --strict --implicit_typename .    Scope of for loops    Consider the loop:             for( int i=0; i<n; i++ ) {             ...          }    The ISO rules limit the scope of  i  to the loop; the Cfront rules treat  i  as though it were declared just before the loop. The most common problem is that the new rules break code that use  i  outside the loop. For instance, a linear search that looks at  i  after the loop exits. The fix is simple: move the declaration and initialization to outside the loop.             int i=0;         for( ; i<n; i++ ) {             ...          }    You should move  both  the declaration and initialization. Below is an example of what could go wrong if just the declaration is moved.             T i;                      // Default constructor.         for( i=0; i<n; i++ ) {    // Assignment to i             ...         }    Now the default constructor  T::T()  and  T::operator=  are used for  i , instead of just the one-argument constructor that was used in the original loop.    The ISO rules can also change how a program behaves, though this is unlikely for real programs. Program  for-scope.C  demonstrates a contrived program whose behavior depends upon ISO versus Cfront rules.  KAI C++  warns about such a change in behavior change with a message such as shown below.             ""for-scope.C"", line 14: warning: reference is to variable ""i"" (declared at                   line 7) -- under old for-init scoping rules it would have been                   variable ""i"" (declared at line 11)               switch( i ) {                       ^    Binding references to temporaries    This is the most insidious difference between ISO and Cfront rules. The problem occurs when binding a reference to a pointer to a qualified type to an unqualified pointer. For example, the behavior of program  bind-ref.C  differs depending upon which rules are used.    One way to look for this problem is to use the following command-line switch:             --diag_warning=340    The switch causes  KAI C++  to report situations where it is generating a temporary for a reference.    The example used a reference for a formal parameter. The problem can also manifest itself with other forms of references, notably class members. In the case of a class member declared as a reference, the generated temporary will almost surely have too short a lifetime, and leave the reference dangling.    Lifetime of temporaries    C++ compilers can generate anonymous temporary objects. Cfront and ISO rules differ on when such objects are destroyed. Cfront let such objects live until the end of the enclosing block; ISO destroys such objects at the end of the containing ``full expression''. For instance, program  lifetime.C  behaves differently depending upon which rules are used.    We have not run into real codes for which lifetimes of temporaries is a problem. The reason is probably that programmers have long since steered clear of this problem, because the ARM gave implementations discretion on when temporaries could be destroyed. Thus implementations of C++ based on the ARM thus varied from giving temporaries long lifetimes (as with Cfront) to extremely short lifetimes (as with the original GNU C++). The ISO rules fall between the extremes, and so are unlikely to cause problems with codes that compiled under both Cfront and GNU C++.     Library Differences        Basic Approach     <foo> vs. <foo.h>      <complex.h>            Type complex is now parameterized        Pass by reference vs. value          <generic.h>      <iostream.h>            Forward declaration of ios, istream, and ostream            Method streambuf::sync replaced        Method streambuf::stossc replaced        No default constructor ostream() or     istream()        Classes iostream and fstream extinct        File mode ios::open_mode::out needs trunc or     append          <math.h> vs. <cmath>      Basic Approach    If you are using commercial libraries such as Rogue Wave's, try reinstalling the libraries with  KAI C++ . The installation process for many commercial libraries automatically figures out how good the  KAI C++  compiler and libraries are, and install the commercial library to match.    The C++ class library shipped with  KAI C++  is a modified form of the Modena C++ Standard Library. This library tracks the ISO Draft Standard. KAI's modifications enable older codes to run with fewer modifications.    <foo> vs. <foo.h>    The biggest change is that the ISO library puts most library identifiers in the namespace  std . To minimize transition difficulties, the include files for  KAI C++  adopt the convention that if header file  <foo>  defines a public symbol  bar , then the header file  <foo.h>  does the same, but exports  bar  to the global namespace too.    For example, the header file  <iostream>  defines the class  std::ostream.  Just having this header file would breaks Cfront codes in two ways:        A Cfront code expects the header file to be called  <iostream.h>     A Cfront code expects ostream to be in the global namespace.     To solve these problems  KAI C++  supplies another header file  <iostream.h> . This header file includes  <iostream> , and then exports  std::ostream  to the global namespace.    There is one exception to the rule. Because many codes expect that  <string.h>  is the header already defined by the ISO C standard, the .h file corresponding to C++ header file  <string>  is called  <bstring.h> , not  <string.h> . The name  <bstring.h>  was chosen to follow the convention of some other existing C++ implementations.    <complex.h>    If you use  <complex.h> , the only way to make your code compatible with the Cfront and ISO libraries is to make judicious use of  typedefs .    For example, we patched in the following for an old copy of a Rogue Wave library:                 #elif defined(__KCC)             #  include <complex.h>                typedef complex  DComplex;                typedef DComplex (*CmathFunTy)(DComplex&);                typedef double  (*CmathFunTy2)(DComplex&);    Of course, if you have a recent copy, reinstalling it with  KAI C++  should fix the problem.    Type complex is now a template    The Cfront  <complex.h>  defines a class  complex  for double-precision complex numbers. The  KAI C++  versions follows the ISO draft -- it defines a template  class complex<T> , where parameter type  T  can be float, double, or long double. To add to the confusion, the old GNU library called it class  Complex .    We advise using a typedef such as  DComplex  for complex numbers, and conditionally defining it:             #if defined(__KCC)         #include <complex.h>         typedef complex<double> DComplex;         #else         #include <complex.h>         typedef complex DComplex;         #endif    Pass by reference vs. value    The Cfront header  <complex.h>  has many functions that pass complex numbers by value. In contrast, the  KAI C++  version (and some others versions such as GNU) pass complex numbers by  const  reference. Normally, the difference is not noticeable. However, we ran across one code that took the address of member functions in  class complex . For instance, it tried to pass  &complex::sqrt  to another function. For the Cfront library, such an address has type:             complex complex::*( complex );    For the  KAI C++  library, such an address has type:             complex  complex ::*( const complex & );    The two pointer-to-member types are incompatible. The most reasonable way to save the code is to use  typedefs  for pointer-to-member. For example, we were able to revive an ancient Rogue Wave code by adding the following to the Rogue Wave  complex.h .             #if defined(__KCC)         #include <complex.h>         typedef DComplex (*CmathFunTy)(DComplex&);         typedef double  (*CmathFunTy2)(DComplex&);         #else         #include <complex.h>         #endif    Reinstalling the Rogue Wave library is probably simpler in most cases. The hacks above are only for old frozen libraries.    <generic.h>    KAI C++ Version 3.0 dropped support for  <generic.h> . This header file is fossil from the age before templates. You have to read Stroustrup's original description of C++ to even find out about it. If you really want a version of it for the current version of KAI C++, ask us, and you can make your own from  this version  from GNU C++.    <iostream.h>    There are numerous minor incompatibilities between Cfront's iostream and ISO's iostream. These may require minor repairs to make old codes comply with the ISO iostream.    Forward declaration of ios, istream, and ostream    In our experience, the biggest problem are codes that contain forward declarations of classes declared in  <iostream> , such as shown below.             class ios;         class istream;         class ostream;    If any of these forward declarations occur before  <iostream.h>  is included,  KAI C++  will report the following sort of error:             include/ostream.h: error: ""ostream"" has already been declared in the current scope         using std::ostream;                    ^    The reason is that  <ostream.h>  defines  std::ostream  and then exports ostream to the global namespace. But the earlier definition of ostream, is already there! There are two ways to fix the problem in existing code. The preferred work-around is to replace the forward declarations with:             #include <iosfwd.h>    This will do the necessary forward declarations. The pure ISO way would be to omit the  .h  and use  #include <iosfwd>  but that will not save old code because it retains the definitions inside the namespace  std:: . Including  <iosfwd.h>  has similar effect, except that the definitions are exported to the global namespace so that pre-namespace code works. One nice property of fixing the code this way is that you can make it run with old C++ compilers by creating your own header file  iosfwd.h  and putting it in the old compiler's search path for include files.     Method streambuf::sync replaced    The method  streambuf::sync  should be replaced with  streambuf::pubsync . In the ISO C++ library,  streambuf  is a  typedef  for the following template instantiation.             std::basic_streambuf<char, std::ios_traits<char> >::sync    Method streambuf::stossc replaced    Calls to the method  streambuf::stossc()  should be replaced by calls  streambuf::sbumpc() , with the result cast to  void . For instance, change  rdbuf->stossc  to  (void)rdbuf->sbumpc() .    No default constructor ostream() or istream()    The Cfront versions of  ostream  and  istream  have default constructors with protected access. The idiom was to use the default constructor, and then call method  init() . Below is an example of the old style for a class  foostream  derived from  ostream .             foostream::foostream( ostream& s ) :              ostream()         {             ios::init(s.rdbuf());         }    The ISO specification has no such constructor  ostream() . Instead, the  streambuf  should be passed to the constructor for  ostream . Below is an ISO version of the aforementioned example.             foostream::foostream( ostream& s ) :              ios( s.rdbuf() ),                ostream( s.rdbuf() )         {             ios::init(str.rdbuf());         }    Classes iostream and fstream extinct    The Cfront library defined classes  iostream  and  fstream , which could be used for both input and output. The corresponding ISO classes are the template classes  std::basic_iostream  and  std::basic_fstream . To ease transition,  KAI C++ 's header files  <iostream.h>  and  <fstream.h>  have (respectively) the two typedefs shown below.             typedef std::basic_iostream<char,std::ios_traits<char> > iostream;         typedef std::basic_fstream<char,std::ios_traits<char> > fstream;    The strict ISO header files  <iostream>  and  <fstream>  do not have these definitions.    File mode ios::open_mode::out needs trunc or append    The following was allowed by Cfront's library, but would seem to not be allowed by the April 1995 public copy of the ISO Draft.             ofstream f;         f.open( ""foo"", ios::open_mode::out );    The problem is that using ``out'' alone is ambiguous -- it does not indicate whether the file is to be truncated or appended. The library shipped with  KAI C++  allows the use of  ios::open_mode::out  and takes it to be the equivalent of  w  for the UNIX fopen, so as to yield the old Cfront behavior.    However, you may want to steer clear of the ambiguity by passing  ios::open_mode::trunc  as part of the flags as shown below.             ofstream f;         f.open( ""foo"", ios::open_mode::out|ios::open_mode::trunc );    <math.h> vs. <cmath>    Cfront had a include file <math.h> corresponding to the same in C.  KAI C++  supplies a similar  <math.h> , so codes using it should compile without difficulty.    However, you may eventually want to migrate to using the ISO header  <cmath> . Though the migration is fairly painless, you should be ready for the following surprise. The header  <cmath>  introduces overloaded prototypes for math functions such as  sqrt . These prototypes declare them for  float  and  long double , and are invaluable for writing templates that work for all precisions. However, these extra prototypes add ambiguity to formerly unambiguous calls. For example, in the code below:             #include <cmath>          double golden_ratio() {return (sqrt(5)+1)/2;}    the call  sqrt(5)  cannot be resolved because the  (int) 5  could be converted to a  float ,  double , or  long double . When switching from  <math.h>  to  <cmath> , you need to add casts to disambiguate such calls. For instance, the aforementioned example can be fixed by replacing the argument  5  with  5.  or  (double)5 .     Compiling GNU C++ codes.        Turning off implicit inclusion      Clamping Down on Excessive inlining      Linkage of template instances      Bitmask ios::open_mode::bin[ary]       Weaknesses in the G++ implementation of templates cause programmers using G++ to adopt a somewhat idiosyncratic style that may cause problems with  KAI C++ . There are also parts of the GCC library that may not match the current ISO Working paper. The list below of problems with compiling G++ codes with  KAI C++  is by no means exhaustive. We appreciate any  feedback  on this issue.    Turning off implicit inclusion    When compiling G++ codes, turn off the implicit inclusion feature with the command-line option  --no_implicit_include . The implicit inclusion feature, which is on by default, is for Cfront template codes and may confuse  KAI C++  when used with G++ codes. The symptom of such confusion is that  KAI C++  appears to be including header files twice.    Clamping Down on Excessive inlining    Problems with G++'s implementation of templates cause some programmers to resort to writing all member functions of template classes inside the template declaration for the class, as shown in  excessive-inline.C  . The ISO C++ rules treat all such member functions as implicitly declared  inline . At optimization level  +K1  and higher,  KAI C++  relentlessly carries out inlining even for very complicated functions. Unless there is a lot of unreachable code involved, the result will be monstrous code bloat.    Use the command-line switch  --inline_keyword_space_time=8  to clamp down on excessive inlining. The value of 8 is a good initial guess for most cases. If you want to tweak it, read Section 3.2.3 (Automatic Inlining) of the  KAI C++  User's Guide for the meaning of the switch.    Linkage of template instances    Some versions of GNU C++ give all template instances internal linkage, even for entities that should have external linkage. We previously advised using the KCC option  -tlocal , but this option has been discontinued because it cannot yield correct results with the KCC draft-standard library. Automatic template instantiation should give correct results unless the program relied on GNU C++'s erroneous template model.    Bitmask  ios::open_mode::bin[ary]    The GNU iostreams library defines a bitmask  ios::open_mode::bin , whereas the ISO specification names it  ios::open_mode::binary .          Compiling old STL codes.        Member overload confusion      Iterator type query functions      New arguments for template class stack         You might think that STL is new enough that no migration problems arise from using it. Alas, STL is evolving with the language.    Member overload confusion    The code fragment and error message in file  vector.C  demonstrate a subtle hassle of the current STL specification. The problem arises from the fact that the following two constructors for class  vector  look very similar to the compiler.             explicit vector (size_type n, const T& value = T ());          template<class InputIterator>           vector (InputIterator first, InputIterator last);    Notice that the latter constructor  matches exactly  any pair of arguments that are of the same type. If your intent is the first constructor, be very careful in typing the arguments, otherwise the second constructor may be a better match.    For example, the declaration  vector<int>(10,1)  does not mean ``a vector of 10 integers initialized to 1''. It means a vector initialized using  int  as an iterator, starting at 10 and ending at 1. Unfortunately, int does not have the properties required of an iterator, and the compilation fails in a somewhat cryptic way deep inside the template instantiations. Writing the  10  as  10u  fixes the problem, since it makes a better match (integral promotion rather than conversion) with the intended constructor.    Iterator type query functions    The old STL had global functions  iterator_category ,  distance_type , and  value_type  that enabled a circuitous style of finding out about types related to iterators. The draft-standard style uses a more  direct style based on the class  iterator_traits .     New arguments for template class stack    The template class stack now takes the element type, not the container type as its argument. See  here  for more details.       Compiling old KCC codes.   Here are issues for application programs being migrated from KCC 3.2 to KCC 3.3. In all cases KCC's new behavior either adheres more closely to the final draft standard, or offers improved efficiency, correctness, or flexibility.      Object files and libraries produced by KCC version 3.3 are  not link-compatible  with      those produced by KCC 3.2 or earlier.  Every component of an application must be recompiled.           Exceptions are now enabled by default.                  Implicit inclusion is now turned off by default.                 Keyword  template              is now required when referring to       member template  typename s.           Function  getline  in <string>             no longer counts characters.           Template class  valarray<T>               no longer has implicit conversions to       T*  and  const T* .   The option --split (used on 3.2 when building archive libraries) is       replaced by the option      -- one_instantiation_per_object       used to build .o files.          Adding or replacing files in an archive library  is now deimplemented.      `` KCC -o libX.a x1.o '' now  removes  libX.a and builds a      new one containing only x1.o.    KCC 3.3's runtime library is now supplied as both a shared object library and      as a traditional archive library.  Most linkers default to choosing the      shared object version, which can require extra care so that it travels       with the application when it is shipped to another host.         Copyright © 1995-1996 by Kuck & Associates, Inc. All rights reserved.   , KAI C++ and KAI are trademarks of Kuck & Associates, Inc."
GX069-10-2450888	"Go forward to  Answers to Exercises . Go backward to  Algebra Tutorial . Go up to  Tutorial .   Programming Tutorial ====================  The Calculator is written entirely in Emacs Lisp, a highly extensible language.  If you know Lisp, you can program the Calculator to do anything you like.  Rewrite rules also work as a powerful programming system.  But Lisp and rewrite rules take a while to master, and often all you want to do is define a new function or repeat a command a few times.  Calc has features that allow you to do these things easily.  (Note that the programming commands relating to user-defined keys are not yet supported under Lucid Emacs 19.)  One very limited form of programming is defining your own functions. Calc's `Z F' command allows you to define a function name and key sequence to correspond to any formula.  Programming commands use the shift-`Z' prefix; the user commands they create use the lower case `z' prefix.       1:  1 + x + x^2 / 2 + x^3 / 6         1:  1 + x + x^2 / 2 + x^3 / 6          .                                     .           ' 1 + x + x^2/2! + x^3/3! RET         Z F e myexp RET RET RET y  This polynomial is a Taylor series approximation to `exp(x)'.  The `Z F' command asks a number of questions.  The above answers say that the key sequence for our function should be `z e'; the `M-x' equivalent should be `calc-myexp'; the name of the function in algebraic formulas should also be `myexp'; the default argument list `(x)' is acceptable; and finally `y' answers the question ""leave it in symbolic form for non-constant arguments?""       1:  1.3495     2:  1.3495     3:  1.3495          .          1:  1.34986    2:  1.34986                         .          1:  myexp(a + 1)                                        .           .3 z e         .3 E           ' a+1 RET z e  First we call our new `exp' approximation with 0.3 as an argument, and compare it with the true `exp' function.  Then we note that, as requested, if we try to give `z e' an argument that isn't a plain number, it leaves the `myexp' function call in symbolic form.  If we had answered `n' to the final question, `myexp(a + 1)' would have evaluated by plugging in `a + 1' for `x' in the defining formula.  (*) *Exercise 1.*  The ""sine integral"" function `Si(x)' is defined as the integral of `sin(t)/t' for `t = 0' to `x' in radians.  (It was invented because this integral has no solution in terms of basic functions; if you give it to Calc's `a i' command, it will ponder it for a long time and then give up.)  We can use the numerical integration command, however, which in algebraic notation is written like `ninteg(f(t), t, 0, x)' with any integrand `f(t)'.  Define a `z s' command and `Si' function that implement this.  You will need to edit the default argument list a bit.  As a test, `Si(1)' should return 0.946083.  (Hint:  `ninteg' will run a lot faster if you reduce the precision to, say, six digits beforehand.) See  1: Programming Answer 1 . (*)  The simplest way to do real ""programming"" of Emacs is to define a ""keyboard macro"".  A keyboard macro is simply a sequence of keystrokes which Emacs has stored away and can play back on demand.  For example, if you find yourself typing `H a S x RET' often, you may wish to program a keyboard macro to type this for you.       1:  y = sqrt(x)          1:  x = y^2          .                        .           ' y=sqrt(x) RET       C-x ( H a S x RET C-x )       1:  y = cos(x)           1:  x = s1 arccos(y) + 2 pi n1          .                        .           ' y=cos(x) RET           X  When you type `C-x (', Emacs begins recording.  But it is also still ready to execute your keystrokes, so you're really ""training"" Emacs by walking it through the procedure once.  When you type `C-x )', the macro is recorded.  You can now type `X' to re-execute the same keystrokes.  You can give a name to your macro by typing `Z K'.       1:  .              1:  y = x^4         1:  x = s2 sqrt(s1 sqrt(y))                             .                   .         Z K x RET            ' y=x^4 RET         z x  Notice that we use shift-`Z' to define the command, and lower-case `z' to call it up.  Keyboard macros can call other macros.       1:  abs(x)        1:  x = s1 y                1:  2 / x    1:  x = 2 / y          .                 .                           .            .        ' abs(x) RET   C-x ( ' y RET a = z x C-x )    ' 2/x RET       X  (*) *Exercise 2.* Define a keyboard macro to negate the item in level 3 of the stack, without disturbing the rest of the stack.  See  2:   Programming Answer 2. (*)  (*) *Exercise 3.* Define keyboard macros to compute the following functions:    1. Compute `sin(x) / x', where `x' is the number on the top of the      stack.    2. Compute the base-`b' logarithm, just like the `B' key except the      arguments are taken in the opposite order.    3. Produce a vector of integers from 1 to the integer on the top of      the stack. See  3: Programming Answer 3 . (*)  (*) *Exercise 4.* Define a keyboard macro to compute the average (mean) value of a list of numbers.  See  4: Programming Answer 4 . (*)  In many programs, some of the steps must execute several times.  Calc has ""looping"" commands that allow this.  Loops are useful inside keyboard macros, but actually work at any time.       1:  x^6          2:  x^6        1: 360 x^2          .            1:  4             .                           .         ' x^6 RET          4         Z < a d x RET Z >  Here we have computed the fourth derivative of `x^6' by enclosing a derivative command in a ""repeat loop"" structure.  This structure pops a repeat count from the stack, then executes the body of the loop that many times.  If you make a mistake while entering the body of the loop, type `Z C-g' to cancel the loop command.  Here's another example:       3:  1               2:  10946      2:  1               1:  17711      1:  20                  .          .       1 RET RET 20       Z < TAB C-j + Z >  The numbers in levels 2 and 1 should be the 21st and 22nd Fibonacci numbers, respectively.  (To see what's going on, try a few repetitions of the loop body by hand; `C-j', also on the Line-Feed or LFD key if you have one, makes a copy of the number in level 2.)  A fascinating property of the Fibonacci numbers is that the `n'th Fibonacci number can be found directly by computing `phi^n / sqrt(5)' and then rounding to the nearest integer, where `phi', the ""golden ratio,"" is `(1 + sqrt(5)) / 2'.  (For convenience, this constant is available from the `phi' variable, or the `I H P' command.)       1:  1.61803         1:  24476.0000409    1:  10945.9999817    1:  10946          .                   .                    .                    .           I H P               21 ^                 5 Q /                R  (*) *Exercise 5.*  The ""continued fraction"" representation of `phi' is `1 + 1/(1 + 1/(1 + 1/( ... )))'. We can compute an approximate value by carrying this however far and then replacing the innermost `1/( ... )' by 1.  Approximate `phi' using a twenty-term continued fraction. See  5: Programming Answer 5 . (*)  (*) *Exercise 6.*  Linear recurrences like the one for Fibonacci numbers can be expressed in terms of matrices.  Given a vector `[a, b]' determine a matrix which, when multiplied by this vector, produces the vector `[b, c]', where `a', `b' and `c' are three successive Fibonacci numbers.  Now write a program that, given an integer `n', computes the `n'th Fibonacci number using matrix arithmetic. See  6: Programming Answer 6 . (*)  A more sophisticated kind of loop is the ""for"" loop.  Suppose we wish to compute the 20th ""harmonic"" number, which is equal to the sum of the reciprocals of the integers from 1 to 20.       3:  0               1:  3.597739      2:  1                   .      1:  20          .       0 RET 1 RET 20         Z ( & + 1 Z )  The ""for"" loop pops two numbers, the lower and upper limits, then repeats the body of the loop as an internal counter increases from the lower limit to the upper one.  Just before executing the loop body, it pushes the current loop counter.  When the loop body finishes, it pops the ""step,"" i.e., the amount by which to increment the loop counter. As you can see, our loop always uses a step of one.  This harmonic number function uses the stack to hold the running total as well as for the various loop housekeeping functions.  If you find this disorienting, you can sum in a variable instead:       1:  0         2:  1                  .            1:  3.597739          .         1:  20                                  .                        .           0 t 7       1 RET 20      Z ( & s + 7 1 Z )       r 7  The `s +' command adds the top-of-stack into the value in a variable (and removes that value from the stack).  It's worth noting that many jobs that call for a ""for"" loop can also be done more easily by Calc's high-level operations.  Two other ways to compute harmonic numbers are to use vector mapping and reduction (`v x 20', then `V M &', then `V R +'), or to use the summation command `a +'.  Both of these are probably easier than using loops.  However, there are some situations where loops really are the way to go:  (*) *Exercise 7.*  Use a ""for"" loop to find the first harmonic number which is greater than 4.0. See  7: Programming Answer 7 . (*)  Of course, if we're going to be using variables in our programs, we have to worry about the programs clobbering values that the caller was keeping in those same variables.  This is easy to fix, though:           .        1:  0.6667       1:  0.6667     3:  0.6667                       .                .          2:  3.597739                                                   1:  0.6667                                                       .          Z `    p 4 RET 2 RET 3 /   s 7 s s a RET    Z '  r 7 s r a RET  When we type `Z `' (that's a back-quote character), Calc saves its mode settings and the contents of the ten ""quick variables"" for later reference.  When we type `Z '' (that's an apostrophe now), Calc restores those saved values.  Thus the `p 4' and `s 7' commands have no effect outside this sequence.  Wrapping this around the body of a keyboard macro ensures that it doesn't interfere with what the user of the macro was doing.  Notice that the contents of the stack, and the values of named variables, survive past the `Z '' command.  The ""Bernoulli numbers"" are a sequence with the interesting property that all of the odd Bernoulli numbers are zero, and the even ones, while difficult to compute, can be roughly approximated by the formula `2 n! / (2 pi)^n'.  Let's write a keyboard macro to compute (approximate) Bernoulli numbers.  (Calc has a command, `k b', to compute exact Bernoulli numbers, but this command is very slow for large `n' since the higher Bernoulli numbers are very large fractions.)       1:  10               1:  0.0756823          .                    .           10     C-x ( RET 2 % Z [ DEL 0 Z : ' 2 $! / (2 pi)^$ RET = Z ] C-x )  You can read `Z [' as ""then,"" `Z :' as ""else,"" and `Z ]' as ""end-if.""  There is no need for an explicit ""if"" command.  For the purposes of `Z [', the condition is ""true"" if the value it pops from the stack is a nonzero number, or ""false"" if it pops zero or something that is not a number (like a formula). Here we take our integer argument modulo 2; this will be nonzero if we're asking for an odd Bernoulli number.  The actual tenth Bernoulli number is `5/66'.       3:  0.0756823    1:  0          1:  0.25305    1:  0          1:  1.16659      2:  5:66             .              .              .              .      1:  0.0757575          .       10 k b RET c f   M-0 DEL 11 X   DEL 12 X       DEL 13 X       DEL 14 X  Just to exercise loops a bit more, let's compute a table of even Bernoulli numbers.       3:  []             1:  [0.10132, 0.03079, 0.02340, 0.033197, ...]      2:  2                  .      1:  30          .        [ ] 2 RET 30          Z ( X | 2 Z )  The vertical-bar `|' is the vector-concatenation command.  When we execute it, the list we are building will be in stack level 2 (initially this is an empty list), and the next Bernoulli number will be in level 1.  The effect is to append the Bernoulli number onto the end of the list.  (To create a table of exact fractional Bernoulli numbers, just replace `X' with `k b' in the above sequence of keystrokes.)  With loops and conditionals, you can program essentially anything in Calc.  One other command that makes looping easier is `Z /', which takes a condition from the stack and breaks out of the enclosing loop if the condition is true (non-zero).  You can use this to make ""while"" and ""until"" style loops.  If you make a mistake when entering a keyboard macro, you can edit it using `Z E'.  First, you must attach it to a key with `Z K'.  One technique is to enter a throwaway dummy definition for the macro, then enter the real one in the edit command.       1:  3                   1:  3           Keyboard Macro Editor.          .                       .           Original keys: 1 RET 2 +                                               type ""1\r""                                              type ""2""                                              calc-plus       C-x ( 1 RET 2 + C-x )    Z K h RET      Z E h  This shows the screen display assuming you have the `macedit' keyboard macro editing package installed, which is usually the case since a copy of `macedit' comes bundled with Calc.  A keyboard macro is stored as a pure keystroke sequence.  The `macedit' package (invoked by `Z E') scans along the macro and tries to decode it back into human-readable steps.  If a key or keys are simply shorthand for some command with a `M-x' name, that name is shown.  Anything that doesn't correspond to a `M-x' command is written as a `type' command.  Let's edit in a new definition, for computing harmonic numbers. First, erase the three lines of the old definition.  Then, type in the new definition (or use Emacs `M-w' and `C-y' commands to copy it from this page of the Info file; you can skip typing the comments that begin with `#').       calc-kbd-push         # Save local values (Z `)      type ""0""              # Push a zero      calc-store-into       # Store it in variable 1      type ""1""      type ""1""              # Initial value for loop      calc-roll-down        # This is the TAB key; swap initial & final      calc-kbd-for          # Begin ""for"" loop...      calc-inv              #   Take reciprocal      calc-store-plus       #   Add to accumulator      type ""1""      type ""1""              #   Loop step is 1      calc-kbd-end-for      # End ""for"" loop      calc-recall           # Now recall final accumulated value      type ""1""      calc-kbd-pop          # Restore values (Z ')  Press `M-# M-#' to finish editing and return to the Calculator.       1:  20         1:  3.597739          .              .           20             z h  If you don't know how to write a particular command in `macedit' format, you can always write it as keystrokes in a `type' command. There is also a `keys' command which interprets the rest of the line as standard Emacs keystroke names.  In fact, `macedit' defines a handy `read-kbd-macro' command which reads the current region of the current buffer as a sequence of keystroke names, and defines that sequence on the `X' (and `C-x e') key.  Because this is so useful, Calc puts this command on the `M-# m' key.  Try reading in this macro in the following form: Press `C-@' (or `C-SPC') at one end of the text below, then type `M-# m' at the other.       Z ` 0 t 1          1 TAB          Z (  & s + 1  1 Z )          r 1      Z '  (*) *Exercise 8.* A general algorithm for solving equations numerically is ""Newton's Method"".  Given the equation `f(x) = 0' for any function `f', and an initial guess `x_0' which is reasonably close to the desired solution, apply this formula over and over:       new_x = x - f(x)/f'(x)  where `f'(x)' is the derivative of `f'.  The `x' values will quickly converge to a solution, i.e., eventually `new_x' and `x' will be equal to within the limits of the current precision.  Write a program which takes a formula involving the variable `x', and an initial guess `x_0', on the stack, and produces a value of `x' for which the formula is zero.  Use it to find a solution of `sin(cos(x)) = 0.5' near `x = 4.5'.  (Use angles measured in radians.)  Note that the built-in `a R' (`calc-find-root') command uses Newton's method when it is able.  See  8: Programming Answer 8 . (*)  (*) *Exercise 9.* The ""digamma"" function `psi(z)' is defined as the derivative of `ln(gamma(z))'.  For large values of `z', it can be approximated by the infinite sum       psi(z) ~= ln(z) - 1/2z - sum(bern(2 n) / 2 n z^(2 n), n, 1, inf)  where `sum' represents the sum over `n' from 1 to infinity (or to some limit high enough to give the desired accuracy), and the `bern' function produces (exact) Bernoulli numbers. While this sum is not guaranteed to converge, in practice it is safe. An interesting mathematical constant is Euler's gamma, which is equal to about 0.5772.  One way to compute it is by the formula, `gamma = -psi(1)'.  Unfortunately, 1 isn't a large enough argument for the above formula to work (5 is a much safer value for `z'). Fortunately, we can compute `psi(1)' from `psi(5)' using the recurrence `psi(z+1) = psi(z) + 1/z'.  Your task:  Develop a program to compute `psi(z)'; it should ""pump up"" `z' if necessary to be greater than 5, then use the above summation formula.  Use looping commands to compute the sum.  Use your function to compute `gamma' to twelve decimal places.  (Calc has a built-in command for Euler's constant, `I P', which you can use to check your answer.) See  9: Programming Answer 9 . (*)  (*) *Exercise 10.* Given a polynomial in `x' and a number `m' on the stack, where the polynomial is of degree `m' or less (i.e., does not have any terms higher than `x^m'), write a program to convert the polynomial into a list-of-coefficients notation.  For example, `5 x^4 + (x + 1)^2' with `m = 6' should produce the list `[1, 2, 1, 0, 5, 0, 0]'.  Also develop a way to convert from this form back to the standard algebraic form.  See  10: Programming Answer 10 . (*)  (*) *Exercise 11.* The ""Stirling numbers of the first kind"" are defined by the recurrences,       s(n,n) = 1   for n >= 0,      s(n,0) = 0   for n > 0,      s(n+1,m) = s(n,m-1) - n s(n,m)   for n >= m >= 1.  This can be implemented using a ""recursive"" program in Calc; the program must invoke itself in order to calculate the two righthand terms in the general formula.  Since it always invokes itself with ""simpler"" arguments, it's easy to see that it must eventually finish the computation.  Recursion is a little difficult with Emacs keyboard macros since the macro is executed before its definition is complete. So here's the recommended strategy:  Create a ""dummy macro"" and assign it to a key with, e.g., `Z K s'.  Now enter the true definition, using the `z s' command to call itself recursively, then assign it to the same key with `Z K s'.  Now the `z s' command will run the complete recursive program.  (Another way is to use `Z E' or `M-# m' (`read-kbd-macro') to read the whole macro at once, thus avoiding the ""training"" phase.)  The task:  Write a program that computes Stirling numbers of the first kind, given `n' and `m' on the stack.  Test it with *small* inputs like `s(4,2)'.  (There is a built-in command for Stirling numbers, `k s', which you can use to check your answers.) See  11: Programming Answer 11 . (*)  The programming commands we've seen in this part of the tutorial are low-level, general-purpose operations.  Often you will find that a higher-level function, such as vector mapping or rewrite rules, will do the job much more easily than a detailed, step-by-step program can:  (*) *Exercise 12.* Write another program for computing Stirling numbers of the first kind, this time using rewrite rules.  Once again, `n' and `m' should be taken from the stack.  See  12: Programming  Answer 12. (*)   This ends the tutorial section of the Calc manual.  Now you know enough about Calc to use it effectively for many kinds of calculations.  But Calc has many features that were not even touched upon in this tutorial.  The rest of this manual tells the whole story."
GX060-27-9194489	"Go forward to  Matrix Functions . Go backward to  Arithmetic . Go up to  Top .   Scientific Functions ********************  The functions described here perform trigonometric and other transcendental calculations.  They generally produce floating-point answers correct to the full current precision.  The `H' (Hyperbolic) and `I' (Inverse) flag keys must be used to get some of these functions from the keyboard.  One miscellanous command is shift-`P' (`calc-pi'), which pushes the value of `pi' (at the current precision) onto the stack.  With the Hyperbolic flag, it pushes the value `e', the base of natural logarithms.  With the Inverse flag, it pushes Euler's constant `gamma' (about 0.5772).  With both Inverse and Hyperbolic, it pushes the ""golden ratio"" `phi' (about 1.618).  (At present, Euler's constant is not available to unlimited precision; Calc knows only the first 100 digits.)  In Symbolic mode, these commands push the actual variables `pi', `e', `gamma', and `phi', respectively, instead of their values; See  Symbolic Mode .  The `Q' (`calc-sqrt') [`sqrt'] function is described elsewhere; See  Basic Arithmetic .  With the Inverse flag [`sqr'], this command computes the square of the argument.  See  Prefix Arguments , for a discussion of the effect of numeric prefix arguments on commands in this chapter which do not otherwise interpret a prefix argument.   Menu    Logarithmic Functions     Trigonometric and Hyperbolic Functions     Advanced Math Functions     Branch Cuts     Random Numbers     Combinatorial Functions     Probability Distribution Functions"
GX070-17-1512929	"[   source navigation   ]   [   identifier search   ]   [   freetext search   ]   [   file search   ]   [   repository   ]         Software     Cross Reference            . / usatlas / fisyak / root / postscript / src / TSVG.cxx             Version:      [   current   ]           File /home/lxr/source/current//usatlas/fisyak/root/postscript/src/TSVG.cxx     1   // @(#)root/postscript:$Name:  $:$Id: TSVG.cxx,v 1.1.1.5 2003/01/20 18:13:15 fisyak Exp $     2   // Author: Olivier Couet     3       4   /*************************************************************************     5    * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *     6    * All rights reserved.                                                  *     7    *                                                                       *     8    * For the licensing terms see $ROOTSYS/LICENSE.                         *     9    * For the list of contributors see $ROOTSYS/README/CREDITS.             *    10    *************************************************************************/    11     12   //////////////////////////////////////////////////////////////////////////    13   //                                                                      //    14   // TSVG                                                                 //    15   //                                                                      //    16   // Graphics interface to SVG.                                           //    17   //                                                                      //    18   //////////////////////////////////////////////////////////////////////////    19      20  #ifdef  WIN32    21  #pragma  optimize ( """" ,off)   22  #endif   23     24  #include  <stdlib.h>> >   25  #include  <string.h>> >   26  #include  <ctype.h>> >   27     28  #include "" Riostream.h ""   29  #include "" TROOT.h ""   30  #include "" TColor.h ""   31  #include "" TVirtualPad.h ""   32  #include "" TPoints.h ""   33  #include "" TSVG.h ""   34  #include "" TStyle.h ""   35  #include "" TMath.h ""   36     37   ClassImp ( TSVG )   38     39   //______________________________________________________________________________    40   //Begin_Html    41   /*    42   <a href="" http://www.w3.org/Graphics/SVG/Overview.htm8""><b>SVG</b></a>  is a    43   language for describing two-dimensional graphics in XML. <b>SVG</b> allows for    44   three types of graphic objects: vector graphic shapes, images and text.    45   Graphical objects can be grouped, styled, transformed and composed into    46   previously rendered objects. The feature set includes nested transformations,    47   clipping paths, alpha masks, filter effects and template objects. <b>SVG</b>    48   drawings can be interactive and dynamic. Animations can be defined and    49   triggered either declaratively or via scripting.    50   <p>    51   The way to access <b>SVG</b> in <b>ROOT</b> (in my private version only) is the    52   following:    53   <PRE>    54      <A HREF=""html/TSVG.html"">TSVG</A> mysvg(&quot;myfile.svg&quot;)    55      object-&gt;Draw();    56      mysvg.Close();    57   </PRE>    58   The result is the ASCII file <tt>myfile.svg</tt>, it is best viewed with    59   Internet Explorer and you need the    60   <a href="" http://www.adobe.com/svg/viewer/install/main.html"">Adobe  <b>SVG</b>    61   Viewer</a>. To zoom using the Adobe <b>SVG</b> Viewer, position the mouse over    62   the area you want to zoom and click the right button. To define the zoom area,    63   use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.    64   By clicking with the right mouse button on the <b>SVG</b> graphics you will get    65   a pop-up menu giving other ways to interact with the image.    66   <p>    67   <b>SVG</b> files can be used directly in compressed mode to minimize the time    68   transfer over the network. Compressed <b>SVG</b> files should be created using    69   <tt>gzip</tt> on a normal ASCII <b>SVG</b> file and should then be renamed    70   using the file extension <tt>.svgz</tt>.    71   */    72   //End_Html    73      74   //______________________________________________________________________________    75   TSVG :: TSVG () :  TVirtualPS ()   76  {   77      // Default SVG constructor    78      79     fStream = 0;   80     fType   = 0;   81      gVirtualPS  =  this ;   82  }   83     84   //______________________________________________________________________________    85   TSVG :: TSVG ( const   char  * fname ,  Int_t  wtype) :  TVirtualPS ( fname , wtype)   86  {   87      // Initialize the SVG interface    88       //    89       //  fname : SVG file name    90       //  wtype : SVG workstation type. Not used in the SVG driver. But as TSVG    91       //          inherits from TVirtualPS it should be kept. Anyway it is not    92       //          necessary to specify this parameter at creation time because it    93       //          has a default value (which is ignore in the SVG case).    94      95     fStream = 0;   96      Open ( fname , wtype);   97  }   98     99   //______________________________________________________________________________   100   void   TSVG :: Open ( const   char  * fname ,  Int_t  wtype)  101  {  102      // Open a SVG file   103     104      if  (fStream) {  105         Warning ( ""Open"" ,  ""SVG file already open"" );  106         return ;  107     }  108    109     fType =  abs (wtype);  110     SetLineScale( gStyle ->GetLineScalePS());  111      gStyle -> GetPaperSize (fXsize, fYsize);  112      Float_t  xrange, yrange;  113      if  ( gPad ) {  114         Double_t  ww =  gPad -> GetWw ();  115         Double_t  wh =  gPad -> GetWh ();  116        ww *=  gPad ->GetWNDC();  117        wh *=  gPad ->GetHNDC();  118         Double_t   ratio  = wh/ww;  119        xrange = fXsize;  120        yrange = fXsize* ratio ;  121         if  (yrange > fYsize) { yrange = fYsize; xrange = yrange/ ratio ;}  122        fXsize = xrange; fYsize = yrange;  123     }  124    125      // Open OS file   126      fStream   =  new   ofstream ( fname , ios :: out );  127      if  (fStream == 0) {  128         printf ( ""ERROR in TSVG::Open: Cannot open file:%s\n"" , fname );  129         return ;  130     }  131    132      gVirtualPS  =  this ;  133    134      for  ( Int_t  i=0;i<512;i++) fBuffer[i] =  ' ' ;  135    136     fBoundingBox =  kFALSE ;  137    138     fRange       =  kFALSE ;  139    140      // Set a default range   141       Range (fXsize, fYsize);  142    143      NewPage ();  144  }  145    146   //______________________________________________________________________________   147   TSVG :: ~TSVG ()  148  {  149      // Default SVG destructor   150     151      Close ();  152  }  153    154   //______________________________________________________________________________   155   void   TSVG :: Close ( Option_t  *)  156  {  157      // Close a SVG file   158       if  (! gVirtualPS )  return ;  159      if  (!fStream)  return ;  160      if  ( gPad )  gPad -> Update ();  161      PrintStr ( ""</svg>@"" );  162    163      // Close file stream   164       if  (fStream) { fStream-> close ();  delete  fStream; fStream = 0;}  165    166      gVirtualPS  = 0;  167  }  168    169   //______________________________________________________________________________   170   void   TSVG ::On()  171  {  172      // Activate an already open SVG file   173     174      // fType is used to know if the SVG file is open. Unlike TPostScript, TSVG   175       // has no ""workstation type"". In fact there is only one SVG type.   176     177      if  (!fType) {  178         Error ( ""On"" ,  ""no SVG file open"" );  179         Off ();  180         return ;  181     }  182      gVirtualPS  =  this ;  183  }  184    185   //______________________________________________________________________________   186   void   TSVG :: Off ()  187  {  188      // Deactivate an already open SVG file   189     190      gVirtualPS  = 0;  191  }  192    193   //______________________________________________________________________________   194   void   TSVG :: DrawBox ( Double_t  x1,  Double_t  y1,  Double_t  x2,  Double_t   y2)  195  {  196      // Draw a Box   197     198      static   Double_t  x[4], y[4];  199      Int_t   ix1  =  XtoSVG (x1);  200      Int_t   ix2  =  XtoSVG (x2);  201      Int_t   iy1  =  YtoSVG (y1);  202      Int_t   iy2  =  YtoSVG (y2);  203      Int_t  fillis = fFillStyle/1000;  204      Int_t  fillsi = fFillStyle%1000;  205    206      if  (fillis == 3 || fillis == 2) {  207         if  (fillsi > 99) {  208           x[0] = x1;   y[0] = y1;  209           x[1] = x2;   y[1] = y1;  210           x[2] = x2;   y[2] = y2;  211           x[3] = x1;   y[3] = y2;  212            return ;  213        }  214         if  (fillsi > 0 && fillsi < 26) {  215           x[0] = x1;   y[0] = y1;  216           x[1] = x2;   y[1] = y1;  217           x[2] = x2;   y[2] = y2;  218           x[3] = x1;   y[3] = y2;  219            DrawPS (-4, &x[0], &y[0]);  220        }  221         if  (fillsi == -3) {  222            PrintFast (9, ""<rect x=\"""" );  223            WriteInteger ( ix1 , 0);  224            PrintFast (5, ""\"" y=\"""" );  225            WriteInteger ( iy2 , 0);  226            PrintFast (9, ""\"" width=\"""" );  227            WriteInteger ( ix2 - ix1 , 0);  228            PrintFast (10, ""\"" height=\"""" );  229            WriteInteger ( iy1 - iy2 , 0);  230            PrintFast (7, ""\"" fill="" );  231            SetColor (5);  232            PrintFast (2, ""/>"" );  233        }  234     }  235      if  (fillis == 1) {  236         PrintFast (9, ""<rect x=\"""" );  237         WriteInteger ( ix1 , 0);  238         PrintFast (5, ""\"" y=\"""" );  239         WriteInteger ( iy2 , 0);  240         PrintFast (9, ""\"" width=\"""" );  241         WriteInteger ( ix2 - ix1 , 0);  242         PrintFast (10, ""\"" height=\"""" );  243         WriteInteger ( iy1 - iy2 , 0);  244         PrintFast (7, ""\"" fill="" );  245         SetColor (fFillColor);  246         PrintFast (2, ""/>"" );  247     }  248      if  (fillis == 0) {  249         PrintFast (9, ""<rect x=\"""" );  250         WriteInteger ( ix1 , 0);  251         PrintFast (5, ""\"" y=\"""" );  252         WriteInteger ( iy2 , 0);  253         PrintFast (9, ""\"" width=\"""" );  254         WriteInteger ( ix2 - ix1 , 0);  255         PrintFast (10, ""\"" height=\"""" );  256         WriteInteger ( iy1 - iy2 , 0);  257         PrintFast (21, ""\"" fill=\""none\"" stroke="" );  258         SetColor (fLineColor);  259         PrintFast (2, ""/>"" );  260     }  261  }  262    263   //______________________________________________________________________________   264   void   TSVG :: DrawFrame ( Double_t  xl,  Double_t  yl,  Double_t  xt,  Double_t   yt,  265                               Int_t   mode ,  Int_t   border ,  Int_t  dark,  Int_t  light)  266  {  267      // Draw a Frame around a box   268       //   269       // mode = -1  the box looks as it is behind the screen   270       // mode =  1  the box looks as it is in front of the screen   271       // border is the border size in already pre-computed SVG units dark is the   272       // color for the dark part of the frame light is the color for the light   273       // part of the frame   274     275      static   Int_t  xps[7], yps[7];  276      Int_t  i, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  277    278      //- Draw top&left part of the box   279     280     xps[0] =  XtoSVG (xl);          yps[0] =  YtoSVG (yl);  281     xps[1] = xps[0] +  border ;     yps[1] = yps[0] -  border ;  282     xps[2] = xps[1];              yps[2] =  YtoSVG (yt) +  border ;  283     xps[3] =  XtoSVG (xt) -  border ; yps[3] = yps[2];  284     xps[4] =  XtoSVG (xt);          yps[4] =  YtoSVG (yt);  285     xps[5] = xps[0];              yps[5] = yps[4];  286     xps[6] = xps[0];              yps[6] = yps[0];  287    288     ixd0 = xps[0];  289     iyd0 = yps[0];  290      PrintFast (10, ""<path d=\""M"" );  291      WriteInteger (ixd0, 0);  292      PrintFast (1, "","" );  293      WriteInteger (iyd0, 0);  294    295      idx  = 0;  296     idy = 0;  297      for  (i=1; i<7; i++) {  298        ixdi = xps[i];  299        iydi = yps[i];  300        ix   = ixdi - ixd0;  301        iy   = iydi - iyd0;  302        ixd0 = ixdi;  303        iyd0 = iydi;  304         if ( ix && iy) {  305            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  306            if ( idy ) {  MovePS (0,idy); idy = 0; }  307            MovePS (ix,iy);  308            continue ;  309        }  310         if  ( ix ) {  311            if ( idy )  {  MovePS (0,idy); idy = 0; }  312            if ( ! idx  ) {  idx  = ix;  continue ;}  313            if ( ix* idx  > 0 ) {  314               idx  += ix;  315           }  else  {  316               MovePS ( idx ,0);  317               idx   = ix;  318           }  319            continue ;  320        }  321         if ( iy ) {  322            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  323            if ( !idy) { idy = iy;  continue ;}  324            if ( iy*idy > 0 ) {  325              idy += iy;  326           }  else  {  327               MovePS (0,idy);  328              idy  = iy;  329           }  330        }  331     }  332      if (  idx  )  MovePS ( idx ,0);  333      if ( idy )  MovePS (0,idy);  334      PrintFast (8, ""z\"" fill="" );  335      if  ( mode  == -1) {  336         SetColor (dark);  337     }  else  {  338         SetColor (light);  339     }  340      PrintFast (2, ""/>"" );  341    342      //- Draw bottom&right part of the box   343      xps[0] =  XtoSVG (xl);          yps[0] =  YtoSVG (yl);  344     xps[1] = xps[0] +  border ;     yps[1] = yps[0] -  border ;  345     xps[2] =  XtoSVG (xt) -  border ; yps[2] = yps[1];  346     xps[3] = xps[2];              yps[3] =  YtoSVG (yt) +  border ;  347     xps[4] =  XtoSVG (xt);          yps[4] =  YtoSVG (yt);  348     xps[5] = xps[4];              yps[5] = yps[0];  349     xps[6] = xps[0];              yps[6] = yps[0];  350    351     ixd0 = xps[0];  352     iyd0 = yps[0];  353      PrintFast (10, ""<path d=\""M"" );  354      WriteInteger (ixd0, 0);  355      PrintFast (1, "","" );  356      WriteInteger (iyd0, 0);  357    358      idx  = 0;  359     idy = 0;  360      for  (i=1;i<7;i++) {  361        ixdi = xps[i];  362        iydi = yps[i];  363        ix   = ixdi - ixd0;  364        iy   = iydi - iyd0;  365        ixd0 = ixdi;  366        iyd0 = iydi;  367         if ( ix && iy) {  368            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  369            if ( idy ) {  MovePS (0,idy); idy = 0; }  370            MovePS (ix,iy);  371            continue ;  372        }  373         if  ( ix ) {  374            if ( idy )  {  MovePS (0,idy); idy = 0; }  375            if ( ! idx  ) {  idx  = ix;  continue ;}  376            if ( ix* idx  > 0 ) {  377               idx  += ix;  378           }  else  {  379               MovePS ( idx ,0);  380               idx   = ix;  381           }  382            continue ;  383        }  384         if ( iy ) {  385            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  386            if ( !idy) { idy = iy;  continue ;}  387            if ( iy*idy > 0 ) {  388              idy += iy;  389           }  else  {  390               MovePS (0,idy);  391              idy  = iy;  392           }  393        }  394     }  395      if (  idx  )  MovePS ( idx ,0);  396      if ( idy )  MovePS (0,idy);  397      PrintFast (8, ""z\"" fill="" );  398      if  ( mode  == -1) {  399         SetColor (light);  400     }  else  {  401         SetColor (dark);  402     }  403      PrintFast (2, ""/>"" );  404  }  405    406   //______________________________________________________________________________   407   void   TSVG :: DrawPolyLine ( Int_t  nn,  TPoints  *xy)  408  {  409      // Draw a PolyLine   410       //   411       //  Draw a polyline through  the points  xy.   412       //  If NN=1 moves only to point x,y.   413       //  If NN=0 the x,y are  written  in the SVG        file   414       //     according to the current transformation.   415       //  If NN>0 the line is clipped as a line.   416       //  If NN<0 the line is clipped as a fill area.   417     418      Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  419    420      if  (nn > 0) {  421        n = nn;  422   ///     SetLineStyle(fLineStyle);   423   ///     SetLineWidth(fLineWidth);   424   ///     SetColor(Int_t(fLineColor));   425      }  else  {  426        n = -nn;  427   ///     SetLineStyle(1);   428   ///     SetLineWidth(1);   429   ///     SetColor(Int_t(fLineColor));   430      }  431    432     ixd0 =  XtoSVG (xy[0]. GetX ());  433     iyd0 =  YtoSVG (xy[0]. GetY ());  434   ///  WriteInteger(ixd0);   435   ///  WriteInteger(iyd0);   436       if ( n <= 1) {  437         if ( n == 0)  return ;  438   ///     PrintFast(2,"" m"");   439          return ;  440     }  441    442      PrintFast (2, "" m"" );  443      idx  = 0;  444     idy = 0;  445      for  ( Int_t  i=1;i<n;i++) {  446        ixdi =  XtoSVG (xy[i]. GetX ());  447        iydi =  YtoSVG (xy[i]. GetY ());  448        ix   = ixdi - ixd0;  449        iy   = iydi - iyd0;  450        ixd0 = ixdi;  451        iyd0 = iydi;  452         if ( ix && iy) {  453            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  454            if ( idy ) {  MovePS (0,idy); idy = 0; }  455            MovePS (ix,iy);  456            continue ;  457        }  458         if  ( ix ) {  459            if ( idy )  {  MovePS (0,idy); idy = 0; }  460            if ( ! idx  ) {  idx  = ix;  continue ;}  461            if ( ix* idx  > 0 ) {  462               idx  += ix;  463           }  else  {  464               MovePS ( idx ,0);  465               idx   = ix;  466           }  467            continue ;  468        }  469         if ( iy ) {  470            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  471            if ( !idy) { idy = iy;  continue ;}  472            if ( iy*idy > 0 ) {  473              idy += iy;  474           }  else  {  475               MovePS (0,idy);  476              idy  = iy;  477           }  478        }  479     }  480      if (  idx  )  MovePS ( idx ,0);  481      if ( idy )  MovePS (0,idy);  482    483      if  (nn > 0 ) {  484   ///     if (xy[0].GetX() == xy[n-1].GetX() && xy[0].GetY() == xy[n-1].GetY()) PrintFast(3,"" cl"");   485   ///     PrintFast(2,"" s"");   486      }  else  {  487   ///     PrintFast(2,"" f"");   488      }  489  }  490    491   //______________________________________________________________________________   492   void   TSVG :: DrawPolyLineNDC ( Int_t  nn,  TPoints  *xy)  493  {  494      // Draw a PolyLine in NDC space   495       //   496       //  Draw a polyline through  the points  xy.   497       //  If NN=1 moves only to point x,y.   498       //  If NN=0 the x,y are  written  in the SVG        file   499       //     according to the current transformation.   500       //  If NN>0 the line is clipped as a line.   501       //  If NN<0 the line is clipped as a fill area.   502     503      Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy;  504    505      if  (nn > 0) {  506        n = nn;  507   ///     SetLineStyle(fLineStyle);   508   ///     SetLineWidth(fLineWidth);   509   ///     SetColor(Int_t(fLineColor));   510      }  else  {  511        n = -nn;  512   ///     SetLineStyle(1);   513   ///     SetLineWidth(1);   514   ///     SetColor(Int_t(fLineColor));   515      }  516    517     ixd0 =  UtoSVG (xy[0]. GetX ());  518     iyd0 =  VtoSVG (xy[0]. GetY ());  519   ///  WriteInteger(ixd0);   520   ///  WriteInteger(iyd0);   521       if ( n <= 1) {  522         if ( n == 0)  return ;  523   ///     PrintFast(2,"" m"");   524          return ;  525     }  526    527   ///  PrintFast(2,"" m"");   528       idx  = 0;  529     idy = 0;  530      for  ( Int_t  i=1;i<n;i++) {  531        ixdi =  UtoSVG (xy[i]. GetX ());  532        iydi =  VtoSVG (xy[i]. GetY ());  533        ix   = ixdi - ixd0;  534        iy   = iydi - iyd0;  535        ixd0 = ixdi;  536        iyd0 = iydi;  537         if ( ix && iy) {  538            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  539            if ( idy ) {  MovePS (0,idy); idy = 0; }  540            MovePS (ix,iy);  541            continue ;  542        }  543         if  ( ix ) {  544            if ( idy )  {  MovePS (0,idy); idy = 0; }  545            if ( ! idx  ) {  idx  = ix;  continue ;}  546            if ( ix* idx  > 0 ) {  547               idx  += ix;  548           }  else  {  549               MovePS ( idx ,0);  550               idx   = ix;  551           }  552            continue ;  553        }  554         if ( iy ) {  555            if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  556            if ( !idy) { idy = iy;  continue ;}  557            if ( iy*idy > 0 ) {  558              idy += iy;  559           }  else  {  560               MovePS (0,idy);  561              idy  = iy;  562           }  563        }  564     }  565      if (  idx  )  MovePS ( idx ,0);  566      if ( idy )  MovePS (0,idy);  567    568      if  (nn > 0 ) {  569         if  (xy[0]. GetX () == xy[n-1]. GetX () && xy[0]. GetY () == xy[n-1]. GetY ())  PrintFast (3, "" cl"" );  570   ///     PrintFast(2,"" s"");   571      }  else  {  572   ///     PrintFast(2,"" f"");   573      }  574  }  575    576   //______________________________________________________________________________   577   void   TSVG :: DrawPS ( Int_t  nn,  Double_t  *xw,  Double_t  *yw)  578  {  579      // This function defines a path with xw and yw and draw it according the   580       // value of nn:   581       //   582       //  If nn>0 a line is drawn.   583       //  If nn<0 a closed polygon is drawn.   584     585   ///   static Float_t dyhatch[24] = {.0075,.0075,.0075,.0075,.0075,.0075,.0075,.0075,   586   ///                                 .01  ,.01  ,.01  ,.01  ,.01  ,.01  ,.01  ,.01  ,   587   ///                                 .015 ,.015 ,.015 ,.015 ,.015 ,.015 ,.015 ,.015};   588   ///   static Float_t anglehatch[24] = {180, 90,135, 45,150, 30,120, 60,   589   ///                                    180, 90,135, 45,150, 30,120, 60,   590   ///                                    180, 90,135, 45,150, 30,120, 60};   591       Int_t   n, ixd0, iyd0,  idx , idy, ixdi, iydi, ix, iy, fais, fasi;  592     fais = fasi = 0;  593    594      if  (nn > 0) {  595        n = nn;  596     }  else  {  597        n = -nn;  598        fais = fFillStyle/1000;  599        fasi = fFillStyle%1000;  600         if  (fais == 3 || fais == 2) {  601            if  (fasi > 100 && fasi <125) {  602   ///        DrawHatch(dyhatch[fasi-101],anglehatch[fasi-101], n, xw, yw);   603                return ;  604           }  605            if  (fasi > 0 && fasi < 26) {  606   ///        SetFillPatterns(fasi, Int_t(fFillColor));   607            }  608        }  609     }  610    611       if ( n <= 1) {  612          Error ( ""DrawPS"" ,  ""Two points are needed"" );  613          return ;  614      }  615    616      ixd0 =  XtoSVG (xw[0]);  617      iyd0 =  YtoSVG (yw[0]);  618    619       PrintFast (10, ""<path d=\""M"" );  620       WriteInteger (ixd0, 0);  621       PrintFast (1, "","" );  622       WriteInteger (iyd0, 0);  623    624       idx  = idy = 0;  625       for  ( Int_t  i=1;i<n;i++) {  626         ixdi =  XtoSVG (xw[i]);  627         iydi =  YtoSVG (yw[i]);  628         ix   = ixdi - ixd0;  629         iy   = iydi - iyd0;  630         ixd0 = ixdi;  631         iyd0 = iydi;  632          if ( ix && iy) {  633             if (  idx  ) {  MovePS ( idx ,0);  idx  = 0; }  634             if ( idy ) {  MovePS (0,idy); idy = 0; }  635             MovePS (ix,iy);  636         }  else   if  ( ix ) {  637             if ( idy )  {  MovePS (0,idy); idy = 0;}  638             if ( ! idx  ) {  idx  = ix;}  639             else   if (  TMath :: Sign (ix, idx ) == ix )        idx  += ix;  640             else  {  MovePS ( idx ,0);   idx   = ix;}  641         }  else   if ( iy ) {  642             if (  idx  ) {  MovePS ( idx ,0);  idx  = 0;}  643             if ( !idy) { idy = iy;}  644             else   if (  TMath :: Sign (iy,idy) == iy)         idy += iy;  645             else  {  MovePS (0,idy);    idy  = iy;}  646         }  647      }  648       if  ( idx )  MovePS ( idx ,0);  649       if  (idy)  MovePS (0,idy);  650    651       if  (nn > 0 ) {  652          if  (xw[0] == xw[n-1] && yw[0] == yw[n-1])  PrintFast (1, ""z"" );  653          PrintFast (21, ""\"" fill=\""none\"" stroke="" );  654          SetColor (fLineColor);  655          if (fLineWidth > 1.) {  656             PrintFast (15, "" stroke-width=\"""" );  657             WriteInteger ( Int_t (fLineWidth), 0);  658             PrintFast (1, ""\"""" );  659         }  660          if  (fLineStyle == 2) {  661             PrintFast (23, "" stroke-dasharray=\""3,3\"""" );  662         }  else   if  (fLineStyle == 3) {  663             PrintFast (23, "" stroke-dasharray=\""1,4\"""" );  664         }  else   if  (fLineStyle == 4) {  665             PrintFast (27, "" stroke-dasharray=\""3,4,1,4\"""" );  666         }  667          PrintFast (2, ""/>"" );  668      }  else  {  669          PrintFast (8, ""z\"" fill="" );  670          if  (fais == 0) {  671             PrintFast (14, ""\""none\"" stroke="" );  672             SetColor (fFillColor);  673   ///      } else if (fais == 3 || fais == 2) {   674   ///        if (fasi > 0 && fasi < 26) {   675   ///           Put SVG patterns here   676          }  else  {  677             SetColor (fFillColor);  678         }  679          PrintFast (2, ""/>"" );  680      }  681  }  682    683   //______________________________________________________________________________   684   void   TSVG :: Initialize ()  685  {  686      // Initialize the SVG file. The main task of the function is to ouput the   687       // SVG header file which consist in <title>, <desc> and <defs>. The   688       // HeaderPS provided by the user program is written in the <defs> part.   689     690      // Title   691       PrintStr ( ""<title>@"" );  692      PrintStr ( GetName ());  693      PrintStr ( ""@"" );  694      PrintStr ( ""</title>@"" );  695    696      // Description   697       PrintStr ( ""<desc>@"" );  698      PrintFast (22, ""Creator: ROOT Version "" );  699      PrintStr ( gROOT ->GetVersion());  700      PrintStr ( ""@"" );  701      PrintFast (14, ""CreationDate: "" );  702      TDatime  t;  703      PrintStr (t. AsString ());  704      //Check a special header is defined in the current style   705       Int_t  nh =  strlen ( gStyle ->GetHeaderPS());  706      if  (nh) {  707         PrintFast (nh, gStyle ->GetHeaderPS());  708     }  709      PrintStr ( ""</desc>@"" );  710    711      // Definitions   712       PrintStr ( ""<defs>@"" );  713      PrintStr ( ""</defs>@"" );  714    715  }  716    717   //______________________________________________________________________________   718   void   TSVG :: MovePS ( Int_t  ix,  Int_t  iy)  719  {  720      // Move to a new position (ix, iy). The move is done in relative coordinates   721       // which allows to have short numbers which decrease the size of the file.   722       // This function use the full power of the SVG's paths by using the   723       // horizontal and vertical move whenever it is possible.   724     725      if  (ix != 0 && iy != 0)  {  726         PrintFast (1, ""l"" );  727         WriteInteger (ix, 0);  728         PrintFast (1, "","" );  729         WriteInteger (iy, 0);  730     }  else   if  (ix != 0)  {  731         PrintFast (1, ""h"" );  732         WriteInteger (ix, 0);  733     }  else   if  (iy != 0)  {  734         PrintFast (1, ""v"" );  735         WriteInteger (iy, 0);  736     }  737  }  738    739   //______________________________________________________________________________   740   void   TSVG :: NewPage ()  741  {  742      // Start the SVG page. This function initialize the pad conversion   743       // coefficients and ouput the <svg> directive which is close later in the   744       // the function Close.   745     746      // Compute pad conversion coefficients   747       if  ( gPad ) {  748         Double_t  ww   =  gPad -> GetWw ();  749         Double_t  wh   =  gPad -> GetWh ();  750        fYsize        = fXsize*wh/ww;  751     }  else  {  752        fYsize = 27;  753     }  754    755      // <svg> directive. It defines the viewBox.   756       if (!fBoundingBox) {  757         PrintStr ( ""@<svg viewBox=\""0 0"" );  758         WriteInteger (CMtoSVG(fXsize));  759        fYsizeSVG = CMtoSVG(fYsize);  760         WriteInteger (fYsizeSVG);  761         PrintStr ( ""\"" xmlns=\""http://www.w3.org/2000/svg\"">"" );  762         PrintStr ( ""@"" );  763         Initialize ();  764        fBoundingBox  =  kTRUE ;  765     }  766  }  767    768   //______________________________________________________________________________   769   void   TSVG :: Range ( Float_t   xsize ,  Float_t   ysize )  770  {  771      // Set the range for the paper in centimetres   772     773      Float_t  xps, yps, xncm, yncm, dxwn, dywn, xwkwn, ywkwn, xymax;  774    775     fXsize =  xsize ;  776     fYsize =  ysize ;  777    778     xps =  xsize ;  779     yps =  ysize ;  780    781      if (  xsize  <= xps &&  ysize  < yps) {  782         if  ( xps > yps ) xymax = xps;  783         else              xymax = yps;  784        xncm  =  xsize /xymax;  785        yncm  =  ysize /xymax;  786        dxwn  = ((xps/xymax)-xncm)/2;  787        dywn  = ((yps/xymax)-yncm)/2;  788     }  else  {  789         if  (xps/yps < 1) xwkwn = xps/yps;  790         else              xwkwn = 1;  791         if  (yps/xps < 1) ywkwn = yps/xps;  792         else              ywkwn = 1;  793    794         if  ( xsize  <  ysize )  {  795           xncm = ywkwn* xsize / ysize ;  796           yncm = ywkwn;  797           dxwn = (xwkwn-xncm)/2;  798           dywn = 0;  799            if ( dxwn < 0) {  800              xncm = xwkwn;  801              dxwn = 0;  802              yncm = xwkwn* ysize / xsize ;  803              dywn = (ywkwn-yncm)/2;  804           }  805        }  else  {  806           xncm = xwkwn;  807           yncm = xwkwn* ysize / xsize ;  808           dxwn = 0;  809           dywn = (ywkwn-yncm)/2;  810            if ( dywn < 0) {  811              yncm = ywkwn;  812              dywn = 0;  813              xncm = ywkwn* xsize / ysize ;  814              dxwn = (xwkwn-xncm)/2;  815           }  816        }  817     }  818     fRange =  kTRUE ;  819  }  820    821   //______________________________________________________________________________   822   void   TSVG :: SetFillColor (  Color_t   cindex  )  823  {  824      // Set color index for fill areas   825     826     fFillColor =  cindex ;  827      if  ( gStyle ->GetFillColor() <= 0)  cindex  = 0;  828  }  829    830   //______________________________________________________________________________   831   void   TSVG :: SetLineColor (  Color_t   cindex  )  832  {  833      // Set color index for lines   834     835     fLineColor =  cindex ;  836  }  837    838   //______________________________________________________________________________   839   void   TSVG :: SetLineStyle ( Style_t  linestyle)  840  {  841      // Change the line style   842       //   843       // linestyle = 2 dashed   844       //           = 3 dotted   845       //           = 4 dash-dotted   846       //           = else solid (1 in is used most of the time)   847     848     fLineStyle = linestyle;  849  }  850    851   //______________________________________________________________________________   852   void   TSVG :: SetLineWidth ( Width_t  linewidth)  853  {  854      // Set the lines width.   855     856     fLineWidth = linewidth;  857  }  858    859   //______________________________________________________________________________   860   void   TSVG :: SetMarkerColor (  Color_t   cindex  )  861  {  862      // Set color index for markers.   863     864     fMarkerColor =  cindex ;  865  }  866    867   //______________________________________________________________________________   868   void   TSVG :: SetColor ( Int_t   color )  869  {  870      // Set color with its color index   871     872      if  ( color  < 0)  color  = 0;  873      TColor  * col  =  gROOT -> GetColor ( color );  874      if  ( col ) {  875         SetColor ( col -> GetRed (),  col -> GetGreen (),  col -> GetBlue ());  876     }  else  {  877         SetColor (1., 1., 1.);  878     }  879  }  880    881   //______________________________________________________________________________   882   void   TSVG :: SetColor ( Float_t  r,  Float_t  g,  Float_t  b)  883  {  884      // Set color with its R G B components   885       //   886       //  r: % of red in [0,1]   887       //  g: % of green in [0,1]   888       //  b: % of blue in [0,1]   889     890      if  (r <= 0. && g <= 0. && b <= 0. ) {  891         PrintFast (7, ""\""black\"""" );  892     }  else   if  (r >= 1. && g >= 1. && b >= 1. ) {  893         PrintFast (7, ""\""white\"""" );  894     }  else  {  895         char   str [12];  896        sprintf( str , ""\""#%2.2x%2.2x%2.2x\"""" , Int_t (255.*r)  897                                          , Int_t (255.*g)  898                                          , Int_t (255.*b));  899         PrintStr ( str );  900     }  901  }  902    903   //______________________________________________________________________________   904   void   TSVG :: SetTextColor (  Color_t   cindex  )  905  {  906      // Set color index for text   907     908     fTextColor =  cindex ;  909  }  910    911   //______________________________________________________________________________   912   void   TSVG :: Text ( Double_t  xx,  Double_t  yy,  const   char  *chars)  913  {  914      // Draw text   915       //   916       // xx: x position of the text   917       // yy: y position of the text   918       // chars: text to be drawn   919     920      static   const   char  *fontFamily[] = {  921      ""Times"" ,  ""Times"" ,  ""Times"" ,  922      ""Helvetica"" ,  ""Helvetica"" ,  ""Helvetica"" ,  ""Helvetica"" ,  923      ""Courier"" ,  ""Courier"" ,  ""Courier"" ,  ""Courier"" ,  924      ""Symbol"" , ""Times"" ,  ""ZapfDingbats"" };  925    926      static   const   char  *fontWeight[] = {  927      ""normal"" ,  ""bold"" ,  ""bold"" ,  928      ""normal"" ,  ""normal"" ,  ""bold"" ,  ""bold"" ,  929      ""normal"" ,  ""normal"" ,  ""bold"" ,  ""bold"" ,  930      ""normal"" , ""normal"" ,  ""normal"" };  931    932      static   const   char  *fontStyle[] = {  933      ""italic"" ,  ""normal"" ,  ""italic"" ,  934      ""normal"" ,  ""oblique"" ,  ""normal"" ,  ""oblique"" ,  935      ""normal"" ,  ""oblique"" ,  ""normal"" ,  ""oblique"" ,  936      ""normal"" , ""normal"" ,  ""normal"" };  937    938      Int_t  ix    =  XtoSVG (xx);  939      Int_t  iy    =  YtoSVG (yy);  940      Int_t   txalh  = fTextAlign/10;  941      if  ( txalh  <1)  txalh  = 1;  if  ( txalh  > 3)  txalh  = 3;  942      Int_t   txalv  = fTextAlign%10;  943      if  ( txalv  <1)  txalv  = 1;  if  ( txalv  > 3)  txalv  = 3;  944    945      Double_t      wh = ( Double_t ) gPad -> XtoPixel ( gPad -> GetX2 ());  946      Double_t      hh = ( Double_t ) gPad -> YtoPixel ( gPad -> GetY1 ());  947      Float_t   fontrap  = 1.09;  //scale down compared to X11   948       Float_t   ftsize ;  949    950      Int_t   font   =  abs (fTextFont)/10;  951      Int_t  ifont =  font -1;  952      if  ( font  > 42 ||  font  < 1)  font  = 1;  953      if  (wh < hh) {  954         ftsize  = fTextSize*fXsize* gPad ->GetAbsWNDC();  955     }  else  {  956         ftsize  = fTextSize*fYsize* gPad ->GetAbsHNDC();  957     }  958    959      Int_t   fontsize  = CMtoSVG( ftsize / fontrap );  960      if (  fontsize  <= 0)  return ;  961    962      if  ( txalv  == 3) iy = iy+ fontsize ;  963      if  ( txalv  == 2) iy = iy+( fontsize /2);  964    965      if  (fTextAngle != 0.) {  966         PrintFast (21, ""<g transform=\""rotate("" );  967         WriteInteger (- Int_t (fTextAngle), 0);  968         PrintFast (1, "","" );  969         WriteInteger (ix, 0);  970         PrintFast (1, "","" );  971         WriteInteger (iy, 0);  972         PrintFast (3, "")\"">"" );  973     }  974    975      PrintFast (9, ""<text x=\"""" );  976      WriteInteger (ix, 0);  977      PrintFast (5, ""\"" y=\"""" );  978      WriteInteger (iy, 0);  979      PrintFast (1, ""\"""" );  980      if  ( txalh  == 2) {  981         PrintFast (21, "" text-anchor=\""middle\"""" );  982     }  else   if  ( txalh  == 3) {  983         PrintFast (18, "" text-anchor=\""end\"""" );  984     }  985      PrintFast (6, "" fill="" );  986      SetColor ( Int_t (fTextColor));  987      PrintFast (12, "" font-size=\"""" );  988      WriteInteger ( fontsize , 0);  989      PrintFast (15, ""\"" font-family=\"""" );  990      PrintStr (fontFamily[ifont]);  991      if  ( strcmp (fontWeight[ifont], ""normal"" )) {  992         PrintFast (15, ""\"" font-weight=\"""" );  993         PrintStr (fontWeight[ifont]);  994     }  995      if  ( strcmp (fontStyle[ifont], ""normal"" )) {  996         PrintFast (14, ""\"" font-style=\"""" );  997         PrintStr (fontStyle[ifont]);  998     }  999      PrintFast (2, ""\"">"" );  1000      if  ( font  == 12 && chars[0] >=  '\xA3'  && chars[0] <=  '\xF2' ) {  1001         char   str [8];  1002        sprintf( str , ""&#x%2.2x;"" , chars[0] & 255);  1003         PrintStr ( str );  1004     }  else  {  1005         PrintStr (chars);  1006     }  1007      PrintFast (7, ""</text>"" );  1008    1009      if  (fTextAngle != 0.)  PrintFast (4, ""</g>"" );  1010  }  1011    1012   //______________________________________________________________________________   1013   void   TSVG :: TextNDC ( Double_t  u,  Double_t  v,  const   char  *chars)  1014  {  1015      // Write a string of characters in NDC   1016     1017      Double_t  x =  gPad -> GetX1 () + u*( gPad -> GetX2 () -  gPad -> GetX1 ());  1018      Double_t  y =  gPad -> GetY1 () + v*( gPad -> GetY2 () -  gPad -> GetY1 ());  1019      Text (x, y, chars);  1020  }  1021    1022   //______________________________________________________________________________   1023   Int_t   TSVG :: UtoSVG ( Double_t  u)  1024  {  1025      // Convert U from NDC coordinate to SVG   1026     1027      Double_t  cm = fXsize*( gPad ->GetAbsXlowNDC() + u* gPad ->GetAbsWNDC());  1028      return   Int_t (0.5 + 72*cm/2.54);  1029  }  1030    1031   //______________________________________________________________________________   1032   Int_t   TSVG :: VtoSVG ( Double_t  v)  1033  {  1034      // Convert V from NDC coordinate to SVG   1035     1036      Double_t  cm = fYsize*( gPad ->GetAbsYlowNDC() + v* gPad ->GetAbsHNDC());  1037      return   Int_t (0.5 + 72*cm/2.54);  1038  }  1039    1040   //______________________________________________________________________________   1041   Int_t   TSVG :: XtoSVG ( Double_t  x)  1042  {  1043      // Convert X from world coordinate to SVG   1044     1045      Double_t  u = (x -  gPad -> GetX1 ())/( gPad -> GetX2 () -  gPad -> GetX1 ());  1046      return    UtoSVG (u);  1047  }  1048    1049   //______________________________________________________________________________   1050   Int_t   TSVG :: YtoSVG ( Double_t  y)  1051  {  1052      // Convert Y from world coordinate to SVG   1053     1054      Double_t  v = (y -  gPad -> GetY1 ())/( gPad -> GetY2 () -  gPad -> GetY1 ());  1055      return   fYsizeSVG- VtoSVG (v);  1056  }  1057    1058   //______________________________________________________________________________   1059   void   TSVG :: CellArrayBegin ( Int_t ,  Int_t ,  Double_t ,  Double_t ,  Double_t ,  1060                             Double_t )  1061  {  1062      Warning ( ""TSVG::CellArrayBegin"" ,  ""not yet implemented"" );  1063  }  1064    1065   //______________________________________________________________________________   1066   void   TSVG :: CellArrayFill ( Int_t ,  Int_t ,  Int_t )  1067  {  1068      Warning ( ""TSVG::CellArrayFill"" ,  ""not yet implemented"" );  1069  }  1070    1071   //______________________________________________________________________________   1072   void   TSVG :: CellArrayEnd ()  1073  {  1074      Warning ( ""TSVG::CellArrayEnd"" ,  ""not yet implemented"" );  1075  }  1076    1077   //______________________________________________________________________________   1078   void   TSVG :: DrawPolyMarker ( Int_t ,  Float_t  *,  Float_t  *)  1079  {  1080      Warning ( ""TSVG::DrawPolyMarker"" ,  ""not yet implemented"" );  1081  }  1082    1083   //______________________________________________________________________________   1084   void   TSVG :: DrawPolyMarker ( Int_t ,  Double_t  *,  Double_t  *)  1085  {  1086      Warning ( ""TSVG::DrawPolyMarker"" ,  ""not yet implemented"" );  1087  }  1088    1089   //______________________________________________________________________________   1090   void   TSVG :: DrawPS ( Int_t ,  Float_t  *,  Float_t  *)  1091  {  1092      Warning ( ""TSVG::DrawPS"" ,  ""not yet implemented"" );  1093  }  1094              [   source navigation   ]   [   identifier search   ]   [   freetext search   ]   [   file search   ]   [   repository   ]       This page was automatically generated by the   LXR engine . Visit the  LXR main site  for more information.   This version by  Torre Wenaus ."
GX029-94-0873623	"Migrating to ISO C++          Introduction   Compiling RogueWave Libraries       Report Additional Issues     Support for Cfront Codes       Compiling old STL   KAI C++ Home     Language Differences   Compiling GNU C++ codes       KAI Home     Library Differences   Compiling old  KCC codes   Contact KAI++             Introduction -- Keeping Up with the Evolution of C++    When you first compile an existing code with  KAI C++  (KCC), you may be shocked at the number of error messages that it generates. In most cases, the problem is the rapid evolution of the C++ language and the fact that KAI C++ tracks this rapid evolution. In general, the designers of C++ have tried to accommodate backwards compatibility to older versions, but in some cases doing so was judged awkward or contradictory.    With KAI C++, sometimes it is sufficient to use the command-line switch  --cfront_3.0  to get the old Cfront behavior. Usually, however, you must make minor changes to your code to bring it up to date with important changes in the language. With a little practice it is possible to modify codes so that they compile under both the old and new rules.  In our experience, the changes take little time, and have the benefit of making the code suitable for more modern C++ compilers. The rest of this document summarize the most common compatibility problems and how to quickly fix them.    The scope of this document is limited to difficulties in migrating existing codes. New C++ language features that you might want to use in new codes are desribed  elsewhere . We also recommend that you look at the   ISO C++ Standard   when you encounter compilation difficulties, particularly when diagnosing library problems.     Report Additional Issues    If you encounter additional problems in porting your Cfront or GNU C++ code to ISO C++, or porting old STL codes, please  let us know  so we can add that problem to this list, allowing others to learn from your experience.     Support for Cfront and ISO Codes    KAI C++ Version 3.3  supports both the ISO Draft Standard rules and Cfront rules. For brevity, the former will be referred to as ``ISO rules'', though it should always be remembered that the current ISO document is still a draft and subject to some change.    By default, KAI C++ parses according to the ISO rules. The command-line switch  --cfront_3.0  forces Cfront 3.0 rules. The Cfront rules are essentially those of the Annotated Reference Manual (ARM), except that a few obscure Cfront bugs are duplicated.    The combined standard template library and its runtime support code that ships with KAI C++ is distinctly ISO, though with some extensions that support Cfront codes.     Dealing with Language Differences        Basic Approach      Overload resolution      New keywords            bool, false, true        explicit        typename          Implicit use of keyword typename     Turning on implicit inclusion      Scope of for loops      Binding references to temporaries      Lifetime of temporaries       Basic Approach    There are many features in ISO C++, beyond what is the ARM. Most of these new features, such as run-time type information (RTTI), are upward compatible with Cfront. This section concerns the few features that are not upward compatible.    KAI C++  tries hard to be permissive when it comes to language differences between ISO and Cfront. As long as there is no fundamental incompatibility, it tends to allow Cfront code, even in ISO mode. Such permissiveness can be turned off with the command-line switch  --strict .    Overload resolution    ISO and Cfront rules differ on resolution of overloaded functions. Cfront's rules for overload resolution allowed for some fine shades of overload resolution, at the expense of complicated rules. The simpler (and saner) ISO rules disallow some of these fine shades. The most common problem that users encounter is demonstrated by program  overload.C . When compiled by  KAI C++  (without the cfront_3.0 switch),  KAI C++  will object:               ""overload.C"", line 12: error: more than one operator ""[]"" matches these                   operands:                     built-in operator ""pointer-to-object[integer]""                     function ""Vec::operator[](unsigned int)""                     operand types are: Vec [ int ]              v[0] = 1;               ^    By the ISO rules,  KAI C++  finds two matches because there are two possible ""conversion sequences"", and each involves a different parameter. The two matches are described below with references to the relevant sections of the ISO Working Paper.        A: (13.3.3.1.2)    To parameter 0 (which is  v ), apply the user-defined   conversion: sequence  Vec --> int* . This conversion   allows built-in operator  pointer[integer]  to match.    B: (13.3.3.1.1)    To parameter 1 (which is  0 ), apply the standard   conversion sequence  int --> unsigned int . This conversion   allows function  Vec::operator[]  to match.     Under the ARM (Cfront) rules, match B wins since it involves only standard conversions. However, The ISO rules are different (13.3.3). For a match to win, it must have ""better"" conversion sequences for each parameter than the losing match. So we have:        For parameter 0, Match B is ""better"" than A since B requires   no conversion of parameter 0.    For parameter 1, Match A is ""better"" than B since A requires   no conversion.     Thus neither match is better than the other and there is an ambiguity.    So this leaves the question of how to change the code to make it acceptable to ISO C++ compilers. The probably intent was to have match B win. To do this, remove the need for the conversion ( int --> unsigned int ) by making the actual parameter  unsigned . E.g.:                  v[0u] = 1;    The overload problem is not specific to the operators in the example. However, there are so many Cfront codes that have problems only with operator[] that  KAI C++  comes with an option to deal with it while otherwise in ISO mode. The option  --special_subscript_cost  causes the overload resolution algorithm to give special weighting to operator[] and avoid the aforementioned problems. For example,             KCC --special_subscript_cost overload.C    will compile  overload.C .    New keywords    The ISO rules add some new keywords. Even in Cfront mode,  KAI C++  recognizes these keywords:         dynamic_cast        catch     const_cast        mutable           namespace               reinterpret_cast        static_cast        throw     try     typeid            using             wchar_t          This should not be a problem unless an old code uses one of these keywords as an identifier. These keywords are now recognized by a wide variety of C++ compilers, it is worth your time to change obsolescent uses of these as identifiers.    Keywords listed below are given special treatment, because they are very recent or their new usage would break common practice in old codes.        bool, false, true      These keywords are not recognized in Cfront mode, because many old   codes have  #define  or  typedef  for   these keywords, particularly for  false  and  true .   To enable the boolean type in Cfront mode, use the command-line switch    --bool .    explicit      The keyword  explicit  is not recognized in Cfront   mode. To enable it, use the option  --explicit .    typename      The keyword  typename  is not recognized in Cfront   mode. To enable it, use the option  --typename . See   also the discussion of  --no_implicit_typename     .     Implicit use of keyword typename    ISO recently introduced a keyword  typename . Its use is required inside templates for certain contexts by the ISO rules, as demonstrated by  typename.C . However, it is so recent that very few codes use it. Therefore, by default,  KAI C++  infers where the keyword  typename  should have been used. To turn off this inference, use the option:             --no_implicit_typename    The option  --strict  also turns off the inference. If you want strict ISO except for  typename , use the options  --strict --implicit_typename .    Turning on implicit inclusion    When compiling Cfront codes that use template definitions not found in the  #include d header files, turn on the   implicit inclusion   feature with the command-line option  --implicit_include .  This non-standard feature complicates the production of accurate dependence information and  the diagnosis of template declaration errors, and so is  off  by default.     Scope of for loops    Consider the loop:             for( int i=0; i<n; i++ ) {             ...          }    The ISO rules limit the scope of  i  to the loop; the Cfront rules treat  i  as though it were declared just before the loop. The most common problem is that the new rules break code that use  i  outside the loop. For instance, a linear search that looks at  i  after the loop exits. The fix is simple: move the declaration and initialization to outside the loop.             int i=0;         for( ; i<n; i++ ) {             ...          }    You should move  both  the declaration and initialization. Below is an example of what could go wrong if just the declaration is moved.             T i;                      // Default constructor.         for( i=0; i<n; i++ ) {    // Assignment to i             ...         }    Now the default constructor  T::T()  and  T::operator=  are used for  i , instead of just the one-argument constructor that was used in the original loop.    The ISO rules can also change how a program behaves, though this is unlikely for real programs. Program  for-scope.C  demonstrates a contrived program whose behavior depends upon ISO versus Cfront rules.  KAI C++  warns about such a change in behavior change with a message such as shown below.             ""for-scope.C"", line 14: warning: reference is to variable ""i"" (declared at                   line 7) -- under old for-init scoping rules it would have been                   variable ""i"" (declared at line 11)               switch( i ) {                       ^    Binding references to temporaries    This is the most insidious difference between ISO and Cfront rules. The problem occurs when binding a reference to a pointer to a qualified type to an unqualified pointer. For example, the behavior of program  bind-ref.C  differs depending upon which rules are used.    One way to look for this problem is to use the following command-line switch:             --diag_warning=340    The switch causes  KAI C++  to report situations where it is generating a temporary for a reference.    The example used a reference for a formal parameter. The problem can also manifest itself with other forms of references, notably class members. In the case of a class member declared as a reference, the generated temporary will almost surely have too short a lifetime, and leave the reference dangling.    Lifetime of temporaries    C++ compilers can generate anonymous temporary objects. Cfront and ISO rules differ on when such objects are destroyed. Cfront let such objects live until the end of the enclosing block; ISO destroys such objects at the end of the containing ""full expression"".  For instance, program  lifetime.C   behaves differently depending upon which rules are used.    We have not run into real codes for which lifetimes of temporaries is a problem. The reason is probably that programmers have long since steered clear of this problem, because the ARM gave implementations discretion on when temporaries could be destroyed. Thus implementations of C++ based on the ARM thus varied from giving temporaries long lifetimes (as with Cfront) to extremely short lifetimes (as with the original GNU C++). The ISO rules fall between the extremes, and so are unlikely to cause problems with codes that compiled under both Cfront and GNU C++.     Library Differences        Basic Approach     <foo> vs. <foo.h>      <complex.h>            Type complex is now parameterized        Pass by reference vs. value          <generic.h>      <iostream.h>            Forward declaration of ios, istream, and ostream            Nonstandard features enabled by -DKAI_NONSTD_IOSTREAM        Method streambuf::sync replaced        Method streambuf::stossc replaced        No default constructor ostream() or     istream()        File mode ios::open_mode::out needs trunc or     append          <math.h> vs. <cmath>      Basic Approach    If you are using commercial libraries such as Rogue Wave's, try reinstalling the libraries with  KAI C++ . The installation process for many commercial libraries automatically figures out how good the  KAI C++  compiler and libraries are, and install the commercial library to match.    The C++ class library shipped with  KAI C++  is a modified form of the Modena C++ Standard Library. This library tracks the ISO Draft Standard. KAI's modifications enable older codes to run with fewer modifications.    <foo> vs. <foo.h>    The biggest change is that the ISO library puts most library identifiers in the namespace  std . To minimize transition difficulties, the include files for   KAI C++   adopt the convention that if header file  <foo>  defines a public symbol  bar , then the header file  <foo.h>  does the same, but exports  bar  to the global namespace too.    For example, the header file  <iostream>  defines the class  std::ostream.  Just having this header file would breaks Cfront codes in two ways:        A Cfront code expects the header file to be called  <iostream.h>     A Cfront code expects ostream to be in the global namespace.     To solve these problems  KAI C++  supplies another header file  <iostream.h> . This header file includes  <iostream> , and then exports  std::ostream  to the global namespace.    There is one exception to the rule. Because many codes expect that  <string.h>  is the header already defined by the ISO C standard, the .h file corresponding to C++ header file  <string>  is called  <bstring.h> , not  <string.h> . The name  <bstring.h>  was chosen to follow the convention of some other existing C++ implementations.    <complex.h>    If you use  <complex.h> , the only way to make your code compatible with the Cfront and ISO libraries is to make judicious use of  typedefs .    For example, we patched in the following for an old copy of a Rogue Wave library:                 #elif defined(__KCC)             #  include <complex.h>                typedef complex  DComplex;                typedef DComplex (*CmathFunTy)(DComplex&);                typedef double  (*CmathFunTy2)(DComplex&);    Of course, if you have a recent copy, reinstalling it with  KAI C++  should fix the problem.    Type complex is now a template    The Cfront  <complex.h>  defines a class  complex  for double-precision complex numbers. The  KAI C++  versions follows the ISO draft -- it defines a template  class complex<T> , where parameter type  T  can be float, double, or long double. To add to the confusion, the old GNU library called it class  Complex .    We advise using a typedef such as  DComplex  for complex numbers, and conditionally defining it:             #if defined(__KCC)         #include <complex.h>         typedef complex<double> DComplex;         #else         #include <complex.h>         typedef complex DComplex;         #endif    Pass by reference vs. value    The Cfront header  <complex.h>  has many functions that pass complex numbers by value. In contrast, the  KAI C++  version (and some others versions such as GNU) pass complex numbers by  const  reference. Normally, the difference is not noticeable. However, we ran across one code that took the address of member functions in  class complex . For instance, it tried to pass  &complex::sqrt  to another function. For the Cfront library, such an address has type:             complex complex::*( complex );    For the  KAI C++  library, such an address has type:             complex  complex ::*( const complex & );    The two pointer-to-member types are incompatible. The most reasonable way to save the code is to use  typedefs  for pointer-to-member. For example, we were able to revive an ancient Rogue Wave code by adding the following to the Rogue Wave  complex.h .             #if defined(__KCC)         #include <complex.h>         typedef DComplex (*CmathFunTy)(DComplex&);         typedef double  (*CmathFunTy2)(DComplex&);         #else         #include <complex.h>         #endif    Reinstalling the Rogue Wave library is probably simpler in most cases. The hacks above are only for old frozen libraries.    <generic.h>    KAI C++ Version 3.0 dropped support for  <generic.h> . This header file is fossil from the age before templates. You have to read Stroustrup's original description of C++ to even find out about it. If you really want a version of it for the current version of KAI C++, ask us, and you can make your own from  this version  from GNU C++.    <iostream.h>    There are numerous minor incompatibilities between Cfront's iostream and ISO's iostream. These may require minor repairs to make old codes comply with the ISO iostream.    Forward declaration of ios, istream, ostream, etc.    In our experience, the biggest problem are codes that contain forward declarations of classes declared in  <iostream> , such as shown below.             class ios;         class istream;         class ostream;  class iostream;    If any of these forward declarations occur before  <iostream.h>  is included,  KAI C++  will report the following sort of error:             include/ostream.h: error: ""ostream"" has already been declared in the current scope         using std::ostream;                    ^    The reason is that  <ostream.h>  defines  std::ostream  and then exports ostream to the global namespace. But the earlier definition of ostream, is already there!  Furthermore, the ISO definitions of these types are not classes, but  typedefs  to template instances. There are two ways to fix the problem in existing code.  The preferred work-around is to replace the forward declarations with:             #include <iosfwd.h>    This will do the necessary forward declarations. The pure ISO way would be to omit the  .h  and use  #include <iosfwd>  but that will not save old code because it retains the definitions inside the namespace  std:: . Including  <iosfwd.h>  has similar effect, except that the definitions are exported to the global namespace so that pre-namespace code works. One nice property of fixing the code this way is that you can make it run with old C++ compilers by creating your own header file  iosfwd.h  and putting it in the old compiler's search path for include files.     A similar problem exists for many other I/O classes such as fstream, streambuf, etc. In all cases, replacing old forward declarations with inclusion of  <iosfwd.h>  should solve the problem.   Nonstandard features enabled by -DKAI_NONSTD_IOSTREAM   Non-ISO features of the library are by default turned off. To turn them on, you must  define certain preprocessor symbols. There is a    table    of such symbols in the User Guide.  In partifular, some old Cfront codes may require features enabled by putting -DKAI_NONSTD_IOSTREAM on the KAI C++ command line.   Method streambuf::sync replaced    The method  streambuf::sync  should be replaced with  streambuf::pubsync . In the ISO C++ library,  streambuf  is a  typedef  for the following template instantiation.             std::basic_streambuf<char, std::ios_traits<char> >::sync    Method streambuf::stossc replaced    Calls to the method  streambuf::stossc()  should be replaced by calls  streambuf::sbumpc() , with the result cast to  void . For instance, change  rdbuf->stossc  to  (void)rdbuf->sbumpc() .    No default constructor ostream() or istream()    The Cfront versions of  ostream  and  istream  have default constructors with protected access. The idiom was to use the default constructor, and then call method  init() . Below is an example of the old style for a class  foostream  derived from  ostream .             foostream::foostream( ostream& s ) :              ostream()         {             ios::init(s.rdbuf());         }    The ISO specification has no such constructor  ostream() . Instead, the  streambuf  should be passed to the constructor for  ostream . Below is an ISO version of the aforementioned example.             foostream::foostream( ostream& s ) :              ios( s.rdbuf() ),                ostream( s.rdbuf() )         {             ios::init(str.rdbuf());         }     File mode ios::open_mode::out needs trunc or append    The following was allowed by Cfront's library, but would seem to not be allowed by the April 1995 public copy of the ISO Draft.             ofstream f;         f.open( ""foo"", ios::open_mode::out );    The problem is that using ``out'' alone is ambiguous -- it does not indicate whether the file is to be truncated or appended. The library shipped with  KAI C++  allows the use of  ios::open_mode::out  and takes it to be the equivalent of  w  for the UNIX fopen, so as to yield the old Cfront behavior.    However, you may want to steer clear of the ambiguity by passing  ios::open_mode::trunc  as part of the flags as shown below.             ofstream f;         f.open( ""foo"", ios::open_mode::out|ios::open_mode::trunc );    <math.h> vs. <cmath>    Cfront had a include file <math.h> corresponding to the same in C.  KAI C++  supplies a similar  <math.h> , so codes using it should compile without difficulty.    However, you may eventually want to migrate to using the ISO header  <cmath> . Though the migration is fairly painless, you should be ready for the following surprise. The header  <cmath>  introduces overloaded prototypes for math functions such as  sqrt . These prototypes declare them for  float  and  long double , and are invaluable for writing templates that work for all precisions. However, these extra prototypes add ambiguity to formerly unambiguous calls. For example, in the code below:             #include <cmath>          double golden_ratio() {return (sqrt(5)+1)/2;}    the call  sqrt(5)  cannot be resolved because the  (int) 5  could be converted to a  float ,  double , or  long double . When switching from  <math.h>  to  <cmath> , you need to add casts to disambiguate such calls. For instance, the aforementioned example can be fixed by replacing the argument  5  with  5.  or  (double)5 .     Compiling GNU C++ codes.        Clamping Down on Excessive inlining      Linkage of template instances      Bitmask ios::open_mode::bin[ary]       Weaknesses in the G++ implementation of templates cause programmers using G++ to adopt a somewhat idiosyncratic style that may cause problems with  KAI C++ . There are also parts of the GCC library that may not match the current ISO Working paper. The list below of problems with compiling G++ codes with  KAI C++  is by no means exhaustive. We appreciate any  feedback  on this issue.    Clamping Down on Excessive inlining    Problems with G++'s implementation of templates cause some programmers to resort to writing all member functions of template classes inside the template declaration for the class, as shown in  excessive-inline.C  . The ISO C++ rules treat all such member functions as implicitly declared  inline . At optimization level  +K1  and higher,  KAI C++  relentlessly carries out inlining even for very complicated functions. Unless there is a lot of unreachable code involved, the result will be monstrous code bloat.    Use the command-line switch  --inline_keyword_space_time=8  to clamp down on excessive inlining. The value of 8 is a good initial guess for most cases. If you want to tweak it, read Section 3.2.3 (Automatic Inlining) of the  KAI C++  User's Guide for the meaning of the switch.    Linkage of template instances    Some versions of GNU C++ give all template instances internal linkage, even for entities that should have external linkage. We previously advised using the KCC option  -tlocal , but this option has been discontinued because it cannot yield correct results with the KCC draft-standard library. Automatic template instantiation should give correct results unless the program relied on GNU C++'s erroneous template model.    Bitmask  ios::open_mode::bin[ary]    The GNU iostreams library defines a bitmask  ios::open_mode::bin , whereas the ISO specification names it  ios::open_mode::binary .          Compiling old STL codes.        Member overload confusion      Iterator type query functions      New arguments for template class stack         You might think that STL is new enough that no migration problems arise from using it. Alas, STL is evolving with the language.    Member overload confusion    The code fragment and error message in file  vector.C  demonstrate a subtle hassle of the current STL specification. The problem arises from the fact that the following two constructors for class  vector  look very similar to the compiler.             explicit vector (size_type n, const T& value = T ());          template<class InputIterator>           vector (InputIterator first, InputIterator last);    Notice that the latter constructor  matches exactly  any pair of arguments that are of the same type. If your intent is the first constructor, be very careful in typing the arguments, otherwise the second constructor may be a better match.    For example, the declaration  vector<int>(10,1)  does not mean ``a vector of 10 integers initialized to 1''. It means a vector initialized using  int  as an iterator, starting at 10 and ending at 1. Unfortunately, int does not have the properties required of an iterator, and the compilation fails in a somewhat cryptic way deep inside the template instantiations. Writing the  10  as  10u  fixes the problem, since it makes a better match (integral promotion rather than conversion) with the intended constructor.    Iterator type query functions    The old STL had global functions  iterator_category ,  distance_type , and  value_type  that enabled a circuitous style of finding out about types related to iterators. The draft-standard style uses a more  direct style based on the class  iterator_traits .     New arguments for template class stack    The template class stack now takes the element type, not the container type as its argument. See  here  for more details.       Compiling old KCC codes.   Here are issues for application programs being migrated from earlier versions of KCC. In all cases KCC's new behavior either adheres more closely to the final draft standard, or offers improved efficiency, correctness, or flexibility.    Migrating from KCC 3.2      Here are issues for application programs being migrated from KCC 3.2 to KCC 3.3.      Object files and libraries produced by KCC version 3.3 are  not       link-compatible  with those produced by KCC 3.2 or earlier.        Every component of an application must be recompiled.          Exceptions are now enabled by default .  Object files compiled with exceptions enabled      are  not link-compatible  with files or libraries produced by  KCC --no_exceptions .          Implicit inclusion is now turned off by default .  Some applications may now need  --implicit_include .          Keyword  template  is now required when referring to member template  typename s.           Function  getline  in <string>  no longer counts characters.           Template class  valarray<T>  no longer has implicit conversions       to  T*  and  const T* .   The option --split (used on 3.2 when building archive libraries) is       replaced by the option      -- one_instantiation_per_object       used to build .o files.          Appending or replacing files in an archive library  is now deimplemented.      `` KCC -o libX.a x1.o ''   removes  libX.a and builds a      new one containing only x1.o.    KCC 3.3's runtime library is now supplied as both a shared object library and      as a traditional archive library.  Most linkers default to choosing the      shared object version, which can require extra care so that it travels       with the application when it is shipped to another host.      Migrating from KCC 3.3    The big issues for migrating from KCC 3.3 to KCC 3.4 are the ISO rules for name lookup. If your code breaks, be sure that you understand the first two items listed below before reporting a bug to KAI.     Object files and libraries produced by KCC version 3.4 are  not       link-compatible  with those produced by KCC 3.3 or earlier.        Every component of an application must be recompiled.          A class's name is injected into the class's scope , causing some identifier to be be bound      to different entities than they were in KCC 3.3.                   Friend declarations no longer inject names into class scope.           Name lookup for unqualified functions names              considers namespaces of arguments.                  Literal strings are now (const char*).             This may change overload resolution.      It also breaks code that overwrites literal strings,       which is in extremely bad taste anyway.    The size argument to method  std::allocator<T>::deallocator        is now taken seriously.       Specifying an incorrect value may corrupt memory.    Assignment to  this  is no longer allowed, even in Cfront modes.       This fossil feature from Cfront 1.2 disappeared in Cfront 2.0,      and so is unlikely to affect codes outside museums.    Class  valarray  now conforms to the standard,       which makes it  much less useful .           Copyright © 1995-1999 by Kuck & Associates, Inc. All rights reserved.   ,  KAI C++ and KAI are trademarks of Kuck & Associates, Inc."
GX024-64-14515688	"Overview            Package            Class            Tree            Deprecated          Index            Help                          PREV   NEXT       FRAMES       NO FRAMES            All Classes              A   C   D   E   F   G   H   I   K   L   M   N   O   P   R   S   T   W   X       A     abs(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the absoulte value of a vector  absSr  -  Variable in class genopt.algorithm. HookeJeeves   The current magnitude of relative step reduction, compared to original step size  add(double[][], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   adds 2 matrices: C = A + B;    Note: C has the dimension of A; B must not have the same                dimension as A (non existing element are considered                as 0 and elements that are not in A but in B are not                taken into account by the summation)  add(double[], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   adds 2 vectors: z = y + x    Note: If the dimension dx of x is bigger than the dimension              dy of y, then only dx elements are added.  algorithm  -  Variable in class genopt.algorithm. Optimizer   The section ""Algorithm"" of the command file  appendToOutputListing(String)  -  Method in class genopt.algorithm. Optimizer   appends a String to the output listing files        C     cFactor  -  Variable in class genopt.algorithm. NelderMeadONeill   The step size factor for perturbation and reconstruction  checkMaxIteration()  -  Method in class genopt.algorithm. HookeJeeves   Checks if the maximum number of iteration is exceeded  checkMaxIteration()  -  Method in class genopt.algorithm. Optimizer   Checks if the maximum number of iteration is exceeded  checkObjectiveFunctionValue()  -  Method in class genopt.algorithm. HookeJeeves   Checks whether the last objective function value has already been  obtained previously.  checkObjectiveFunctionValue()  -  Method in class genopt.algorithm. Optimizer   Checks whether the last objective function value has already been  obtained previously.  checkObjFun  -  Variable in class genopt.algorithm. HookeJeeves   A flag whether the objective function value has to be checked for previous  matching results ( true ), or whether it has been obtained from  the database ( false )  clone()  -  Method in class genopt.algorithm.util.math. Point   Clones the object  com  -  Variable in class genopt.algorithm.util.math. Point   the point's comment  compare(Object, Object)  -  Method in class genopt.algorithm.util.math. Point   Compares two objects for equality, whereas only the x-coordinates  (in  float  format) and the step number are compared.  compareTo(Object)  -  Method in class genopt.algorithm.util.math. Point   Compares this object with the specified object for equality, whereas only the x-coordinates  (in  float  format) and the step number are compared.  conMode  -  Variable in class genopt.algorithm. Optimizer   flag for indicating how constraints are treated  coo  -  Variable in class genopt.algorithm.util.math. Point   the point's coordinates  copyRunFiles(String[], String[], String[])  -  Method in class genopt.algorithm. Optimizer   Copies the files from  path  to  savePath  and   adds the run number in front of the file name  COUEXPMAX  -  Static variable in class genopt.algorithm.util.optimality. Perturber   counter how many times an expansion can be done        D     data  -  Variable in class genopt.algorithm. Optimizer   The reference to the GenOpt kernel  deleteRunFiles(String[], String[])  -  Method in class genopt.algorithm. Optimizer   Deletes the run files specified by path and name.     dFMin  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The minimal difference between the lowest  3 function values that has to be obtained before the search stops  (only used if  stoCri=1   dim  -  Variable in class genopt.algorithm.util.optimality. Perturber   dimension of the independent variable  dimF  -  Variable in class genopt.algorithm. HookeJeeves   The number of function values  dimF  -  Variable in class genopt.algorithm. EquMesh   number of function values  dimF  -  Variable in class genopt.algorithm. Optimizer   The number of function values  dimF  -  Variable in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   The number of function values  dimF  -  Variable in class genopt.algorithm.util.math. Point   the dimension of the function value vector  dimX  -  Variable in class genopt.algorithm. HookeJeeves   The number of independent variables  dimX  -  Variable in class genopt.algorithm. EquMesh   number of independent variables  dimX  -  Variable in class genopt.algorithm. Optimizer   The number of independent variables  dimX  -  Variable in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   The number of independent variables  dimX  -  Variable in class genopt.algorithm.util.math. Point   the point's dimension  dimX  -  Variable in class genopt.algorithm. NelderMeadONeill   The dimension of the problem  dimXP1  -  Variable in class genopt.algorithm. NelderMeadONeill   The dimension of the problem plus 1  dx  -  Variable in class genopt.algorithm. EquMesh   width of steps for each dimension  dx  -  Variable in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   The maximal width of the interval ( dx=xEnd-x0 )        E     equals(Object)  -  Method in class genopt.algorithm.util.math. Point   Compares this object with the specified object for equality, whereas only the x-coordinates  (in  float  format) and the step number are compared.  EquMesh  - class genopt.algorithm. EquMesh . Class for doing parametric run where the free parameters are  the nodes of an equidistant grid. EquMesh(GenOpt)  -  Constructor for class genopt.algorithm. EquMesh   Constructor  evaluateSimulation(Point)  -  Method in class genopt.algorithm. Optimizer   Evaluates the simulation  writes a new input file  launches the simulation  checks for simulation errors  returns an array with the values of the objective function  evaPoi  -  Variable in class genopt.algorithm. HookeJeeves   list with evaluated points and its function values  explore()  -  Method in class genopt.algorithm. HookeJeeves   Makes exploration step around the base  rb    Note:  If return value is 0, then  rb  and                fp  are modified if and only if               a step has been successful, i.e., led to a reduction of               the function value        F     FAIEXPMOV  -  Static variable in class genopt.algorithm. HookeJeeves      fibo  -  Variable in class genopt.algorithm.util.linesearch. FibonacciDivision   The Fibonacci numbers  Fibonacci  - class genopt.algorithm. Fibonacci . Class for doing a  one-dimensional minimization  using  Fibonacci division. Fibonacci(GenOpt)  -  Constructor for class genopt.algorithm. Fibonacci   Constructor  FibonacciDivision  - class genopt.algorithm.util.linesearch. FibonacciDivision . Class for doing a line search along a given direction using  the the Fibonacci division.     FibonacciDivision(Optimizer)  -  Constructor for class genopt.algorithm.util.linesearch. FibonacciDivision   Constructor  fillDiagonal(double[][], double, double, double)  -  Static method in class genopt.algorithm.util.math. LinAlg   fills the diagonal matrix element and sets all other elements to zero.  FiniteIntervalSearcher  - class genopt.algorithm.util.linesearch. FiniteIntervalSearcher . Abstract Class for implementing a line search in a given, finite interval.   FiniteIntervalSearcher  - class genopt.algorithm. FiniteIntervalSearcher . Abstract class for doing a  one-dimensional minimization   in a finite interval. FiniteIntervalSearcher(GenOpt)  -  Constructor for class genopt.algorithm. FiniteIntervalSearcher   Constructor  FiniteIntervalSearcher(Optimizer)  -  Constructor for class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   Constructor  fLowBor  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The lower function value of the 2 border  ( x0  or  x3 ) that limit the interval  of uncertainity  fp  -  Variable in class genopt.algorithm. HookeJeeves   The function value at the previous base point  fr  -  Variable in class genopt.algorithm. HookeJeeves   The function value at the resulting base point  FS  -  Static variable in class genopt.algorithm. Optimizer   System dependent line separator  fun  -  Variable in class genopt.algorithm.util.math. Point   the point's function values  funValPoi  -  Variable in class genopt.algorithm. Optimizer   pointer that assign to each objective function value the number of the output file   in which it is        G     gaussElimination(double[][], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   solves a vector x by a Gauss elimination of a NxN matrix with  normalization and interchange of rows.  gaussEliminationTridiagonal(double[][], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   solves a vector x by a Gauss elimination of a tridiagonal NxN  matrix with normalization and interchange of rows.  genopt.algorithm  - package genopt.algorithm   genopt.algorithm.util.linesearch  - package genopt.algorithm.util.linesearch   genopt.algorithm.util.math  - package genopt.algorithm.util.math   genopt.algorithm.util.optimality  - package genopt.algorithm.util.optimality   getAbsAccuracyFunction()  -  Method in class genopt.algorithm. Optimizer   Gets the absolute accuracy of the last two main iterations  getBest()  -  Method in class genopt.algorithm. NelderMeadONeill   Gets the number of the best point  getCenter(double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   gets the center point of several points  getColumn(double[][], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   gets a column of a matrix  getComment()  -  Method in class genopt.algorithm.util.math. Point   Gets the point's comment  getDimensionF()  -  Method in class genopt.algorithm. Optimizer   Gets the number of function values  getDimensionX()  -  Method in class genopt.algorithm. Optimizer   Gets the number of independent variables  getDimF()  -  Method in class genopt.algorithm.util.math. Point   Gets the dimension of the points function value vector  getDimX()  -  Method in class genopt.algorithm.util.math. Point   Gets the dimension of the points coordinates  getDx(int)  -  Method in class genopt.algorithm. Optimizer   Gets the step size  dx[i]    Note:   dx[i]  might be in the transformed space  depending on the value of  constraints .  getF()  -  Method in class genopt.algorithm.util.math. Point   Gets the point's function values  getF(double[])  -  Method in class genopt.algorithm. HookeJeeves   Gets the objective function value and registers it into  the data base  getF(int)  -  Method in class genopt.algorithm.util.math. Point   Gets the point's function values  getF(Point)  -  Method in class genopt.algorithm. Optimizer   Evaluates the simulation based on the parameter set x   The value  constraints  determines in which mode the constraints  are treated  After this call, the parameters in the original  and  in the      transformed space are set to the values that correspond to  x   The step size in the transformed space is updated according      to the transformation function  A new input file is writen  the simulation is launched  simulation errors are checked  the value of the objective function is returned  getF(Point)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Evaluates the objective function, reports the results, and checks for  a null space of the objective function  getFibonacci(int)  -  Static method in class genopt.algorithm.util.linesearch. FibonacciDivision   Gets the Fibonacci numbers  getInputValueBoolean(String)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueDouble(String)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueInteger(String)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueString(String)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getKindOfConstraint(int)  -  Method in class genopt.algorithm. Optimizer   Gets the kind of constraint that is imposed on the i-th parameter  getL(int)  -  Method in class genopt.algorithm. Optimizer   Gets the lower bound  l[i]  of  x[i]   getMainIterationNumber()  -  Method in class genopt.algorithm. Optimizer   Gets the main iteration number  getMaxIterationNumber()  -  Method in class genopt.algorithm. Optimizer   Gets the maximum number of allowed main iterations  getMode()  -  Method in class genopt.algorithm. Optimizer   Gets the mode of the optimization  getOptimialPoint()  -  Method in class genopt.algorithm.util.optimality. Perturber   gets the point with the lowest function value  getReductionFactor()  -  Method in class genopt.algorithm.util.linesearch. FibonacciDivision   Gets the reduction factor q = I(n+1)/I(n)  getReductionFactor()  -  Method in class genopt.algorithm.util.linesearch. GoldenRatio   Gets the reduction factor q = I(n+1)/I(n)  getReductionFactor()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Gets the reduction factor q = I(n+1)/I(n)  getRelAccuracyFunction()  -  Method in class genopt.algorithm. Optimizer   Gets the relative accuracy of the last two main iterations  getSimulationNumber()  -  Method in class genopt.algorithm. Optimizer   Gets the number of simulation  getStepNumber()  -  Method in class genopt.algorithm. Optimizer   Gets the current step number  getStepNumber()  -  Method in class genopt.algorithm.util.math. Point   Gets the point's step number  getSub(double[], int, int)  -  Static method in class genopt.algorithm.util.math. LinAlg   gets a part of a vector  getU(int)  -  Method in class genopt.algorithm. Optimizer   Gets the upper bound  u[i]  of  x[i]   getVariableName(int)  -  Method in class genopt.algorithm. Optimizer   Gets the name of  x[i]   getWorst()  -  Method in class genopt.algorithm. NelderMeadONeill   Gets the number of the worst point  getX()  -  Method in class genopt.algorithm. Optimizer   Gets the values of  x    Note:   x  might be in the transformed space  depending on the value of  constraints   getX()  -  Method in class genopt.algorithm.util.math. Point   Gets the point's coordinates  getX(int)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  x[i]    Note:   x[i]  might be in the transformed space  depending on the value of  constraints   getX(int)  -  Method in class genopt.algorithm.util.math. Point   Gets the point's i-th coordinate  getXCenter(int)  -  Method in class genopt.algorithm. NelderMeadONeill   Gets the center point for the reflection  getXLower()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   gets the lower bound of the uncertainity interval  getXMin()  -  Method in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   Gets the point with the lowest function value  getXUpper()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   gets the upper bound of the uncertainity interval  GoldenRatio  - class genopt.algorithm.util.linesearch. GoldenRatio . Class for doing a line search along a given direction using  the Golden Section division.     GoldenRatio(Optimizer)  -  Constructor for class genopt.algorithm.util.linesearch. GoldenRatio   Constructor  GoldenSection  - class genopt.algorithm. GoldenSection . Class for doing a  one-dimensional minimization  using  the Golden Section algorithm. GoldenSection(GenOpt)  -  Constructor for class genopt.algorithm. GoldenSection   Constructor  goToEndOfCommandFile()  -  Method in class genopt.algorithm. Optimizer   Checks whether the current section is closed and then moves to  the end of the file.   gotOptimum()  -  Method in class genopt.algorithm.util.optimality. Perturber   checks whether we have an optimum point  gr  -  Static variable in class genopt.algorithm.util.linesearch. GoldenRatio   The Golden ratio (=0.618...)        H     HookeJeeves  - class genopt.algorithm. HookeJeeves . Class for minimizing a function using the Pattern Search algorithm  developed by Robert Hooke and T.  HookeJeeves(GenOpt)  -  Constructor for class genopt.algorithm. HookeJeeves   Constructor        I     id  -  Variable in class genopt.algorithm. FiniteIntervalSearcher   The IntervalDivider that performs the line search  increaseStepNumber()  -  Method in class genopt.algorithm. HookeJeeves   Increases the step number  increaseStepNumber()  -  Method in class genopt.algorithm. Optimizer   Increases the step number without a function evaluation.  increaseStepNumber(Point)  -  Method in class genopt.algorithm. Optimizer   Increases the step number.  initialize()  -  Method in class genopt.algorithm. FiniteIntervalSearcher   Initializes the IntervalDivider instance  initialize(double[][], double)  -  Static method in class genopt.algorithm.util.math. LinAlg   initializes a rectangular matrix  initialize(double[], double)  -  Static method in class genopt.algorithm.util.math. LinAlg   initializes a vector  innerProduct(double[], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the inner product (dot product):     c[i] = sum(a[i] * b[i] , i = 0..N-1)  IntervalDivider  - class genopt.algorithm.util.linesearch. IntervalDivider . Abstract class for doing a line search along a given direction using  an interval division method.     IntervalDivider(Optimizer)  -  Constructor for class genopt.algorithm.util.linesearch. IntervalDivider   Constructor  isDFltdFMin()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Checks whether the difference between the lower of either  f1   or  f2  and the lower of either  f0  or  f3   is smaller than the prescribed  dFMin   isFeasiblePoint(double[])  -  Method in class genopt.algorithm. HookeJeeves   Checks whether a point is feasible  isNextToken(String)  -  Method in class genopt.algorithm. Optimizer   Checks whether the next Token is equal to the passed String.  iterate()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Checks whether the iteration has to be continued.        K     konvge  -  Variable in class genopt.algorithm. NelderMeadONeill   A flag whether the convergence check is only allowed after 'konvge'   main iterations        L     LinAlg  - class genopt.algorithm.util.math. LinAlg . Class with functions for linear algebra.    LinAlg()  -  Constructor for class genopt.algorithm.util.math. LinAlg      LS  -  Static variable in class genopt.algorithm. Optimizer   System dependent line separator  LS  -  Static variable in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   System dependent line separator  LS  -  Static variable in class genopt.algorithm.util.optimality. Perturber   System dependent line separator        M     MAINITERATION  -  Static variable in class genopt.algorithm. Optimizer   constant to indicate that it is a main iteration  maxDiff(double[][], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the maximum magnitude of the difference between  corresponding matrix element, defined as  maxDiff = max(|A[i][j]-A[i][j]|) for all i,j  maxNorm(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the Lmax norm of a vector, defined as  Lmax(u) = (max(|u(i)|, i = 1..n)  maxNorm(double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates Lmax norm of a matrix   The max norm of a matrix is the maximum row  sum, where the row sum is the sum of the magnitudes of  the elements in a given row  modStoCri  -  Variable in class genopt.algorithm. NelderMeadONeill   A flag whether the stopping criterion has to be modified or not  multiply(double[][], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   multiplicates a matrix with a vector: r = A * u;    (Returns the product of the row vector x and the rectangular   array A)  multiply(double[][], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   multiplicates a matrix with a matrix: C = A * B;  multiply(double[], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   multiplicates a vector with a matrix: r = u^T * A;    (Returns the product of the row vector x and the rectangular   array A)  multiply(double, double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates S-multiplication : r = s * u;  multiply(double, double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates S-multiplication : B = s * A;        N     nameF  -  Variable in class genopt.algorithm. Optimizer   The name of the function values  NEGDIR  -  Static variable in class genopt.algorithm. HookeJeeves      NelderMeadONeill  - class genopt.algorithm. NelderMeadONeill . Class for minimizing a function using the Simplex strategy of Nelder and Mead  with an extension by O'Neill. NelderMeadONeill(GenOpt)  -  Constructor for class genopt.algorithm. NelderMeadONeill   Constructor  nIntRed  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The counter for number of interval reductions  nIntRedMax  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The maximum number of interval reductions  NINTREDMAXDEF  -  Static variable in class genopt.algorithm.util.linesearch. IntervalDivider   The default value for number of interval reductions  nMaxSteRed  -  Variable in class genopt.algorithm. HookeJeeves   The maximal number of step reduction before the algorithm terminates  NoConvergenceException  - exception genopt.algorithm.util.math. NoConvergenceException . Exception that is thrown when convergence is not achieved.     NoConvergenceException()  -  Constructor for class genopt.algorithm.util.math. NoConvergenceException   Constructs a NoConvergenceException with no detail message  NoConvergenceException(String)  -  Constructor for class genopt.algorithm.util.math. NoConvergenceException   Constructs a NoConvergenceException with the specified detail message  nS  -  Variable in class genopt.algorithm. EquMesh   number of required function evalations  nSimInpFil  -  Variable in class genopt.algorithm. Optimizer   The number of the simulation input files  nSimLogFil  -  Variable in class genopt.algorithm. Optimizer   The number of the simulation log files  nSimOutFil  -  Variable in class genopt.algorithm. Optimizer   The number of the simulation output files  nSteRed  -  Variable in class genopt.algorithm. HookeJeeves   The number of step reduction        O     o  -  Variable in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   The reference to the Optimizer object  o  -  Variable in class genopt.algorithm.util.optimality. Perturber   reference to Optimizer Object  objFunMap  -  Variable in class genopt.algorithm. Optimizer   The objective function delimiter  oneNorm(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates L1 norm of a vector, defined as  L1(u) = (sum(u(i), i = 1..n)  oneNorm(double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates L1 norm of a matrix   The one-norm of a matrix is the maximum column sum, where the column sum  is the sum of the magnitudes of the elements in a given column.  optComFilNam  -  Variable in class genopt.algorithm. Optimizer   The name of the optimization command file  optimalPoint  -  Variable in class genopt.algorithm.util.optimality. Perturber   flag:  true  if xC is the optimal point,  false  otherwise  Optimizer  - class genopt.algorithm. Optimizer . Abstract Class that represents the structure of an optimization algorithm class  and offers generic methods to run the optimization. Optimizer(GenOpt, int)  -  Constructor for class genopt.algorithm. Optimizer   Constructor  ORIGINAL  -  Static variable in class genopt.algorithm. Optimizer   constant for indicating that the optimization is in the original space  outerProduct(double[], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the outer product (Tensor product):         M[i][j] = a[i] * b[j]        P     PATMOV  -  Static variable in class genopt.algorithm. HookeJeeves      perturb(int)  -  Method in class genopt.algorithm. EquMesh   Perturbs the point and evaluates a simulation  perturb(Point, double)  -  Method in class genopt.algorithm.util.optimality. Perturber   checks the optimality condition in the transformed space  by testing in each orthogonal direction of  xL  whether   the function increases or not.  Perturber  - class genopt.algorithm.util.optimality. Perturber . Class for checking the optimality condition of a point. Perturber(Optimizer)  -  Constructor for class genopt.algorithm.util.optimality. Perturber   constructor for checking the optimality condition  Point  - class genopt.algorithm.util.math. Point . Abstract class for a point. Point(double[], double[], int, String)  -  Constructor for class genopt.algorithm.util.math. Point   Constructor  Point(int, int)  -  Constructor for class genopt.algorithm.util.math. Point   Constructor  POSDIR  -  Static variable in class genopt.algorithm. HookeJeeves      postProcessObjectiveFunction(int, double[])  -  Method in class genopt.algorithm. Optimizer   Post-process the objective function value.  print(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   prints a vector to the output stream  print(double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   prints a matrix to the output stream  print(double[], String)  -  Static method in class genopt.algorithm.util.math. LinAlg   reports a scalar and a vector to the output stream, where the  entries are separated by the given delimiter  print(double, double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   reports a scalar and a vector to the output stream  print(double, double[], String)  -  Static method in class genopt.algorithm.util.math. LinAlg   reports a scalar and a vector to the output stream, where the  entries are separated by the given delimiter  print(int[])  -  Static method in class genopt.algorithm.util.math. LinAlg   prints a vector to the output stream  print(String)  -  Method in class genopt.algorithm. Optimizer   Prints a message to the output device without finishing the line    Note:  Use this method instead of  System.out.printl(String) ,  otherwise it won't be reported in the GUI  println(String)  -  Method in class genopt.algorithm. Optimizer   Prints a message to the output device, and then finishs the line    Note:  Use this method instead of  System.out.println(String) ,  otherwise it won't be reported in the GUI        R     rank(double)  -  Method in class genopt.algorithm. NelderMeadONeill   Compares a trial with the other vertices  rb  -  Variable in class genopt.algorithm. HookeJeeves   The base point resulting from the current move  reflect(double[], double[])  -  Method in class genopt.algorithm. NelderMeadONeill   Reflects a point  report(Point, boolean)  -  Method in class genopt.algorithm. HookeJeeves   Reports the new trial  report(Point, boolean)  -  Method in class genopt.algorithm. Optimizer   Reports the new trial and updates the parameters  updates the original value  updates the transformed value  updates the transformed step size  reports the new trial  reports the objective function value  increases the number of the iteration   Note:  If a sub iteration is also a main iteration, then               you have to call this function twice, first with                MainIteration = false  and then with                MainIteration = true   reportCurrentLowestPoint()  -  Method in class genopt.algorithm. Optimizer   Reports the current lowest point for the case that GenOpt  has to terminate.  reportMinimum()  -  Method in class genopt.algorithm. Optimizer   Reports the minimum point.  restartCriterion()  -  Method in class genopt.algorithm. NelderMeadONeill   Determines whether a restart with a smaller simplex should be tried or not  retryEvaluateSimulation(Point, Throwable)  -  Method in class genopt.algorithm. Optimizer   Tries to evaluate the simulation a second time if an exception has been  thrown  run()  -  Method in class genopt.algorithm. HookeJeeves   Runs the optimization process until a termination criteria  is satisfied  run()  -  Method in class genopt.algorithm. EquMesh   Runs the evaluation  run()  -  Method in class genopt.algorithm. Optimizer   Abstract method for running the optimization algorithm      until a termination criteria is satisfied  run()  -  Method in class genopt.algorithm. FiniteIntervalSearcher   Runs the optimization process until a termination criteria  is satisfied  run()  -  Method in class genopt.algorithm. NelderMeadONeill   Runs the optimization process until a termination criteria  is satisfied  run(Point, Point)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Runs a line search in the interval from  xS  to   xE .  run(Point, Point)  -  Method in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   Runs a line search in the interval from  xS  to   xE .        S     separator  -  Variable in class genopt.algorithm. Optimizer   Separator that separate the objective function value from the values behind it.            set(double[], double[], int, String)  -  Method in class genopt.algorithm.util.math. Point   Sets a point  set(double[], int, String)  -  Method in class genopt.algorithm.util.math. Point   Sets a point  setAbsDFMin(double, int)  -  Method in class genopt.algorithm.util.linesearch. FibonacciDivision   Set the minimal absolut difference between the lowest  3 function values as the stopping criteria  setAbsDFMin(double, int)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Sets the minimal absolut difference between the lowest  function values as the stopping criteria  setColumn(double[][], double[], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   sets a column of a matrix    Note:  the dimension of x can be smaller than the column               length of A  setComment(String)  -  Method in class genopt.algorithm.util.math. Point   Sets a comment  setF(double[])  -  Method in class genopt.algorithm.util.math. Point   Sets a point's function value  setInfo(String)  -  Method in class genopt.algorithm. Optimizer   Sets a message in the InformationManager  The message will be displayed in the output stream  (GUI in WinGenOpt, command shell otherwise) and in  the log file  setMaxIntRed(int)  -  Method in class genopt.algorithm.util.linesearch. FibonacciDivision   Sets the maximum number of interval reductions  setMaxIntRed(int)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Sets the maximum number of interval reductions  setMode(int)  -  Method in class genopt.algorithm. Optimizer   Sets the mode of the optimization  setNumberOfMatchingResults(int)  -  Method in class genopt.algorithm. Optimizer   Sets the maximal allowed number of matching results  setRow(double[][], double[], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   sets a row of a matrix    Note:  the dimension of x can be smaller than the row               length of A  setStepNumber(int)  -  Method in class genopt.algorithm.util.math. Point   Sets a the step number  setUncertainityInterval(double)  -  Method in class genopt.algorithm.util.linesearch. FibonacciDivision   Sets the fraction of the desired uncertainity interval (0..1)  setUncertainityInterval(double)  -  Method in class genopt.algorithm.util.linesearch. GoldenRatio   Sets the fraction of the desired uncertainity interval (0..1)  setUncertainityInterval(double)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Sets the fraction of the desired uncertainity interval (0..1)  setWarning(String)  -  Method in class genopt.algorithm. Optimizer   Sets a message in the WarningManager.    setX(double[])  -  Method in class genopt.algorithm.util.math. Point   Sets the point's coordinates  setX(int, double)  -  Method in class genopt.algorithm. Optimizer   Sets the value of  x[i] .  setX(int, double)  -  Method in class genopt.algorithm.util.math. Point   Sets the i-th element of the point's coordinates  simInpTemFilHan  -  Variable in class genopt.algorithm. Optimizer   The simulation input template file handler  simLogFil  -  Variable in class genopt.algorithm. Optimizer   The simulation log file names (incl. path)  simOutFil  -  Variable in class genopt.algorithm. Optimizer   The simulation output file names (incl. path)  sqEps  -  Variable in class genopt.algorithm. NelderMeadONeill   The required accuracy of the variance (eps*eps)  sr  -  Variable in class genopt.algorithm. HookeJeeves   The current relative step reduction, compared to original step size,  including its sign.  steNum  -  Variable in class genopt.algorithm.util.math. Point   the point's step number  step  -  Variable in class genopt.algorithm. EquMesh   number of steps  stepNumber  -  Variable in class genopt.algorithm. Optimizer   The step number (for implementing variation of the weighting factors              for penalty function, barrier function and/or slackness variables  steRed  -  Variable in class genopt.algorithm. HookeJeeves   The relative step reduction for each reduction  stoCri  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The stopping criteria        0: number of interval reduction        1: maximum difference of the best 3 function values  SUBITERATION  -  Static variable in class genopt.algorithm. Optimizer   constant to indicate that it is a sub iteration  subtract(double[][], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   subtracts 2 matrices: C = A - B;    Note: C has the dimension of A; B must not have the same                dimension as A (non existing element are considered                as 0 and elements that are not in A but in B are not                taken into account by the summation)  subtract(double[], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   subtracts 2 vectors: z = y - x;    Note:  If the dimension dx of x is bigger than the dimension               dy of y, then only dx elements are subtracted.  SUCEXPMOV  -  Static variable in class genopt.algorithm. HookeJeeves      sumColumn(double[][], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   returns the sum of the elements in the i-th column  sumRow(double[][], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   returns the sum of the elements in the i-th row        T     throwInputError(String)  -  Method in class genopt.algorithm. Optimizer   Throws an input error.   TRANSFORMED  -  Static variable in class genopt.algorithm. Optimizer   constant for indicating that the optimization is in the transformed space  twoNorm(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the L2 norm of a vector, defined as  L2(u) = (sum(u(i)**2, i = 1..n) ^ 0.5  twoNorm(double[], double)  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the L2 norm with a scaling factor of a vector,  defined as L2(u) = (sum(h * u(i)**2, i = 1..n) ^ 0.5        W     wriSteNum  -  Variable in class genopt.algorithm. Optimizer   A flag to indicate whether the step number has to be written in the simulation              input file (and hence a simulation done)  writeStepNumber()  -  Method in class genopt.algorithm. Optimizer   Returns the flag that indicates whether the step number  has to written to the simulation input file or not.        X     x  -  Variable in class genopt.algorithm. EquMesh   free parameter  x  -  Variable in class genopt.algorithm. NelderMeadONeill   A point  x0  -  Variable in class genopt.algorithm. EquMesh   lower bound  x0  -  Variable in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   The lowest value on abscissa (start of interval)  x1  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The 2nd lowest value on abscissa  x2  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The 3rd lowest value on abscissa  x3  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The highest value on abscissa  xC  -  Variable in class genopt.algorithm.util.optimality. Perturber   point to be checked  xL  -  Variable in class genopt.algorithm.util.optimality. Perturber   lowest point in the neighborhood of xC  xLow  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The lower border of the uncertainity interval after stop of algorithm  xMin  -  Variable in class genopt.algorithm.util.linesearch. FiniteIntervalSearcher   The point with the lowest obtained function value  xUpp  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The upper border of the uncertainity interval after stop of algorithm      A   C   D   E   F   G   H   I   K   L   M   N   O   P   R   S   T   W   X                             Overview            Package            Class            Tree            Deprecated          Index            Help                          PREV   NEXT       FRAMES       NO FRAMES            All Classes                      GenOpt  |  LBL SRG  |  LBL      Copyright © 2000 The Regents of the University of California. All rights reserved.  For problems or questions regarding this page contact  MWetter@lbl.gov"
GX019-73-14197270	Overview            Package            Class            Tree            Deprecated          Index            Help                          PREV   NEXT       FRAMES       NO FRAMES            All Classes              A   B   C   D   E   F   G   H   I   K   L   M   N   O   P   R   S   T   U   V   W   X   _       A     abs(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the absoulte value of a vector  absSr  -  Variable in class genopt.algorithm. HookeJeeves   The current magnitude of relative step reduction, compared to original step size  activateSmoothing()  -  Method in class genopt.algorithm. Optimizer   Activate smoothing of cost function  add(double[][], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   adds 2 matrices: C = A + B;    Note: C has the dimension of A; B must not have the same                dimension as A (non existing element are considered                as 0 and elements that are not in A but in B are not                taken into account by the summation)  add(double[], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   adds 2 vectors: z = y + x    Note: If the dimension dx of x is bigger than the dimension              dy of y, then only dx elements are added.  add(double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Adds two numbers.    add(double, double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Adds three numbers.    add(double, double, double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Adds four numbers.    add(double, double, double, double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Adds five numbers.    add(double, double, double, double, double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Adds six numbers.    add(Point[], Point[])  -  Method in class genopt.algorithm.util.gps. ModelGPS      algorithm  -  Static variable in class genopt.algorithm. Optimizer   The section  Algorithm  of the command file  algorithmRequiresUsageOfStepNumber()  -  Method in class genopt.algorithm. Optimizer   A call to this method sets  useSteNum = true .     Alp  -  Variable in class genopt.algorithm.util.linesearch. Armijo   Algorithm parameter  Alp  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Algorithm parameter  ANewCot  -  Variable in class genopt.algorithm. Optimizer.Smoothing   Coefficients for the Newton-Cotes integration formula  appendToOutputListing(String)  -  Method in class genopt.algorithm. Optimizer   appends a String to the output listing files  areEqual(double, double)  -  Static method in class genopt.algorithm.util.math. Point   Compares two numbers for equality.   Armijo  - class genopt.algorithm.util.linesearch. Armijo . Class for doing a line search along a given direction using  the Armijo algorithm with reset option for the step-size.     Armijo(Optimizer, int, int, int, double, double)  -  Constructor for class genopt.algorithm.util.linesearch. Armijo   Constructor  arrLis  -  Variable in class genopt.algorithm.util.math. FunctionEvaluator   List with Elements that resulted from function parsing.        B     basDirMat  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The base direction matrix.  Bet  -  Variable in class genopt.algorithm.util.linesearch. Armijo   Algorithm parameter  Bet  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Algorithm parameter  Binary  - class genopt.algorithm.util.math. Binary . Mathematical functions for binary numbers. Binary()  -  Constructor for class genopt.algorithm.util.math. Binary   Empty constructor.     binaryToLong(char[])  -  Static method in class genopt.algorithm.util.math. Binary   Converts a binary  char  array to   the long number it presents.  binaryToLong(int[])  -  Static method in class genopt.algorithm.util.math. Binary   Converts a binary  int  array to   the long number it presents.  binaryToString(int[])  -  Static method in class genopt.algorithm.util.math. Binary   Returns a  String  representation of the argument  that contains  0  or  1 .  binaryToString(int[], int)  -  Static method in class genopt.algorithm.util.math. Binary   Returns a  String  representation of the argument  that contains  0  or  1 .  BIT_SIZE  -  Static variable in class genopt.algorithm.util.math. Binary   The number of bits used to present binary numbers        C     cFactor  -  Variable in class genopt.algorithm. NelderMeadONeill   The step size factor for perturbation and reconstruction  checkMaxIteration()  -  Method in class genopt.algorithm. HookeJeeves   Checks if the maximum number of iteration is exceeded  checkMaxIteration()  -  Method in class genopt.algorithm. Optimizer   Checks if the maximum number of iteration is exceeded  checkObjectiveFunctionValue()  -  Method in class genopt.algorithm. HookeJeeves   Checks whether the last objective function value has already been  obtained previously.  checkObjectiveFunctionValue()  -  Method in class genopt.algorithm. Optimizer   Checks whether the last objective function value has already been  obtained previously.  checkObjectiveFunctionValue()  -  Method in class genopt.algorithm.util.gps. ModelGPS   Checks whether the last cost function value has already been  obtained previously.  checkObjFun  -  Variable in class genopt.algorithm. HookeJeeves   A flag whether the objective function value has to be checked for previous  matching results.  checkObjFun  -  Variable in class genopt.algorithm.util.gps. ModelGPS   A flag whether the cost function value has to be checked for previous  matching results.  clampVelocity(double, double)  -  Static method in class genopt.algorithm.util.pso. ModelPSO   Clamps the velocity  clone()  -  Method in class genopt.algorithm.util.math. Point   Clones the object.  clone()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator.Element   Clones the instance.  CogAcc  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Acceleration constant for cognitive component  com  -  Variable in class genopt.algorithm.util.math. Point   the point's comment  compare(Object, Object)  -  Method in class genopt.algorithm.util.math. Point   Compares two objects for equality,  whereas only the x-coordinates in ( float  precision),  the index of the discrete variables,  and the step number are compared.  compareTo(Object)  -  Method in class genopt.algorithm.util.math. Point   Compares this object with the specified object for equality,   whereas only the x-coordinates in ( float  precision),  the index of the discrete variables,  and the step number are compared.  ConFac  -  Variable in class genopt.algorithm. PSOCC   Constriction Factor  conMode  -  Variable in class genopt.algorithm. Optimizer   flag for indicating how constraints are treated  constructIntegrator()  -  Method in class genopt.algorithm. Optimizer   Calls the constructor for the double integration.     cooCon  -  Variable in class genopt.algorithm.util.math. Point   the point's continuous coordinates  cooDis  -  Variable in class genopt.algorithm.util.math. Point   the point's discrete coordinates  cooDisBitLength  -  Variable in class genopt.algorithm.util.math. Point   the length of the binary string representation  cooDisMax  -  Variable in class genopt.algorithm.util.math. Point   the maximum allowed value for the point's discrete coordinates.     cooPoi  -  Variable in class genopt.algorithm. GPSCoordinateSearch   Array with element 0 or 1, if the previous step in this direction was         successful or failed, respectively  COUEXPMAX  -  Static variable in class genopt.algorithm.util.optimality. Perturber   counter how many times an expansion can be done  CurPop  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Current population        D     data  -  Static variable in class genopt.algorithm. Optimizer   The reference to the GenOpt kernel  deleteRunFiles(String[], String[])  -  Method in class genopt.algorithm. Optimizer   Deletes the run files specified by path and name.     Delta  -  Variable in class genopt.algorithm. Optimizer.Smoothing   Half width of the length of the integration domain for              each coordinate direction  Delta  -  Variable in class genopt.algorithm. PSOCCMesh   Mesh size factor  dFMin  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The minimal difference between the lowest  3 function values that has to be obtained before the search stops  (only used if  stoCri=1   dim  -  Variable in class genopt.algorithm.util.optimality. Perturber   dimension of the independent variable  dimCon  -  Static variable in class genopt.algorithm. Optimizer   The number of independent, continuous variables  dimCon  -  Variable in class genopt.algorithm. Parametric   number of independent continuous variables  dimCon  -  Variable in class genopt.algorithm.util.math. Point   the number of continuous independent variables  dimCon  -  Variable in class genopt.algorithm.util.pso. ModelPSO   The number of independent continuous variables  dimDis  -  Static variable in class genopt.algorithm. Optimizer   The number of independent, discrete variables  dimDis  -  Variable in class genopt.algorithm. Parametric   number of independent discrete variables  dimDis  -  Variable in class genopt.algorithm.util.math. Point   the number of discrete independent variables  dimDis  -  Variable in class genopt.algorithm.util.pso. ModelPSO   The number of independent discrete variables  dimF  -  Variable in class genopt.algorithm. HookeJeeves   The number of function values  dimF  -  Static variable in class genopt.algorithm. Optimizer   The number of cost function values  dimF  -  Variable in class genopt.algorithm. EquMesh   number of function values  dimF  -  Variable in class genopt.algorithm. Parametric   number of function values  dimF  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The number of function values  dimF  -  Variable in class genopt.algorithm.util.math. Point   the dimension of the function value vector  dimF  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The number of function values  dimF  -  Variable in class genopt.algorithm.util.pso. ModelPSO   The number of function values  dimF  -  Variable in class genopt.algorithm. GPSHookeJeeves   The number of function values  dimF  -  Variable in class genopt.algorithm. GPSCoordinateSearch   The number of function values  dimF  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   The number of function values  dimInpFun  -  Static variable in class genopt.algorithm. Optimizer   The number of input functions  dimX  -  Variable in class genopt.algorithm. HookeJeeves   The number of independent variables  dimX  -  Static variable in class genopt.algorithm. Optimizer   The number of independent variables (sum of continuous and discrete)  dimX  -  Variable in class genopt.algorithm. EquMesh   number of independent variables  dimX  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The number of independent variables  dimX  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The number of independent variables  dimX  -  Variable in class genopt.algorithm. NelderMeadONeill   The dimension of the problem  dimX  -  Variable in class genopt.algorithm. GPSCoordinateSearch   The number of independent variables  dimX  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   The number of independent variables  dimXP1  -  Variable in class genopt.algorithm. NelderMeadONeill   The dimension of the problem plus 1  DiscreteArmijoGradient  - class genopt.algorithm. DiscreteArmijoGradient . Class for minimizing a function using the   Discrete Armijo Gradient algorithm. DiscreteArmijoGradient(GenOpt)  -  Constructor for class genopt.algorithm. DiscreteArmijoGradient   Constructor  divide(double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Divides two numbers.    doSmoothing  -  Static variable in class genopt.algorithm. Optimizer   Flag whether the cost function should be smoothed or not  dx  -  Variable in class genopt.algorithm. EquMesh   width of steps for each dimension  dx  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The maximal width of the interval ( dx=xEnd-x0 )  dXIni  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Step size for scaling of the independent parameters        E     EMPTY_SEARCH_SET  -  Static variable in class genopt.algorithm.util.gps. ModelGPS   Array of points with zero elements.  ensureOnlyContinuousParameters()  -  Method in class genopt.algorithm. Optimizer   Checks whether all independent parameters are continuous.    ensureOnlyDiscreteParameters()  -  Method in class genopt.algorithm. Optimizer   Checks whether all independent parameters are discrete.    EPSILON  -  Static variable in class genopt.algorithm.util.math. Point   Accuracy for testing of rounding errors  EpsM  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Relative accuracy of gradient approximation  EpsX  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Relative accuracy of independent parameter before optimization stops  equals(Object)  -  Method in class genopt.algorithm.util.math. Point   Compares this object with the specified object for equality,  whereas only the x-coordinates in ( float  precision),  the index of the discrete variables,  and the step number are compared.  EquMesh  - class genopt.algorithm. EquMesh . Class for doing a parametric run where the parameters are  the nodes of an equidistant grid. EquMesh(GenOpt)  -  Constructor for class genopt.algorithm. EquMesh   Constructor  evaluate()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator   Evaluates the function.  evaluateSimulation(Point)  -  Method in class genopt.algorithm. Optimizer   Evaluates the simulation  writes a new input file  launches the simulation  checks for simulation errors  returns an array with the values of the objective function  evaluateSupportPoint(Point)  -  Method in class genopt.algorithm. Optimizer.Smoothing   Evaluates a support point for the numerical approximation to the   double integral  evaPoi  -  Static variable in class genopt.algorithm. Optimizer   The list with evaluated points and its function values.           evaPoi  -  Variable in class genopt.algorithm. Parametric   list with evaluated points and its function values  evaPoiF1  -  Variable in class genopt.algorithm. Optimizer.Smoothing   The list with evaluated points and its function values              after the first smoothing.               evaPoiF2  -  Variable in class genopt.algorithm. Optimizer.Smoothing   The list with evaluated points and its function values              after the second smoothing.               EXCLUDING  -  Static variable in class genopt.algorithm. Optimizer   constant to indicate strict inequality  explore()  -  Method in class genopt.algorithm. HookeJeeves   Makes exploration step around the base  rb    Note:  If return value is 0, then  rb  and                fp  are modified if and only if               a step has been successful, i.e., led to a reduction of               the function value  explore(Point, double)  -  Method in class genopt.algorithm. GPSHookeJeeves            F     FAIEXPMOV  -  Static variable in class genopt.algorithm. HookeJeeves      FAIMOV  -  Static variable in class genopt.algorithm. GPSCoordinateSearch      fibo  -  Variable in class genopt.algorithm.util.linesearch. FibonacciDivision   The Fibonacci numbers  Fibonacci  - class genopt.algorithm. Fibonacci . Class for doing a one-dimensional minimization using  Fibonacci division.    Fibonacci(GenOpt)  -  Constructor for class genopt.algorithm. Fibonacci   Constructor  FibonacciDivision  - class genopt.algorithm.util.linesearch. FibonacciDivision . Class for doing a line search along a given direction using  the the Fibonacci division.     FibonacciDivision(Optimizer)  -  Constructor for class genopt.algorithm.util.linesearch. FibonacciDivision   Constructor  fillDiagonal(double[][], double, double, double)  -  Static method in class genopt.algorithm.util.math. LinAlg   fills the diagonal matrix element and sets all other elements to zero.  FinAlg  -  Variable in class genopt.algorithm. GPSPSOCCHJ   Class for finishing the optimization  fIni  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Initial values of the cost function  FinIne  -  Variable in class genopt.algorithm. PSOIW   Final inertia  fLowBor  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The lower function value of the 2 border  ( x0  or  x3 ) that limit the interval  of uncertainty  fp  -  Variable in class genopt.algorithm. HookeJeeves   The function value at the previous base point  fr  -  Variable in class genopt.algorithm. HookeJeeves   The function value at the resulting base point  FS  -  Static variable in class genopt.algorithm. Optimizer   System dependent file separator  fun  -  Variable in class genopt.algorithm.util.math. Point   the point's function values  Fun  - class genopt.algorithm.util.math. Fun . Collection of mathematical functions.  Fun()  -  Constructor for class genopt.algorithm.util.math. Fun      Func  -  Variable in class genopt.algorithm.util.math. FunctionEvaluator   Function to be evaluated.  FunctionEvaluator  - class genopt.algorithm.util.math. FunctionEvaluator . Function parser.   FunctionEvaluator.Element  - class genopt.algorithm.util.math. FunctionEvaluator.Element . Internal class for an element that contains either a    String , a  double , or   a  char  value. FunctionEvaluator.Element(String)  -  Constructor for class genopt.algorithm.util.math. FunctionEvaluator.Element   Creates a new  Element  instance.  FunctionEvaluator(String, String)  -  Constructor for class genopt.algorithm.util.math. FunctionEvaluator   Creates a new  FunctionEvaluator  instance.  funValPoi  -  Static variable in class genopt.algorithm. Optimizer   pointer that assign to each objective function value    the number of the output file in which it is stored        G     Gam  -  Variable in class genopt.algorithm.util.linesearch. Armijo   Algorithm parameter  Gam  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Algorithm parameter  gaussElimination(double[][], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   solves a vector x by a Gauss elimination of a NxN matrix with  normalization and interchange of rows.  gaussEliminationTridiagonal(double[][], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   solves a vector x by a Gauss elimination of a tridiagonal NxN  matrix with normalization and interchange of rows.  GBEST  -  Static variable in class genopt.algorithm.util.pso. ModelPSO   Constant to denote the  gbest  neighborhood topology  genopt.algorithm  - package genopt.algorithm   genopt.algorithm.util.gps  - package genopt.algorithm.util.gps   genopt.algorithm.util.linesearch  - package genopt.algorithm.util.linesearch   genopt.algorithm.util.math  - package genopt.algorithm.util.math   genopt.algorithm.util.optimality  - package genopt.algorithm.util.optimality   genopt.algorithm.util.pso  - package genopt.algorithm.util.pso   getAbsAccuracyFunction()  -  Method in class genopt.algorithm. Optimizer   Gets the absolute accuracy of the last two main iterations  getBest()  -  Method in class genopt.algorithm. NelderMeadONeill   Gets the number of the best point  getCenter(double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   gets the center point of several points  getClosestEuclideanMeshPoint(double[], double[], double[])  -  Static method in class genopt.algorithm. PSOCCMesh   Gets the mesh point, on a rectangular mesh, that is closest to the argument.  getColumn(double[][], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   gets a column of a matrix  getComment()  -  Method in class genopt.algorithm.util.math. Point   Gets the point's comment  getDimensionContinuous()  -  Method in class genopt.algorithm. Optimizer   Gets the number of independent, continuous variables  getDimensionContinuous()  -  Method in class genopt.algorithm.util.math. Point   Gets the number of continuous coordinates  getDimensionDiscrete()  -  Method in class genopt.algorithm. Optimizer   Gets the number of independent, continuous variables  getDimensionDiscrete()  -  Method in class genopt.algorithm.util.math. Point   Gets the number of discrete coordinates  getDimensionF()  -  Method in class genopt.algorithm. Optimizer   Gets the number of function values  getDimensionF()  -  Method in class genopt.algorithm.util.math. Point   Gets the dimension of the points function value vector  getDimensionX()  -  Method in class genopt.algorithm. Optimizer   Gets the number of independent variables (sum of continuous and discrete)  getDiscreteValueDouble(int)  -  Method in class genopt.algorithm. Optimizer   Gets the double representation of the  variableNumber -th     discrete  parameter.  getDx(int)  -  Method in class genopt.algorithm. Optimizer   Gets the step size  dx[i]  of the i-th continuous variable    Note:   dx[i]  might be in the transformed space  depending on the value of  constraints .  getF()  -  Method in class genopt.algorithm.util.math. Point   Gets the point's function values  getF(double[])  -  Method in class genopt.algorithm. HookeJeeves   Gets the objective function value and registers it into  the data base  getF(int)  -  Method in class genopt.algorithm.util.math. Point   Gets the point's function values  getF(Point)  -  Method in class genopt.algorithm. Optimizer   Evaluates the simulation based on the parameter set x   The value  constraints  determines in which mode the constraints  are treated  After this call, the parameters in the original  and  in the      transformed space are set to the values that correspond to  x   The step size in the transformed space is updated according      to the transformation function  A new input file is writen  the simulation is launched  simulation errors are checked  the value of the objective function is returned  getF(Point)  -  Method in class genopt.algorithm. Optimizer.Smoothing   Gets the objective function value and registers it into  the data base  getF(Point)  -  Method in class genopt.algorithm. EquMesh   Evaluates a simulation and reports result  getF(Point)  -  Method in class genopt.algorithm. Parametric   Evaluates a simulation and reports result  getF(Point)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Evaluates the objective function, reports the results, and checks for  a null space of the objective function  getF(Point)  -  Method in class genopt.algorithm.util.gps. ModelGPS   Gets the cost function value and registers it into  the data base  getF(Point)  -  Method in class genopt.algorithm. DiscreteArmijoGradient      getF(Point)  -  Method in class genopt.algorithm. PSOCCMesh   Evaluates the simulation based on the parameter set x   The value  constraints  determines in which mode the constraints  are treated  After this call, the parameters in the original  and  in the      transformed space are set to the values that correspond to  x   The step size in the transformed space is updated according      to the transformation function  A new input file is writen  the simulation is launched  simulation errors are checked  the value of the objective function is returned  getF(Point, boolean)  -  Method in class genopt.algorithm. DiscreteArmijoGradient   Evaluates the simulation based on the parameter set x   The value  constraints  determines in which mode the constraints  are treated  After this call, the parameters in the original  and  in the      transformed space are set to the values that correspond to  x   The step size in the transformed space is updated according      to the transformation function  A new input file is writen  the simulation is launched  simulation errors are checked  the value of the objective function is returned  getF1(Point)  -  Method in class genopt.algorithm. Optimizer.Smoothing   Gets the function value of the smoothed cost function using one integration.  getF2(Point)  -  Method in class genopt.algorithm. Optimizer.Smoothing   Gets the function value of the smoothed cost function using double integration.  getFibonacci(int)  -  Static method in class genopt.algorithm.util.linesearch. FibonacciDivision   Gets the Fibonacci numbers  getFunction()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator      getGrayBinaryString(int)  -  Method in class genopt.algorithm.util.math. Point   Gets the value of a discrete variable encoded as a binary string   using Gray encoding.  getGrayBinaryStringLength(int)  -  Method in class genopt.algorithm.util.math. Point   Gets the string length used to represent the maximum value of the parameter   as a Gray coded binary string.  getGrayCode(long)  -  Static method in class genopt.algorithm.util.math. Binary   Gets the Gray code.  getIndex()  -  Method in class genopt.algorithm. Optimizer   Gets the indices of the discrete variable  x   getIndex()  -  Method in class genopt.algorithm.util.math. Point   Gets the indices of the discrete point's  getIndex(int)  -  Method in class genopt.algorithm. Optimizer   Gets the value (i.e., the index) of  x[i]   getIndex(int)  -  Method in class genopt.algorithm.util.math. Point   Gets the i-th point's index  getIndexLowestFunctionValue(Point[])  -  Static method in class genopt.algorithm.util.gps. ModelGPS      getIndexWithLowestCost()  -  Method in class genopt.algorithm.util.linesearch. Armijo   Gets the index to the point with the lowest function value.  getInitialDelta()  -  Method in class genopt.algorithm.util.gps. ModelGPS      getInitialMeshSizeExponent()  -  Method in class genopt.algorithm. PSOCCMesh   Gets the initial mesh size exponent.  getInputValueBoolean(String)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueDouble(String)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueDouble(String, double, double, double, double)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueInteger(String)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueInteger(String, int, int, int, int)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueString(String)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInputValueString(String, String[])  -  Method in class genopt.algorithm. Optimizer   Gets the value of  keyWord  from the  algorithmEntry   If another String than  keyWord  is at the current position  of the  algorithmEntry , an InputFormatException is thrown  getInverseGrayCode(int[])  -  Static method in class genopt.algorithm.util.math. Binary   Gets the inverse of the Gray code of a binary  int  array.     getInverseGrayCode(long)  -  Static method in class genopt.algorithm.util.math. Binary   Gets the inverse of the Gray code.  getIterationNumber()  -  Method in class genopt.algorithm.util.gps. ModelGPS      getKindOfConstraint(int)  -  Method in class genopt.algorithm. Optimizer   Gets the kind of constraint that is imposed on the i-th continuous  variable  getKWithLowestCost()  -  Method in class genopt.algorithm.util.linesearch. Armijo   Gets the exponent  k  of  Beta .  getL(int)  -  Method in class genopt.algorithm. Optimizer   Gets the lower bound  l[i]  of the continuous  variable  x[i]   getL2Norm(int[], int[])  -  Static method in class genopt.algorithm.util.math. Binary   Gets the L2 norm.  getLengthDiscrete(int)  -  Method in class genopt.algorithm. Optimizer   Gets the number of elements of the i-th discrete variable  getMainIterationNumber()  -  Method in class genopt.algorithm. Optimizer   Gets the main iteration number  getMaximumIndex()  -  Method in class genopt.algorithm.util.math. Point   Gets the maximum allowed value of the indices of the discrete point's  getMaximumNumberOfStepReduction()  -  Method in class genopt.algorithm.util.gps. ModelGPS   Gets the maximum number of step reductions.  getMaxIterationNumber()  -  Method in class genopt.algorithm. Optimizer   Gets the maximum number of allowed main iterations  getMeshSizeDivider()  -  Method in class genopt.algorithm. PSOCCMesh   Gets the mesh size divider.  getMinimumPoint()  -  Method in class genopt.algorithm. Optimizer   Gets the minimum point.  getMinimumPoint()  -  Method in class genopt.algorithm.util.gps. ModelGPS   Gets the minimum point.  getMode()  -  Method in class genopt.algorithm. Optimizer   Gets the mode of the optimization  getName()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator      getNumber()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator.Element   Gets the  double  value of the element.  getNumberOfStepReduction()  -  Method in class genopt.algorithm.util.gps. ModelGPS   Gets the number of step reductions done up to now.           getObjectiveFunctionName(int)  -  Method in class genopt.algorithm. Optimizer   Gets the name of the  i -th objective function value.       getOptimialPoint()  -  Method in class genopt.algorithm.util.optimality. Perturber   gets the point with the lowest function value  getOutputPath()  -  Method in class genopt.algorithm. Optimizer   Gets the output path.     getPointWithLowestCost()  -  Method in class genopt.algorithm.util.linesearch. Armijo   Gets the point with lowest cost.  getReductionFactor()  -  Method in class genopt.algorithm.util.linesearch. FibonacciDivision   Gets the reduction factor q = I(n+1)/I(n)  getReductionFactor()  -  Method in class genopt.algorithm.util.linesearch. GoldenRatio   Gets the reduction factor q = I(n+1)/I(n)  getReductionFactor()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Gets the reduction factor q = I(n+1)/I(n)  getRelAccuracyFunction()  -  Method in class genopt.algorithm. Optimizer   Gets the relative accuracy of the last two main iterations  getSimulationNumber()  -  Method in class genopt.algorithm. Optimizer   Gets the number of simulation.     getSpacing(int, double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Gets an array containing spacing between  x0  and  x1 .  getStepNumber()  -  Method in class genopt.algorithm. Optimizer   Gets the current step number  getStepNumber()  -  Method in class genopt.algorithm.util.math. Point   Gets the point's step number  getString()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator.Element   Gets the  String  value of the element.  getStringLength(long)  -  Static method in class genopt.algorithm.util.math. Binary   Gets the length of the binary string required to represent  the argument.  getStringRepresentation()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator.Element   Gets the  String  representation of the element.    getSub(double[], int, int)  -  Static method in class genopt.algorithm.util.math. LinAlg   gets a part of a vector  getU(int)  -  Method in class genopt.algorithm. Optimizer   Gets the upper bound  u[i]  of the continuous   variable  x[i]   getVariableNameContinuous(int)  -  Method in class genopt.algorithm. Optimizer   Gets the name of the continuous variable  x[i]   getVariableNameDiscrete(int)  -  Method in class genopt.algorithm. Optimizer   Gets the name of the discrete variable  x[i]   getWorst()  -  Method in class genopt.algorithm. NelderMeadONeill   Gets the number of the worst point  getX()  -  Method in class genopt.algorithm. Optimizer   Gets the values of the continuous variable  x    Note:   x  might be in the transformed space  depending on the value of  constraints   getX()  -  Method in class genopt.algorithm.util.math. Point   Gets the point's continuous independent variables  getX(int)  -  Method in class genopt.algorithm. Optimizer   Gets the value of  x[i]    Note:   x[i]  might be in the transformed space  depending on the value of  constraints   getX(int)  -  Method in class genopt.algorithm.util.math. Point   Gets the point's i-th continuous coordinate  getXCenter(int)  -  Method in class genopt.algorithm. NelderMeadONeill   Gets the center point for the reflection  getXLower()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   gets the lower bound of the uncertainty interval  getXMin()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Gets the point with the lowest function value  getXUpper()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   gets the upper bound of the uncertainty interval  globalSearch(Point[], double)  -  Method in class genopt.algorithm.util.gps. ModelGPS   Abstract method for the global search.  globalSearch(Point[], double)  -  Method in class genopt.algorithm. GPSHookeJeeves   Method for the global search (this method returns always  null .  globalSearch(Point[], double)  -  Method in class genopt.algorithm. GPSCoordinateSearch   Method for the global search (this method returns always  null .  GloBes  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Global best particles  GoldenRatio  - class genopt.algorithm.util.linesearch. GoldenRatio . Class for doing a line search along a given direction using  the Golden Section division.     GoldenRatio(Optimizer)  -  Constructor for class genopt.algorithm.util.linesearch. GoldenRatio   Constructor  GoldenSection  - class genopt.algorithm. GoldenSection . Class for doing a one-dimensional minimization using  the Golden Section algorithm.    GoldenSection(GenOpt)  -  Constructor for class genopt.algorithm. GoldenSection   Constructor  goToEndOfCommandFile()  -  Method in class genopt.algorithm. Optimizer   Checks whether the current section is closed and then moves to  the end of the file.   gotOptimum()  -  Method in class genopt.algorithm.util.optimality. Perturber   checks whether we have an optimum point  GPSCoordinateSearch  - class genopt.algorithm. GPSCoordinateSearch . Class for minimizing a function using the coordinate search algorithm.    GPSCoordinateSearch(GenOpt)  -  Constructor for class genopt.algorithm. GPSCoordinateSearch   Constructor  GPSCoordinateSearch(int, int)  -  Constructor for class genopt.algorithm. GPSCoordinateSearch   Constructor used to run the algorithm in a hybrid algorithm for the   last iterations.  GPSHookeJeeves  - class genopt.algorithm. GPSHookeJeeves . Class for minimizing a function using the Hooke-Jeeves  Generalized Pattern Search algorithm. GPSHookeJeeves(GenOpt)  -  Constructor for class genopt.algorithm. GPSHookeJeeves   Constructor  GPSHookeJeeves(int, int)  -  Constructor for class genopt.algorithm. GPSHookeJeeves   Constructor used to run the algorithm in a hybrid algorithm for the   last iterations.  GPSPSOCCHJ  - class genopt.algorithm. GPSPSOCCHJ . Class for minimizing a function using a hybrid   GPS algorithm. GPSPSOCCHJ(GenOpt)  -  Constructor for class genopt.algorithm. GPSPSOCCHJ   Constructor  gr  -  Static variable in class genopt.algorithm.util.linesearch. GoldenRatio   The Golden ratio (=0.618...)        H     HookeJeeves  - class genopt.algorithm. HookeJeeves . Class for minimizing a function using the Hooke-Jeeves  algorithm. HookeJeeves(GenOpt)  -  Constructor for class genopt.algorithm. HookeJeeves   Constructor        I     id  -  Variable in class genopt.algorithm.util.linesearch. ModelFiniteIntervalSearcher   The IntervalDivider that performs the line search  ieor(long, long)  -  Static method in class genopt.algorithm.util.math. Binary   Computes the value of a bitwise exclusive or between the arguments.  IGen  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Number of the current generation  INCLUDING  -  Static variable in class genopt.algorithm. Optimizer   constant to indicate weak inequality  increaseLength(char[], int)  -  Static method in class genopt.algorithm.util.math. Binary   Increases the length of a  char  array by   setting additional elements with 0.       increaseSize(Point[])  -  Static method in class genopt.algorithm.util.gps. ModelGPS      increaseStepNumber()  -  Method in class genopt.algorithm. Optimizer   Increases the step number without a function evaluation.  increaseStepNumber(Point)  -  Method in class genopt.algorithm. Optimizer   Increases the step number.  INCSTENUM  -  Static variable in class genopt.algorithm. HookeJeeves      IniIne  -  Variable in class genopt.algorithm. PSOIW   Initial inertia  iniMesSizExp  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The initial mesh size exponent 's_k'  IniMesSizExp  -  Variable in class genopt.algorithm. PSOCCMesh   The initial mesh size exponent 's_k'  initalizeCurrentPopulation()  -  Method in class genopt.algorithm.util.pso. ModelPSO   Initializes the current population  initialize()  -  Method in class genopt.algorithm.util.linesearch. ModelFiniteIntervalSearcher   Initializes the IntervalDivider instance  initialize(double[][], double)  -  Static method in class genopt.algorithm.util.math. LinAlg   initializes a rectangular matrix  initialize(double[], double)  -  Static method in class genopt.algorithm.util.math. LinAlg   initializes a vector  initializeBaseDirectionMatrix()  -  Method in class genopt.algorithm.util.gps. ModelGPS   Method that initializes the base direction matrix.  initializeBaseDirectionMatrix()  -  Method in class genopt.algorithm. GPSCoordinateSearch   Method that initializes the base direction matrix.  initializeNeighborhoodIndices()  -  Method in class genopt.algorithm.util.pso. ModelPSO   Initializes the neighborhood indices for each particle  InitializeNormalization  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Flag whether the normalization must be initialized  innerProduct(double[], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the inner product (dot product):     c[i] = sum(a[i] * b[i] , i = 0..N-1)  inpFun  -  Static variable in class genopt.algorithm. Optimizer   Text representation of the input functions  IntervalDivider  - class genopt.algorithm.util.linesearch. IntervalDivider . Abstract class for doing a line search along a given direction using  an interval division method.     IntervalDivider(Optimizer)  -  Constructor for class genopt.algorithm.util.linesearch. IntervalDivider   Constructor  isDFltdFMin()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Checks whether the difference between the lower of either  f1   or  f2  and the lower of either  f0  or  f3   is smaller than the prescribed  dFMin   isFeasible(Point)  -  Method in class genopt.algorithm. Optimizer   Checks whether a point is feasible.  isFeasiblePoint(double[])  -  Method in class genopt.algorithm. HookeJeeves   Checks whether a point is feasible  ishft(long, int)  -  Static method in class genopt.algorithm.util.math. Binary   Computes the value obtained by shifting the bits of  i    by  shift  positions.     isNextToken(String)  -  Method in class genopt.algorithm. Optimizer   Checks whether the next Token is equal to the passed String.  iterate()  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Checks whether the iteration has to be continued.        K     k  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The iteration number (counting only the main loop)  K  -  Variable in class genopt.algorithm.util.linesearch. Armijo   The exponents  k  and  k-1  of  Beta   K0  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Algorithm parameter  Kappa  -  Variable in class genopt.algorithm.util.linesearch. Armijo   Algorithm parameter  Kappa  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Algorithm parameter  konvge  -  Variable in class genopt.algorithm. NelderMeadONeill   A flag whether the convergence check is only allowed after 'konvge'   main iterations  KSta  -  Variable in class genopt.algorithm.util.linesearch. Armijo   Algorithm parameter  KSta  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Algorithm parameter        L     LBEST  -  Static variable in class genopt.algorithm.util.pso. ModelPSO   Constant to denote the  lbest  neighborhood topology  LenBitStr  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Length of the bit string used to encode each component of the discrete parameters  LinAlg  - class genopt.algorithm.util.math. LinAlg . Class with functions for linear algebra.    LinAlg()  -  Constructor for class genopt.algorithm.util.math. LinAlg      LMax  -  Variable in class genopt.algorithm.util.linesearch. Armijo   Algorithm parameter  LMax  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Algorithm parameter  LN10  -  Static variable in class genopt.algorithm.util.math. Fun   Natural logarithm of 10.  localSearch(Point[], double)  -  Method in class genopt.algorithm.util.gps. ModelGPS   Abstract method for the local search.  localSearch(Point[], double)  -  Method in class genopt.algorithm. GPSCoordinateSearch   Method for the local search.  LocBes  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Local best particles  log10(double)  -  Static method in class genopt.algorithm.util.math. Fun   Returns the logarithm (base 10) of a double  value.   LS  -  Static variable in class genopt.algorithm. Optimizer   System dependent line separator  LS  -  Static variable in class genopt.algorithm.util.linesearch. IntervalDivider   System dependent line separator  LS  -  Static variable in class genopt.algorithm.util.math. FunctionEvaluator   Line separator  LS  -  Static variable in class genopt.algorithm.util.optimality. Perturber   System dependent line separator        M     main(String[])  -  Static method in class genopt.algorithm.util.math. Point      main(String[])  -  Static method in class genopt.algorithm.util.math. Binary      MAINITERATION  -  Static variable in class genopt.algorithm. Optimizer   constant to indicate that it is a main iteration  maxDiff(double[][], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the maximum magnitude of the difference between  corresponding matrix element, defined as  maxDiff = max(|A[i][j]-A[i][j]|) for all i,j  maxIterationReached()  -  Method in class genopt.algorithm. Optimizer   Checks if the maximum number of iteration is reached.  maxNorm(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the Lmax norm of a vector, defined as  Lmax(u) = (max(|u(i)|, i = 1..n)  maxNorm(double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates Lmax norm of a matrix   The max norm of a matrix is the maximum row  sum, where the row sum is the sum of the magnitudes of  the elements in a given row  MaxVelDis  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Maximum velocity for discrete parameter  MaxVelGaiCon  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Gain for maximal velocity of continuous parameters  mesSizDiv  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The mesh size divider 'r'  MesSizDiv  -  Variable in class genopt.algorithm. PSOCCMesh   The mesh size divider 'r'  mesSizExpInc  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The increment of the mesh size exponent 't_k' (fixed for all k)  ModelFiniteIntervalSearcher  - class genopt.algorithm.util.linesearch. ModelFiniteIntervalSearcher . Abstract class for doing a  one-dimensional minimization   in a finite interval. ModelFiniteIntervalSearcher(GenOpt)  -  Constructor for class genopt.algorithm.util.linesearch. ModelFiniteIntervalSearcher   Constructor  ModelGPS  - class genopt.algorithm.util.gps. ModelGPS . Abstract class with model Generalized  Pattern Search algorithm. ModelGPS(GenOpt)  -  Constructor for class genopt.algorithm.util.gps. ModelGPS   Constructor used to run it as a single algorithm.  ModelGPS(int, int)  -  Constructor for class genopt.algorithm.util.gps. ModelGPS   Constructor used to run the algorithm in a hybrid algorithm for the   last iterations.  ModelPSO  - class genopt.algorithm.util.pso. ModelPSO . Abstract class with model   Particle Swarm Optimization algorithm. ModelPSO(GenOpt)  -  Constructor for class genopt.algorithm.util.pso. ModelPSO   Constructor  modStoCri  -  Variable in class genopt.algorithm. NelderMeadONeill   A flag whether the stopping criterion has to be modified or not  multiply(double[][], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   multiplicates a matrix with a vector: r = A * u;    (Returns the product of the row vector x and the rectangular   array A)  multiply(double[][], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   multiplicates a matrix with a matrix: C = A * B;  multiply(double[], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   multiplicates a vector with a matrix: r = u^T * A;    (Returns the product of the row vector x and the rectangular   array A)  multiply(double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Multiplies two numbers.    multiply(double, double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates S-multiplication : r = s * u;  multiply(double, double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates S-multiplication : B = s * A;  multiply(double, double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Multiplies three numbers.    multiply(double, int[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates S-multiplication : r = s * u;   The computations are done in  double .  mustStopOptimization()  -  Method in class genopt.algorithm. Optimizer   Returns a flag that indicates whether GenOpt must be stopped after   the current simulation  (due to a user request).        N     Name  -  Variable in class genopt.algorithm.util.math. FunctionEvaluator   Function name.  nameF  -  Static variable in class genopt.algorithm. Optimizer   The name of the function values  NEGDIR  -  Static variable in class genopt.algorithm. HookeJeeves      NEGDIR  -  Static variable in class genopt.algorithm. GPSCoordinateSearch      NeiHooInd  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Index with neighborhood points for each particle  NeiHooSiz  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Neighborhood size  NeiHooTop  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Neighborhood topology  NelderMeadONeill  - class genopt.algorithm. NelderMeadONeill . Class for minimizing a function using the Simplex strategy of Nelder and Mead  with an extension by O'Neill. NelderMeadONeill(GenOpt)  -  Constructor for class genopt.algorithm. NelderMeadONeill   Constructor  nFunObj  -  Static variable in class genopt.algorithm. Optimizer   The number of function objects  nIntRed  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The counter for number of interval reductions  nIntRedMax  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The maximum number of interval reductions  NINTREDMAXDEF  -  Static variable in class genopt.algorithm.util.linesearch. IntervalDivider   The default value for number of interval reductions  nMaxSteRed  -  Variable in class genopt.algorithm. HookeJeeves   The maximal number of step reduction before the algorithm terminates  nMaxSteRed  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The maximal number of step reduction before the algorithm terminates  NoConvergenceException  - exception genopt.algorithm.util.math. NoConvergenceException . Exception that is thrown when convergence is not achieved.     NoConvergenceException()  -  Constructor for class genopt.algorithm.util.math. NoConvergenceException   Constructs a NoConvergenceException with no detail message  NoConvergenceException(String)  -  Constructor for class genopt.algorithm.util.math. NoConvergenceException   Constructs a NoConvergenceException with the specified detail message  nS  -  Variable in class genopt.algorithm. EquMesh   number of required function evalations  nSimInpFil  -  Static variable in class genopt.algorithm. Optimizer   The number of the simulation input files  nSimLogFil  -  Static variable in class genopt.algorithm. Optimizer   The number of the simulation log files  nSimOutFil  -  Static variable in class genopt.algorithm. Optimizer   The number of the simulation output files  nSteRed  -  Variable in class genopt.algorithm. HookeJeeves   The number of step reduction  nSteRed  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The number of step reduction done up to now  NumGen  -  Variable in class genopt.algorithm.util.pso. ModelPSO   The number of generations  NumOfInt  -  Variable in class genopt.algorithm. Optimizer.Smoothing   Number of integrations along the coordinate directions  NumPar  -  Variable in class genopt.algorithm.util.pso. ModelPSO   The number of particles  NumSupPoi  -  Variable in class genopt.algorithm. Optimizer.Smoothing   Number of support points for the integration              for each coordinate direction  nval  -  Variable in class genopt.algorithm.util.math. FunctionEvaluator.Element            O     o  -  Variable in class genopt.algorithm.util.optimality. Perturber   reference to Optimizer Object  objFunObj  -  Static variable in class genopt.algorithm. Optimizer   The objective function objects  ONEMINUSEPSILON  -  Static variable in class genopt.algorithm.util.math. Point      oneNorm(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates L1 norm of a vector, defined as  L1(u) = (sum(u(i), i = 1..n)  oneNorm(double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates L1 norm of a matrix   The one-norm of a matrix is the maximum column sum, where the column sum  is the sum of the magnitudes of the elements in a given column.  ONEPLUSEPSILON  -  Static variable in class genopt.algorithm.util.math. Point      opt  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The reference to the Optimizer object  Opt  -  Variable in class genopt.algorithm.util.linesearch. Armijo   The reference to the Optimizer object  optComFilNam  -  Static variable in class genopt.algorithm. Optimizer   The name of the optimization command file  optimalPoint  -  Variable in class genopt.algorithm.util.optimality. Perturber   flag:  true  if xC is the optimal point,  false  otherwise  Optimizer  - class genopt.algorithm. Optimizer . Abstract Class that represents the structure of an optimization algorithm class  and offers generic methods to run the optimization. Optimizer.Smoothing  - class genopt.algorithm. Optimizer.Smoothing . Inner class for smoothing the cost function. Optimizer.Smoothing()  -  Constructor for class genopt.algorithm. Optimizer.Smoothing      Optimizer()  -  Constructor for class genopt.algorithm. Optimizer   Constructor  Optimizer(GenOpt, int)  -  Constructor for class genopt.algorithm. Optimizer   Constructor  ORIGINAL  -  Static variable in class genopt.algorithm. Optimizer   constant for indicating that the optimization is in the original space  outerProduct(double[], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the outer product (Tensor product):         M[i][j] = a[i] * b[j]  outFun  -  Static variable in class genopt.algorithm. Optimizer   Text representation of the output functions        P     Parametric  - class genopt.algorithm. Parametric . Class for doing a parametric run where one parameter  is perturbed at a time while the others are fixed.    Parametric(GenOpt)  -  Constructor for class genopt.algorithm. Parametric   Constructor  parseCommandFile(int, int)  -  Method in class genopt.algorithm.util.gps. ModelGPS   Parses the command file.  PATMOV  -  Static variable in class genopt.algorithm. HookeJeeves      perturb(int)  -  Method in class genopt.algorithm. EquMesh   Perturbs the point and evaluates a simulation  perturb(Point, double)  -  Method in class genopt.algorithm.util.optimality. Perturber   checks the optimality condition in the transformed space  by testing in each orthogonal direction of  xL  whether   the function increases or not.  perturb(Point, double, int)  -  Method in class genopt.algorithm. GPSCoordinateSearch   Perturbs a given point in one direction.  Perturber  - class genopt.algorithm.util.optimality. Perturber . Class for checking the optimality condition of a point. Perturber(Optimizer)  -  Constructor for class genopt.algorithm.util.optimality. Perturber   constructor for checking the optimality condition  Point  - class genopt.algorithm.util.math. Point . Abstract class for a point with continuous and discrete coordinates. Point(double[], double[], int, String)  -  Constructor for class genopt.algorithm.util.math. Point   Constructor for a point with only continuous independent variables  Point(double[], int[], double[], int, String)  -  Constructor for class genopt.algorithm.util.math. Point   Constructor for a point with continuous and discrete    independent variables  Point(double[], int[], int[], double[], int, String)  -  Constructor for class genopt.algorithm.util.math. Point   Constructor for a point with continuous and discrete    independent variables  Point(int[], double[], int, String)  -  Constructor for class genopt.algorithm.util.math. Point   Constructor for a point with only discrete independent variables  Point(int, int, int)  -  Constructor for class genopt.algorithm.util.math. Point   Constructor  POSDIR  -  Static variable in class genopt.algorithm. HookeJeeves      POSDIR  -  Static variable in class genopt.algorithm. GPSCoordinateSearch      postProcessObjectiveFunction(int, double[])  -  Method in class genopt.algorithm. Optimizer   Deprecated.   You should use function objects, which can be defined              in the input files, instead of this function.   print(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   prints a vector to the output stream  print(double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   prints a matrix to the output stream  print(double[], String)  -  Static method in class genopt.algorithm.util.math. LinAlg   reports a scalar and a vector to the output stream, where the  entries are separated by the given delimiter  print(double, double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   reports a scalar and a vector to the output stream  print(double, double[], String)  -  Static method in class genopt.algorithm.util.math. LinAlg   reports a scalar and a vector to the output stream, where the  entries are separated by the given delimiter  print(int[])  -  Static method in class genopt.algorithm.util.math. LinAlg   prints a vector to the output stream  print(String)  -  Method in class genopt.algorithm. Optimizer   Prints a message to the output device without finishing the line    Note:  Use this method instead of  System.out.printl(String) ,  otherwise it won't be reported in the GUI  println(String)  -  Method in class genopt.algorithm. Optimizer   Prints a message to the output device, and then finishs the line    Note:  Use this method instead of  System.out.println(String) ,  otherwise it won't be reported in the GUI  processResultFunction(String[], double[])  -  Method in class genopt.algorithm. Optimizer   Process the function objects for post processing of the objective function.  PSOCC  - class genopt.algorithm. PSOCC . Class for minimizing a function the particle swarm optimization  algorithm with constriction coefficient for the particle location update  equation.    PSOCC(GenOpt)  -  Constructor for class genopt.algorithm. PSOCC   Constructor  PSOCCMesh  - class genopt.algorithm. PSOCCMesh . Class for minimizing a function using a mesh particle swarm optimization  algorithm with constriction coefficient for the particle location update  equation.    PSOCCMesh(GenOpt)  -  Constructor for class genopt.algorithm. PSOCCMesh   Constructor  PSOIW  - class genopt.algorithm. PSOIW . Class for minimizing a function the particle swarm optimization  algorithm with inertia weight for the particle location update  equation.    PSOIW(GenOpt)  -  Constructor for class genopt.algorithm. PSOIW   Constructor        R     RanGen  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Random number generator  rank(double)  -  Method in class genopt.algorithm. NelderMeadONeill   Compares a trial with the other vertices  rb  -  Variable in class genopt.algorithm. HookeJeeves   The base point resulting from the current move  reflect(double[], double[])  -  Method in class genopt.algorithm. NelderMeadONeill   Reflects a point  report(Point, boolean)  -  Method in class genopt.algorithm. HookeJeeves   Reports the new trial  report(Point, boolean)  -  Method in class genopt.algorithm. Optimizer   Reports the new trial and updates the parameters  updates the original value  updates the transformed value  updates the transformed step size  reports the new trial  reports the objective function value  increases the number of the iteration   Note:  If a sub iteration is also a main iteration, then               you have to call this function twice, first with                MainIteration = false  and then with                MainIteration = true   report(Point, boolean)  -  Method in class genopt.algorithm.util.gps. ModelGPS   Reports the new trial  reportCurrentLowestPoint()  -  Method in class genopt.algorithm. Optimizer   Reports the current lowest point for the case that GenOpt  has to terminate.  reportFailure(Point, int)  -  Method in class genopt.algorithm. GPSCoordinateSearch   Reports a trial that yield no reduction in the objective function value.  reportMinimum()  -  Method in class genopt.algorithm. Optimizer   Reports the minimum point.  reportSuccess(Point, int)  -  Method in class genopt.algorithm. GPSCoordinateSearch   Reports a trial that reduced the objective function value.  reportSuccessFullIterate(Point)  -  Method in class genopt.algorithm. DiscreteArmijoGradient   Reports the new trial and updates the parameters  updates the original value  updates the transformed value  updates the transformed step size  reports the new trial  reports the objective function value  increases the number of the iteration   Note:  If a sub iteration is also a main iteration, then               you have to call this function twice, first with                MainIteration = false  and then with                MainIteration = true   restartCriterion()  -  Method in class genopt.algorithm. NelderMeadONeill   Determines whether a restart with a smaller simplex should be tried or not  retryEvaluateSimulation(Point, Throwable)  -  Method in class genopt.algorithm. Optimizer   Tries to evaluate the simulation a second time if an exception has been  thrown  roundCoordinates(Point)  -  Static method in class genopt.algorithm. Optimizer   Rounds the coordinates of the continuous parameters to float format.  run()  -  Method in class genopt.algorithm. HookeJeeves   Runs the optimization process until a termination criteria  is satisfied  run()  -  Method in class genopt.algorithm. Optimizer   Abstract method for running the optimization algorithm      until a termination criteria is satisfied  run()  -  Method in class genopt.algorithm. EquMesh   Runs the evaluation  run()  -  Method in class genopt.algorithm. Parametric   Runs the evaluation  run()  -  Method in class genopt.algorithm.util.linesearch. ModelFiniteIntervalSearcher   Runs the optimization process until a termination criteria  is satisfied  run()  -  Method in class genopt.algorithm.util.gps. ModelGPS   Runs the optimization process until a termination criteria  is satisfied  run()  -  Method in class genopt.algorithm.util.pso. ModelPSO   Runs the optimization process until a termination criteria  is satisfied  run()  -  Method in class genopt.algorithm. NelderMeadONeill   Runs the optimization process until a termination criteria  is satisfied  run()  -  Method in class genopt.algorithm. DiscreteArmijoGradient   Runs the optimization process until a termination criteria  is satisfied  run()  -  Method in class genopt.algorithm. GPSPSOCCHJ   Runs the optimization process until a termination criteria  is satisfied  run(int, Point, double[], int, double)  -  Method in class genopt.algorithm.util.linesearch. Armijo   Runs the line search.  run(Point, Point)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Runs a line search in the interval from  xS  to   xE .        S     separator  -  Static variable in class genopt.algorithm. Optimizer   Separator that separate the objective function value from the values behind it.           set(double[], double[], int, String)  -  Method in class genopt.algorithm.util.math. Point   Sets a point with only continuous independent variables  set(double[], int[], double[], int, String)  -  Method in class genopt.algorithm.util.math. Point   Sets a point with continuous and discrete independent variables  set(double[], int[], int[], double[], int, String)  -  Method in class genopt.algorithm.util.math. Point   Sets a point with continuous and discrete independent variables  set(double[], int, String)  -  Method in class genopt.algorithm.util.math. Point   Sets a point with only continuous independent variables  set(int[], double[], int, String)  -  Method in class genopt.algorithm.util.math. Point   Sets a point with only discrete independent variables  set(int[], int, String)  -  Method in class genopt.algorithm.util.math. Point   Sets a point with only discrete independent variables  setAbsDFMin(double, int)  -  Method in class genopt.algorithm.util.linesearch. FibonacciDivision   Set the minimal absolut difference between the lowest  3 function values as the stopping criteria  setAbsDFMin(double, int)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Sets the minimal absolut difference between the lowest  function values as the stopping criteria  setColumn(double[][], double[], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   sets a column of a matrix    Note:  the dimension of x can be smaller than the column               length of A  setComment(String)  -  Method in class genopt.algorithm.util.math. Point   Sets a comment  setConstrictionCoefficientParameter(double)  -  Method in class genopt.algorithm. PSOCC   Sets the constriction coefficient parameter  setF(double[])  -  Method in class genopt.algorithm.util.math. Point   Sets a point's function value  setF(int, double)  -  Method in class genopt.algorithm.util.math. Point   Sets a point's function value  setGrayBinaryString(int, int[])  -  Method in class genopt.algorithm.util.math. Point   Sets the value of a discrete variable as a Gray encoded binary string.     setIndex(int[])  -  Method in class genopt.algorithm.util.math. Point   Sets the indices of the point's discrete variables  setIndex(int[], int[])  -  Method in class genopt.algorithm.util.math. Point   Sets the indices of the point's discrete variables and its maximum allowed values  setIndex(int, int)  -  Method in class genopt.algorithm. Optimizer   Sets the index of the discrete variable  x[variableNumber]    to the value  index .  setIndex(int, int)  -  Method in class genopt.algorithm.util.math. Point   Sets the index of the point's i-th discrete variables  setInfo(String)  -  Method in class genopt.algorithm. Optimizer   Sets a message in the InformationManager  The message will be displayed in the output stream  (GUI in WinGenOpt, command shell otherwise) and in  the log file  setMaximumIndex(int, int)  -  Method in class genopt.algorithm.util.math. Point   Sets the maximum value for the index of the    point's i-th discrete variables.      setMaximumNumberOfStepReduction(int)  -  Method in class genopt.algorithm.util.gps. ModelGPS   Sets the maximum number of step reductions.  setMaxIntRed(int)  -  Method in class genopt.algorithm.util.linesearch. FibonacciDivision   Sets the maximum number of interval reductions  setMaxIntRed(int)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Sets the maximum number of interval reductions  setMode(int)  -  Method in class genopt.algorithm. Optimizer   Sets the mode of the optimization  setNumberOfMatchingResults(int)  -  Method in class genopt.algorithm. Optimizer   Sets the maximal allowed number of matching results  setRow(double[][], double[], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   sets a row of a matrix    Note:  the dimension of x can be smaller than the row               length of A  setStepNumber(int)  -  Method in class genopt.algorithm.util.math. Point   Sets a the step number  setToFeasibleCoordinate(double, double, double)  -  Static method in class genopt.algorithm. Optimizer   Restricts the value of  x  such that  l <= x <= u .       setToFeasibleCoordinate(int, int, int)  -  Static method in class genopt.algorithm. Optimizer   Restricts the value of  x  such that  l <= x <= u .       setUncertaintyInterval(double)  -  Method in class genopt.algorithm.util.linesearch. FibonacciDivision   Sets the fraction of the desired uncertainty interval (0..1)  setUncertaintyInterval(double)  -  Method in class genopt.algorithm.util.linesearch. GoldenRatio   Sets the fraction of the desired uncertainty interval (0..1)  setUncertaintyInterval(double)  -  Method in class genopt.algorithm.util.linesearch. IntervalDivider   Sets the fraction of the desired uncertainty interval (0..1)  setWarning(String)  -  Method in class genopt.algorithm. Optimizer   Sets a message in the WarningManager.    setX(double[])  -  Method in class genopt.algorithm.util.math. Point   Sets the point's continuous coordinates  setX(int, double)  -  Method in class genopt.algorithm. Optimizer   Sets the value of the continuous variable  x[i]  to  value .  setX(int, double)  -  Method in class genopt.algorithm.util.math. Point   Sets the i-th continuous independent variable  setX(int, int)  -  Method in class genopt.algorithm.util.math. Point   Deprecated.   replaced by  setIndex(int, int)   setXIndex(double[], int[])  -  Method in class genopt.algorithm.util.math. Point   Sets the point's discrete and continuous coordinates  simInpTemFilHan  -  Static variable in class genopt.algorithm. Optimizer   The simulation input template file handler  simLogFil  -  Static variable in class genopt.algorithm. Optimizer   The simulation log file names (incl. path)  simOutFil  -  Static variable in class genopt.algorithm. Optimizer   The simulation output file names (incl. path)  smoo  -  Static variable in class genopt.algorithm. Optimizer   Instance for smoothing the cost function  SocAcc  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Acceleration constant for social component  sqEps  -  Variable in class genopt.algorithm. NelderMeadONeill   The required accuracy of the variance (eps*eps)  sr  -  Variable in class genopt.algorithm. HookeJeeves   The current relative step reduction, compared to original step size,  including its sign.  steNum  -  Variable in class genopt.algorithm.util.math. Point   the point's step number  step  -  Variable in class genopt.algorithm. EquMesh   number of steps  stepNumber  -  Static variable in class genopt.algorithm. Optimizer   The step number (for implementing variation of the weighting factors         for penalty function and barrier function  steRed  -  Variable in class genopt.algorithm. HookeJeeves   The relative step reduction for each reduction  stoCri  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The stopping criteria       0: number of interval reduction       1: maximum difference of the best 3 function values  stopAtError  -  Variable in class genopt.algorithm. EquMesh   flag whether run should stop or proceed if a simulation error occurs  stopAtError  -  Variable in class genopt.algorithm. Parametric   flag whether run should stop or proceed if a simulation error occurs  SUBITERATION  -  Static variable in class genopt.algorithm. Optimizer   constant to indicate that it is a sub iteration  subtract(double[][], double[][])  -  Static method in class genopt.algorithm.util.math. LinAlg   subtracts 2 matrices: C = A - B;    Note: C has the dimension of A; B must not have the same                dimension as A (non existing element are considered                as 0 and elements that are not in A but in B are not                taken into account by the summation)  subtract(double[], double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   subtracts 2 vectors: z = y - x;    Note:  If the dimension dx of x is bigger than the dimension               dy of y, then only dx elements are subtracted.  subtract(double, double)  -  Static method in class genopt.algorithm.util.math. Fun   Subtracts two numbers.    subtract(int[], int[])  -  Static method in class genopt.algorithm.util.math. LinAlg   subtracts 2 vectors: z = y - x;    Note:  If the dimension dx of x is bigger than the dimension               dy of y, then only dx elements are subtracted.  SUCEXPMOV  -  Static variable in class genopt.algorithm. HookeJeeves      SUCMOV  -  Static variable in class genopt.algorithm. GPSCoordinateSearch      sumColumn(double[][], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   returns the sum of the elements in the i-th column  sumRow(double[][], int)  -  Static method in class genopt.algorithm.util.math. LinAlg   returns the sum of the elements in the i-th row  sval  -  Variable in class genopt.algorithm.util.math. FunctionEvaluator.Element            T     throwInputError(String)  -  Method in class genopt.algorithm. Optimizer   Throws an input error.   toBinaryChar(long)  -  Static method in class genopt.algorithm.util.math. Binary   Returns a  char[]  representation of the long   argument as an unsigned integer in base 2.  toBinaryInt(char[])  -  Static method in class genopt.algorithm.util.math. Binary   Converts a  char  array with binary values to   a binary  int  array.  toBinaryInt(long)  -  Static method in class genopt.algorithm.util.math. Binary   Returns an  int[]  representation of the long   argument as an unsigned integer in base 2.  toBinaryInt(long, int)  -  Static method in class genopt.algorithm.util.math. Binary   Returns an  int[]  representation of the long   argument as an unsigned integer in base 2.  toString()  -  Method in class genopt.algorithm.util.math. Point   Returns a string representation of the object.  toString()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator.Element   Returns a  String  representation of the object.  TRANSFORMED  -  Static variable in class genopt.algorithm. Optimizer   constant for indicating that the optimization is in the transformed space  TT_CBRA  -  Static variable in class genopt.algorithm.util.math. FunctionEvaluator.Element      TT_COMMA  -  Static variable in class genopt.algorithm.util.math. FunctionEvaluator.Element      TT_NUMBER  -  Static variable in class genopt.algorithm.util.math. FunctionEvaluator.Element      TT_OBRA  -  Static variable in class genopt.algorithm.util.math. FunctionEvaluator.Element      TT_WORD  -  Static variable in class genopt.algorithm.util.math. FunctionEvaluator.Element      ttype  -  Variable in class genopt.algorithm.util.math. FunctionEvaluator.Element      twoNorm(double[])  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the L2 norm of a vector, defined as  L2(u) = (sum(u(i)**2, i = 1..n) ^ 0.5  twoNorm(double[], double)  -  Static method in class genopt.algorithm.util.math. LinAlg   calculates the L2 norm with a scaling factor of a vector,  defined as L2(u) = (sum(h * u(i)**2, i = 1..n) ^ 0.5        U     updateGlobalBest()  -  Method in class genopt.algorithm.util.pso. ModelPSO   Updates the global best particles based on the local best particles  updateLocalBest()  -  Method in class genopt.algorithm.util.pso. ModelPSO   Updates the local best particles based on the current population  updateParameterSetting(Point)  -  Method in class genopt.algorithm. Optimizer   Updates the settings of the current value of the continuous   and discrete parameters.  updateParticleLocation()  -  Method in class genopt.algorithm.util.pso. ModelPSO   Updates the particle location  updateVelocity()  -  Method in class genopt.algorithm.util.pso. ModelPSO   Updates the particle velocity  updateVelocity()  -  Method in class genopt.algorithm. PSOCC   Updates the particle velocity  updateVelocity()  -  Method in class genopt.algorithm. PSOIW   Updates the particle velocity  useSteNum  -  Static variable in class genopt.algorithm. Optimizer   A flag to indicate whether the step number is used by the optimization algorithm.                 V     VelCon  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Velocity of the continuous particles  VelDis  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Velocity of the discrete particles  VelMaxCon  -  Variable in class genopt.algorithm.util.pso. ModelPSO   Maximum velocity for each component of the continuous parameter  VONNEUMANN  -  Static variable in class genopt.algorithm.util.pso. ModelPSO   Constant to denote the  von Neumann  neighborhood topology        W     wriSteNum  -  Static variable in class genopt.algorithm. Optimizer   A flag to indicate whether the step number has to be written in the simulation         input file (and hence a simulation done)  writeStepNumber()  -  Method in class genopt.algorithm. Optimizer   Returns the flag that indicates whether the step number  has to written to the simulation input file or not.        X     x  -  Variable in class genopt.algorithm. EquMesh   free parameter  x  -  Variable in class genopt.algorithm.util.gps. ModelGPS   The sequence of iterates  x  -  Variable in class genopt.algorithm. NelderMeadONeill   The points  x0  -  Variable in class genopt.algorithm. EquMesh   lower bound  x0  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The lowest value on abscissa (start of interval)  X0Con  -  Variable in class genopt.algorithm. PSOCCMesh   Initial values of the continuous parameters  x1  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The 2nd lowest value on abscissa  x2  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The 3rd lowest value on abscissa  x3  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The highest value on abscissa  xC  -  Variable in class genopt.algorithm.util.optimality. Perturber   point to be checked  xIni  -  Variable in class genopt.algorithm. DiscreteArmijoGradient   Initial values of the independent parameters  xL  -  Variable in class genopt.algorithm.util.optimality. Perturber   lowest point in the neighborhood of xC  xLow  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The lower border of the uncertainty interval after stop of algorithm  xLS  -  Variable in class genopt.algorithm.util.linesearch. Armijo   The two points of the line search  xMin  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The point with the lowest obtained function value  xUpp  -  Variable in class genopt.algorithm.util.linesearch. IntervalDivider   The upper border of the uncertainty interval after stop of algorithm        _     _convertPointToUserUnits(Point)  -  Method in class genopt.algorithm. DiscreteArmijoGradient   Converts the argument's independent parameters  to the units used in the simulation input.  _copyRunFiles()  -  Method in class genopt.algorithm. Optimizer   Copies the files from  path  to  savePath  and   adds the run number in front of the file name.  _copyRunFiles(String[], String[], String[])  -  Method in class genopt.algorithm. Optimizer   Copies the files from  path  to  savePath  and   adds the run number in front of the file name.  _evaluate(String, Stack)  -  Method in class genopt.algorithm.util.math. FunctionEvaluator   Evaluates the function  fun  using all elements in  sta  as the argument.  _getErrorMessagePrefix()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator   Gets the prefix for the error message.  _getF(Point)  -  Method in class genopt.algorithm. Optimizer   Evaluates the simulation based on the parameter set x   The value  constraints  determines in which mode the constraints  are treated  After this call, the parameters in the original  and  in the      transformed space are set to the values that correspond to  x   The step size in the transformed space is updated according      to the transformation function  A new input file is writen  the simulation is launched  simulation errors are checked  the value of the objective function is returned  _getVonNeumannIndex(int, int, int)  -  Method in class genopt.algorithm.util.pso. ModelPSO   Computes the index of a point used in the von Neumann neighborhood  _initialize(int, int, int)  -  Method in class genopt.algorithm.util.math. Point   Allocates all arrays.  _initializeRungeCotteCoefficients()  -  Method in class genopt.algorithm. Optimizer.Smoothing   Initializes the coefficients for the Runge-Cotte integration  _parse(ArrayList, String)  -  Method in class genopt.algorithm.util.math. FunctionEvaluator   Parses the function.  _replaceInInputFile(String, String, FileHandler[])  -  Method in class genopt.algorithm. Optimizer   Replaces  text  with  value  in  simulationInput .  _replaceInInputFunction(String, String)  -  Method in class genopt.algorithm. Optimizer   Replaces  text  with  value  in input functions.  _replaceInOutputFunction(String, String)  -  Method in class genopt.algorithm. Optimizer   Replaces  text  with  value  output functions.  _setArrayList()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator   Sets the array list that will be used to evaluate the function  _setAttribute()  -  Method in class genopt.algorithm.util.math. FunctionEvaluator.Element      _setToFeasibleCoordinate(double, double, double)  -  Static method in class genopt.algorithm. Optimizer   Computes  x := 2 * l - x  if  x < l ,   or  x := 2 * u - x  if  x < u .     _setToFeasibleCoordinate(int, int, int)  -  Static method in class genopt.algorithm. Optimizer   Computes  x := 2 * l - x  if  x < l ,   or  x := 2 * u - x  if  x < u .     _variableNotFound(String)  -  Method in class genopt.algorithm. Optimizer   Throws a  SimulationInputException  that says that the variable   could not be found.      A   B   C   D   E   F   G   H   I   K   L   M   N   O   P   R   S   T   U   V   W   X   _                             Overview            Package            Class            Tree            Deprecated          Index            Help                          PREV   NEXT       FRAMES       NO FRAMES            All Classes                      GenOpt  |  LBL SRG  |  LBL      Copyright © 1998-2003 The Regents of the University of California (through Lawrence Berkeley National Laboratory), subject to receipt of any required approvals from U.S. Department of Energy.  For problems or questions regarding this page contact  MWetter@lbl.gov
GX034-39-12651882	Adobe     SVG                                                                                                                                                 Scalable Vector Graphics                                             •       XML language to represent graphics                                             •       SVG drawings can be dynamic and                                   interactive                                             •       A valuable instrument where graphics need                                   to be manipulated dynamically                                             •       Limited functionality for for capturing and                                   processing text oriented data                                             •       SVG is primarily an XML based presentation                             technique                                             •       SVG is an adjunct to PDF not a replacement
GX005-28-7957977	What     Is SVG?                                                                                                                                                 Scalable     Vector Graphics (SVG) is                             W3C's     non-proprietary alternative to                             Flash     and bitmapped graphics.                                             SVG     enables 2-D resolution- and                             media-independent     graphics in a text-                             based format.                                             This     permits integration with XHTML,                             XSL     and XSLT, XLink, SMIL, DOM and                             other     W3 specifications…                                             …including     complete support for CSS,                       scripting,     and animation.                                             3     Object Types:    Vector graphic                             shapes     (paths consisting of straight                             lines     and curves), Text, and Images.                                                                                                                           2
GX005-80-4222562	"Grace User's Guide (v0.6 - for Grace-5.1.0)    by the Grace Team 02.04.2000      This document explains the usage of    Grace , a WYSIWYG 2D plotting tool for scientific data.     1. Introduction        1.1 What is Grace?      Grace is a WYSIWYG tool to make two-dimensional plots of scientific data. It runs under various (if not all) flavors of Unix with X11 and Motif (LessTif). It also runs under VMS, OS/2, and Windows (95/98/NT). Its capabilities are roughly similar to GUI-based programs like Sigmaplot or Microcal Origin plus script-based tools like Gnuplot or Genplot. Its strength lies in the fact that it combines the convenience of a graphical user interface with the power of a scripting language which enables it to do sophisticated calculations or perform automated tasks.  Grace is derived from Xmgr (a.k.a. ACE/gr), originally written by Paul Turner.  From version number 4.00, the development was taken over by a team of volunteers under the coordination of Evgeny Stambulchik. You can get the newest information about Grace and download the latest version at the   Grace home page .  When its copyright was changed to GPL, the name was changed to Grace, which stands for ``GRaphing, Advanced Computation and Exploration of data'' or ``Grace Revamps ACE/gr''. The first version of Grace available is named 5.0.0, while the last public version of Xmgr has the version number 4.1.2.  Paul still maintains and develops a non-public version of Xmgr for internal use.    1.2 Copyright statement            Copyright (©) 1991-1995 Paul J Turner, Portland, OR Copyright (©) 1996-2000 Grace Development Team  Maintained by Evgeny Stambulchik                            All Rights Reserved  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.        For certain libraries required to build Grace (which are therefore even included in a suitable version) there may be different Copyright/License statements. Though their License may by chance match the one used for Grace, the Grace Copyright holders can not influence or change them.         Package   License   cephes   Free   T1lib   LGPL   Xbae   BSD-like   Tab   BSD-like            Licenses               1.3 Comments and bug reports            2. Installation guide           2.1 Installing from sources             Configuration         Requirements. Grace usually compiles out of the box in a regular Unix-like environment. You need an ANSI C compiler (gcc is just fine), the X11R5 or above libraries and headers, and Motif-1.2 or above. If you want to compile your own changes to certain parts of Grace, you will need a parser generator ( yacc  or, better,  bison ).    Extra libraries. Some features will be available only if additional libraries are installed. Those are:     The JPEG backend needs the IJG's (  JPEG library ), version 6.x.    The PNG backend needs the (  libpng ) library (version 0.96 or above).    The PDF driver requires the PDFlib library of Thomas Merz to be installed, which is available  here , version 3.00 or above.    If your computer has the FFTW library installed when Grace is compiled, Grace will link itself to this, and drop all conventional FFT's and DFT's. All transforms will be routed through this package. Note that there is then no difference between pushing the ""FFT"" button and the ""DFT"" button, except that FFT will complain if the length isn't a power of 2, and DFT will not.  For more information on this package, see the   FFTW Home page . In short, this package allows one to do non-power-of-2 length FFT's along with the normal ones.  It seems to work very efficiently for any set length which factors into 2^a 3^b 5^c 7^d for integer a, b, c, d. The great feature here is that set lengths which are powers of 10 (e.g. 1000, 10000) and integer multiples of these (500, 2000, 2500, 5000, etc.) can be computed with no significant penalty (maybe 20%) over power-of-2 transforms. Very often, real datasets come in these sizes, and not in powers of 2.    In order to read/write sets in the NetCDF data format, you will also need the   NetCDF libraries .        Decide whether you want to compile in a separate place (thus leaving the source tree pristine). You most probably would want it if compiling Grace for more than one OS and keeping the sources in a central shared (e.g. via NFS) location. If you don't need it, skip the rest of this paragraph and go right to the next step. Otherwise, assuming the sources are in  /usr/local/src/grace-x.y.z  and the compilation will be performed in  /tmp/grace-obj , do the following:    % mkdir /tmp/grace-obj   % cd /tmp/grace-obj   % /usr/local/src/grace-x.y.z/ac-tools/shtool mkshadow \     /usr/local/src/grace-x.y.z .                         The  configure  shell script attempts to guess correct values for various system-dependent variables used during compilation. It uses those values to create  Make.conf  in the top directory of the package. It also create  config.h  file containing system-dependent definitions. Finally, it creates a shell script  config.status  that you can run in the future to recreate the current configuration, a file  config.cache  that saves the results of its tests to speed up reconfiguring, and a file  config.log  containing compiler output (useful mainly for debugging  configure ). If at some point  config.cache  contains results you don't want to keep, you may remove or edit it.    Run  ./configure --help  to get list of additional switches specific to Grace    Run  ./configure <options> . Just an example:    % ./configure --enable-grace-home=/opt/grace      --with-extra-incpath=/usr/local/include:/opt/include \     --with-extra-ldpath=/usr/local/lib:/opt/lib --prefix=/usr                      would use  /usr/local/include  and  /opt/include  in addition to the default include path and  /usr/local/lib  and  /opt/lib  in addition to the default ld path. As well, all stuff would be put under the /opt/grace directory and soft links made to  /usr/bin ,  /usr/lib  and  /usr/include .  Note : If you change one of the  --with-extra-incpath  or  --with-extra-ldpath  options from one run of configure to another, remember to delete the  config.cache  file!!!         Compilation     Issue  make   If something goes wrong, try to see if the problem has been described already in the  Grace FAQ  (in the  doc  directory).         Testing           make tests   This will give you a slide show demonstrating some nice features of Grace.         Installation      make install     make links   The later (optional) step will make soft links from some files under the Grace home directory to the system-wide default locations (can be changed by the  --prefix  option during the configuration, see above).            2.2 Binary installation             Getting pre-built packages    Installation    Running tests       2.3 Alternative packaging schemes (RPM, ...)          Not written yet...      3. Getting started         For a jump-in start, you can browse the demos (""Help/Examples"" menu tree). Also, read the   Tutorial .    3.1 General concepts             Project files               A project file contains all information necessary to restore a plot created by Grace, as well as some of preferences. Each plot is represented on a single page, but may have an unlimited number of graphs.     Graphs               A graph consists of (every element is optional): a graph frame, axes, a title and a subtitle, a number of sets and additional annotative objects (time stamp string, text strings, lines, boxes and ellipses).  The graph type can be any of:     XY Graph    XY Chart    Polar Graph    Fixed Graph    Pie chart        Sets               A set is a way of representing numerical data (datasets). It consists of a pointer to a dataset plus a collection of parameters describing the visual appearance of the data (like color, line dash pattern etc).  The set type can be any of the following:           Set type   # of num. cols   Description   XY   2   An X-Y scatter and/or line plot, plus (optionally) an annotated value   XYDX   3   Same as XY, but with error bars (either one- or two-sided) along X axis   XYDY   3   Same as XYDX, but error bars are along Y axis   XYDXDX   4   Same as XYDX, but left and right error bars are defined separately   XYDYDY   4   Same as XYDXDX, but error bars are along Y axis   XYDXDY   4   Same as XY, but with X and Y error bars (either one- or two-sided)   XYDXDXDYDY   6   Same as XYDXDY, but left/right and upper/lower error bars are defined separately   BAR   2   Same as XY, but vertical bars are used instead of symbols   BARDY   3   Same as BAR, but with error bars (either one- or two-sided) along Y axis   BARDYDY   4   Same as BARDY, but lower and upper error bars are defined separately   XYHILO   5   Hi/Low/Open/Close plot   XYZ   3   Same as XY; makes no sense unless the annotated value is Z   XYR   3   X, Y, Radius. Only allowed in Fixed graphs   XYSIZE   3   Same as XY, but symbol size is variable   XYCOLOR   3   X, Y, color index (of the symbol fill)  XYCOLPAT   4   X, Y, color index, pattern index (currently used for Pie charts only)   XYVMAP   4   Vector map   XYBOXPLOT   6   Box plot (X, median, upper/lower limit, upper/lower whisker)                 Set types                    Not all set types, however, can be plotted on any graph type. The following table summarizes it:           Set type   XY Graph   XY Chart   Fixed   Polar   Pie   XY   +   +   +   +   +   XYDX   +   -   +   -   -   XYDY   +   +   +   -   -   XYDXDX   +   -   +   -   -   XYDYDY   +   +   +   -   -   XYDXDY   +   -   +   -   -   XYDXDXDYDY   +   -   +   -   -   BAR   +   +   +   -   -   BARDY   -   +   -   -   -   BARDYDY   -   +   -   -   -   XYHILO   +   -   -   -   -   XYZ   +   -   +   -   -   XYR   -   -   +   -   -   XYSIZE   +   +   +   +   -   XYCOLOR   +   +   +   +   +   XYCOLPAT   -   -   -   -   +   XYVMAP   +   -   +   -   -   XYBOXPLOT   +   -   -   -   -                 Graph/Set type connection                     Datasets             A dataset is a collection of points with x and y coordinates, up to four optional data values (which, depending on the set type, can be displayed as error bars or like) and one optional character string.   Regions               Regions are sections of the graph defined by the interior or exterior of a polygon, or a half plane defined by a line. Regions are used to restrict data transformations to a geometric area occupied by region.     Real Time Input               Real Time Input refers to the ability Grace has to be fed in real time by an external program. The Grace process spawned by the driver program is a full featured Grace process: the user can interact using the GUI at the same time the program sends data and commands. The process will adapt itself to the incoming data rate.     Hotlinks               Hotlinks are sources containing varying data. Grace can be instructed a file or a pipe is a hotlink in which case it will provide specific commands to refresh the data on a mouse click (a later version will probably allow automatic refresh).     File formats               Grace understands several input files formats. The most basic one is ASCII text files containing space and comma separated columns of data. The data fields can be either numeric (Fortran 'd' and 'D' exponent markers are supported) or alphanumeric (with or without quotes). Several calendar date formats are recognized automatically and you can specify your own reference for numeric dates formats. Grace also has a command language (see   command interpreter ), you can include commands in data files using lines having ""@"" as their first non-blank character. Depending on configuration, Grace can also read NetCDF files (see   configuration ).     Devices            Grace allows the user to choose between several output devices to produce its graphics. The current list of supported devices is:       X11    PostScript (level 1 and level 2)    EPS (encapsulated PostScript)    Metafile (which is Grace format, used at the moment mostly for debugging purposes)    MIF (Maker Interchange Format used by FrameMaker)    SVG (Scalable Vector Graphics, a language for describing two-dimensional vector and mixed vector/raster graphics in XML)    PDF (depends on extra libraries, see   configuration )    PNM (portable anymap file format)    JPEG (depends on extra libraries, see   configuration )    PNG (depends on extra libraries, see   configuration )       Note that Grace no longer supports GIF due to the copyright policy of Unisys. Grace can also be instructed to launch conversion programs automatically based on file name. As an example you can produce MIF (FrameMaker Interchange Format) or Java applets using pstoedit, or almost any image format using the netpbm suite (see the   FAQ ).     Magic path            In many cases, when Grace needs to access a file given with a relative  pathname , it searches for the file along the following path:  ./pathname:./.grace/pathname:~/.grace/pathname:$GRACE_HOME/pathname      Dynamic modules            Grace can access external functions present in either system or third-party shared libraries or modules specially compiled for use with it. The term dynamic refers to the possibility Grace has to open the library at run time to find the code of the external function, there is no need to recompile Grace itself (the functions already compiled in Grace are ""statically linked"").     Coordinate frames             There are two types of coordinates in Grace: the  world coordinates  and the  viewport coordinates . Points of data sets are defined in the world coordinates. The viewport coordinates correspond to the image of the plot drawn on the canvas (or printed on, say, PS output page). The transformation converting the world coordinates into the viewport ones is determined by both the graph type and the axis scaling.  Actually, there is yet another level in the hierarchy of coordinates - the  device coordinates . However, you (as a user of Grace) should not worry about the latter. The mapping between the viewport coordinates and the device coordinates is always set in such a way that the origin of the viewport corresponds to the left bottom corner of the device page, the smallest of the device dimensions corresponds to one unit in the viewport coordinates. Oh, and the most important thing about the viewport -> device transformation is that it is homotetic, i.e. a square is guaranteed to remain a square, not a rectangle, a circle remains a circle (not an ellipse) etc.  3.2 Invocation            Operational mode              With respect to the user interface, there are three modes of operation that Grace can be invoked in. The full-featured GUI-based version is called  xmgrace . A batch-printing version is called  gracebat . A command-line interface mode is called  grace . Usually, a single executable is called in all cases, with two of the three files being (symbolic) links to a ""real"" one.    Command line options                 -arrange  rows   cols   Arrange the graphs in a grid rows by cols     -autoscale  x|y|xy   Override any parameter file settings     -barebones  Turn off all toolbars     -batch  batch_file   Execute batch_file on start up     -block  block_data   Assume data file is block data     -bxy  x:y:etc.   Form a set from the current block data set using the current set type from columns given in the argument     -cols  gcols   Arrange graphs in gcols columns     -datehint  iso|european|us|days|seconds|nohint   Set the hint for dates analysis     -dpipe  descriptor   Read data from descriptor (anonymous pipe) on startup     -fixed  width   height   Set canvas size fixed to width*height     -free  Use free page layout     -graph  graph_number   Set the current graph number     -graphtype  graph_type   Set the type of the current graph     -hardcopy  No interactive session, just print and quit     -hdevice  hardcopy_device_name   Set default hardcopy device     -install  Install private colormap     -legend  load   Turn the graph legend on     -log  x|y|xy   Set the axis scaling of the current graph to logarithmic     -logwindow  Open the log window     -mono  Run Grace in monochrome mode (affects the display only)     -noask  Assume the answer is yes to all requests - if the operation would overwrite a file, Grace will do so without prompting     -noinstall  Don't use private colormap     -nologwindow  No log window, overrides resource setting     -noprint  In batch mode, do not print     -nosigcatch  Don't catch signals     -npipe  file   Read data from named pipe on startup     -nxy  nxy_file   Assume data file is in X Y1 Y2 Y3 ... format     -param  parameter_file   Load parameters from parameter_file to the current graph     -pexec  parameter_string   Interpret string as a parameter setting     -pipe  Read data from stdin on startup     -printfile  file  Save print output to file     -remove  Remove data file after read     -results  results_file   Write results of some data manipulations to results_file     -rows  grows   Arrange graphs in grows rows     -rvideo  Exchange the color indices for black and white     -saveall  save_file   Save all graphs to save_file     -seed  seed_value   Integer seed for random number generator     -source  disk|pipe   Source type of next data file     -timer  delay   Set allowed time slice for real time inputs to delay ms     -timestamp  Add timestamp to plot     -settype  xy|xydx|...   Set the type of the next data file     -version  Show the program version     -viewport  xmin ymin xmax ymax   Set the viewport for the current graph     -wd  directory   Set the working directory     -world  xmin ymin xmax ymax   Set the world coordinates for the current graph     -usage|-help  This message        3.3 Customization           Environment variables                GRACE_HOME  Set the location of Grace. This will be where help files, auxiliary programs, and examples are located. If you are unable to find the location of this directory, contact your system administrator.       GRACE_PRINT_CMD  Print command. If the variable is defined but is an empty string, ""Print to file"" will be selected as default.       GRACE_EDITOR  The editor used for manual editing of dataset values.       GRACE_HELPVIEWER  The HTML viewer for on-line browsing of help documents       GRACE_FFTW_WISDOM_FILE and GRACE_FFTW_RAM_WISDOM  These flags control behavior of the FFTW planner (see  FFTW tuning  for detailed info)           Init file          Upon start-up, Grace loads its init file,  gracerc . The file is searched for in the magic path (see  magic path ); once found, the rest of the path is ignored. It's recommended that in the  gracerc  file, one doesn't use statements which are part of a project file - such defaults, if needed, should be set in the default template (see   default template ).     Default template          Whenever a new project is started, Grace loads the default template,  templates/Default.agr . The file is searched for in the magic path (see    magic path ); once found, the rest of the path is ignored. It's recommended that in the default template, one doesn't use statements which are NOT part of a project file - such defaults, if needed, should be set in the  gracerc  (see   init file ).    X resources            The following Grace-specific X resource settings are supported:       XMgrace.invertDraw  Use GXinvert rather than GXxor for rubber-band lines. If the rubber-banding for zooms and lines, etc. doesn't appear on the canvas, set this resource to yes.      XMgrace.allowDoubleClick  When Yes, allow double clicks on the canvas to bring up various popups depending on  the location of the pointer when the double click occurs.      XMgrace.toolBar  Enables button toolbar      XMgrace.statusBar  Enables status bar      XMgrace.locatorBar  Enables locator bar         It is also possible to customize menus by assigning key accelerators to any item.  You'll need to derive the item's X resource name from the respective menu label, which is easily done following these rules:     All non-alphanumeric characters are skipped    Start with lower case; each new word (if any) continues from the capital letter    Add the item's type to the end - ""Menu"" for pulldown menus, ""Button"" for menu buttons.     For example, in order to make Grace popup the Non-linear curve fitting by pressing Control+F, you would add the following two lines  XMgrace*transformationsMenu.nonLinearCurveFittingButton.acceleratorText: Ctrl+F  XMgrace*transformationsMenu.nonLinearCurveFittingButton.accelerator: Ctrl<Key>f     to your  .Xresources  file (the file which is read when an X session starts; it could be  .Xdefaults ,  .Xsession  or some other file - ask your system administrator when in doubt).     4. Guide to menus and popups      (Not finished yet... Read the   Tutorial  as well).     4.1 File menu        The file menu contains all entries related to the input/output features of Grace.     New           Reset the state of Grace as if it had just started (one empty graph ranging from 0 to 1 along both axes). If some work has been done and not yet saved, a warning popup is displayed to allow canceling the operation.     Open           Open an existing   project file . A popup is displayed that allow to browse the file system.     Save           Save the current work in a project file, using the name that was used for the last open or save. If no name has been set (i.e., if the project has been created from scratch) act as   save as .     Save as           Save the current work in a project file with a new name. A popup allows to browse the file system and set the name, the format to use for saving data points (the default value is ""%16.8g""), and a textual description of the project. A warning is displayed if a file with the same name already exists.     Revert to saved           Abandon all modifications performed on the project since the last save. A confirmation popup is fired to allow the user canceling the operation.     Read menu              Sets              Read new sets of data in a graph. A   graph selector  is used to specify the graph where the data should go (except when reading block data, which are copied to graphs later on).  Reading as ""Single set"" means that if the source contains only one column of numeric data, one set will be created using the indices (from 1 to the total number of points) as abscissas and read values as ordinates and that if the source contains more than one column of data, the first two numeric columns will be used. Reading as ""NXY"" means that the first numeric column will provide the abscissas and all remaining columns will provide the ordinates of several sets. Reading as ""Block data"" means all column will be read and stored and that another popup will allow to select the abscissas and ordinates at will. It should be noted that block data are stored as long as you do not override them by a new read. You can still retrieve data from a block long after having closed all popups, using the   set          selector .  The set type can be one of the predefined set presentation types (see   sets ).  The data source can be selected as ""Disk"" or ""Pipe"". In the first case the text in the ""Selection"" field is considered to be a file name (it can be automatically set by the file selector at the top of the popup). In the latter case the text is considered to be a command which is executed and should produce the data on its standard output. On systems that allows is, the command can be a complete sequence of programs glued together with pipes.  If the source contains date fields, they should be automatically detected. Several formats are recognized (see appendix   dates in grace ). Calendar dates are converted to numerical dates upon reading.  The ""Autoscale on read"" menu controls whether, upon reading in new sets, which axes of the graph should be autoscaled.     NetCDF              This entry exists only if Grace has been compiled with support for the NetCDF data format (see   configuration ).     Parameters              Retrieve settings previously saved.     Write menu              Sets              Save data sets in a file. A   set          selector  is used to specify the set to be saved. The format to use for saving data points can be specified (the default value is ""%16.8g""). A warning is displayed if a file with the same name already exists.     Parameters              Save the parameters either for only the current graph or for all graphs.     Print           Print the project using the current printer settings     Device setup           Set the properties of the printing device. Each device has its own set of specific options (see   Device-specific       settings ). According to the device, the output can be sent either directly to a printer or directed to a file. The global settings available for all devices are the sizing parameters.     Exit           Exit from Grace. If some work has been done and not saved, a warning popup will be displayed to allow the user to cancel the operation.     4.2 Edit menu           Data sets           Using the data set popup, you can view the properties of datasets. This include its type, length, associated comment and main some statistics (min, max, mean, standard deviation). A horizontal scrollbar at the bottom allows to get the two last properties, they are not displayed by default. Also note that if you find some columns are too narrow to show all significant digits, you can drag the vertical rules using Shift+Button 2.     Set operations           The set operations popup allows you to interact with sets as a whole. If you want to operate on the data ordering of the sets, you should use the   data set operations  popup from the Data menu. The popup allows you to select a source (one set within one graph) and a destination and perform some action upon them (copy, move, swap). This popup also give you a quick access to several graph and set selectors if you want to perform some other operation like hiding a graph or creating a new set from block data.     Arrange graphs           This entry fires up a popup to lay out several graphs in a regular grid given rows and columns. The graphs can be packed together (either horizontally or vertically). New graphs are created if needed. An important note is that reducing the number of graphs never delete any graphs! If you select a 6 by 3 grid and then reduce it to 5 by 3, you will still have 18 graphs on your screen, three of them looking strange in the middle of the other ones. This is a security feature that prevent you from losing data accepting too quickly a wrong setting. If you really want to get rid of some of the graphs, you should hide or kill them using any graph selector you can find around (for example in the set operations presented above).  If you don't want the regular layout this arrangement gives you, you can change it afterwards using the mouse (select a graph and double click on the focus marker, see   clicks and double clicks ).     Overlay graphs           You can overlay a graph on top of another one. The main use of this feature is to plot several curves using different scales on the same (apparently) graph. The main difficulty is to be sure you operate on the graph you want at all times (you can hide one for a moment if this becomes too difficult).     Autoscale           Using this entry, you can autoscale one graph or all graphs according to the specified sets only. This is useful if you need either to have truly comparable graphs despite every one contains data of different ranges, or if you want to focus your attention on one set only while it is displayed with other data in a complex graph.     Regions menu              Status              This small popup only displays the current state (type and whether it is active or not) of the existing regions.     Define              You can define a new region (or redefine an existing one), the allowed region types are:       Inside polygon    Outside polygon    Above line    Below line    Left of line    Right of line    In horizontal range    In vertical range    Out of horizontal range    Out of vertical range     A region can be either linked to the current graph only or to all graphs.     Clear              This kills a region.     Report on              This popup reports you which sets or points are inside or outside of a region.     Hot links           You can link a set to a file or a pipe using this feature. Once a link has been established, you can update it (i.e., read data again) by clicking on the update button. If you have specified a command (using grace language) in the corresponding text field of the popup, it will be executed after each update. Note that you can use several commands separated by ';' characters.  Currently, only simple XY sets can be used for hotlinks.     Set locator fixed point           After having selected this menu entry, you can select a point on a graph that will be used as the origin of the locator display (just below the menu bar). The fixed point is taken into account only when the display type of the locator is set to [DX,DY].     Clear locator fixed point           This entry is provided to remove a fixed point set before and use the default again: point [0, 0].     Locator props           The locator props popup allows you to customize the display of the locator, mainly its type and the format and precision of the display. You can use all the formats that are allowed in the graphs scales.     Preferences           The preferences popup allows you to set miscellaneous properties of your grace session, such as GUI behavior, cursor type, date reading hint and reference date used for calendar conversions.     4.3 Data menu           Data set operations           This popup gathers all operations that are related to the ordering of data points inside a set or between sets. If you want to operate on the sets as a whole, you should use the   set operations  popup from the Edit menu. You can sort according to any coordinate (X, Y, DX, ...) in ascending or descending order, reverse the order of the points, join several sets into one, split one set into several others of equal lengths, or drop a range of points from a set. The   set selector  of the popup shows the number of points in each set in square brackets like this: G0.S0[63], the points are numbered from 0 to n-1.     Transformations menu           The transformations sub-menu gives you access to all data-mining features of Grace.     Evaluate expression              Using evaluate expression allows you to create a set by applying an explicit formula to another set, or to parts of another set if you use regions restrictions.  All the classical mathematical functions are available (cos, sin, but also lgamma, j1, erf, ...). As usual all trigonometric functions use radians by default but you can specify a unit if you prefer to say cos (x rad) or sin (3 * y deg). Other predefined names include pi (for the constant) and a, b, c and d for scratch arrays you can use to store data between evaluations.  In the formula, you can use X, Y, Y1, ..., Y4 to denote any coordinate you like from the source set. An implicit loop will be used around your formula so if you say:               x = x - 4966.5                you will shift all points of your set 4966.5 units to the left.  You can use more than one set in the same formula, like this:               y = y - 0.653 * sin (x deg) + s2.y                which means you use both X and Y from the source set but also the Y coordinate of set 2. Beware that the loop is a simple loop over the indices, all the sets you use in such an hybrid expression should therefore have the same number of points and point i of one set should really be related to point i of the other set. If your sets do not follow these requirements, you should first homogenize them using  interpolation .     Histograms              The histograms popup allows you to compute either standard or cumulative histograms from the Y coordinates of your data. You can select only a range using the start and end fields and you can specify the bin width.     Fourier transforms              This popup is devoted to direct and inverse Fourier transforms. The default is to perform a direct transform on unfiltered data and to produce a set with the index as abscissa and magnitude as ordinate. You can filter the input data window through triangular, Hanning, Welch, Hamming, Blackman and Parzen filters. You can load magnitude, phase or coefficients and use either index, frequency or period as abscissas. You can choose between direct and inverse Fourier transforms. If you specify real input data, X is assumed to be equally spaced and ignored; if you specify complex input data X is taken as the real part and Y as the imaginary part.  If Grace was configured with the FFTW library (see   configuration ), then the DFT and FFT buttons really perform the same transform (so there is no speed-up in using FFT in this case). If you want Grace can to use FFTW  wisdom  files, you should set several   environment variables  to name them.     Running averages              The running average popup allows you to compute some values on a sliding window over your data. You choose both the value you need (average, median, minimum, maximum, standard deviation) and the length of the window and perform the operation. You can restrict the operation to the points belonging to (or outside of) a region.     Differences              The differences popup is used to compute approximations of the first derivative of a function with finite differences. The only choice (apart from the source set of course) is the type of differences to use: forward, backward or centered.     Seasonal differences              The seasonal differences popup is used to subtract data from a period to data of the preceding period (namely y[i] - y[i + period]). Beware that the period is entered in terms of index in the set and not in terms of abscissa!     Integration              The integration popup is used to compute the integral of a set and optionally to load it. The numerical value of the integral is shown in the text field after computation. Selecting ""cumulative sum"" in the choice item will create and load a new set with the integral and compute the end value, selecting ""sum only"" will only compute the end value.     Interpolation              The interpolation popup is used to force the abscissas of one set to correspond exactly to the abscissas of another set. This is mainly used before performing some complex operations between the two sets with the   evaluate          expression  popup. Several interpolation methods can be used: linear, spline or Akima splines. Note that if the interpolated set is not wider than the reference set, some extremal points will be missing. You can check this with the number of points of each set (it appears in the set selectors of the popup). In this case you can perform a second run interpolating the reference set at the abscissas of the newly created set, this will remove the extra points.     Splines              Using the splines popup you can fit a part of a set with cubic or Akima splines. You select which part you want to operate on with the start and stop fields, they are both expressed in abscissa units. The number of points refer to the spline you want to create.     Regression              The regression popup can be used to fit a set against polynomials or some specific functions (y=A*x^B, y=A*exp(B*x), y=A+B*ln(x) and y=1/(A+Bx)) for which a simple transformation of input data can be used to apply linear regression formulas.  You can load either the fitted values, the residuals or the function itself. Choosing to load fitted values or residuals leads to a set of the same length and abscissas as the initial set. Choosing to load the function is almost similar to load the fitted values except that you choose yourself the boundaries and the number of points. This can be used for example to draw the curve outside of the data sample range or to produce an evenly spaced set from an irregular one.     Non-linear fit              The non linear fit popup can be used for functions outside of the simple regression methods scope. With this popup you provide the expression yourself using a0, a1, ..., a9 to denote the fit parameters (as an example you can say y = a0 * cos (a1 * x + a2)). You specify a tolerance, starting values and optional bounds and run several steps before loading the results.  The fit characteristics (number of parameters, formula, ...) can be saved in a file and retrieved as needed using the file menu of the popup.  In the ""Advanced"" tab, you can additionally apply a restriction to the set(s) to be fitted (thus ignoring points not satisfying the criteria), use one of preset weighting schemes or define your own, and choose whether to load the fitted values, the residuals or the function itself. Choosing to load fitted values or residuals leads to a set of the same length and abscissas as the initial set. Choosing to load the function is almost similar to load the fitted values except that you choose yourself the boundaries and the number of points. This can be used for example to draw the curve outside of the data sample range or to produce an evenly spaced set from an irregular one.     Cross/auto correlation              The correlation popup can be used to compute autocorrelation of one set or cross correlation between two sets. You only select the set (or sets) and specify the maximum lag.     Digital filter              You can use a set as a weight to filter another set. Only the Y part and the length of the weighting set are important, the X part is ignored.     Linear convolution              The convolution popup is used to ... convolve two sets. You only select the sets and apply.     Geometric transforms              You can rotate, scale or translate sets using the geometric transformations popup. You specify the characteristics of each transform and the application order.     Sample points              This popup provides two sampling methods. The first one is to choose a starting point and a step, the second one is to select only the points that satisfy a boolean expression you specify.     Prune data              This popup is devoted to reducing huge sets (and then saving both computation time and disk space).  The interpolation method can be applied only to ordered sets: it is based on the assumption that if a real point and an interpolation based on neighboring points are closer than a specified threshold, then the point is redundant and can be eliminated.  The geometric methods (circle, ellipse, rectangle) can be applied to any set, they test each point in turn and keep only those that are not in the neighborhood of previous points.       Feature extraction           Given a set of curves in a graph, extract a feature from each curve and use the values of the feature to provide the Y values for a new curve.         Feature   Description   Y minimum   Minimum Y value of set   Y maximum   Maximum Y value of set   Y average   Average Y value of set   Y std. dev.   Standard deviation of Y values   Y median   Median Y value   X minimum   Minimum X value of set   X maximum   Maximum X value of set   X average   Average X value of set   X std. dev.   Standard deviation of X values   X median   Median X value   Frequency   Perform DFT (FFT if set length a power of 2) to find largest frequency component   Period   Inverse of above   Zero crossing   Time of the first zero crossing, + or - going   Rise time   Assume curve starts at the minimum and rises to the maximum, get time to go from 10% to 90% of rise. For single exponential curves, this is 2.2*time constant   Fall time   Assume curve starts at the maximum and drops to the minimum, get time to go from 90% to 10% of fall   Slope   Perform linear regression to obtain slope   Y intercept   Perform linear regression to obtain Y-intercept   Set length   Number of data points in set   Half maximal width   Assume curve starts from the minimum, rises to the maximum and drops to the minimum again. Determine the time for which the curve is elevated more than 50% of the maximum rise.   Barycenter X   Barycenter along X axis   Barycenter Y   Barycenter along Y axis   X (Y max)   X of Maximum Y   Y (X max)   Y of Maximum X   integral   cumulative sum                   Extractable features                 4.4 Plot menu           Plot appearance           The plot appearance popup let you set the time stamp properties and the background color of the page. The color is used outside of graphs and also on graphs were no specific background color is set. The time stamp is updated every time the project is modified.     Graph appearance           The graph appearance popup can be displayed from both the plot menu and by double-clicking on a legend, title, or subtitle of a graph (see   Clicks and double clicks ). The graph selector at the top allows to choose the graph you want to operate on, it also allows certain common actions through its popup menu (see   graph selector ). The main tab includes the properties you will need more often (title for example), and other tabs are used to fine tune some less frequently used options (fonts, sizes, colors, placements).  If you need special characters or special formatting in your title or subtitle, you can use grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!     Set appearance           The set appearance popup can be displayed from both the plot menu and by double-clicking anywhere in a graph (see   Clicks and double clicks ). The set selector at the top allows to choose the set you want to operate on, it also allows certain common actions through its popup menu (see  set selector ). The main tab gathers the properties you will need more often (line and symbol properties or legend string for example), and other tabs are used to fine tune some less frequently used options (drop lines, fill properties, annotated values and error bars properties for example).  You should note that despite the legend string related to  one  set is entered in the set appearance popup, this is not sufficient to display it. Displaying  all  legends is a graph level decision, so the toggle is in the main tab of the   graph appearance  popup.  If you need special characters or special formatting in your legend, you can use grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!     Axis properties           The axis properties popup can be displayed from both the ""Plot"" menu and by double-clicking exactly on an axis (see   Clicks and double clicks ). The pulldown menu at the top allows to select the axis you want to operate on. The ""Active"" toggle globally activates or deactivates the axis (all GUI elements are insensitive for deactivated axes). The start and stop fields depict the displayed range. Three types of scales are available: linear, logarithmic or reciprocal, and you can invert the axis (which normally increases from left to right and from bottom to top).  The main tab includes the properties you will need more often (axis label, tick spacing and format for example), and other tabs are used to fine tune some less frequently used options (fonts, sizes, colors, placements, stagger, grid lines, special ticks, ...).  If you need special characters or special formatting in your label, you can use grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!  Once you have set the options as you want, you can apply them. One useful feature is that you can set several axes at once with the bottom pulldown menu (current axis, all axes current graph, current axis all graphs, all axes all graphs). Beware that you always apply the properties of all tabs, not only the selected one.     4.5 View menu           Show locator bar           This toggle item shows or hides the locator below the menu bar.     Show status bar           This toggle item shows or hides the status string below the canvas.     Show tool bar           This toggle item shows or hides the tool bar at the left of the canvas.     Redraw           This menu item triggers a redrawing of the canvas.     Update all           This menu item causes an update of all GUI controls. Usually, everything is updated automatically, unless one makes modifications by entering commands in the   Command  tool.       4.6 Window menu           Commands              Point tracking              Drawing objects              Font tool              Results                4.7 Help menu           On context           This function is not implemented yet.     User's guide           Browse the Grace user's guide.     Tutorial           Browse the Grace tutorial.     FAQ           Frequently Asked Questions with answers.     Changes           The list of changes during the Grace development.     Examples           The whole tree of submenus each loading a sample plot.     Comments           Use this to send your suggestions or bug reports.     License terms           Grace licensing terms will be displayed (GPL version 2).     About           A popup with basic info on the software, including some configuration details. More details can be found when running Grace with the ""-version"" command line flag.    5. GUI controls         5.1 List selectors           Various selectors are available in several popups. They all display lists of objects (graphs, sets, ...) and can be used to perform simple operations on these objects (copying, deleting, ...). The operations are available from a popup menu that appears when pressing mouse button 3 on them. Depending on the required functionality, they may allow multiple choices or not. The following shortcuts are enabled (if the result of an action would contradict the list's selection policy, this would be ignored):     Ctrl+a select all    Ctrl+u unselect all    Ctrl+i invert selection        Graph selector              The operations that can be performed on graphs through the graph selector's menu popup are:     focus to    hide    show    duplicate    kill    swap    create new     All this operations are not available in every instance of the selector. For example in the ""read sets"" popup only one graph can be selected at a time, and the swap operation is disabled.  Double-clicking on a list entry will switch the focus to that graph.     Set selector              The operations that can be performed on sets through the set selector are:     hide    show    bring to front    send to back    duplicate    kill    kill data    swap    edit     in spreadsheet    in text editor        create new     by formula    in spreadsheet    in text editor    from block data        pack all sets    selector operations     view set comments    show data-less    show hidden    select all    unselect all    invert selection    update             6. Canvas actions           6.1 Hotkeys          When the pointer focus is on the canvas (where the graph is drawn), there are some shortcuts to activate several actions. They are:       Ctrl <Key>A: Autoscale    Ctrl <Key>D: Delete an object    Ctrl <Key>L: Move current graph legend    Ctrl <Key>M: Move an object    Ctrl <Key>T: Place timestamp    Ctrl <Key>U: Refresh hotlinks    Ctrl <Key>V: Set the viewport with mouse    Ctrl <Key>Z: Zoom    Ctrl Alt <Key>L: Draw a line    Ctrl Alt <Key>B: Draw a box    Ctrl Alt <Key>E: Draw an ellipse    Ctrl Alt <Key>T: Write a text string        6.2 Clicks and double clicks          A single click inside a graph switches focus to that graph. This is the default policy, but it can be changed from the ""Edit/Preferences"" popup.      Double clicking on parts of the canvas will invoke certain actions or raise some popups:       on a focus marker: move selected viewport corner     on an axis:  ""Axis properties"" popup    on a set:    ""Set appearance"" popup    on a legend: ""Graph appearance"" popup    on a (sub)title: ""Graph appearance"" popup    on an object (box, line, ...): a popup for editing properties of that object     The double clicking actions can be enabled/disabled from the ""Edit/Preferences"" popup.      7. Command interpreter            7.1 General notes        The interpreter parses its input in a line-by-line manner. There may be several statements per line, separated by semicolon ( ; ). The maximal line length is 4 kbytes (hardcoded). The parser is case-insensitive.  7.2 Definitions             Name   Description   Examples   expr  Any numeric expression  1.5 + sin(2)   iexpr  Any expression that evaluates to an integer  25, 0.1 + 1.9, PI/asin(1)   nexpr  Non-negative iexpr  2 - 1   indx  Non-negative iexpr      qstr  Quoted string  ""a string""                         Basic types                 Expression   Description   Types   Example   GRAPH[ id ]  graph  id   indx  id   GRAPH[0]   G nn   graph  nn   nn : 0-99  G0                         Graph selections                 Expression   Description   Types   Example    graph .SETS[ id ]  set  id  in graph  graph indx  id , graphsel  graph   GRAPH[0].SETS[1]    graph .S nn   set  nn  in graph  graph nn : 0-99, graphsel  graph   G0.S1   SET[ id ]  set  id  in the current graph indx  id   SET[1]   S nn   set  nn  in the current graph nn : 0-99  S1                         Set selections                 Expression   Description   Types   Example   COLOR  ""colorname""   a mapped color  colorname   -  COLOR ""red""   COLOR  id   a mapped color with ID  id   nexpr  id   COLOR 2                         Color selections                 Expression   Description   Types   Example   PATTERN  id   pattern with ID  id   nexpr  id   PATTERN 1                         Pattern selections                 Expression   Description   Types   Example   X  the first column  -  X   Y  the second column  -  Y   Y n   ( n  + 2)-th column  n  = 0 - 4  Y3                         Data column selections            Not finished yet...  7.3 Variables               Variable   Description   datacolumn   data column of current set   set.datacolumn   data column of set   vvar   user-defined array                         Vector variables                     Variable   Description   vvariable[i]   i-th element of a vector variable   var   user-defined variable                         Scalar variables                7.4 Numerical operators and functions          In numerical expressions, the infix format is used. Arguments of both operators and functions can be either scalars or vector arrays.           Operator   Description   +   addition   -   substraction   *   multiplication   /   division   %   modulus   ^   raising to power                         Arithmetic operators                     Operator   Description   AND or &&   logical AND   OR or ||   logical OR   NOT or !   logical NOT                         Logical operators                     Operator   Description   EQ or ==   equal   NE or !=   not equal   LT or <   less than   LE or <=   less than or equal   GT or >   greater than   GE or >=   greater than or equal                         Comparison operators                     Function   Description   abs(x)   absolute value   acos(x)   arccosine   acosh(x)   hyperbolic arccosine   asin(x)   arcsine   asinh(x)   hyperbolic arcsine   atan(x)   arctangent   atan2(y,x)   arc tangent of two variables   atanh(x)   hyperbolic arctangent   ceil(x)   greatest integer function   cos(x)   cosine   cosh(x)   hyperbolic cosine   exp(x)   e^x   fac(n)   factorial function, n!   floor(x)   least integer function   irand(n)   random integer less than n   ln(x)   natural log   log10(x)   log base 10   log2(x)   base 2 logarithm of x   maxof(x,y)   returns greater of x and y   minof(x,y)   returns lesser of x and y   mod(x,y)   mod function (also x % y)   pi   the PI constant   rand   pseudo random number distributed uniformly on (0.0,1.0)   rint(x)   round to closest integer   sin(x)   sine function   sinh(x)   hyperbolic sine   sqr(x)   x^2   sqrt(x)   x^0.5   tan(x)   tangent function   tanh(x)   hyperbolic tangent                         Functions                 Function   Description   chdtr(df, x)   chi-square distribution   chdtrc(v, x)   complemented Chi-square distribution   chdtri(df, y)   inverse of complemented Chi-square distribution   erf(x)   error function   erfc(x)   complement of error function   fdtr(df1, df2, x)   F distribution function   fdtrc(x)   complemented F distribution   fdtri(x)   inverse of complemented F distribution   gdtr(a, b, x)   gamma distribution function   gdtrc(a, b, x)   complemented gamma distribution function   ndtr(x)   Normal distribution function   ndtri(x)   inverse of Normal distribution function   norm(x)   gaussian density function   pdtr(k, m)   Poisson distribution   pdtrc(k, m)   complemented Poisson distribution   pdtri(k, y)   inverse Poisson distribution   rnorm(xbar,s)   pseudo random number distributed N(xbar,s)   stdtr(k, t)   Student's t distribution   stdtri(k, p)   functional inverse of Student's t distribution                         Statistical functions                 Function   Description   ai(x), bi(x)   Airy functions (two independent solutions of the differential equation  y''(x) = xy )   beta(x)   beta function   chi(x)   hyperbolic cosine integral   ci(x)   cosine integral   dawsn(x)   Dawson's integral   ellie(phi, m)   incomplete elliptic integral of the second kind   ellik(phi, m)   incomplete elliptic integral of the first kind   ellpe(m)   complete elliptic integral of the second kind   ellpk(m)   complete elliptic integral of the first kind   expn(x)   exponential integral   fresnlc(x)   cosine Fresnel integral   fresnls(x)   sine Fresnel integral   gamma(x)   gamma function   hyp2f1(a, b, c, x)   Gauss hyper-geometric function   hyperg(a, b, x)   confluent hyper-geometric function   i0e(x)   modified Bessel function of order zero, exponentially scaled   i1e(x)   modified Bessel function of order one, exponentially scaled   igam(a, x)   incomplete gamma integral   igamc(a, x)   complemented incomplete gamma integral   igami(a, p)   inverse of complemented incomplete gamma integral   incbet(a, b, x)   incomplete beta integral   incbi(a, b, y)   Inverse of incomplete beta integral   iv(v, x)   modified Bessel function of order v   jv(v, x)   Bessel function of order v   k0e(x)   modified Bessel function, third kind, order zero, exponentially scaled   k1e(x)   modified Bessel function, third kind, order one, exponentially scaled   kn(n, x)   modified Bessel function, third kind, integer order   lbeta(x)   natural log of |beta(x)|   lgamma(x)   log of gamma function   psi(x)   psi (digamma) function   rgamma(x)   reciprocal gamma function   shi(x)   hyperbolic sine integral   si(x)   sine integral   spence(x)   dilogarithm   struve(v, x)   Struve function   yv(v, x)   Bessel function of order v   zeta(x, q)   Riemann zeta function of two arguments   zetac(x)   Riemann zeta function                         Special math functions              7.5 Procedures            Not written yet...      7.6 Device parameters               Command   Description   PAGE SIZE xdim, ydim   set page dimensions (in pp) of all devices   DEVICE  ""devname""  PAGE SIZE xdim, ydim   set page dimensions (in pp) of device  devname    DEVICE  ""devname""  DPI dpi   set device's dpi (dots per pixel)   DEVICE  ""devname""  FONT onoff   enable/disable usage of built-in fonts for device  devname    DEVICE  ""devname""  FONT ANTIALIASING onoff   enable/disable font aliasing for device  devname    DEVICE  ""devname""  OP  ""options""    set device specific options (see   Device-specific settings )   HARDCOPY DEVICE  ""devname""    set device  devname  as current hardcopy device                         Device parameters              7.7 Flow control             Statement   Description   Types   Example   SLEEP  n   sleep for  n  seconds  expr  n   SLEEP(3)   EXIT( status )  causes normal program termination with exit status  status   iexpr  status   EXIT(0)   EXIT  causes normal program termination; same as EXIT(0)     EXIT                         Flow control            7.8 Declarations             Statement   Description   Types   Example   DEFINE  var   define new scalar variable  var      DEFINE myvar   DEFINE  vvar []  define new vector variable  vvar  of zero length     DEFINE myvvar[]   DEFINE  vvar [ n ]  define new vector variable  vvar  of length  n   nexpr  n   DEFINE myvvar[10]   CLEAR  var   undefine new variable  var  and deallocate associated storage     CLEAR myvar    vvar  LENGTH  n   reallocate vector variable  vvar   nexpr  n   myvvar LENGTH 25                         User variables            Not written yet...  7.9 Graph properties          Not written yet...    7.10 Set properties          Not written yet...    8. Advanced topics           8.1 Fonts        For all devices, Grace uses Type1 fonts. Both PFA (ASCII) and PFB (binary) formats can be used.    Font configuration          The file responsible for the font configurations of Grace is  fonts/FontDataBase . The first line contains a positive integer specifying the number of fonts declared in that file. All remaining lines contain declarations of one font each, composed out of three fields:     Font name. The name will appear in the font selector controls. Also, backend devices that has built-in fonts, will be given the name as a font identifier.    Font fall-back. Grace will try to use this in case the real font is not found.    Font filename. The file with the font outline data.     Here is the default  FontDataBase  file:      14 Times-Roman             Times-Roman             n021003l.pfb Times-Italic            Times-Italic            n021023l.pfb Times-Bold              Times-Bold              n021004l.pfb Times-BoldItalic        Times-BoldItalic        n021024l.pfb Helvetica               Helvetica               n019003l.pfb Helvetica-Oblique       Helvetica-Oblique       n019023l.pfb Helvetica-Bold          Helvetica-Bold          n019004l.pfb Helvetica-BoldOblique   Helvetica-BoldOblique   n019024l.pfb Courier                 Courier                 n022003l.pfb Courier-Oblique         Courier-Oblique         n022023l.pfb Courier-Bold            Courier-Bold            n022004l.pfb Courier-BoldOblique     Courier-BoldOblique     n022024l.pfb Symbol                  Symbol                  s050000l.pfb ZapfDingbats            ZapfDingbats            d050000l.pfb                   Font data files        For text rastering, three types of files are used.      .pfa -/ .pfb -files: These contain the character outline descriptions. The files are assumed to be in the  fonts/type1  directory; these are the filenames specified in the  FontDataBase  configuration file.     .afm -files: These contain high-precision font metric descriptions as well as some extra information, such as kerning and ligature information for a particular font. It is assumed that the filename of a font metric file has same basename as the respective font outline file, but with the  .afm  extension; the metric files are expected to be found in the  fonts/type1  directory, too.     .enc -files: These contain encoding arrays in a special but simple form. They are only needed if someone wants to load a special encoding to re-encode a font. Their place is  fonts/enc       Custom fonts          It is possible to use custom fonts with Grace. One mostly needs to use extra fonts for the purpose of localization. For many European languages, the standard fonts supplied with Grace should contain all the characters needed, but encoding may have to be adjusted. This is done by putting a  Default.enc  file with proper encoding scheme into the  fonts/enc  directory. Grace comes with a few encoding files in the directory; more can be easily found on the Internet. (If the  Default.enc  file doesn't exist, the IsoLatin1 encoding will be used). Notice that for fonts having an encoding scheme in themselves (such as the Symbol font, and many nationalized fonts) the default encoding is ignored.  If you do need to use extra fonts, you should modify the  FontDataBase  file accordingly, obeying its format. However, if you are going to exchange Grace project files with other people who do not have the extra fonts configured, an important thing is to define reasonable fall-back font names.  For example, let us assume I use Hebrew fonts, and the configuration file has lines like these:          ... Courier-Hebrew              Courier                 courh___.pfa Courier-Hebrew-Oblique      Courier-Oblique         courho__.pfa     ...               My colleague, who lives in Russia, uses Cyrillic fonts with Grace configured like this:          ... Cronix-Courier              Courier                 croxc.pfb Cronix-Courier-Oblique      Courier-Oblique         croxco.pfb     ...               The font mapping information (Font name <-> Font fall-back) is stored in the Grace project files. Provided that all the localized fonts have English characters in the lower part of the ASCII table unmodified, I can send my friend files (with no Hebrew characters, of course) and be sure they render correctly on his computer.  Thus, with properly configured national fonts, you can make localized annotations for plots intended for internal use of your institution, while being able to exchange files with colleagues from abroad. People who ever tried to do this with MS Office applications should appreciate the flexibility :-).    8.2 Interaction with other applications            Using pipes              Using grace_np library          The grace_np library is a set of compiled functions that allows you to launch and drive a Grace subprocess from your C or Fortran application. Functions are provided to start the subprocess, to send it commands or data, to stop it or detach from it.       Function   Arguments   Description   int GraceOpen   (int  buf_size )  launch a Grace subprocess and open a communication channel with it   int GraceIsOpen   (void)   test if a Grace subprocess is currently connected   int GraceClose   (void)   close the communication channel and exit the Grace subprocess   int GraceClosePipe   (void)   close the communication channel and leave the Grace subprocess alone   int GraceFlush   (void)   flush all the data remaining in the buffer   int GracePrintf   (const char*  format , ...)  format a command and send it to the Grace subprocess   int GraceCommand   (const char*  cmd )  send an already formated command to the Grace subprocess   GraceErrorFunctionType GraceRegisterErrorFunction  (GraceErrorFunctionType  f )  register a user function  f  to display library errors                 grace_np library C functions.                 Function   Arguments   Description   integer GraceOpenF   (integer  buf_size )  launch a Grace subprocess and open a communication channel with it   integer GraceIsOpenF   (void)   test if a Grace subprocess is currently connected   integer GraceCloseF   (void)   close the communication channel and exit the Grace subprocess   integer GraceClosePipeF   (void)   close the communication channel and leave the Grace subprocess alone   integer GraceFlushF   (void)   flush all the data remaining in the buffer   integer GraceCommandF   (character*(*)  cmd )  send an already formatted command to the Grace subprocess   GraceFortranFunctionType GraceRegisterErrorFunctionF  (GraceFortranFunctionType  f )  register a user function  f  to display library errors                 grace_np library F77 functions.               There is no fortran equivalent for the GracePrintf function, you should format all the data and commands yourself before sending them with GraceCommandF.  The Grace subprocess listen for the commands you send and interpret them as if they were given in a batch file. You can send any command you like (redraw, autoscale, ...). If you want to send data, you should include them in a command like ""g0.s0 point 3.5, 4.2"".  Apart from the fact it monitors the data sent via an anonymous pipe, the Grace subprocess is a normal process. You can interact with it through the GUI. Note that no error can be sent back to the parent process. If your application send erroneous commands, an error popup will be displayed by the subprocess.  If you exit the subprocess while the parent process is still using it, the broken pipe will be detected. An error code will be returned to every further call to the library (but you can still start a new process if you want to manage this situation).  Here is an example use of the library, you will find this program in the distribution.        #include <stdlib.h> #include <stdio.h> #include <unistd.h> #include ""grace_np.h""  #ifndef EXIT_SUCCESS #  define EXIT_SUCCESS 0 #endif  #ifndef EXIT_FAILURE #  define EXIT_FAILURE -1 #endif  void my_error_function(const char *msg) {     fprintf(stderr, ""library message: \""%s\""\n"", msg); }  int main(int argc, char* argv[]) {     int i;      GraceRegisterErrorFunction(my_error_function);      /* Start Grace with a buffer size of 2048 and open the pipe */     if (GraceOpen(2048) == -1) {         fprintf(stderr, ""Can't run Grace. \n"");         exit(EXIT_FAILURE);     }          /* Send some initialization commands to Grace */     GracePrintf(""world xmax 100"");     GracePrintf(""world ymax 10000"");     GracePrintf(""xaxis tick major 20"");     GracePrintf(""xaxis tick minor 10"");     GracePrintf(""yaxis tick major 2000"");     GracePrintf(""yaxis tick minor 1000"");     GracePrintf(""s0 on"");     GracePrintf(""s0 symbol 1"");     GracePrintf(""s0 symbol size 0.3"");     GracePrintf(""s0 symbol fill pattern 1"");     GracePrintf(""s1 on"");     GracePrintf(""s1 symbol 1"");     GracePrintf(""s1 symbol size 0.3"");     GracePrintf(""s1 symbol fill pattern 1"");      /* Display sample data */     for (i = 1; i <= 100 && GraceIsOpen(); i++) {         GracePrintf(""g0.s0 point %d, %d"", i, i);         GracePrintf(""g0.s1 point %d, %d"", i, i * i);         /* Update the Grace display after every ten steps */         if (i % 10 == 0) {             GracePrintf(""redraw"");             /* Wait a second, just to simulate some time needed for                calculations. Your real application shouldn't wait. */             sleep(1);         }     }      if (GraceIsOpen()) {         /* Tell Grace to save the data */         GracePrintf(""saveall \""sample.agr\"""");          /* Flush the output buffer and close Grace */         GraceClose();          /* We are done */         exit(EXIT_SUCCESS);     } else {         exit(EXIT_FAILURE);     } }           8.3 FFTW tuning        When the FFTW capabilities are compiled in, Grace looks at two environment variables to decide what to do with the FFTW 'wisdom' capabilities.  First, a quick summary of what this is. The FFTW package is capable of adaptively determining the most efficient factorization of a set to give the fastest computation.  It can store these factorizations as 'wisdom', so that if a transform of a given size is to be repeated, it is does not have to re-adapt.  The good news is that this seems to work very well.  The bad news is that, the first time a transform of a given size is computed, if it is not a sub-multiple of one already known, it takes a LONG time (seconds to minutes).  The first environment variable is GRACE_FFTW_WISDOM_FILE. If this is set to the name of a file which can be read and written (e.g., $HOME/.grace_fftw_wisdom) then Grace will automatically create this file (if needed) and maintain it. If the file is read-only, it will be read, but not updated with new wisdom. If the symbol GRACE_FFTW_WISDOM_FILE either doesn't exist, or evaluates to an empty string, Grace will drop the use of wisdom, and will use the fftw estimator (FFTW_ESTIMATE flag sent to the planner) to guess a good factorization, instead of adaptively determining it.  The second variable is GRACE_FFTW_RAM_WISDOM. If this variable is defined to be non-zero, and GRACE_FFTW_WISDOM_FILE variable is not defined (or is an empty string), Grace will use wisdom internally, but maintain no persistent cache of it. This will result in very slow execution times the first time a transform is executed after Grace is started, but very fast repeats. I am not sure why anyone would want to use wisdom without writing it to disk, but if you do, you can use this flag to enable it.       8.4 DL modules         Grace can access external functions present in either system or third-party shared libraries or modules specially compiled for use with Grace.    Function types        One must make sure, however, that the external function is of one of supported by Grace types:     Grace type   Description   f_of_i   a function of 1  int  variable   f_of_d   a function of 1  double  variable   f_of_nn   a function of 2  int  parameters   f_of_nd   a function of 1  int  parameter and 1  double  variable   f_of_dd   a function of 2  double  variables   f_of_nnd   a function of 2  int  parameters and 1  double  variable   f_of_ppd   a function of 2  double  parameters and 1  double  variable   f_of_pppd   a function of 3  double  parameters and 1  double  variable                                     Grace types for external functions            The return values of functions are assumed to be of the  double  type.  Note, that there is no difference from the point of view of function prototype between parameters and variables; the difference is in the way Grace treats them - an attempt to use a vector expression as a parameter argument will result in a parse error.  Let us consider few examples.    Examples           Caution: the examples provided below (paths and compiler flags) are valid for Linux/ELF with gcc. On other operating systems, you may need to refer to compiler/linker manuals or ask a guru.    Example 1           Suppose I want to use function  pow(x,y)  from the Un*x math library (libm). Of course, you can use the ""^"" operator defined in the Grace language, but here, for the sake of example, we want to access the function directly.  The command to make it accessible by Grace is   USE ""pow"" TYPE f_of_dd FROM ""/usr/lib/libm.so""    Try to plot y = pow(x,2) and y = x^2 graphs (using, for example, ""create new -> Formula"" from any   set        selector ) and compare.    Example 2           Now, let us try to write a function ourselves. We will define function  my_function  which simply returns its (second) argument multiplied by integer parameter transferred as the first argument.  In a text editor, type in the following C code and save it as ""my_func.c"":               double my_function (int n, double x)        {            double retval;            retval = (double) n * x;            return (retval);        }                OK, now compile it:               $gcc -c -fPIC my_func.c        $gcc -shared my_func.o -o /tmp/my_func.so                (You may strip it to save some disk space):               $strip /tmp/my_func.so                That's all! Ready to make it visible to Grace as ""myf"" - we are too lazy to type the very long string ""my_function"" many times.     USE ""my_function"" TYPE f_of_nd FROM ""/tmp/my_func.so"" ALIAS ""myf""        Example 3           A more serious example. There is a special third-party library available on your system which includes a very important for you yet very difficult-to-program from the scratch function that you want to use with Grace.  But, the function prototype is NOT one of any predefined   types .  The solution is to write a simple function wrapper. Here is how:  Suppose, the name of the library is ""special_lib"" and the function you are interested in is called ""special_func"" and according to the library manual, should be accessed as  void special_func(double *input, double *output, int parameter) . The wrapper would look like this:               double my_wrapper(int n, double x)        {            extern void special_func(double *x, double *y, int n);            double retval;            (void) special_func(&x, &retval, n);            return (retval);        }                Compile it:               $gcc -c -fPIC my_wrap.c        $gcc -shared my_wrap.o -o /tmp/my_wrap.so -lspecial_lib -lblas        $strip /tmp/my_wrap.so                Note that I added  -lblas  assuming that the special_lib library uses some functions from the BLAS. Generally, you have to add  all  libraries which your module depends on (and all libraries those libraries rely upon etc.), as if you wanted to compile a plain executable.  Fine, make Grace aware of the new function     USE ""my_wrapper"" TYPE f_of_nd FROM ""/tmp/my_wrap.so"" ALIAS ""special_func""    so we can use it with its original name.    Example 4           An example of using Fortran modules.  Here we will try to achieve the same functionality as in Example 2, but with the help of F77.               DOUBLE PRECISION FUNCTION MYFUNC (N, X)        IMPLICIT NONE        INTEGER N        DOUBLE PRECISION X C        MYFUNC = N * X C        RETURN        END                As opposite to C, there is no way to call such a function from Grace directly - the problem is that in Fortran all arguments to a function (or subroutine) are passed by reference. So, we need a wrapper:               double myfunc_wrapper(int n, double x)        {            extern double myfunc_(int *, double *);            double retval;            retval = myfunc_(&n, &x);            return (retval);        }                Note that most of f77 compilers by default add underscore to the function names and convert all names to the lower case, hence I refer to the Fortran function  MYFUNC  from my C wrapper as  myfunc_ , but in your case it can be different!  Let us compile the whole stuff:               $g77 -c -fPIC myfunc.f        $gcc -c -fPIC myfunc_wrap.c        $gcc -shared myfunc.o myfunc_wrap.o -o /tmp/myfunc.so -lf2c -lm        $strip /tmp/myfunc.so                And finally, inform Grace about this new function:     USE ""myfunc_wrapper"" TYPE f_of_nd FROM ""/tmp/myfunc.so"" ALIAS ""myfunc""      Operating system issues               OS/2              In general the method outlined in the examples above can be used on OS/2, too. However you have to create a DLL (Dynamic Link Library) which is a bit more tricky on OS/2 than on some un*x systems.  This document can't explain the whole procedure in detail but roughly describes the way to go. Since Grace was ported with EMX we also use it to create the examples, however other development environments should work as well. We refer to Example 2, since Example 1 is showing a problem on OS/2: DLLs might have their entry points (i.e. exported functions) callable as ordinals only, so you might not know how to access a specific function without some research.  First compile my_func.c to my_func.obj     gcc -Zomf -Zmt -c my_func.c    Then you need to create a linker definition file my_func.def which gives some basic info about the DLL and declares the exported functions.                 LIBRARY my_func INITINSTANCE TERMINSTANCE          CODE LOADONCALL          DATA LOADONCALL MULTIPLE NONSHARED          DESCRIPTION 'This is a test DLL: my_func.dll'          EXPORTS          my_function                  (don't forget about the 8 characters limit on the DLL name!). Finally link the DLL:     gcc my_func.obj my_func.def -o my_func.dll -Zdll -Zno-rte -Zmt -Zomf    (the -Zno-rte flag depends on the content of the library; check out the EMX documentation about this as well as  the other compiler/linker flags used here!) To use these new library function in Grace you may either put the DLL in the LIBPATH and use the short form:     USE ""my_function"" TYPE f_of_nd FROM ""my_func"" ALIAS ""myf""    or have it in an arbitrary path which you need to specify explicitly then:     USE ""my_function"" TYPE f_of_nd FROM ""e:/foo/my_func.dll"" ALIAS ""myf""      9. References            9.1 Typesetting        Grace permits quite complex typesetting on a per string basis. Any string displayed (titles, legends, tick marks,...) may contain special control codes to display subscripts, change fonts within the string etc.         Control code   Description   \f{x}   switch to font named ""x""   \f{n}   switch to font number n   \f{}   return to original font   \R{x}   switch to color named ""x""   \R{n}   switch to color number n   \R{}   return to original color   \#{x}   treat ""x"" (must be of even length) as list of hexadecimal char codes   \t{xx xy yx yy}   apply transformation matrix   \t{}   reset transformation matrix   \z{x}   zoom x times   \z{}   return to original zoom   \r{x}   rotate by x degrees   \l{x}   slant by factor x   \v{x}   shift vertically by x   \v{}   return to unshifted baseline   \h{x}   horizontal shift by x   \u   begin underline   \U   stop underline   \o   begin overline   \O   stop overline   \Fk   enable kerning   \FK   disable kerning   \Fl   enable ligatures   \FL   disable ligatures   \m{n}   mark current position as n   \M{n}   return to saved position n   \dl   LtoR substring direction   \dr   RtoL substring direction   \dL   LtoR text advancing   \dR   RtoL text advancing   \x   switch to Symbol font (same as \f{Symbol})   \+   increase size (same as \z{1.19} ; 1.19 = sqrt(sqrt(2)))   \-   decrease size (same as \z{0.84} ; 0.84 = 1/sqrt(sqrt(2)))   \s   begin subscripting (same as \v{-0.4}\z{0.71})   \S   begin superscripting (same as \v{0.6}\z{0.71})   \T{xx xy yx yy}   same as \t{}\t{xx xy yx yy}   \Z{x}   absolute zoom x times (same as \z{}\z{x})   \q   make font oblique (same as \l{0.25})   \Q   undo oblique (same as \l{-0.25})   \N   return to normal style (same as \v{}\t{})   \\   print \   \n   switch to font number n (0-9) (deprecated)   \c   begin using upper 128 characters of set (deprecated)   \C   stop using upper 128 characters of set (deprecated)                                     Control codes.              Example:  F\sX\N(\xe\f{}) = sin(\xe\f{})\#{b7}e\S-X\N\#{b7}cos(\xe\f{})   prints roughly                           -x        F (e) = sin(e)·e  ·cos(e)         x              using string's initial font and e prints as epsilon from the Symbol font.  NOTE: Characters from the upper half of the char table can be entered directly from the keyboard, using appropriate  xmodmap(1)  settings, or with the help of the font tool (""Window/Font tool"").       9.2 Device-specific limitations          Grace can output plots using several device backends. The list of available devices can be seen (among other stuff) by specifying the ""-version"" command line switch.     X11, PostScript and EPS are full-featured devices    Raster drivers (PNM/JPEG/PNG):     only even-odd fill rule is supported    patterned lines are not implemented        PDF driver:     patterned fills are not implemented    bitmapped text strings are not transparent    arcs of angles != 90*n are approximated very roughly        MIF driver: the driver is a brand new one and still in beta test     some of patterned fills not implemented    bitmapped text strings not implemented        SVG driver: the driver is a brand new one and still in beta test, one should also be aware that SVG is still a W3C working draft, not yet a recommendation (see the   Scalable Vector Graphics (SVG) 1.0 Specification )     patterned fills not implemented    bitmapped text strings not implemented                9.3 Device-specific settings          Some of the output devices accept several configuration options. You can set the options by passing a respective string to the interpreter using the ""DEVICE  ""devname""  OP  ""options"" "" command (see  Device parameters ). A few options can be passed in one command, separated by commas.           Command   Description   grayscale   set grayscale output   color   set color output   level1   use only PS Level 1 subset of commands   level2   use also PS Level 2 commands if needed   xoffset: x    set page offset in X direction  x  pp   yoffset: y    set page offset in Y direction  y  pp   mediafeed:auto   default input tray   mediafeed:match   select input with media matching page dimensions   mediafeed:manual   manual media feed   hwresolution:on   set hardware resolution   hwresolution:off   do not set hardware resolution                   PostScript driver options                     Command   Description   grayscale   set grayscale output   color   set color output   level1   use only PS Level 1 subset of commands   level2   use also PS Level 2 commands if needed   bbox:tight   enable ""tight"" bounding box   bbox:page   bounding box coincides with page dimensions                   EPS driver options                     Command   Description   PDF1.2   set compatibility mode to PDF-1.2   PDF1.3   set compatibility mode to PDF-1.3   compression:value   set compression level (0 - 9)                   PDF driver options                     Command   Description   format:pbm   output in PBM format   format:pgm   output in PGM format   format:ppm   output in PPM format   rawbits:on   ""rawbits"" (binary) output   rawbits:off   ASCII output                   PNM driver options                     Command   Description   grayscale   set grayscale output   color   set color output   optimize:on/off   enable/disable optimization   quality:value   set compression quality (0 - 100)   smoothing:value   set smoothing (0 - 100)   baseline:on/off   do/don't force baseline output   progressive:on/off   do/don't output in progressive format   dct:ifast   use fast integer DCT method   dct:islow   use slow integer DCT method   dct:float   use floating-point DCT method                   JPEG driver options                     Command   Description   interlaced:on   make interlaced image   interlaced:off   don't make interlaced image   transparent:on   produce transparent image   transparent:off   don't produce transparent image   compression:value   set compression level (0 - 9)                   PNG driver options                     9.4 Dates in Grace         We use two calendars in Grace: the one that was established in 532 by Denys and lasted until 1582, and the one that was created by Luigi Lilio (Alyosius Lilius) and Christoph Klau (Christophorus Clavius) for pope Gregorius XIII. Both use the same months (they were introduced under emperor Augustus, a few years after Julian calendar introduction, both Julius and Augustus were honored by a month being named after each one).  The leap years occurred regularly in Denys's calendar: once every four years, there is no year 0 in this calendar (the leap year -1 was just before year 1). This calendar was not compliant with earth motion and the dates were slowly shifting with regard to astronomical events.  This was corrected in 1582 by introducing Gregorian calendar. First a ten days shift was introduced to reset correct dates (Thursday October the 4th was followed by Friday October the 15th). The rules for leap years were also changed: three leap years are removed every four centuries. These years are those that are multiple of 100 but not multiple of 400: 1700, 1800, and 1900 were not leap years, but 1600 and 2000 were (will be) leap years.  We still use Gregorian calendar today, but we now have several time scales for increased accuracy. The International Atomic Time (TAI) is a linear scale: the best scale to use for scientific reference. The Coordinated Universal Time (UTC, often confused with Greenwich Mean Time) is a legal time that is almost synchronized with earth motion. However, since the earth is slightly slowing down, leap seconds are introduced from time to time in UTC (about one second every 18 months). UTC is not a continuous scale ! When a leap second is introduced by International Earth Rotation Service, this is published in advance and the legal time sequence is as follows: 23:59:59 followed one second later by 23:59:60 followed one second later by 00:00:00. At the time of this writing (1999-01-05) the difference between TAI and UTC was 32 seconds, and the last leap second was introduced in 1998-12-31.  These calendars allow to represent any date from the mist of the past to the fog of the future, but they are not convenient for computation. Another time scale is possible: counting only the days from a reference. Such a time scale was introduced by Joseph-Juste Scaliger (Josephus Justus Scaliger) in 1583. He decided to use ""-4713-01-01T12:00:00"" as a reference date because it was at the same time a Monday, first of January of a leap year, there was an exact number of 19 years Meton cycle between this date and year 1 (for Easter computation), and it was at the beginning of a 15 years  Roman indiction  cycle. The day number counted from this reference is traditionally called  Julian day , but it has really nothing to do with the Julian calendar.  Grace stores dates internally as reals numbers counted from a reference date. The default reference date is the one chosen by Scaliger, it is a classical reference for astronomical events. It can modified for a single session using the   Edit->Preferences  popup of the GUI. If you often work with a specific reference date you can set it for every sessions with a REFERENCE DATE command in your configuration file (see   Default template ).  The following date formats are supported (hour, minutes and seconds are always optional):      iso8601  : 1999-12-31T23:59:59.999   european : 31/12/1999 23:59:59.999 or 31/12/99 23:59:59.999   us       : 12/31/1999 23:59:59.999 or 12/31/99 23:59:59.999   Julian   : 123456.789     One should be aware that Grace does not allow to put a space in one data column as spaces are used to separate fields. You should always use another separator (:/.- or better T) between date and time in data files. The GUI, the batch language and the command line flags do not have this limitation, you can use spaces there without any problem. The T separator comes from the ISO8601 standard. Grace support its use also in european and us formats.  You can also provide a hint about the format (""ISO8601"", ""european"", ""us"") using the -datehint command line flag or the ref name=""Edit->Preferences"" id=""preferences""> popup of the GUI. The formats are tried in the following order: first the hint given by the user, then iso, european and us (there is no ambiguity between calendar formats and numerical formats and therefore no order is specified for them). The separators between various fields can be any characters in the set: "" :/.-T"" (one or more spaces act as one separator, other characters can not be repeated, the T separator is allowed only between date and time, mainly for iso8601), so the string ""1999-12 31:23/59"" is allowed (but not recommended).  The '-' character is used both as a separator (it is traditionally used in iso8601 format) and as the unary minus (for dates in the far past or for numerical dates). By default years are left untouched, so 99 is a date far away in the past. This behavior can be changed with the   Edit->preferences  popup, or with the  DATE WRAP on  and  DATE WRAP YEAR year  commands. Suppose for example that the wrap year is chosen as 1950, if the year is between 0 and 99 and is written with two or less digits, it is mapped to the present era as follows:  range [00 ; 49] is mapped to [2000 ; 2049]  range [50 ; 99] is mapped to [1950 ; 1999]  with a wrap year set to 1970, the mapping would have been:  range [00 ; 69] is mapped to [2000 ; 2069]  range [70 ; 99] is mapped to [1970 ; 1999]  this is reasonably Y2K compliant and is consistent with current use.  Specifying year 1 is still possible using more than two digits as follows: ""0001-03-04"" is unambiguously March the 4th, year 1. The inverse transform is applied for dates written by Grace, for example as tick labels. Using two digits only for years is not recommended, we introduce a  wrap year + 100  bug here so this feature should be removed at some point in the future ...  The date scanner can be used either for Denys's and Gregorian calendars. Inexistent dates are detected, they include year 0, dates between 1582-10-05 and 1582-10-14, February 29th of non leap years, months below 1 or above 12, ...  the scanner does not take into account leap seconds: you can think it works only in International Atomic Time (TAI) and not in Coordinated Unified Time (UTC). If you find yourself in a situation were you need UTC, a very precise scale, and should take into account leap seconds ... you should convert your data yourself (for example using International Atomic Time). But if you bother with that you probably already know what to do.      9.5 Xmgr to Grace migration guide          This is a very brief guide describing problems and workarounds for reading in project files saved with Xmgr. You should read the docs or just play with Grace to test new features and controls.       Grace must be explicitly told the version number of the software used to create a file. You can manually put ""@version VERSIONID"" string at the beginning of the file. The VERSIONID is built as MAJOR_REV*10000 + MINOR_REV*100 + PATCHLEVEL; so 40101 corresponds to xmgr-4.1.1. Projects saved with Xmgr-4.1.2 do NOT need the above, since they already have the version string in them. If you have no idea what version of Xmgr your file was created with, try some. In most cases, 40102 would do the trick.      The above relates to the ASCII projects only. The old binary projects (saved with xmgr-4.0.*) are not automatically converted anymore. An input filter must be defined to make the conversion work on-the-fly. Add the following line to  /.gracerc or the system-wide $GRACE_HOME/gracerc resource file: DEFINE IFILTER ""grconvert %s -"" MAGIC ""00000031"" See docs for more info on the I/O filters.      Documentation on the script language is severely lacking still.      Grace is WYSIWYG. Xmgr was not. Many changes required to achieve the WYSIWYG'ness led to the situation when graphs with objects carefully aligned under Xmgr may not look so under Grace. Grace tries its best to compensate for the differences, but sometimes you may have to adjust such graphs manually.      A lot of symbol types (all except *real* symbols) are removed. ""Location *"" types can be replaced (with much higher comfort) by A(nnotating)values. ""Impulse *"", ""Histogram *"" and ""Stair steps *"" effects can be achieved using the connecting line parameters (Type, Drop lines). ""Dot"" symbol is removed as well; use the filled circle symbol of the zero size with no outline to get the same effect.      Default page layout switched from free (allowing to resize canvas with mouse) to fixed. For the old behavior, put ""PAGE LAYOUT FREE"" in the Grace resource file or use the ""-free"" command line switch.  The use of the ""free"" page layout is in general deprecated, though.       System (shell) variables GR_* renamed to GRACE_*      Smith plots don't work now. They'll be put back soon."
GX008-12-6285034	"Grace User's Guide (for Grace-5.1.12)    by the Grace Team 22.02.2003      This document explains the usage of    Grace , a WYSIWYG 2D plotting tool for numerical data.       1.   Introduction      1.1   What is Grace?   1.2   Copyright statement       2.   Installation guide      2.1   Installing from sources   2.2   Binary installation   2.3   Alternative packaging schemes (RPM, ...)       3.   Getting started      3.1   General concepts   3.2   Invocation   3.3   Customization       4.   Guide to the graphical user interface      4.1   GUI controls   4.2   The main window   4.3   File menu    4.4   Edit menu    4.5   Data menu    4.6   Plot menu    4.7   View menu    4.8   Window menu    4.9   Help menu        5.   Command interpreter       5.1   General notes   5.2   Definitions   5.3   Variables   5.4   Numerical operators and functions   5.5   Procedures   5.6   Device parameters   5.7   Flow control   5.8   Declarations   5.9   Graph properties   5.10   Set properties       6.   Advanced topics      6.1   Fonts   6.2   Interaction with other applications   6.3   FFTW tuning   6.4   DL modules        7.   References      7.1   Typesetting   7.2   Device-specific limitations   7.3   Device-specific settings   7.4   Dates in Grace    7.5   Xmgr to Grace migration guide        1.   Introduction      1.1   What is Grace?        Grace is a WYSIWYG tool to make two-dimensional plots of numerical data. It runs under various (if not all) flavors of Unix with X11 and M*tif (LessTif or Motif). It also runs under VMS, OS/2, and Windows (95/98/NT/2000/XP). Its capabilities are roughly similar to GUI-based programs like Sigmaplot or Microcal Origin plus script-based tools like Gnuplot or Genplot. Its strength lies in the fact that it combines the convenience of a graphical user interface with the power of a scripting language which enables it to do sophisticated calculations or perform automated tasks.   Grace is derived from Xmgr (a.k.a. ACE/gr), originally written by Paul Turner.   From version number 4.00, the development was taken over by a team of volunteers under the coordination of Evgeny Stambulchik. You can get the newest information about Grace and download the latest version at the   Grace home page .   When its copyright was changed to GPL, the name was changed to Grace, which stands for ``GRaphing, Advanced Computation and Exploration of data'' or ``Grace Revamps ACE/gr''. The first version of Grace available is named 5.0.0, while the last public version of Xmgr has the version number 4.1.2.   Paul still maintains and develops a non-public version of Xmgr for internal use.    1.2   Copyright statement             Copyright (©) 1991-1995 Paul J Turner, Portland, OR Copyright (©) 1996-2003 Grace Development Team  Maintained by Evgeny Stambulchik                            All Rights Reserved  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.         For certain libraries required to build Grace (which are therefore even included in a suitable version) there may be different Copyright/License statements. Though their License may by chance match the one used for Grace, the Grace Copyright holders can not influence or change them.         Package   License   cephes library   Free   T1lib   LGPL   Xbae   BSD-like   Tab Widget   BSD-like            Licenses               2.   Installation guide         2.1   Installing from sources               Configuration         Requirements. Grace usually compiles out of the box in a regular Unix-like environment. You need an ANSI C compiler (gcc is just fine), the X11R5 or above libraries and headers, and an implementaion of the M*tif API, version 1.2 or above. If you want to compile your own changes to certain parts of Grace, you will need a parser generator ( yacc  or, better,  bison ).    Extra libraries. Some features will be available only if additional libraries are installed. Those are:     The JPEG backend needs the IJG's (  JPEG library ), version 6.x.    The PNG backend needs the (  libpng ) library (version 0.96 or above).    The PDF driver requires the PDFlib library of Thomas Merz to be installed, which is available  here , version 4.0.3 or above.    If your computer has the FFTW library installed when Grace is compiled, Grace will link itself to this, and drop all conventional FFT's and DFT's. All transforms will be routed through this package. Note that there is then no difference between pushing the ""FFT"" button and the ""DFT"" button, except that FFT will complain if the length isn't a power of 2, and DFT will not.  For more information on this package, see the   FFTW Home page . In short, this package allows one to do non-power-of-2 length FFT's along with the normal ones.  It seems to work very efficiently for any set length which factors into 2^a 3^b 5^c 7^d for integer a, b, c, d. The great feature here is that set lengths which are powers of 10 (e.g. 1000, 10000) and integer multiples of these (500, 2000, 2500, 5000, etc.) can be computed with no significant penalty (maybe 20%) over power-of-2 transforms. Very often, real datasets come in these sizes, and not in powers of 2.    In order to read/write sets in the NetCDF data format, you will also need the   NetCDF libraries .        Decide whether you want to compile in a separate place (thus leaving the source tree pristine). You most probably would want it if compiling Grace for more than one OS and keeping the sources in a central shared (e.g. via NFS) location. If you don't need it, skip the rest of this paragraph and go right to the next step. Otherwise, assuming the sources are in  /usr/local/src/grace-x.y.z  and the compilation will be performed in  /tmp/grace-obj , do the following:    % mkdir /tmp/grace-obj   % cd /tmp/grace-obj   % /usr/local/src/grace-x.y.z/ac-tools/shtool mkshadow \     /usr/local/src/grace-x.y.z .                         The  configure  shell script attempts to guess correct values for various system-dependent variables used during compilation. It uses those values to create  Make.conf  in the top directory of the package. It also create  config.h  file containing system-dependent definitions. Finally, it creates a shell script  config.status  that you can run in the future to recreate the current configuration, a file  config.cache  that saves the results of its tests to speed up reconfiguring, and a file  config.log  containing compiler output (useful mainly for debugging  configure ). If at some point  config.cache  contains results you don't want to keep, you may remove or edit it.    Run  ./configure --help  to get list of additional switches specific to Grace    Run  ./configure <options> . Just an example:    % ./configure --enable-grace-home=/opt/grace      --with-extra-incpath=/usr/local/include:/opt/include \     --with-extra-ldpath=/usr/local/lib:/opt/lib --prefix=/usr                      would use  /usr/local/include  and  /opt/include  in addition to the default include path and  /usr/local/lib  and  /opt/lib  in addition to the default ld path. As well, all stuff would be put under the /opt/grace directory and soft links made to  /usr/bin ,  /usr/lib  and  /usr/include .  Note : If you change one of the  --with-extra-incpath  or  --with-extra-ldpath  options from one run of configure to another, remember to delete the  config.cache  file!!!          Compilation     Issue  make   If something goes wrong, try to see if the problem has been described already in the  Grace FAQ  (in the  doc  directory).          Testing           make tests   This will give you a slide show demonstrating some nice features of Grace.          Installation      make install     make links   The later (optional) step will make soft links from some files under the Grace home directory to the system-wide default locations (can be changed by the  --prefix  option during the configuration, see above).              2.2   Binary installation               Getting pre-built packages    Installation    Running tests        2.3   Alternative packaging schemes (RPM, ...)           Not written yet...     3.   Getting started        For a jump-in start, you can browse the demos (""Help/Examples"" menu tree). These are ordinary Grace projects, so you can play with them and modify them. Also, read the   Tutorial .   O.k. Here's a VERY quick introduction:     Start the GUI version: xmgrace (return).    Select/check the output medium and canvas size in File/Device Setup.    If needed, set the graph size ('Viewport' in Plot/Graph Appearance).    Load your data with Data/Import/ASCII. 'Load as': 'Single set' for two-column ASCII data, 'Block data' for multi-column ASCII data.    Adjust the scales, axis labels and tick marks in Plot/Axis properties. Acknowledge all changes with 'Apply'.    Adjust lines, symbols, legends in Plot/Set appearance.    Adjust titles, plot frame and legend display in Plot/Graph Appearance.    Data can be manipulated in Data/Transformations. To shift a data set by 20 to the left, e.g., in 'Evaluate Expression' select the same set on the left and the right, and say Formula: y=y-20. As you'll probably notice, Grace can do MUCH more than that. Explore at your leisure.    When you like your plot, select File/Print. That's it!        3.1   General concepts             Project files              A project file contains all information necessary to restore a plot created by Grace, as well as some of preferences. Each plot is represented on a single page, but may have an unlimited number of graphs.You create a project file of your current graph with File/Save,Save as.     Parameter files              A parameter file contains the detailed settings of your project. It can be used to transfer these settings to a different plot/project. You generate a parameter file with File/Save menu entry selected from the ""Plot/Graph appearance popup"". You can load the settings contained in a parameter file with File/Open.     Input File formats              Grace understands several input files formats. The most basic one is ASCII text files containing space and comma separated columns of data. The data fields can be either numeric (Fortran 'd' and 'D' exponent markers are supported) or alphanumeric (with or without quotes). Several calendar date formats are recognized automatically and you can specify your own reference for numeric dates formats. Grace also has a command language (see   command interpreter ), you can include commands in data files using lines having ""@"" as their first non-blank character. Depending on configuration, Grace can also read NetCDF files (see   configuration ).     Graphs              A graph consists of (every element is optional): a graph frame, axes, a title and a subtitle, a number of sets and additional annotative objects (time stamp string, text strings, lines, boxes and ellipses).   The graph type can be any of:        XY Graph    XY Chart    Polar Graph    Fixed Graph    Pie chart       The idea of ""XY Chart"" is to plot bars (or symbols in general) of several sets side by side, assuming the abscissas of all the sets are the same (or subsets of the longest set).     Datasets              A dataset is a collection of points with x and y coordinates, up to four optional data values (which, depending on the set type, can be displayed as error bars or like) and one optional character string.     Sets              A set is a way of representing datasets. It consists of a pointer to a dataset plus a collection of parameters describing the visual appearance of the data (like color, line dash pattern etc).   The set type can be any of the following:          Set type   # of num. cols   Description   XY   2   An X-Y scatter and/or line plot, plus (optionally) an annotated value   XYDX   3   Same as XY, but with error bars (either one- or two-sided) along X axis   XYDY   3   Same as XYDX, but error bars are along Y axis   XYDXDX   4   Same as XYDX, but left and right error bars are defined separately   XYDYDY   4   Same as XYDXDX, but error bars are along Y axis   XYDXDY   4   Same as XY, but with X and Y error bars (either one- or two-sided)   XYDXDXDYDY   6   Same as XYDXDY, but left/right and upper/lower error bars are defined separately   BAR   2   Same as XY, but vertical bars are used instead of symbols   BARDY   3   Same as BAR, but with error bars (either one- or two-sided) along Y axis   BARDYDY   4   Same as BARDY, but lower and upper error bars are defined separately   XYHILO   5   Hi/Low/Open/Close plot   XYZ   3   Same as XY; makes no sense unless the annotated value is Z   XYR   3   X, Y, Radius. Only allowed in Fixed graphs   XYSIZE   3   Same as XY, but symbol size is variable   XYCOLOR   3   X, Y, color index (of the symbol fill)  XYCOLPAT   4   X, Y, color index, pattern index (currently used for Pie charts only)   XYVMAP   4   Vector map   XYBOXPLOT   6   Box plot (X, median, upper/lower limit, upper/lower whisker)                 Set types                   Not all set types, however, can be plotted on any graph type. The following table summarizes it:          Set type   XY Graph   XY Chart   Fixed   Polar   Pie   XY   +   +   +   +   +   XYDX   +   -   +   -   -   XYDY   +   +   +   -   -   XYDXDX   +   -   +   -   -   XYDYDY   +   +   +   -   -   XYDXDY   +   -   +   -   -   XYDXDXDYDY   +   -   +   -   -   BAR   +   +   +   -   -   BARDY   -   +   -   -   -   BARDYDY   -   +   -   -   -   XYHILO   +   -   -   -   -   XYZ   +   -   +   +   -   XYR   -   -   +   -   -   XYSIZE   +   +   +   +   -   XYCOLOR   +   +   +   +   +   XYCOLPAT   -   -   -   -   +   XYVMAP   +   -   +   -   -   XYBOXPLOT   +   -   -   -   -                 Graph/Set type connection                    Regions              Regions are sections of the graph defined by the interior or exterior of a polygon, or a half plane defined by a line. Regions are used to restrict data transformations to a geometric area occupied by region.     Real Time Input              Real Time Input refers to the ability Grace has to be fed in real time by an external program. The Grace process spawned by the driver program is a full featured Grace process: the user can interact using the GUI at the same time the program sends data and commands. The process will adapt itself to the incoming data rate.     Hotlinks              Hotlinks are sources containing varying data. Grace can be instructed a file or a pipe is a hotlink in which case it will provide specific commands to refresh the data on a mouse click (a later version will probably allow automatic refresh).     Devices            Grace allows the user to choose between several output devices to produce its graphics. The current list of supported devices is:        X11    PostScript (level 1 and level 2)    EPS (encapsulated PostScript)    Metafile (which is Grace format, used at the moment mostly for debugging purposes)    MIF (Maker Interchange Format used by FrameMaker)    SVG (Scalable Vector Graphics, a language for describing two-dimensional vector and mixed vector/raster graphics in XML)    PDF (depends on extra libraries, see   configuration )    PNM (portable anymap file format)    JPEG (depends on extra libraries, see   configuration )    PNG (depends on extra libraries, see   configuration )        Note that Grace no longer supports GIF due to the copyright policy of Unisys. Grace can also be instructed to launch conversion programs automatically based on file name. As an example you can produce MIF (FrameMaker Interchange Format) or Java applets using pstoedit, or almost any image format using the netpbm suite (see the   FAQ ).     Magic path            In many cases, when Grace needs to access a file given with a relative  pathname , it searches for the file along the following path:  ./pathname:./.grace/pathname:~/.grace/pathname:$GRACE_HOME/pathname     Dynamic modules            Grace can access external functions present in either system or third-party shared libraries or modules specially compiled for use with it. The term dynamic refers to the possibility Grace has to open the library at run time to find the code of the external function, there is no need to recompile Grace itself (the functions already compiled in Grace are ""statically linked"").     Coordinate frames             There are two types of coordinates in Grace: the  world coordinates  and the  viewport coordinates . Points of data sets are defined in the world coordinates. The viewport coordinates correspond to the image of the plot drawn on the canvas (or printed on, say, PS output page). The transformation converting the world coordinates into the viewport ones is determined by both the graph type and the axis scaling.   Actually, there is yet another level in the hierarchy of coordinates - the  device coordinates . However, you (as a user of Grace) should not worry about the latter. The mapping between the viewport coordinates and the device coordinates is always set in such a way that the origin of the viewport corresponds to the left bottom corner of the device page, the smallest of the device dimensions corresponds to one unit in the viewport coordinates. Oh, and the most important thing about the viewport -> device transformation is that it is homotetic, i.e. a square is guaranteed to remain a square, not a rectangle, a circle remains a circle (not an ellipse) etc.   3.2   Invocation            Operational mode             With respect to the user interface, there are three modes of operation that Grace can be invoked in. The full-featured GUI-based version is called  xmgrace . A batch-printing version is called  gracebat . A command-line interface mode is called  grace . Usually, a single executable is called in all cases, with two of the three files being (symbolic) links to a ""real"" one.    Command line options                 -autoscale  x|y|xy   Override any parameter file settings     -barebones  Turn off all toolbars     -batch  batch_file   Execute batch_file on start up     -block  block_data   Assume data file is block data     -bxy  x:y:etc.   Form a set from the current block data set using the current set type from columns given in the argument     -datehint  iso|european|us|days|seconds|nohint   Set the hint for dates analysis     -dpipe  descriptor   Read data from descriptor (anonymous pipe) on startup     -fixed  width   height   Set canvas size fixed to width*height     -free  Use free page layout     -graph  graph_number   Set the current graph number     -graphtype  graph_type   Set the type of the current graph     -hardcopy  No interactive session, just print and quit     -hdevice  hardcopy_device_name   Set default hardcopy device     -install  Install private colormap     -legend  load   Turn the graph legend on     -log  x|y|xy   Set the axis scaling of the current graph to logarithmic     -mono  Run Grace in monochrome mode (affects the display only)     -netcdf  file   Assume data  file  is in netCDF format. This option is present only if the netCDF support was compiled in     -netcdfxy  X_var   Y_var   If -netcdf was used previously, read from the netCDF file  X_var   Y_var  variables and create a set. If  X_var  name is ""null"" then load the index of Y to X. This option is present only if the netCDF support was compiled in       -noask  Assume the answer is yes to all requests - if the operation would overwrite a file, Grace will do so without prompting     -noinstall  Don't use private colormap     -noprint  In batch mode, do not print     -nosafe  Disable safe mode     -nosigcatch  Don't catch signals     -npipe  file   Read data from named pipe on startup     -nxy  nxy_file   Assume data file is in X Y1 Y2 Y3 ... format     -param  parameter_file   Load parameters from parameter_file to the current graph     -pexec  parameter_string   Interpret string as a parameter setting     -pipe  Read data from stdin on startup     -printfile  file  Save print output to file     -remove  Remove data file after read     -results  results_file   Write results of some data manipulations to results_file     -rvideo  Exchange the color indices for black and white     -safe  Run in the safe mode (default) - no file system modifications are allowd through the batch language     -saveall  save_file   Save all graphs to save_file     -seed  seed_value   Integer seed for random number generator     -source  disk|pipe   Source type of next data file     -timer  delay   Set allowed time slice for real time inputs to delay ms     -timestamp  Add timestamp to plot     -settype  xy|xydx|...   Set the type of the next data file     -version  Show the program version     -viewport  xmin ymin xmax ymax   Set the viewport for the current graph     -wd  directory   Set the working directory     -world  xmin ymin xmax ymax   Set the world coordinates for the current graph     -usage|-help  This message         3.3   Customization            Environment variables                GRACE_HOME  Set the location of Grace. This will be where help files, auxiliary programs, and examples are located. If you are unable to find the location of this directory, contact your system administrator.       GRACE_PRINT_CMD  Print command. If the variable is defined but is an empty string, ""Print to file"" will be selected as default.       GRACE_EDITOR  The editor used for manual editing of dataset values.       GRACE_HELPVIEWER  The shell command to run an HTML viewer for on-line browsing of the help documents. Must include at least one instance of ""%s"" which will be replaced with the actual URL by Grace.       GRACE_FFTW_WISDOM_FILE and GRACE_FFTW_RAM_WISDOM  These flags control behavior of the FFTW planner (see  FFTW tuning  for detailed info)            Init file          Upon start-up, Grace loads its init file,  gracerc . The file is searched for in the magic path (see  magic path ); once found, the rest of the path is ignored. It's recommended that in the  gracerc  file, one doesn't use statements which are part of a project file - such defaults, if needed, should be set in the default template (see   default template ).     Default template          Whenever a new project is started, Grace loads the default template,  templates/Default.agr . The file is searched for in the magic path (see    magic path ); once found, the rest of the path is ignored. It's recommended that in the default template, one doesn't use statements which are NOT part of a project file - such defaults, if needed, should be set in the  gracerc  (see   init file ).    X resources           The following Grace-specific X resource settings are supported:        XMgrace.invertDraw  Use GXinvert rather than GXxor for rubber-band lines. If the rubber-banding for zooms and lines, etc. doesn't appear on the canvas, set this resource to yes.      XMgrace.allowDoubleClick  When Yes, allow double clicks on the canvas to bring up various popups depending on  the location of the pointer when the double click occurs.      XMgrace.toolBar  Enables button toolbar      XMgrace.statusBar  Enables status bar      XMgrace.locatorBar  Enables locator bar          It is also possible to customize menus by assigning key accelerators to any item.   You'll need to derive the item's X resource name from the respective menu label, which is easily done following these rules:     All non-alphanumeric characters are skipped    Start with lower case; each new word (if any) continues from the capital letter    Add the item's type to the end - ""Menu"" for pulldown menus, ""Button"" for menu buttons.       For example, in order to make Grace popup the Non-linear curve fitting by pressing Control+F, you would add the following two lines   XMgrace*transformationsMenu.nonLinearCurveFittingButton.acceleratorText: Ctrl+F  XMgrace*transformationsMenu.nonLinearCurveFittingButton.accelerator: Ctrl<Key>f    to your  .Xresources  file (the file which is read when an X session starts; it could be  .Xdefaults ,  .Xsession  or some other file - ask your system administrator when in doubt).    Similarly, it may be desirable to alter default filename patterns of file selection dialogs. The recipe for the dialog's name is like for menu buttons outlined above, with ""Button"" being replaced with ""FSB"". E.g., to list all files in the ""Open project"" dialog (""File/Open...""), set the following resource:   XMgrace*openProjectFSB.pattern: *      4.   Guide to the graphical user interface        4.1   GUI controls          This section describes interface controls - basic building blocks, used in many popups.    File selection dialogs           Whenever the user is expected to provide a filename, either for reading in or writing some data, a file selection dialog is popped up. In addition to the standard entries (the directory and file lists and the filter entry), there is a pulldown menu for quick directory change to predefined locations (the current working directory, user's home directory and the file system root). Also, a ""Set as cwd"" button is there which allows to set any directory as you navigate through the directory tree as the current working directory (cwd). Once defined, it can be used in any other file selection dialog to switch to that directory quickly.     List selectors           Various selectors are available in several popups. They all display lists of objects (graphs, sets, ...) and can be used to perform simple operations on these objects (copying, deleting, ...). The operations are available from a popup menu that appears when pressing mouse button 3 on them. Depending on the required functionality, they may allow multiple choices or not. The following shortcuts are enabled (if the result of an action would contradict the list's selection policy, this would be ignored):     Ctrl+a select all    Ctrl+u unselect all    Ctrl+i invert selection         Graph selector             The operations that can be performed on graphs through the graph selector's popup menu are:     focus to    hide    show    duplicate    kill    swap    create new     All this operations are not available in every instance of the selector. For example in the ""read sets"" popup only one graph can be selected at a time, and the swap operation is disabled.   Double-clicking on a list entry will switch the focus to that graph.     Set selector             The operations that can be performed on sets through the set selector's popup menu are:     hide    show    bring to front    send to back    duplicate    kill    kill data    swap    edit     in spreadsheet (see  Spreadsheet data set editor )    in text editor        create new     by formula    in spreadsheet (see  Spreadsheet data set editor )    in text editor    from block data        pack all sets    selector operations     view set comments    show data-less    show hidden    select all    unselect all    invert selection    update           Double-clicking on a list entry will open the spreadsheet editor (see   Spreadsheet data set editor ) on the set data.      4.2   The main window             The canvas           Canvas hotkeys             When the pointer focus is on the canvas (where the graph is drawn), there are some shortcuts to activate several actions. They are:        Ctrl <Key>A: Autoscale the current graph    Ctrl <Key>D: Delete an object    Ctrl <Key>L: Move current graph legend    Ctrl <Key>M: Move an object    Ctrl <Key>T: Place timestamp    Ctrl <Key>U: Refresh hotlinks    Ctrl <Key>V: Set the viewport with mouse    Ctrl <Key>Z: Zoom    Ctrl Alt <Key>L: Draw a line    Ctrl Alt <Key>B: Draw a box    Ctrl Alt <Key>E: Draw an ellipse    Ctrl Alt <Key>T: Write a text string         Clicks and double clicks            A single click inside a graph switches focus to that graph. This is the default policy, but it can be changed from the ""Edit/Preferences"" popup.   Double clicking on parts of the canvas will invoke certain actions or raise some popups:        on a focus marker: move selected viewport corner     on an axis:  ""Plot/Axis properties"" popup    on a set:    ""Plot/Set appearance"" popup    on a legend: ""Plot/Graph appearance"" popup    on a (sub)title: ""Plot/Graph appearance"" popup    on an object (box, line, ...): a popup for editing properties of that object       The double clicking actions can be enabled/disabled from the ""Edit/Preferences"" popup.     Toolbar buttons          Along the left-hand side of the canvas (if shown) is the ToolBar. It is armed with several buttons to provide quick and easy access to the more commonly used Grace functions.           Draw : This will redraw the canvas and sets. Useful if ""Auto Redraw"" has been deselected in the Edit|Preferences dialog or after executing commands directly from the Window|Commands interpreter.          Lens : A zoom lens.  Click on the lens, then select the area of interest on the graph with the ""rubber band"".  The region enclosed by the rubber band will fill the entire graph.         AS : AutoScale.  Autoscales the graph to contain all data points of all visible (not hidden) sets.        Z/z :  Zoom in/out by 5%. The zoom percentage can be set in the Edit/Preferences dialog.     Arrows :  Scroll active graph by 5% in the arrow's direction.  The scroll percentage can be set in the Edit/Preferences dialog.        AutoT : AutoTick Axes.  This will find the optimum number of major and minor tick marks for both axes.     AutoO : Autoscale On set.  Click the  AutoO  button, then click on the graph near the set you wish to use for determining the autoscale boundaries of the graph.       ZX,ZY : Zoom along an axis.  These buttons work like the zoom lens above but are restricted to a single axis.      AX,AY : Autoscale one axis only.  The following buttons deal with the graph stack and there is a good example under Help/Examples/General Intro/World Stack.       Pu/Po : Push and pop the current world settings to/from the graph stack. When popping, makes the new stack top current.     PZ : Push before Zooming.  Functions as the zoom lens, but first pushes the current world settings to the stack.       Cy : Cycles through the stack settings of the active graph.  Each graph may have up to twenty layers on the stack.               Exit : Pretty obvious, eh?           4.3   File menu          The file menu contains all entries related to the input/output features of Grace.     New           Reset the state of Grace as if it had just started (one empty graph ranging from 0 to 1 along both axes). If some work has been done and not yet saved, a warning popup is displayed to allow canceling the operation.     Open           Open an existing   project file . A popup is displayed that allow to browse the file system.     Save           Save the current work in a project file, using the name that was used for the last open or save. If no name has been set (i.e., if the project has been created from scratch) act as   save as .     Save as           Save the current work in a project file with a new name. A popup allows to browse the file system and set the name, the format to use for saving data points (the default value is ""%16.8g""), and a textual description of the project. A warning is displayed if a file with the same name already exists.     Revert to saved           Abandon all modifications performed on the project since the last save. A confirmation popup is fired to allow the user canceling the operation.     Print setup           Set the properties of the printing device. Each device has its own set of specific options (see   Device-specific       settings ). According to the device, the output can be sent either directly to a printer or directed to a file. The global settings available for all devices are the sizing parameters. The size of the graph is fixed. Changing the 'Page' settings changes the size of the canvas underneath the graph. Switching between portrait and landscape rotates the canvas. Make sure the canvas size is large enough to hold your graph. Otherwise you get a 'Printout truncated' warning. If your canvas size cannot easily be changed because, for example, you want to print on letter size paper, you need to adjust the size of your graph ('Viewport' in Plot/Graph Appearance).     Print           Print the project using the current printer settings     Exit           Exit from Grace. If some work has been done and not saved, a warning popup will be displayed to allow the user to cancel the operation.      4.4   Edit menu            Data sets           Using the data set popup, you can view the properties of datasets. This include its type, length, associated comment and some statistics (min, max, mean, standard deviation). A horizontal scrollbar at the bottom allows to get the two last properties, they are not displayed by default. Also note that if you find some columns are too narrow to show all significant digits, you can drag the vertical rules using Shift+Button 2.   Using the menu on the top of this dialog, you can manipulate existing sets or add new ones. Among the most important entries in the menu, are options to create or modify a set using the spreadsheet data set editor (see   Spreadsheet data set editor ).     Spreadsheet data set editor            The dialog presents an editable matrix of numbers, corresponding to the data set being edited. The set type (and hence, the number of data columns) can be changed using the ""Type:"" selector. Clicking on a column label pops up a dialog allowing to adjust the column formatting. Clicking on the row labels toggles the respective row state (selected/unselected). The selected rows can be deleted via the dialog's ""Edit"" menu. Another entry in this menu lets you add a row; the place of the new row is determined by the row containing a cell with the keyboard focus on. As well, just typing in an empty cell will add one or several rows (filling the intermediate rows with zeros).   To resize columns, drag the vertical rules using Shift+Button 2.    Set operations           The set operations popup allows you to interact with sets as a whole. If you want to operate on the data ordering of the sets, you should use the   data set operations  popup from the Data menu. The popup allows you to select a source (one set within one graph) and a destination and perform some action upon them (copy, move, swap). This popup also give you a quick access to several graph and set selectors if you want to perform some other operation like hiding a graph or creating a new set from block data.     Arrange graphs           This entry fires up a popup to lay out several graphs in a regular grid given by  M  rows and  N  columns.    The graph selector at the top allows one to select a number of graphs the arrangement will operate on. If the number of selected graphs isn't equal to  M  times  N ,  new graphs may be created or extra graphs killed if needed. These options are  controlled by the respective checkboxes below the graph selector.   The order in which the matrix is filled in with the graphs can be selected (first horizontally then vertically or vise versa, with either of them inverted). Additionaly, one may choose to fill the matrix in the snake-like manner (adjacent ""strokes"" are anti-parallel).   The rest of the controls of the dialog window deal with the matrix spacing: left/right/top/bottom page offsets (in the viewport coordinates) and  relative  inter-cell distances, vertical and horizontal. Next to each of the vertical/horizontal spacing spinboxes, a ""Pack"" checkbox is found. Enabling it effectively sets the respective inter-cell distance to zero and alter axis tickmark settings such that only bottom/left-most tickmarks are visible.   If you don't want the regular layout this arrangement gives you, you can change it afterwards using the mouse (select a graph and double click on the focus marker, see   clicks and double clicks ).     Overlay graphs           You can overlay a graph on top of another one. The main use of this feature is to plot several curves using different scales on the same (apparently) graph. The main difficulty is to be sure you operate on the graph you want at all times (you can hide one for a moment if this becomes too difficult).     Autoscale           Using this entry, you can autoscale one graph or all graphs according to the specified sets only. This is useful if you need either to have truly comparable graphs despite every one contains data of different ranges, or if you want to focus your attention on one set only while it is displayed with other data in a complex graph.     Regions menu             Status              This small popup only displays the current state (type and whether it is active or not) of the existing regions.     Define              You can define a new region (or redefine an existing one), the allowed region types are:        Inside polygon    Outside polygon    Above line    Below line    Left of line    Right of line    In horizontal range    In vertical range    Out of horizontal range    Out of vertical range       A region can be either linked to the current graph only or to all graphs.     Clear              This kills a region.     Report on              This popup reports you which sets or points are inside or outside of a region.     Hot links           You can link a set to a file or a pipe using this feature. Once a link has been established, you can update it (i.e., read data again) by clicking on the update button.   Currently, only simple XY sets can be used for hotlinks.     Set locator fixed point           After having selected this menu entry, you can select a point on a graph that will be used as the origin of the locator display (just below the menu bar). The fixed point is taken into account only when the display type of the locator is set to [DX,DY].     Clear locator fixed point           This entry is provided to remove a fixed point set before and use the default again: point [0, 0].     Locator props           The locator props popup allows you to customize the display of the locator, mainly its type and the format and precision of the display. You can use all the formats that are allowed in the graphs scales.     Preferences           The preferences popup allows you to set miscellaneous properties of your Grace session, such as GUI behavior, cursor type, date reading hint and reference date used for calendar conversions.      4.5   Data menu            Data set operations           This popup gathers all operations that are related to the ordering of data points inside a set or between sets. If you want to operate on the sets as a whole, you should use the   set operations  popup from the Edit menu. You can sort according to any coordinate (X, Y, DX, ...) in ascending or descending order, reverse the order of the points, join several sets into one, split one set into several others of equal lengths, or drop a range of points from a set. The   set selector  of the popup shows the number of points in each set in square brackets like this: G0.S0[63], the points are numbered from 0 to n-1.     Transformations menu           The transformations sub-menu gives you access to all data-mining features of Grace.     Evaluate expression              Using evaluate expression allows you to create a set by applying an explicit formula to another set, or to parts of another set if you use regions restrictions.   All the classical mathematical functions are available (cos, sin, but also lgamma, j1, erf, ...). As usual all trigonometric functions use radians by default but you can specify a unit if you prefer to say cos (x rad) or sin (3 * y deg). For the full list of available numerical functions and operators, see  Operators and functions .   In the formula, you can use X, Y, Y1, ..., Y4 to denote any coordinate you like from the source set. An implicit loop will be used around your formula so if you say:                x = x - 4966.5                  you will shift all points of your set 4966.5 units to the left.   You can use more than one set in the same formula, like this:                y = y - 0.653 * sin (x deg) + s2.y                  which means you use both X and Y from the source set but also the Y coordinate of set 2. Beware that the loop is a simple loop over the indices, all the sets you use in such an hybrid expression should therefore have the same number of points and point i of one set should really be related to point i of the other set. If your sets do not follow these requirements, you should first homogenize them using  interpolation .     Histograms              The histograms popup allows you to compute either standard or cumulative histograms from the Y coordinates of your data. Optionally, the histograms can be normalized to 1 (hence producing a PDF (Probability Distribution Function).   The bins can be either a linear mesh defined by its min, max, and length values, or a mesh formed by abscissas of another set (in which case abscissas of the set must form a strictly monotonic array).     Fourier transforms              This popup is devoted to direct and inverse Fourier transforms. The default is to perform a direct transform on unfiltered data and to produce a set with the index as abscissa and magnitude as ordinate. You can filter the input data window through triangular, Hanning, Welch, Hamming, Blackman and Parzen filters. You can load magnitude, phase or coefficients and use either index, frequency or period as abscissas. You can choose between direct and inverse Fourier transforms. If you specify real input data, X is assumed to be equally spaced and ignored; if you specify complex input data X is taken as the real part and Y as the imaginary part.   If Grace was configured with the FFTW library (see   configuration ), then the DFT and FFT buttons really perform the same transform (so there is no speed-up in using FFT in this case). If you want Grace can to use FFTW  wisdom  files, you should set several   environment variables  to name them.     Running averages              The running average popup allows you to compute some values on a sliding window over your data. You choose both the value you need (average, median, minimum, maximum, standard deviation) and the length of the window and perform the operation. You can restrict the operation to the points belonging to (or outside of) a region.     Differences              The differences popup is used to compute approximations of the first derivative of a function with finite differences. The only choice (apart from the source set of course) is the type of differences to use: forward, backward or centered.     Seasonal differences              The seasonal differences popup is used to subtract data from a period to data of the preceding period (namely y[i] - y[i + period]). Beware that the period is entered in terms of index in the set and not in terms of abscissa!     Integration              The integration popup is used to compute the integral of a set and optionally to load it. The numerical value of the integral is shown in the text field after computation. Selecting ""cumulative sum"" in the choice item will create and load a new set with the integral and compute the end value, selecting ""sum only"" will only compute the end value.     Interpolation/Splines              This popup is used to interpolate a set on an array of alternative X coordinates. This is mainly used before performing some complex operations between two sets with the   evaluate          expression  popup.   The sampling array can be either a linear mesh defined by its min, max, and length values, or a mesh formed by abscissas of another set.    Several interpolation methods can be used: linear, spline or Akima spline.   Note that if the sampling mesh is not entirely within the source set X bounds, evaluation at the points beyond the bounds will be performed using interpolation parameters from the first (or the last) segment of the source set, which can be considered a primitive extrapolation. This behaviour can be disabled by checking the ""Strict"" option on the popup.   The abscissas of the set being interpolated must form a strictly monotonic array.     Regression              The regression popup can be used to fit a set against polynomials or some specific functions (y=A*x^B, y=A*exp(B*x), y=A+B*ln(x) and y=1/(A+Bx)) for which a simple transformation of input data can be used to apply linear regression formulas.   You can load either the fitted values, the residuals or the function itself. Choosing to load fitted values or residuals leads to a set of the same length and abscissas as the initial set. Choosing to load the function is almost similar to load the fitted values except that you choose yourself the boundaries and the number of points. This can be used for example to draw the curve outside of the data sample range or to produce an evenly spaced set from an irregular one.     Non-linear fit              The non linear fit popup can be used for functions outside of the simple regression methods scope. With this popup you provide the expression yourself using a0, a1, ..., a9 to denote the fit parameters (as an example you can say y = a0 * cos (a1 * x + a2)). You specify a tolerance, starting values and optional bounds and run several steps before loading the results.   The fit characteristics (number of parameters, formula, ...) can be saved in a file and retrieved as needed using the file menu of the popup.   In the ""Advanced"" tab, you can additionally apply a restriction to the set(s) to be fitted (thus ignoring points not satisfying the criteria), use one of preset weighting schemes or define your own (notice that ""dY"" in the preset ""1/dY^2"" one actually refers to the third column of the data set; use the ""Custom"" function if this doesn't make sense for your data set), and choose whether to load the fitted values, the residuals or the function itself. Choosing to load fitted values or residuals leads to a set of the same length and abscissas as the initial set. Choosing to load the function is almost similar to load the fitted values except that you choose yourself the boundaries and the number of points. This can be used for example to draw the curve outside of the data sample range or to produce an evenly spaced set from an irregular one.     Correlation/covariance              This popup can be used to compute autocorrelation of one set or cross correlation between two sets. You only select the set (or sets) and specify the maximum lag. A check box allows one to evaluate covariance instead of correlation. The result is normalized so that C(0) = 1.     Digital filter              You can use a set as a weight to filter another set. Only the Y part and the length of the weighting set are important, the X part is ignored.     Linear convolution              The convolution popup is used to ... convolve two sets. You only select the sets and apply.     Geometric transforms              You can rotate, scale or translate sets using the geometric transformations popup. You specify the characteristics of each transform and the application order.     Sample points              This popup provides two sampling methods. The first one is to choose a starting point and a step, the second one is to select only the points that satisfy a boolean expression you specify.     Prune data              This popup is devoted to reducing huge sets (and then saving both computation time and disk space).   The interpolation method can be applied only to ordered sets: it is based on the assumption that if a real point and an interpolation based on neighboring points are closer than a specified threshold, then the point is redundant and can be eliminated.   The geometric methods (circle, ellipse, rectangle) can be applied to any set, they test each point in turn and keep only those that are not in the neighborhood of previous points.      Feature extraction           Given a set of curves in a graph, extract a feature from each curve and use the values of the feature to provide the Y values for a new curve.         Feature   Description   Y minimum   Minimum Y value of set   Y maximum   Maximum Y value of set   Y average   Average Y value of set   Y std. dev.   Standard deviation of Y values   Y median   Median Y value   X minimum   Minimum X value of set   X maximum   Maximum X value of set   X average   Average X value of set   X std. dev.   Standard deviation of X values   X median   Median X value   Frequency   Perform DFT (FFT if set length a power of 2) to find largest frequency component   Period   Inverse of above   Zero crossing   Time of the first zero crossing, + or - going   Rise time   Assume curve starts at the minimum and rises to the maximum, get time to go from 10% to 90% of rise. For single exponential curves, this is 2.2*time constant   Fall time   Assume curve starts at the maximum and drops to the minimum, get time to go from 90% to 10% of fall   Slope   Perform linear regression to obtain slope   Y intercept   Perform linear regression to obtain Y-intercept   Set length   Number of data points in set   Half maximal width   Assume curve starts from the minimum, rises to the maximum and drops to the minimum again. Determine the time for which the curve is elevated more than 50% of the maximum rise.   Barycenter X   Barycenter along X axis   Barycenter Y   Barycenter along Y axis   X (Y max)   X of Maximum Y   Y (X max)   Y of Maximum X   integral   cumulative sum                   Extractable features               Import menu             ASCII              Read new sets of data in a graph. A   graph selector  is used to specify the graph where the data should go (except when reading block data, which are copied to graphs later on).   Reading as ""Single set"" means that if the source contains only one column of numeric data, one set will be created using the indices (from 1 to the total number of points) as abscissas and read values as ordinates and that if the source contains more than one column of data, the first two numeric columns will be used. Reading as ""NXY"" means that the first numeric column will provide the abscissas and all remaining columns will provide the ordinates of several sets. Reading as ""Block data"" means all column will be read and stored and that another popup will allow to select the abscissas and ordinates at will. It should be noted that block data are stored as long as you do not override them by a new read. You can still retrieve data from a block long after having closed all popups, using the   set          selector .   The set type can be one of the predefined set presentation types (see   sets ).   The data source can be selected as ""Disk"" or ""Pipe"". In the first case the text in the ""Selection"" field is considered to be a file name (it can be automatically set by the file selector at the top of the popup). In the latter case the text is considered to be a command which is executed and should produce the data on its standard output. On systems that allows is, the command can be a complete sequence of programs glued together with pipes.   If the source contains date fields, they should be automatically detected. Several formats are recognized (see appendix   dates in grace ). Calendar dates are converted to numerical dates upon reading.   The ""Autoscale on read"" menu controls whether, upon reading in new sets, which axes of the graph should be autoscaled.     NetCDF              This entry exists only if Grace has been compiled with support for the NetCDF data format (see   configuration ).     Export menu             ASCII              Save data sets in a file. A   set          selector  is used to specify the set to be saved. The format to use for saving data points can be specified (the default value is ""%16.8g""). A warning is displayed if a file with the same name already exists.       4.6   Plot menu            Plot appearance           The plot appearance popup let you set the time stamp properties and the background color of the page. The color is used outside of graphs and also on graphs were no specific background color is set. The time stamp is updated every time the project is modified.     Graph appearance           The graph appearance popup can be displayed from both the plot menu and by double-clicking on a legend, title, or subtitle of a graph (see   Clicks and double clicks ). The graph selector at the top allows to choose the graph you want to operate on, it also allows certain common actions through its popup menu (see  graph selector ). Most of the actions can also be performed using the ""Edit"" menu available from the popup menubar. The main tab includes the properties you will need more often (title for example), and other tabs are used to fine tune some less frequently used options (fonts, sizes, colors, placements).   If you need special characters or special formatting in your title or subtitle, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!   You can save graph appearance parameters or retrieve settings previously saved via the ""File"" menu of this popup. In the ""Save parameters"" dialog, you can choose to save settings either for the current graph only or for all graphs.      Set appearance           The set appearance popup can be displayed from both the plot menu and by double-clicking anywhere in a graph (see   Clicks and double clicks ). The set selector at the top allows to choose the set you want to operate on, it also allows certain common actions through its popup menu (see  set selector ). The main tab gathers the properties you will need more often (line and symbol properties or legend string for example), and other tabs are used to fine tune some less frequently used options (drop lines, fill properties, annotated values and error bars properties for example).   You should note that despite the legend string related to  one  set is entered in the set appearance popup, this is not sufficient to display it. Displaying  all  legends is a graph level decision, so the toggle is in the main tab of the   graph appearance  popup.   If you need special characters or special formatting in your legend, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!     Axis properties           The axis properties popup can be displayed from both the ""Plot"" menu and by double-clicking exactly on an axis (see   Clicks and double clicks ). The pulldown menu at the top allows to select the axis you want to operate on. The ""Active"" toggle globally activates or deactivates the axis (all GUI elements are insensitive for deactivated axes). The start and stop fields depict the displayed range. Three types of scales are available: linear, logarithmic or reciprocal, and you can invert the axis (which normally increases from left to right and from bottom to top).  The main tab includes the properties you will need more often (axis label, tick spacing and format for example), and other tabs are used to fine tune some less frequently used options (fonts, sizes, colors, placements, stagger, grid lines, special ticks, ...).   If you need special characters or special formatting in your label, you can use Grace escape sequences (the sequence will appear verbatim in the text field but will be rendered on the graph), see   typesetting . If you don't remember the mapping between alphabetic characters and the glyph you need in some specific fonts (mainly symbol and zapfdingbats), you can invoke the font tool from the text field by hitting CTRL-e. You can change fonts and select characters from there, they will be copied back in the text field when you press the ""Accept"" button. Beware of the position of the cursor as you enter text or change font in the font tool, the character or command will be inserted at this position, not at the end of the string!   Once you have set the options as you want, you can apply them. One useful feature is that you can set several axes at once with the bottom pulldown menu (current axis, all axes current graph, current axis all graphs, all axes all graphs). Beware that you always apply the properties of all tabs, not only the selected one.      4.7   View menu            Show locator bar           This toggle item shows or hides the locator below the menu bar.     Show status bar           This toggle item shows or hides the status string below the canvas.     Show tool bar           This toggle item shows or hides the tool bar at the left of the canvas.     Page setup           Set the properties of the display device. It is the same dialog as in   Print setup .     Redraw           This menu item triggers a redrawing of the canvas.     Update all           This menu item causes an update of all GUI controls. Usually, everything is updated automatically, unless one makes modifications by entering commands in the   Command  tool.       4.8   Window menu             Commands           Command driven version of the interface to Grace. Here, commands are typed at the ""Command:"" text item and executed when <Return> is pressed. The command will be parsed and executed, and the command line is placed in the history list. Items in the history list can be recalled by simply clicking on them with the left mouse button. For a reference on the Grace command interpreter, see   Command interpreter .    Point tracking           Not written yet...    Drawing objects           Not written yet...    Font tool           Not written yet...    Console           The console window displays errors and results of some numerical operations, e.g. nonlinear fit (see   Non-linear fit ). The window is popped up automatically whenever an error occurs or new result messages appear. This can be altered by checking the ""Options/Popup only on errors"" option.     4.9   Help menu            On context           Click on any element of the interface to get context-sensitive help on it. Only partially implemented at the moment.    User's guide           Browse the Grace user's guide.    Tutorial           Browse the Grace tutorial.    FAQ           Frequently Asked Questions with answers.    Changes           The list of changes during the Grace development.    Examples           The whole tree of submenus each loading a sample plot.    Comments           Use this to send your suggestions or bug reports.    License terms           Grace licensing terms will be displayed (GPL version 2).    About           A popup with basic info on the software, including some configuration details. More details can be found when running Grace with the ""-version"" command line flag.     5.   Command interpreter          5.1   General notes          The interpreter parses its input in a line-by-line manner. There may be several statements per line, separated by semicolon ( ; ). The maximal line length is 4 kbytes (hardcoded). The parser is case-insensitive and ignores lines beginning with the "" # "" sign.   5.2   Definitions               Name   Description   Examples   expr  Any numeric expression  1.5 + sin(2)   iexpr  Any expression that evaluates to an integer  25, 0.1 + 1.9, PI/asin(1)   nexpr  Non-negative iexpr  2 - 1   indx  Non-negative iexpr      qstr  Quoted string  ""a string""   vexpr  Vector expression  ""2*x""                         Basic types                  Expression   Description   Types   Example   GRAPH[ id ]  graph  id   indx  id   GRAPH[0]   G nn   graph  nn   nn : 0-99  G0                         Graph selections                  Expression   Description   Types   Example    graph .SETS[ id ]  set  id  in graph  graph indx  id , graphsel  graph   GRAPH[0].SETS[1]    graph .S nn   set  nn  in graph  graph nn : 0-99, graphsel  graph   G0.S1   SET[ id ]  set  id  in the current graph indx  id   SET[1]   S nn   set  nn  in the current graph nn : 0-99  S1   S_  the last allocated set in the current graph -  S_   S$  the active set in the current graph -  S$                         Set selections                  Expression   Description   Types   Example   R n   region  n   n : 0-4  R0                         Region selections                  Expression   Description   Types   Example   COLOR  ""colorname""   a mapped color  colorname   -  COLOR ""red""   COLOR  id   a mapped color with ID  id   nexpr  id   COLOR 2                         Color selections                  Expression   Description   Types   Example   PATTERN  id   pattern with ID  id   nexpr  id   PATTERN 1                         Pattern selections                  Expression   Description   Types   Example   X  the first column  -  X   Y  the second column  -  Y   Y n   ( n  + 2)-th column  n  = 0 - 4  Y3                         Data column selections             Not finished yet...   5.3   Variables                Variable   Description   datacolumn   data column of current set   set.datacolumn   data column of set   vvar   user-defined array   vvariable [i:j]   segment of a vector variable (elements from i-th to j-th inclusive, i <= j)                         Vector variables                    Variable   Description   vvariable[i]   i-th element of a vector variable   var   user-defined variable                         Scalar variables                 5.4   Numerical operators and functions           In numerical expressions, the infix format is used. Arguments of both operators and functions can be either scalars or vector arrays.          Operator   Description   +   addition   -   substraction   *   multiplication   /   division   %   modulus   ^   raising to power                         Arithmetic operators                    Operator   Description   AND or &&   logical AND   OR or ||   logical OR   NOT or !   logical NOT                         Logical operators                    Operator   Description   EQ or ==   equal   NE or !=   not equal   LT or <   less than   LE or <=   less than or equal   GT or >   greater than   GE or >=   greater than or equal                         Comparison operators                    Function   Description   abs(x)   absolute value   acos(x)   arccosine   acosh(x)   hyperbolic arccosine   asin(x)   arcsine   asinh(x)   hyperbolic arcsine   atan(x)   arctangent   atan2(y,x)   arc tangent of two variables   atanh(x)   hyperbolic arctangent   ceil(x)   greatest integer function   cos(x)   cosine   cosh(x)   hyperbolic cosine   exp(x)   e^x   fac(n)   factorial function, n!   floor(x)   least integer function   irand(n)   random integer less than n   ln(x)   natural log   log10(x)   log base 10   log2(x)   base 2 logarithm of x   maxof(x,y)   returns greater of x and y   mesh(n)   mesh array (0 ... n - 1)   mesh(x1, x2, n)   mesh array of n equally spaced points between x1 and x2 inclusive   minof(x,y)   returns lesser of x and y   mod(x,y)   mod function (also x % y)   pi   the PI constant   rand   pseudo random number distributed uniformly on (0.0,1.0)   rand(n)   array of n random numbers   rint(x)   round to closest integer   rsum(x)   running sum of x   sin(x)   sine function   sinh(x)   hyperbolic sine   sqr(x)   x^2   sqrt(x)   x^0.5   tan(x)   tangent function   tanh(x)   hyperbolic tangent                         Functions                  Function   Description   chdtr(df, x)   chi-square distribution   chdtrc(v, x)   complemented Chi-square distribution   chdtri(df, y)   inverse of complemented Chi-square distribution   erf(x)   error function   erfc(x)   complement of error function   fdtr(df1, df2, x)   F distribution function   fdtrc(x)   complemented F distribution   fdtri(x)   inverse of complemented F distribution   gdtr(a, b, x)   gamma distribution function   gdtrc(a, b, x)   complemented gamma distribution function   ndtr(x)   Normal distribution function   ndtri(x)   inverse of Normal distribution function   norm(x)   gaussian density function   pdtr(k, m)   Poisson distribution   pdtrc(k, m)   complemented Poisson distribution   pdtri(k, y)   inverse Poisson distribution   rnorm(xbar,s)   pseudo random number distributed N(xbar,s)   stdtr(k, t)   Student's t distribution   stdtri(k, p)   functional inverse of Student's t distribution                         Statistical functions                  Function   Description   ai(x), bi(x)   Airy functions (two independent solutions of the differential equation  y''(x) = xy )   beta(x)   beta function   chi(x)   hyperbolic cosine integral   ci(x)   cosine integral   dawsn(x)   Dawson's integral   ellie(phi, m)   incomplete elliptic integral of the second kind   ellik(phi, m)   incomplete elliptic integral of the first kind   ellpe(m)   complete elliptic integral of the second kind   ellpk(m)   complete elliptic integral of the first kind   expn(n, x)   exponential integral   fresnlc(x)   cosine Fresnel integral   fresnls(x)   sine Fresnel integral   gamma(x)   gamma function   hyp2f1(a, b, c, x)   Gauss hyper-geometric function   hyperg(a, b, x)   confluent hyper-geometric function   i0e(x)   modified Bessel function of order zero, exponentially scaled   i1e(x)   modified Bessel function of order one, exponentially scaled   igam(a, x)   incomplete gamma integral   igamc(a, x)   complemented incomplete gamma integral   igami(a, p)   inverse of complemented incomplete gamma integral   incbet(a, b, x)   incomplete beta integral   incbi(a, b, y)   Inverse of incomplete beta integral   iv(v, x)   modified Bessel function of order v   jv(v, x)   Bessel function of order v   k0e(x)   modified Bessel function, third kind, order zero, exponentially scaled   k1e(x)   modified Bessel function, third kind, order one, exponentially scaled   kn(n, x)   modified Bessel function, third kind, integer order   lbeta(x)   natural log of |beta(x)|   lgamma(x)   log of gamma function   psi(x)   psi (digamma) function   rgamma(x)   reciprocal gamma function   shi(x)   hyperbolic sine integral   si(x)   sine integral   spence(x)   dilogarithm   struve(v, x)   Struve function   yv(v, x)   Bessel function of order v   zeta(x, q)   Riemann zeta function of two arguments   zetac(x)   Riemann zeta function                         Special math functions                    Function   Description   MIN(x)   min value of array x   MAX(x)   max value of array x   AVG(x)   average of array x   SD(x)   standard deviation of array x   SUM(x)   sum of all elements of array x   INT(x,y)   integral of y dx                         Aggregate functions                   5.5   Procedures          Methods of directly manipulating the data corresponding to the Data|Transformation menu are described in table  transformations  .         Statement   Description   Types   Example   INTERPOLATE (set, mesh, method, strict)  interpolate  set  on a sampling  mesh  using  method .  strict  flag controls whether result should be bound within the source set  vexpr  mesh ,  method : one of LINEAR, SPLINE, and ASPLINE, onoff  strict   INTERPOLATE (S0, S1.X, ASPLINE, OFF)   HISTOGRAM (set, bins, cumulative, normalize)  calculate histogram of  set  on defined  bins .  cumulative  and  normalize  flags control whether to calculate cumulative and normalized (aka PDF) histograms, respectively. Data points are placed at upper limit of the bin  vexpr  bins , onoff  cumulative , onoff  normalize   HISTOGRAM (S0, MESH(0, 1, 11), OFF, ON)   XCOR (set1, set2, maxlag, covar)  calculate cross-correlation (or -covariance if the  covar  flag is set) of  set1  with  set2  with maximum lag  maxlag .  nexpr  maxlag , onoff  covar   XCOR (S0, S0, 50, OFF)   RESTRICT (set, restriction)  filter  set  according to logical  restriction . The original set will be overwritten  vexpr  restriction   RESTRICT (S0, S0.X < 0)   RESTRICT (set, region, negate)  filter  set  by keeping only points lying inside/outside  region . The original set will be overwritten  onoff  negate RESTRICT (S0, R1, OFF)                         Transformations             Not finished yet...   5.6   Device parameters          For producing ""hard copy"", several parameters can be set via the command interpreter.  They are summarized in table   Device parameters .        Command   Description   PAGE SIZE xdim, ydim   set page dimensions (in pp) of all devices   PAGE RESIZE xdim, ydim   same as above plus rescale the current plot accordingly   DEVICE  ""devname""  PAGE SIZE xdim, ydim   set page dimensions (in pp) of device  devname    DEVICE  ""devname""  DPI dpi   set device's dpi (dots per pixel)   DEVICE  ""devname""  FONT onoff   enable/disable usage of built-in fonts for device  devname    DEVICE  ""devname""  FONT ANTIALIASING onoff   enable/disable font aliasing for device  devname    DEVICE  ""devname""  OP  ""options""    set device specific options (see   Device-specific settings )   HARDCOPY DEVICE  ""devname""    set device  devname  as current hardcopy device   PRINT TO  ""filename""    set print output to  filename  (but do not print)   PRINT TO DEVICE   set print output to hardcopy device (but do not print)                         Device parameters              5.7   Flow control               Statement   Description   Types   Example   EXIT( status )  cause normal program termination with exit status  status   iexpr  status   EXIT(0)   EXIT  cause normal program termination; same as EXIT(0)     EXIT   HELP  url   open a HTML document pointed to by  url   qstr  url   HELP ""doc/FAQ.html""   HELP  open User's Guide     HELP   PRINT  execute print job     PRINT   REDRAW  refresh the canvas to reflect the current project state     REDRAW   SLEEP  n   sleep for  n  seconds  expr  n   SLEEP(3)   UPDATEALL  update the GUI (graph and set selectors etc) to reflect the current project state     UPDATEALL                         Flow control             5.8   Declarations          User-defined variables are set and used according to the syntax described in table   User variables .        Statement   Description   Types   Example   DEFINE  var   define new scalar variable  var      DEFINE myvar   DEFINE  vvar []  define new vector variable  vvar  of zero length     DEFINE myvvar[]   DEFINE  vvar [ n ]  define new vector variable  vvar  of length  n   nexpr  n   DEFINE myvvar[10]   CLEAR  var   undefine new variable  var  and deallocate associated storage     CLEAR myvar    vvar  LENGTH  n   reallocate vector variable  vvar   nexpr  n   myvvar LENGTH 25                         User variables             Not finished yet...   5.9   Graph properties        We divide the commands pertaining to the properties and appearance of graphs into those which directly manipulate the graphs and those that  affect the appearance of graph elements---the parameters that can appear in a Grace project file.   Command operations        General graph creation/annihilation and control commands appear in table   Graph operations .        Statement   Description   Types   Example   FOCUS  graph    Makes  graph  current and unhides it if necessary  graphsel  graph    FOCUS G0   KILL  graph    Kills  graph    graphsel  graph    KILL G0   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap )  Arrange existing graphs (or add extra if needed) to form an  nrows  by  ncols  matrix, leaving  offset  at each page edge with  hgap  and  vgap  relative horizontal and vertical spacings  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap   ARRANGE(2, 2, 0.1, 0.15, 0.2)   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap ,  hvinv ,  hinv ,  vinv )  Same as above, plus additional  hvinv ,  hinv , and  vinv  flags allowing to alter the order of the matrix filling  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap , onoff  hvinv ,  hinv ,  vinv   ARRANGE(2, 2, 0.1, 0.15, 0.2, ON, OFF, ON)   ARRANGE( nrows ,  ncols ,  offset ,  hgap ,  vgap ,  hvinv ,  hinv ,  vinv ,  snake )  Same as above, plus additional  snake  flag allowing to fill the matrix in a snake-like fashion  nexpr  nrows ,  ncols , expr  offset ,  hgap ,  vgap , onoff  hvinv ,  hinv ,  vinv ,  snake   ARRANGE(2, 2, 0.1, 0.15, 0.2, ON, OFF, ON, ON)                         Graph operations             Parameter settings        Setting the active graph and its type is accomplished with the commands found in table   Graph selection parameters .        Statement   Description   Types   Example   WITH  graph    Makes  graph  current  graphsel  graph    WITH G0   TYPE  type    Sets  type  of current graph  graphtype  type   TYPE XY    graph  onoff  (De)Activates selected  graph    graphsel  graph , onoff   G0 ON    graph  HIDDEN onoff   Hides selected  graph    graphsel  graph , onoff   G1 HIDDEN TRUE    graph  TYPE  type    Sets  type  of  graph   graphsel  graph , graphtype  type    G0 TYPE XYDY                         Graph selection parameters             The axis range and scale of the current graph as well as its  location on the plot viewport are set with the commands listed in table  Axis parameters .     Statement   Description   Types   Example   WORLD XMIN  xmin    Sets minimum value of current graph's x axis to  xmin   expr  xmin    WORLD XMIN -10   WORLD XMAX  xmax    Sets maximum value of current graph's x axis to  xmin   expr  xmax    WORLD XMAX 22.5   WORLD YMIN  ymin    Sets minimum value of current graph's y axis to  ymin   expr  ymin    WORLD YMIN 0   WORLD YMAX  ymax    Sets maximum value of current graph's y axis to  ymax   expr  ymax    WORLD YMAX 1e4   VIEW XMIN  xmin    Sets left edge of current graph at x= xmin  in the viewport  expr  xmin  VIEW XMIN .2   VIEW XMAX  xmax    Sets right edge of current graph at x= xmax  in the viewport  expr  xmax  VIEW XMAX 1.0   VIEW YMIN  ymin    Sets bottom edge of current graph at y= ymin  in the viewport  expr  ymin  VIEW YMIN .25   VIEW YMAX  ymax    Sets top edge of current graph at y= ymax  in the viewport  expr  ymax  VIEW YMAX .75   XAXES SCALE  type    Set scaling of the x axes to  type   type : one of NORMAL, LOGARITHMIC, or RECIPROCAL   XAXES SCALE NORMAL   YAXES SCALE  type    Set scaling of the y axes to  type   type : one of NORMAL, LOGARITHMIC, or RECIPROCAL   YAXES SCALE LOGARITHMIC   XAXES INVERT onoff   If ON, draws xmin to xmax from right to left  onoff   XAXES INVERT OFF   YAXES INVERT onoff   If ON, draws ymin to ymax from top to bottom  onoff   YAXES INVERT OFF   AUTOSCALE ONREAD  type    Set automatic scaling on read according to  type   type : one of NONE, XAXES, YAXES, XYAXES   AUTOSCALE ONREAD NONE                         Axis parameters             The commands to set the appearance and textual content of titles and legends are given in table   Titles and legends .        Statement   Description   Types   Example   TITLE  title    Sets the title of current graph  qstr  title    TITLE ""Foo""   TITLE FONT  font    Selects font of title string  fontsel  font    TITLE FONT 1   TITLE SIZE  size    Sets size of title string  expr  size    TITLE SIZE 1.5   TITLE COLOR  color    Sets color of title string  colorsel  color    TITLE COLOR 1   SUBTITLE  subtitle    Sets the subtitle of current graph  qstr  subtitle    SUBTITLE ""Bar""   SUBTITLE FONT  font    Selects font of subtitle string  fontsel  font    SUBTITLE FONT ""Times-Italic""   SUBTITLE SIZE  size    Sets size of subtitle string  expr  size    SUBTITLE SIZE .60   SUBTITLE COLOR  color    Sets color of subtitle string  colorsel  color    SUBTITLE COLOR ""blue""   LEGEND onoff   Toggle legend display  onoff   LEGEND ON   LEGEND LOCTYPE  type    Posistion legend in  type  coordinates  type : either WORLD or VIEW   LEGEND LOCTYPE WORLD   LEGEND  xloc, yloc    Set location of legend box (upper left corner)  expr  xloc, yloc    LEGEND .5,.75   LEGEND FONT  font  Set legend font type  fontsel  font    LEGEND FONT ""Helvetica""   LEGEND CHAR SIZE  size    Sets size of legend label characters (1 is normal) expr  size    LEGEND CHAR SIZE .30   LEGEND  color  Set color of legend text  colorsel  color    LEGEND COLOR 1   LEGEND VGAP  gap    Sets vertical gap between legend entries  nexpr  gap    LEGEND VGAP 1   LEGEND HGAP  gap    Sets horizontal gap between symbol and description  nexpr  gap    LEGEND HGAP 4   LEGEND LENGTH  length  Sets  length  of legend nexpr  length    LEGEND LENGTH 5   LEGEND INVERT onoff   Determines relationship between order of sets and order of legend labels  onoff   LEGEND INVERT true   LEGEND BOX onoff   Determines if the legend bounding box is drawn  onoff   LEGEND BOX off   LEGEND BOX COLOR  color    Sets color of legend bounding box   colorsel  color   LEGEND BOX COLOR 1  LEGEND BOX PATTERN  pattern  Sets pattern of legend bounding box   patternsel  pattern   LEGEND BOX PATTERN 2  LEGEND BOX LINESTYLE  style  Sets line style of bounding box  nexpr  style   LEGEND BOX LINESTYLE 1   LEGEND BOX LINEWIDTH  width  Sets line width of bounding box nexpr  width   LEGEND BOX LINEWIDTH 2   LEGEND BOX FILL onoff   Determines if the legend bounding box is filled  onoff   LEGEND BOX FILL false   LEGEND BOX FILL COLOR  color    Sets color of legend box fill   colorsel  color   LEGEND BOX COLOR 3   LEGEND BOX FILL  pattern  Sets pattern of legend box fill  patternsel  pattern   LEGEND BOX FILL PATTERN 1                        Titles and legends             Not finished yet...   5.10   Set properties          Again, as with the graphs, we separate those parser commands that manipulate the data in a set from the commands that determine parameters---elements that are saved in a project file.    Commands        Operations for set I/O are summarized in table   Set input, output,  and creation .  (Note that this is incomplete  and only lists  input  commands at the moment.)        Statement   Description   Types   Example   READ  file    Reads  file  as a single set  qstr  file    READ ""foo.dat""   READ  settype   file    Reads  file  into a single set of type  settype   xytype  settype , qstr  file    READ xydy ""bar.dat""   READ NXY  file    Reads  file  as NXY data  qstr  file    READ NXY ""gad.dat""   READ BLOCK  file    Reads  file  as block data  qstr  file    READ BLOCK ""zooks.dat""   BLOCK  settype   columns    Forms a data set of type  settype  using  columns  from current block data file.  xytype  settype , qstr  columns    BLOCK xydxdy ""0:2:1:3""                         Set input, output,  and creation             The parser commands analogous to the Data|Data set operations dialogue can be found in table   Set operations .      Statement   Description   Types   Example   COPY  src  TO  dest    Copies  src  to  dest setsel  src,dest    COPY S0 TO S1   MOVE  src  TO  dest    Moves  src  to  dest   setsel  src,dest    MOVE G0.S0 TO G1.S0   SWAP  src  AND  dest    Interchanges  src  and  dest   setsel  src,dest    SWAP G0.S0 AND G0.S1   KILL  set    Kills  set    setsel  set    KILL G0.S0                         Set operations             Not Finished yet...    Parameter settings        Not written yet...    6.   Advanced topics           6.1   Fonts          For all devices, Grace uses Type1 fonts. Both PFA (ASCII) and PFB (binary) formats can be used.    Font configuration          The file responsible for the font configurations of Grace is  fonts/FontDataBase . The first line contains a positive integer specifying the number of fonts declared in that file. All remaining lines contain declarations of one font each, composed out of three fields:     Font name. The name will appear in the font selector controls. Also, backend devices that has built-in fonts, will be given the name as a font identifier.    Font fall-back. Grace will try to use this in case the real font is not found.    Font filename. The file with the font outline data.       Here is the default  FontDataBase  file:      14 Times-Roman             Times-Roman             n021003l.pfb Times-Italic            Times-Italic            n021023l.pfb Times-Bold              Times-Bold              n021004l.pfb Times-BoldItalic        Times-BoldItalic        n021024l.pfb Helvetica               Helvetica               n019003l.pfb Helvetica-Oblique       Helvetica-Oblique       n019023l.pfb Helvetica-Bold          Helvetica-Bold          n019004l.pfb Helvetica-BoldOblique   Helvetica-BoldOblique   n019024l.pfb Courier                 Courier                 n022003l.pfb Courier-Oblique         Courier-Oblique         n022023l.pfb Courier-Bold            Courier-Bold            n022004l.pfb Courier-BoldOblique     Courier-BoldOblique     n022024l.pfb Symbol                  Symbol                  s050000l.pfb ZapfDingbats            ZapfDingbats            d050000l.pfb                   Font data files        For text rastering, three types of files are used.      .pfa -/ .pfb -files: These contain the character outline descriptions. The files are assumed to be in the  fonts/type1  directory; these are the filenames specified in the  FontDataBase  configuration file.     .afm -files: These contain high-precision font metric descriptions as well as some extra information, such as kerning and ligature information for a particular font. It is assumed that the filename of a font metric file has same basename as the respective font outline file, but with the  .afm  extension; the metric files are expected to be found in the  fonts/type1  directory, too.     .enc -files: These contain encoding arrays in a special but simple form. They are only needed if someone wants to load a special encoding to re-encode a font. Their place is  fonts/enc        Custom fonts          It is possible to use custom fonts with Grace. One mostly needs to use extra fonts for the purpose of localization. For many European languages, the standard fonts supplied with Grace should contain all the characters needed, but encoding may have to be adjusted. This is done by putting a  Default.enc  file with proper encoding scheme into the  fonts/enc  directory. Grace comes with a few encoding files in the directory; more can be easily found on the Internet. (If the  Default.enc  file doesn't exist, the IsoLatin1 encoding will be used). Notice that for fonts having an encoding scheme in themselves (such as the Symbol font, and many nationalized fonts) the default encoding is ignored.   If you do need to use extra fonts, you should modify the  FontDataBase  file accordingly, obeying its format. However, if you are going to exchange Grace project files with other people who do not have the extra fonts configured, an important thing is to define reasonable fall-back font names.   For example, let us assume I use Hebrew fonts, and the configuration file has lines like these:          ... Courier-Hebrew              Courier                 courh___.pfa Courier-Hebrew-Oblique      Courier-Oblique         courho__.pfa     ...               My colleague, who lives in Russia, uses Cyrillic fonts with Grace configured like this:          ... Cronix-Courier              Courier                 croxc.pfb Cronix-Courier-Oblique      Courier-Oblique         croxco.pfb     ...               The font mapping information (Font name <-> Font fall-back) is stored in the Grace project files. Provided that all the localized fonts have English characters in the lower part of the ASCII table unmodified, I can send my friend files (with no Hebrew characters, of course) and be sure they render correctly on his computer.   Thus, with properly configured national fonts, you can make localized annotations for plots intended for internal use of your institution, while being able to exchange files with colleagues from abroad. People who ever tried to do this with MS Office applications should appreciate the flexibility :-).    6.2   Interaction with other applications            Using pipes            Using grace_np library          The grace_np library is a set of compiled functions that allows you to launch and drive a Grace subprocess from your C or Fortran application. Functions are provided to start the subprocess, to send it commands or data, to stop it or detach from it.        Function   Arguments   Description   int GraceOpenVA   (char * exe , int  buf_size , ...)  launch a Grace executable  exe  and open a communication channel with it using  buf_size  bytes for data buffering. The remaining NULL-terminated list of options is command line arguments passed to the Grace process   int GraceOpen   (int  buf_size )  equivalent to GraceOpenVA(""xmgrace"", buf_size, ""-nosafe"", ""-noask"", NULL)   int GraceIsOpen   (void)   test if a Grace subprocess is currently connected   int GraceClose   (void)   close the communication channel and exit the Grace subprocess   int GraceClosePipe   (void)   close the communication channel and leave the Grace subprocess alone   int GraceFlush   (void)   flush all the data remaining in the buffer   int GracePrintf   (const char*  format , ...)  format a command and send it to the Grace subprocess   int GraceCommand   (const char*  cmd )  send an already formated command to the Grace subprocess   GraceErrorFunctionType GraceRegisterErrorFunction  (GraceErrorFunctionType  f )  register a user function  f  to display library errors                 grace_np library C functions.                  Function   Arguments   Description   integer GraceOpenF   (integer  buf_size )  launch a Grace subprocess and open a communication channel with it   integer GraceIsOpenF   (void)   test if a Grace subprocess is currently connected   integer GraceCloseF   (void)   close the communication channel and exit the Grace subprocess   integer GraceClosePipeF   (void)   close the communication channel and leave the Grace subprocess alone   integer GraceFlushF   (void)   flush all the data remaining in the buffer   integer GraceCommandF   (character*(*)  cmd )  send an already formatted command to the Grace subprocess   GraceFortranFunctionType GraceRegisterErrorFunctionF  (GraceFortranFunctionType  f )  register a user function  f  to display library errors                 grace_np library F77 functions.               There is no Fortran equivalent for the GracePrintf function, you should format all the data and commands yourself before sending them with GraceCommandF.   The Grace subprocess listens for the commands you send and interprets them as if they were given in a batch file. You can send any command you like (redraw, autoscale, ...). If you want to send data, you should include them in a command like ""g0.s0 point 3.5, 4.2"".   Apart from the fact it monitors the data sent via an anonymous pipe, the Grace subprocess is a normal process. You can interact with it through the GUI. Note that no error can be sent back to the parent process. If your application send erroneous commands, an error popup will be displayed by the subprocess.   If you exit the subprocess while the parent process is still using it, the broken pipe will be detected. An error code will be returned to every further call to the library (but you can still start a new process if you want to manage this situation).   Here is an example use of the library, you will find this program in the distribution.         #include <stdlib.h> #include <stdio.h> #include <unistd.h> #include <grace_np.h>  #ifndef EXIT_SUCCESS #  define EXIT_SUCCESS 0 #endif  #ifndef EXIT_FAILURE #  define EXIT_FAILURE -1 #endif  void my_error_function(const char *msg) {     fprintf(stderr, ""library message: \""%s\""\n"", msg); }  int main(int argc, char* argv[]) {     int i;      GraceRegisterErrorFunction(my_error_function);      /* Start Grace with a buffer size of 2048 and open the pipe */     if (GraceOpen(2048) == -1) {         fprintf(stderr, ""Can't run Grace. \n"");         exit(EXIT_FAILURE);     }          /* Send some initialization commands to Grace */     GracePrintf(""world xmax 100"");     GracePrintf(""world ymax 10000"");     GracePrintf(""xaxis tick major 20"");     GracePrintf(""xaxis tick minor 10"");     GracePrintf(""yaxis tick major 2000"");     GracePrintf(""yaxis tick minor 1000"");     GracePrintf(""s0 on"");     GracePrintf(""s0 symbol 1"");     GracePrintf(""s0 symbol size 0.3"");     GracePrintf(""s0 symbol fill pattern 1"");     GracePrintf(""s1 on"");     GracePrintf(""s1 symbol 1"");     GracePrintf(""s1 symbol size 0.3"");     GracePrintf(""s1 symbol fill pattern 1"");      /* Display sample data */     for (i = 1; i <= 100 && GraceIsOpen(); i++) {         GracePrintf(""g0.s0 point %d, %d"", i, i);         GracePrintf(""g0.s1 point %d, %d"", i, i * i);         /* Update the Grace display after every ten steps */         if (i % 10 == 0) {             GracePrintf(""redraw"");             /* Wait a second, just to simulate some time needed for                calculations. Your real application shouldn't wait. */             sleep(1);         }     }      if (GraceIsOpen()) {         /* Tell Grace to save the data */         GracePrintf(""saveall \""sample.agr\"""");          /* Flush the output buffer and close Grace */         GraceClose();          /* We are done */         exit(EXIT_SUCCESS);     } else {         exit(EXIT_FAILURE);     } }             6.3   FFTW tuning          When the FFTW capabilities are compiled in, Grace looks at two environment variables to decide what to do with the FFTW 'wisdom' capabilities.  First, a quick summary of what this is. The FFTW package is capable of adaptively determining the most efficient factorization of a set to give the fastest computation.  It can store these factorizations as 'wisdom', so that if a transform of a given size is to be repeated, it is does not have to re-adapt.  The good news is that this seems to work very well.  The bad news is that, the first time a transform of a given size is computed, if it is not a sub-multiple of one already known, it takes a LONG time (seconds to minutes).   The first environment variable is GRACE_FFTW_WISDOM_FILE. If this is set to the name of a file which can be read and written (e.g., $HOME/.grace_fftw_wisdom) then Grace will automatically create this file (if needed) and maintain it. If the file is read-only, it will be read, but not updated with new wisdom. If the symbol GRACE_FFTW_WISDOM_FILE either doesn't exist, or evaluates to an empty string, Grace will drop the use of wisdom, and will use the fftw estimator (FFTW_ESTIMATE flag sent to the planner) to guess a good factorization, instead of adaptively determining it.   The second variable is GRACE_FFTW_RAM_WISDOM. If this variable is defined to be non-zero, and GRACE_FFTW_WISDOM_FILE variable is not defined (or is an empty string), Grace will use wisdom internally, but maintain no persistent cache of it. This will result in very slow execution times the first time a transform is executed after Grace is started, but very fast repeats. I am not sure why anyone would want to use wisdom without writing it to disk, but if you do, you can use this flag to enable it.       6.4   DL modules           Grace can access external functions present in either system or third-party shared libraries or modules specially compiled for use with Grace.    Function types        One must make sure, however, that the external function is of one of supported by Grace types:     Grace type   Description   f_of_i   a function of 1  int  variable   f_of_d   a function of 1  double  variable   f_of_nn   a function of 2  int  parameters   f_of_nd   a function of 1  int  parameter and 1  double  variable   f_of_dd   a function of 2  double  variables   f_of_nnd   a function of 2  int  parameters and 1  double  variable   f_of_ppd   a function of 2  double  parameters and 1  double  variable   f_of_pppd   a function of 3  double  parameters and 1  double  variable                                     Grace types for external functions             The return values of functions are assumed to be of the  double  type.   Note, that there is no difference from the point of view of function prototype between parameters and variables; the difference is in the way Grace treats them - an attempt to use a vector expression as a parameter argument will result in a parse error.   Let us consider few examples.    Examples           Caution: the examples provided below (paths and compiler flags) are valid for Linux/ELF with gcc. On other operating systems, you may need to refer to compiler/linker manuals or ask a guru.    Example 1           Suppose I want to use function  pow(x,y)  from the Un*x math library (libm). Of course, you can use the ""^"" operator defined in the Grace language, but here, for the sake of example, we want to access the function directly.   The command to make it accessible by Grace is   USE ""pow"" TYPE f_of_dd FROM ""/usr/lib/libm.so""      Try to plot y = pow(x,2) and y = x^2 graphs (using, for example, ""create new -> Formula"" from any   set        selector ) and compare.    Example 2           Now, let us try to write a function ourselves. We will define function  my_function  which simply returns its (second) argument multiplied by integer parameter transferred as the first argument.   In a text editor, type in the following C code and save it as ""my_func.c"":                double my_function (int n, double x)        {            double retval;            retval = (double) n * x;            return (retval);        }                  OK, now compile it:                $gcc -c -fPIC my_func.c        $gcc -shared my_func.o -o /tmp/my_func.so                  (You may strip it to save some disk space):                $strip /tmp/my_func.so                  That's all! Ready to make it visible to Grace as ""myf"" - we are too lazy to type the very long string ""my_function"" many times.      USE ""my_function"" TYPE f_of_nd FROM ""/tmp/my_func.so"" ALIAS ""myf""        Example 3           A more serious example. There is a special third-party library available on your system which includes a very important for you yet very difficult-to-program from the scratch function that you want to use with Grace.  But, the function prototype is NOT one of any predefined   types .  The solution is to write a simple function wrapper. Here is how:   Suppose, the name of the library is ""special_lib"" and the function you are interested in is called ""special_func"" and according to the library manual, should be accessed as  void special_func(double *input, double *output, int parameter) . The wrapper would look like this:                double my_wrapper(int n, double x)        {            extern void special_func(double *x, double *y, int n);            double retval;            (void) special_func(&x, &retval, n);            return (retval);        }                  Compile it:                $gcc -c -fPIC my_wrap.c        $gcc -shared my_wrap.o -o /tmp/my_wrap.so -lspecial_lib -lblas        $strip /tmp/my_wrap.so                  Note that I added  -lblas  assuming that the special_lib library uses some functions from the BLAS. Generally, you have to add  all  libraries which your module depends on (and all libraries those libraries rely upon etc.), as if you wanted to compile a plain executable.   Fine, make Grace aware of the new function      USE ""my_wrapper"" TYPE f_of_nd FROM ""/tmp/my_wrap.so"" ALIAS ""special_func""      so we can use it with its original name.    Example 4           An example of using Fortran modules.   Here we will try to achieve the same functionality as in Example 2, but with the help of F77.                DOUBLE PRECISION FUNCTION MYFUNC (N, X)        IMPLICIT NONE        INTEGER N        DOUBLE PRECISION X C        MYFUNC = N * X C        RETURN        END                  As opposite to C, there is no way to call such a function from Grace directly - the problem is that in Fortran all arguments to a function (or subroutine) are passed by reference. So, we need a wrapper:                double myfunc_wrapper(int n, double x)        {            extern double myfunc_(int *, double *);            double retval;            retval = myfunc_(&n, &x);            return (retval);        }                  Note that most of f77 compilers by default add underscore to the function names and convert all names to the lower case, hence I refer to the Fortran function  MYFUNC  from my C wrapper as  myfunc_ , but in your case it can be different!   Let us compile the whole stuff:                $g77 -c -fPIC myfunc.f        $gcc -c -fPIC myfunc_wrap.c        $gcc -shared myfunc.o myfunc_wrap.o -o /tmp/myfunc.so -lf2c -lm        $strip /tmp/myfunc.so                  And finally, inform Grace about this new function:      USE ""myfunc_wrapper"" TYPE f_of_nd FROM ""/tmp/myfunc.so"" ALIAS ""myfunc""       Operating system issues              OS/2              In general the method outlined in the examples above can be used on OS/2, too. However you have to create a DLL (Dynamic Link Library) which is a bit more tricky on OS/2 than on most Un*x systems. Since Grace was ported by using EMX we also use it to create the examples; however other development environments should work as well (ensure to use the _System calling convention!). We refer to Example 2 only. Example 1 might demonstrate that DLLs can have their entry points (i.e. exported functions) callable via ordinals only, so you might not know how to access a specific function without some research. First compile the source from Example 2 to ""my_func.obj""      gcc -Zomf -Zmt -c my_func.c -o my_func.obj      Then you need to create a linker definition file ""my_func.def"" which contains some basic info about the DLL and declares the exported functions.                  LIBRARY my_func INITINSTANCE TERMINSTANCE          CODE LOADONCALL          DATA LOADONCALL MULTIPLE NONSHARED          DESCRIPTION 'This is a test DLL: my_func.dll'          EXPORTS          my_function                    (don't forget about the 8 characters limit on the DLL name!). Finally link the DLL:      gcc my_func.obj my_func.def -o my_func.dll -Zdll -Zno-rte -Zmt -Zomf      (check out the EMX documentation about the compiler/linker flags used here!) To use this new library function within Grace you may either put the DLL in the LIBPATH and use the short form:      USE ""my_function"" TYPE f_of_nd FROM ""my_func"" ALIAS ""myf""      or put it in an arbitrary path which you need to specify explicitly then:      USE ""my_function"" TYPE f_of_nd FROM ""e:/foo/my_func.dll"" ALIAS ""myf""      (as for most system-APIs you may use the Un*x-like forward slashs within the path!)    7.   References           7.1   Typesetting          Grace permits quite complex typesetting on a per string basis. Any string displayed (titles, legends, tick marks,...) may contain special control codes to display subscripts, change fonts within the string etc.         Control code   Description   \f{x}   switch to font named ""x""   \f{n}   switch to font number n   \f{}   return to original font   \R{x}   switch to color named ""x""   \R{n}   switch to color number n   \R{}   return to original color   \#{x}   treat ""x"" (must be of even length) as list of hexadecimal char codes   \t{xx xy yx yy}   apply transformation matrix   \t{}   reset transformation matrix   \z{x}   zoom x times   \z{}   return to original zoom   \r{x}   rotate by x degrees   \l{x}   slant by factor x   \v{x}   shift vertically by x   \v{}   return to unshifted baseline   \V{x}   shift baseline by x   \V{}   reset baseline   \h{x}   horizontal shift by x   \n   new line   \u   begin underline   \U   stop underline   \o   begin overline   \O   stop overline   \Fk   enable kerning   \FK   disable kerning   \Fl   enable ligatures   \FL   disable ligatures   \m{n}   mark current position as n   \M{n}   return to saved position n   \dl   LtoR substring direction   \dr   RtoL substring direction   \dL   LtoR text advancing   \dR   RtoL text advancing   \x   switch to Symbol font (same as \f{Symbol})   \+   increase size (same as \z{1.19} ; 1.19 = sqrt(sqrt(2)))   \-   decrease size (same as \z{0.84} ; 0.84 = 1/sqrt(sqrt(2)))   \s   begin subscripting (same as \v{-0.4}\z{0.71})   \S   begin superscripting (same as \v{0.6}\z{0.71})   \T{xx xy yx yy}   same as \t{}\t{xx xy yx yy}   \Z{x}   absolute zoom x times (same as \z{}\z{x})   \q   make font oblique (same as \l{0.25})   \Q   undo oblique (same as \l{-0.25})   \N   return to normal style (same as \v{}\t{})   \\   print \   \n   switch to font number n (0-9) (deprecated)   \c   begin using upper 128 characters of set (deprecated)   \C   stop using upper 128 characters of set (deprecated)                                     Control codes.              Example:   F\sX\N(\xe\f{}) = sin(\xe\f{})\#{b7}e\S-X\N\#{b7}cos(\xe\f{})    prints roughly                           -x        F (e) = sin(e)·e  ·cos(e)         x                using string's initial font and e prints as epsilon from the Symbol font.   NOTE: Characters from the upper half of the char table can be entered directly from the keyboard, using appropriate  xmodmap(1)  settings, or with the help of the font tool (""Window/Font tool"").       7.2   Device-specific limitations           Grace can output plots using several device backends. The list of available devices can be seen (among other stuff) by specifying the ""-version"" command line switch.     X11, PostScript and EPS are full-featured devices    Raster drivers (PNM/JPEG/PNG):     only even-odd fill rule is supported    patterned lines are not implemented        PDF driver:     bitmapped text strings are not transparent        MIF driver:     some of patterned fills not implemented    bitmapped text strings not implemented        SVG driver:     bitmapped text strings not implemented                7.3   Device-specific settings           Some of the output devices accept several configuration options. You can set the options by passing a respective string to the interpreter using the ""DEVICE  ""devname""  OP  ""options"" "" command (see  Device parameters ). A few options can be passed in one command, separated by commas.          Command   Description   grayscale   set grayscale output   color   set color output   level1   use only PS Level 1 subset of commands   level2   use also PS Level 2 commands if needed   docdata:7bit   the document data is 7bit clean   docdata:8bit   the document data is 8bit clean   docdata:binary   the document data may be binary   xoffset: x    set page offset in X direction  x  pp   yoffset: y    set page offset in Y direction  y  pp   mediafeed:auto   default input tray   mediafeed:match   select input with media matching page dimensions   mediafeed:manual   manual media feed   hwresolution:on   set hardware resolution   hwresolution:off   do not set hardware resolution                   PostScript driver options                    Command   Description   grayscale   set grayscale output   color   set color output   level1   use only PS Level 1 subset of commands   level2   use also PS Level 2 commands if needed   bbox:tight   enable ""tight"" bounding box   bbox:page   bounding box coincides with page dimensions                   EPS driver options                    Command   Description   PDF1.2   set compatibility mode to PDF-1.2   PDF1.3   set compatibility mode to PDF-1.3   compression:value   set compression level (0 - 9)   patterns:on   enable use of patterns   patterns:off   disable use of patterns                   PDF driver options                    Command   Description   format:pbm   output in PBM format   format:pgm   output in PGM format   format:ppm   output in PPM format   rawbits:on   ""rawbits"" (binary) output   rawbits:off   ASCII output                   PNM driver options                    Command   Description   grayscale   set grayscale output   color   set color output   optimize:on/off   enable/disable optimization   quality:value   set compression quality (0 - 100)   smoothing:value   set smoothing (0 - 100)   baseline:on/off   do/don't force baseline output   progressive:on/off   do/don't output in progressive format   dct:ifast   use fast integer DCT method   dct:islow   use slow integer DCT method   dct:float   use floating-point DCT method                   JPEG driver options                    Command   Description   interlaced:on   make interlaced image   interlaced:off   don't make interlaced image   transparent:on   produce transparent image   transparent:off   don't produce transparent image   compression:value   set compression level (0 - 9)                   PNG driver options                   7.4   Dates in Grace           We use two calendars in Grace: the one that was established in 532 by Denys and lasted until 1582, and the one that was created by Luigi Lilio (Alyosius Lilius) and Christoph Klau (Christophorus Clavius) for pope Gregorius XIII. Both use the same months (they were introduced under emperor Augustus, a few years after Julian calendar introduction, both Julius and Augustus were honored by a month being named after each one).   The leap years occurred regularly in Denys's calendar: once every four years, there is no year 0 in this calendar (the leap year -1 was just before year 1). This calendar was not compliant with earth motion and the dates were slowly shifting with regard to astronomical events.   This was corrected in 1582 by introducing Gregorian calendar. First a ten days shift was introduced to reset correct dates (Thursday October the 4th was followed by Friday October the 15th). The rules for leap years were also changed: three leap years are removed every four centuries. These years are those that are multiple of 100 but not multiple of 400: 1700, 1800, and 1900 were not leap years, but 1600 and 2000 were (will be) leap years.   We still use Gregorian calendar today, but we now have several time scales for increased accuracy. The International Atomic Time (TAI) is a linear scale: the best scale to use for scientific reference. The Coordinated Universal Time (UTC, often confused with Greenwich Mean Time) is a legal time that is almost synchronized with earth motion. However, since the earth is slightly slowing down, leap seconds are introduced from time to time in UTC (about one second every 18 months). UTC is not a continuous scale ! When a leap second is introduced by International Earth Rotation Service, this is published in advance and the legal time sequence is as follows: 23:59:59 followed one second later by 23:59:60 followed one second later by 00:00:00. At the time of this writing (1999-01-05) the difference between TAI and UTC was 32 seconds, and the last leap second was introduced in 1998-12-31.   These calendars allow to represent any date from the mist of the past to the fog of the future, but they are not convenient for computation. Another time scale is possible: counting only the days from a reference. Such a time scale was introduced by Joseph-Juste Scaliger (Josephus Justus Scaliger) in 1583. He decided to use ""-4713-01-01T12:00:00"" as a reference date because it was at the same time a Monday, first of January of a leap year, there was an exact number of 19 years Meton cycle between this date and year 1 (for Easter computation), and it was at the beginning of a 15 years  Roman indiction  cycle. The day number counted from this reference is traditionally called  Julian day , but it has really nothing to do with the Julian calendar.   Grace stores dates internally as reals numbers counted from a reference date. The default reference date is the one chosen by Scaliger, it is a classical reference for astronomical events. It can modified for a single session using the   Edit->Preferences  popup of the GUI. If you often work with a specific reference date you can set it for every sessions with a REFERENCE DATE command in your configuration file (see   Default template ).   The following date formats are supported (hour, minutes and seconds are always optional):       iso8601  : 1999-12-31T23:59:59.999   european : 31/12/1999 23:59:59.999 or 31/12/99 23:59:59.999   us       : 12/31/1999 23:59:59.999 or 12/31/99 23:59:59.999   Julian   : 123456.789       One should be aware that Grace does not allow to put a space in one data column as spaces are used to separate fields. You should always use another separator (:/.- or better T) between date and time in data files. The GUI, the batch language and the command line flags do not have this limitation, you can use spaces there without any problem. The T separator comes from the ISO8601 standard. Grace support its use also in european and us formats.   You can also provide a hint about the format (""ISO8601"", ""european"", ""us"") using the -datehint command line flag or the ref name=""Edit->Preferences"" id=""preferences""> popup of the GUI. The formats are tried in the following order: first the hint given by the user, then iso, european and us (there is no ambiguity between calendar formats and numerical formats and therefore no order is specified for them). The separators between various fields can be any characters in the set: "" :/.-T"" (one or more spaces act as one separator, other characters can not be repeated, the T separator is allowed only between date and time, mainly for iso8601), so the string ""1999-12 31:23/59"" is allowed (but not recommended).  The '-' character is used both as a separator (it is traditionally used in iso8601 format) and as the unary minus (for dates in the far past or for numerical dates). By default years are left untouched, so 99 is a date far away in the past. This behavior can be changed with the   Edit->preferences  popup, or with the  DATE WRAP on  and  DATE WRAP YEAR year  commands. Suppose for example that the wrap year is chosen as 1950, if the year is between 0 and 99 and is written with two or less digits, it is mapped to the present era as follows:   range [00 ; 49] is mapped to [2000 ; 2049]   range [50 ; 99] is mapped to [1950 ; 1999]   with a wrap year set to 1970, the mapping would have been:   range [00 ; 69] is mapped to [2000 ; 2069]   range [70 ; 99] is mapped to [1970 ; 1999]   this is reasonably Y2K compliant and is consistent with current use.  Specifying year 1 is still possible using more than two digits as follows: ""0001-03-04"" is unambiguously March the 4th, year 1. The inverse transform is applied for dates written by Grace, for example as tick labels. Using two digits only for years is not recommended, we introduce a  wrap year + 100  bug here so this feature should be removed at some point in the future ...   The date scanner can be used either for Denys's and Gregorian calendars. Inexistent dates are detected, they include year 0, dates between 1582-10-05 and 1582-10-14, February 29th of non leap years, months below 1 or above 12, ...  the scanner does not take into account leap seconds: you can think it works only in International Atomic Time (TAI) and not in Coordinated Unified Time (UTC). If you find yourself in a situation were you need UTC, a very precise scale, and should take into account leap seconds ... you should convert your data yourself (for example using International Atomic Time). But if you bother with that you probably already know what to do.     7.5   Xmgr to Grace migration guide           This is a very brief guide describing problems and workarounds for reading in project files saved with Xmgr. You should read the docs or just play with Grace to test new features and controls.        Grace must be explicitly told the version number of the software used to create a file. You can manually put ""@version VERSIONID"" string at the beginning of the file. The VERSIONID is built as MAJOR_REV*10000 + MINOR_REV*100 + PATCHLEVEL; so 40101 corresponds to xmgr-4.1.1. Projects saved with Xmgr-4.1.2 do NOT need the above, since they already have the version string in them. If you have no idea what version of Xmgr your file was created with, try some. In most cases, 40102 would do the trick.      The above relates to the ASCII projects only. The old binary projects (saved with xmgr-4.0.*) are not automatically converted anymore. An input filter must be defined to make the conversion work on-the-fly. Add the following line to  /.gracerc or the system-wide $GRACE_HOME/gracerc resource file: DEFINE IFILTER ""grconvert %s -"" MAGIC ""00000031"" See docs for more info on the I/O filters.      Documentation on the script language is severely lacking still.      Grace is WYSIWYG. Xmgr was not. Many changes required to achieve the WYSIWYG'ness led to the situation when graphs with objects carefully aligned under Xmgr may not look so under Grace. Grace tries its best to compensate for the differences, but sometimes you may have to adjust such graphs manually.      A lot of symbol types (all except *real* symbols) are removed. ""Location *"" types can be replaced (with much higher comfort) by A(nnotating)values. ""Impulse *"", ""Histogram *"" and ""Stair steps *"" effects can be achieved using the connecting line parameters (Type, Drop lines). ""Dot"" symbol is removed as well; use the filled circle symbol of the zero size with no outline to get the same effect.      Default page layout switched from free (allowing to resize canvas with mouse) to fixed. For the old behavior, put ""PAGE LAYOUT FREE"" in the Grace resource file or use the ""-free"" command line switch.  The use of the ""free"" page layout is in general deprecated, though.       System (shell) variables GR_* renamed to GRACE_*      Smith plots don't work now. They'll be put back soon."
GX037-11-6851340	MATLAB Function Reference      Go to function:          Search      Help Desk       primes       Examples     See Also               Generate list of prime numbers   Syntax   p = primes(n)    Description   p = primes(n)    returns a row vector of the prime numbers less than or equal to  n . A prime number is one that has no factors other than  1  and itself.   Examples   p = primes(37)    p =         2     3     5     7    11    13    17    19    23    29    31    37    See Also   factor        [  Previous  |  Help Desk  |  Next  ]
GX033-37-14476546	TRandom3     class description  -  source file  -  inheritance tree       class  TRandom3  : public  TRandom          public:                  TRandom3   TRandom3 ( UInt_t  seed = 65539)                 TRandom3   TRandom3 (const  TRandom3 &)            virtual  void   ~TRandom3 ()          static  TClass *  Class ()         virtual  TClass *  IsA () const        virtual  Double_t   Rndm ( Int_t  i = 0)            virtual  void   RndmArray ( Int_t  n,  Float_t * array)            virtual  void   RndmArray ( Int_t  n,  Double_t * array)            virtual  void   SetSeed ( UInt_t  seed = 0)            virtual  void   ShowMembers ( TMemberInspector & insp,  char * parent)            virtual  void   Streamer ( TBuffer & b)                     void   StreamerNVirtual ( TBuffer & b)        Data Members        private:          UInt_t   fMt[624]               Int_t   fCount624            Class Description     TRandom3    Random number generator class based on    M. Matsumoto and T. Nishimura,    Mersenne Twistor: A 623-diminsionally equidistributed    uniform pseudorandom number generator    ACM Transactions on Modeling and Computer Simulation,    Vol. 8, No. 1, January 1998, pp 3--30.   For more information see the Mersenne Twistor homepage    http://www.math.keio.ac.jp/~matumoto/emt. html    Advantage: large period 2**19937-1             relativly fast               (only two times slower than  TRandom , but                two times faster than  TRandom2 )  Drawback:  a relative large internal state of 624 integers    Aug.99 ROOT implementation based on CLHEP by P.Malzacher   the original code contains the following copyright notice:      TRandom3 ( UInt_t  seed)    *-*-*-*-*-*-*-*-*-*-*default constructor*-*-*-*-*-*-*-*-*-*-*-*-*-*-* *-*                  ===================      ~TRandom3 ()    *-*-*-*-*-*-*-*-*-*-*default destructor*-*-*-*-*-*-*-*-*-*-*-*-*-*-* *-*                  ==================    Double_t   Rndm ( Int_t )      Machine independent random number generator.   Produces uniformly-distributed floating points in [0,1]   Method: Mersenne Twistor    void   RndmArray ( Int_t  n,  Float_t  *array)     Return an array of n random numbers uniformly distributed in ]0,1]    void   RndmArray ( Int_t  n,  Double_t  *array)     Return an array of n random numbers uniformly distributed in ]0,1]    void   SetSeed ( UInt_t  seed)      Set the random generator sequence    void   Streamer ( TBuffer  &R__b)     Stream an object of class  TRandom3 .    Inline Functions                  TClass *  Class ()               TClass *  IsA () const                  void   ShowMembers ( TMemberInspector & insp,  char * parent)                  void   StreamerNVirtual ( TBuffer & b)              TRandom3   TRandom3 (const  TRandom3 &)         Last update: Fri Aug 29 13:51:24 2003           ROOT page  -  Home page  -  Class index  -  Top of the page          This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to  ROOT support , or contact  the developers  with any questions or problems regarding ROOT.
GX060-04-10677882	"Go to the  previous ,  next  section.   Functions that Operate on Arrays      In this section, we describe the functions that accept both strings and vectors.      Function:   arrayp   object  This function returns  t  if  object  is an array (i.e., either a vector or a string).    (arrayp [a]) => t (arrayp ""asdf"") => t          Function:   aref   array index  This function returns the  index th element of  array .  The first element is at index zero.    (setq primes [2 3 5 7 11 13])      => [2 3 5 7 11 13] (aref primes 4)      => 11 (elt primes 4)      => 11  (aref ""abcdefg"" 1)      => 98           ;  `b'  is ASCII code 98.     See also the function  elt , in section  Sequences .      Function:   aset   array index object  This function sets the  index th element of  array  to be  object .  It returns  object .    (setq w [foo bar baz])      => [foo bar baz] (aset w 0 'fu)      => fu w      => [fu bar baz]  (setq x ""asdfasfd"")      => ""asdfasfd"" (aset x 3 ?Z)      => 90 x      => ""asdZasfd""     If  array  is a string and  object  is not a character, a  wrong-type-argument  error results.      Function:   fillarray   array object  This function fills the array  array  with  object , so that each element of  array  is  object .  It returns  array .    (setq a [a b c d e f g])      => [a b c d e f g] (fillarray a 0)      => [0 0 0 0 0 0 0] a      => [0 0 0 0 0 0 0] (setq s ""When in the course"")      => ""When in the course"" (fillarray s ?-)      => ""------------------""     If  array  is a string and  object  is not a character, a  wrong-type-argument  error results.   The general sequence functions  copy-sequence  and  length  are often useful for objects known to be arrays.  See section  Sequences .    Go to the  previous ,  next  section."
GX059-46-13203257	"The Perl 5 Module List  Maintained by Tim Bunce and Andreas König  <modules@perl.org> ;    $Revision: 3.112 $ $Date: 2002/08/27 23:28:18 $ -*- coding:utf-8 -*-    Contents        Introduction        Where Are The Modules Kept?        Playing Your Part        How To Get a More Recent Copy of the List        Editorial Information and Copyright     Part 1 - Modules: Creation, Use and Abuse   1)   Perl 5 Module Terminology   2)   Guidelines for Module Creation   3)   Guidelines for Converting Perl 4 Library Scripts into Modules   4)   Guidelines for Reusing Application Code   5)   Namespace Coordination   Part 2 - The Perl 5 Module List   1)   Module Listing Format   2)   Perl Core Modules, Perl Language Extensions and Documentation Tools   3)   Development Support   4)   Operating System Interfaces, Hardware Drivers   5)   Networking, Device Control (modems) and InterProcess Communication   6)   Data Types and Data Type Utilities   7)   Database Interfaces   8)   User Interfaces   9)   Interfaces to or Emulations of Other Programming Languages   10)  File Names, File Systems and File Locking (see also File Handles)   11)  String Processing, Language Text Processing, Parsing and Searching   12)  Option, Argument, Parameter and Configuration File Processing   13)  Internationalization and Locale   14)  Authentication, Security and Encryption   15)  World Wide Web, HTML, HTTP, CGI, MIME   16)  Server and Daemon Utilities   17)  Archiving, Compression and Conversion   18)  Images, Pixmap and Bitmap Manipulation, Drawing and Graphing   19)  Mail and Usenet News   20)  Control Flow Utilities (callbacks and exceptions etc)   21)  File Handle, Directory Handle and Input/Output Stream Utilities   22)  Microsoft Windows Modules   23)  Miscellaneous Modules   24)  Interface Modules to Commercial Software   25)  Bundles   Part 3 - Standards Cross-reference   3.1) IETF - Internet Engineering Task Force (RFCs)   3.2) ITU - International Telegraph Union (X.*)   3.3) ISO - International Standards Organization (ISO*)   Part 4 - Who's Who and What's Where   4.1) Information / Contact Reference Details   4.2) Perl Frequently Asked Questions (FAQ) Files         Introduction  This document is a semi-formal list of Perl 5 Modules. The Perl 4 concept of packages has been extended in Perl 5 and a new standardised form of reusable software component has been defined: the Module.      Perl 5 Modules typically conform to certain guidelines which make them easier to use, reuse, integrate and extend.       This list has two key aims:    FOR DEVELOPERS: To change duplication of effort into cooperation.  FOR USERS: To quickly locate existing software which can be reused.      This list includes the Perl 5 standard modules, other completed modules, work-in-progress modules and would-be-nice-to-have ideas for modules. It also includes guidelines for those wishing to create new modules including how to name them.       Where Are The Modules Kept?  Most, but not all, of the modules can be found within CPAN, the Comprehensive Perl Archive Network of mirrored FTP sites. Within the CPAN scheme the modules described in this list can be found in the modules/ directory below the CPAN root directory. CPAN is a worlswide network of mirrors and you can find your closest mirror in the file   http://www.cpan.org/SITES.html       NOTE: If you can't find what you want, or wish to check that what you've found is the latest version, or wonder why a module mentioned in this list is not on CPAN, you should contact the person associated with the module (and not the maintainers of the archives or this list). Contact details are given at the start of Part 4.       Playing Your Part  Perl is a huge collaborative effort. Everyone who uses perl is benefiting from the contributions of many hundreds, maybe thousands, of people. How much time has perl saved you since you started using it?      Do you have any modules you could share with others? For example, you may have some perl4 scripts from which generally useful, and reusable, modules could be extracted. There may be many people who would find your work very useful. Please play your part and contribute to the Perl community where you can. [ end of sermon :-]      Help save the world! Please submit new entries and updates to us so we can keep this list up-to-date. Send the new or corrected entry by email to    modules@perl.org      . Please do not send code to this address. Instead upload your module, once registered, to the PAUSE site for forwarding on to CPAN. See section 2, especially 2.6 and 2.11.       How To Get a More Recent Copy of the List  This Module List is fed into CPAN on a semi-regular basis. Its relative path within a CPAN mirror is in modules/00modlist.long.html .       Editorial Information and Copyright  This document is Copyright (c) 1997-2000 by Tim Bunce and Andreas König. All rights reserved. Permission to distribute this document, in full or part, via electronic means (emailed, posted or archived) or printed copy is granted providing that no charges are involved, reasonable attempt is made to use the most current version, and all credits and copyright notices are retained. Requests for other distribution rights, including incorporation in commercial products, such as books, magazine articles, or CD-ROMs should be made to    Tim.Bunce@pobox.com       and    andreas.koenig@anima.de      .      Disclaimer: The content of this document is simply a collection of information gathered from many sources with little or no checking. There are NO warranties with regard to this information or its use.      A little background information... I (Tim) created the Module List in August 1994 and maintained it manually till April 1996. By that time Andreas had implemented the Perl Authors Upload Server (PAUSE) and it was happily feeding modules through to the CPAN archive sites (see   http://www.cpan.org/modules/04pause.html    for details). Since PAUSE held a database of module information which could be maintained by module authors it made sense for the module listing part of the Module List to be built from that database. In April 1996 Andreas took over the automatic posting of the Module List and I now maintain the other parts of the text. We plan to add value to the automation over time.              Part 1 - Modules: Creation, Use and Abuse   1)   Perl 5 Module Terminology  Perl 5 implements a class using a package, but the presence of a package doesn't imply the presence of a class. A package is just a namespace. A class is a package that provides subroutines that can be used as methods. A method is just a subroutine that expects, as its first argument, either the name of a package (for ""static"" methods), or a reference to something (for ""virtual"" methods).      A module is a file that (by convention) provides a class of the same name (sans the .pm), plus an import method in that class that can be called to fetch exported symbols. This module may implement some of its methods by loading dynamic C or C++ objects, but that should be totally transparent to the user of the module. Likewise, the module might set up an AUTOLOAD function to slurp in subroutine definitions on demand, but this is also transparent. Only the .pm file is required to exist.       2)   Guidelines for Module Creation   2.1 Do similar modules already exist in some form?     If so, please try to reuse the existing modules either in whole or    by inheriting useful features into a new class.  If this is not    practical try to get together with the module authors to work on    extending or enhancing the functionality of the existing modules.    A perfect example is the plethora of packages in perl4 for dealing    with command line options.         If you are writing a module to expand an already existing set of    modules, please coordinate with the author of the package.  It    helps if you follow the same naming scheme and module interaction    scheme as the original author.        2.2 Try to design the new module to be easy to extend and reuse.     Use blessed references.  Use the two argument form of bless to bless    into the class name given as the first parameter of the constructor,    e.g.:            sub new {          my $class = shift;          return bless {}, $class;      }       or even this if you'd like it to be used as either a static    or a virtual method.            sub new {          my $self  = shift;          my $class = ref($self) || $self;          return bless {}, $class;      }       Pass arrays as references so more parameters can be added later    (it's also faster).  Convert functions into methods where    appropriate.  Split large methods into smaller more flexible ones.    Inherit methods from other modules if appropriate.         Avoid class name tests like: die ""Invalid"" unless ref $ref eq 'FOO'.    Generally you can delete the ""eq 'FOO'"" part with no harm at all.    Let the objects look after themselves! If it's vital then you can    use the UNIVERSAL methods isa and can. Generally, avoid hardwired    class names as far as possible.         Avoid $r->Class::func() where using @ISA=qw(... Class ...) and    $r->func() would work (see perlbot man page for more details).         Use autosplit or the SelfLoader module so little used or newly added    functions won't be a burden to programs which don't use them. Add    test functions to the module after __END__ either using autosplit or    by saying:            eval join('',<main::DATA>) || die $@ unless caller();       Does your module pass the 'empty sub-class' test? If you say    ""@SUBCLASS::ISA = qw(YOURCLASS);"" your applications should be able    to use SUBCLASS in exactly the same way as YOURCLASS.  For example,    does your application still work if you change:  $obj = new YOURCLASS;    into: $obj = new SUBCLASS; ?         Avoid keeping any state information in your packages. It makes it    difficult for multiple other packages to use yours. Keep state    information in objects.         Always use -w. Try to ""use strict;"" (or ""use strict qw(...);"").    Remember that you can add ""no strict qw(...);"" to individual blocks    of code which need less strictness. Always use -w. Always use -w!    Follow the guidelines in the perlstyle(1) manual.        2.3 Some simple style guidelines     The perlstyle manual supplied with perl has many helpful points.         Coding style is a matter of personal taste. Many people evolve their    style over several years as they learn what helps them write and    maintain good code.  Here's one set of assorted suggestions that    seem to be widely used by experienced developers:         Use underscores to separate words.  It is generally easier to read    $var_names_like_this than $VarNamesLikeThis, especially for    non-native speakers of English. It's also a simple rule that works    consistently with VAR_NAMES_LIKE_THIS.         Package/Module names are an exception to this rule. Perl informally    reserves lowercase module names for 'pragma' modules like integer    and strict. Other modules normally begin with a capital letter and    use mixed case with no underscores (need to be short and portable).         You may find it helpful to use letter case to indicate the scope    or nature of a variable. For example:            $ALL_CAPS_HERE   constants only (beware clashes with perl vars)      $Some_Caps_Here  package-wide global/static      $no_caps_here    function scope my() or local() variables       Function and method names seem to work best as all lowercase.    E.g., $obj->as_string().         You can use a leading underscore to indicate that a variable or    function should not be used outside the package that defined it.         For method calls use either            $foo = new Foo $arg1, $arg2;     # no parentheses      $foo = Foo->new($arg1, $arg2);       but avoid the ambiguous form            $foo = new Foo($arg1, $arg2);    # Foo() looks like function call       It can be very helpful if the names of the classes that your module    uses can be specified as parameters. Consider:            $dog_class = $args{dog_class} || 'Dog';      $spot = $dog_class->new(...);       This allows the user of your module to specify an alternative class    (typically a subclass of the one you would normally have used).         On how to report constructor failure, Larry said:         I tend to see it as exceptional enough that I'll throw a real Perl    exception (die) if I can't construct an object.  This has a couple    of advantages right off the bat.  First, you don't have to check the    return value of every constructor.  Just say ""$fido = new Doggie;""    and presume it succeeded.  This leads to clearer code in most cases.         Second, if it does fail, you get a better diagnostic than just the    undefinedness of the return value.  In fact, the exception it throws    may be quite rich in ""stacked"" error messages, if it's rethrowing an    exception caught further in.         And you can always catch the exception if it does happen using eval {}.         If, on the other hand, you expect your constructor to fail a goodly    part of the time, then you shouldn't use exceptions, but you should    document the interface so that people will know to check the return    value.  You don't need to use defined(), since a constructor would    only return a true reference or a false undef.  So good Perl style    for checking a return value would simply say             $conn = new Connection $addr          or die ""Couldn't create Connection"";       In general, make as many things meaningful in a Boolean context as    you can.  This leads to straightforward code.  Never write anything    like             if (do_your_thing() == OK)       in Perl.  That's just asking for logic errors and domain errors.    Just write             if (do_your_thing())       Perl is designed to help you eschew obfuscation, if that's your thing.        2.4 Select what to export.     Do NOT export method names!    Do NOT export anything else by default without a good reason!         Exports pollute the namespace of the module user.  If you must    export try to use @EXPORT_OK in preference to @EXPORT and avoid    short or common names to reduce the risk of name clashes.         Generally anything not exported is still accessible from outside the    module using the ModuleName::item_name (or $blessed_ref->method)    syntax.  By convention you can use a leading underscore on names to    informally indicate that they are 'internal' and not for public use.         (It is actually possible to get private functions by saying:    my $subref = sub { ... };  &$subref; But there's no way to call that    directly as a method, since a method must have a name in the symbol    table.)         As a general rule, if the module is trying to be object oriented    then export nothing. If it's just a collection of functions then    @EXPORT_OK anything but use @EXPORT with caution.        2.5 Select a name for the module.     This name should be as descriptive, accurate and complete as    possible.  Avoid any risk of ambiguity. Always try to use two or    more whole words.  Generally the name should reflect what is special    about what the module does rather than how it does it.         Having 57 modules all called Sort will not make life easy for anyone    (though having 23 called Sort::Quick is only marginally better :-).    Imagine someone trying to install your module alongside many others.    If in any doubt ask for suggestions in comp.lang.perl.modules or       modules@perl.org      .         Please use a nested module name to informally group or categorise    a module, e.g., placing a sorting module into a Sort:: category.    A module should have a very good reason not to have a nested name.    Please avoid using more than one level of nesting for module names    (packages or classes within modules can, of course, use any number).         Module names should begin with a capital letter. Lowercase names are    reserved for special modules such as pragmas (e.g., lib and strict).         Note that module names are not related to class hierarchies.    A module name Foo::Bar does not in any way imply that Foo::Bar    inherits from Foo.  Nested names are simply used to provide some    useful categorisation for humans. The same is generally true for    all package names.         Since the CPAN is huge and growing daily, it's essential that    module authors choose names which lend themselves to browsing.    That means minimizing acronyms, cute names, and jargon. Also,    don't make up a new top level category unless you have a good    reason; please choose an already-existing category when    possible. Send mail to    modules@perl.org       before you upload, so    we can help you select a name.         If you insist on a name that we consider inappropriate, we    won't prevent you from uploading your module -- but it'll    remain in your ""author"" directory and won't be directly visible    from CPAN/modules/by-module.         We appreciate the efforts of the contributors who have helped    make the CPAN the world's largest reusable code repository.    Please help us enhance it by working with us to choose the    best name possible.         If you are developing a suite of related modules/classes it's good    practice to use nested classes with a common prefix as this will    avoid namespace clashes. For example:  Xyz::Control, Xyz::View,    Xyz::Model etc. Use the modules in this list as a naming guide.         If adding a new module to a set, follow the original author's    standards for naming modules and the interface to methods in    those modules.         If developing modules for private internal or project specific use,    that will never be released to the public, then you should ensure    that their names will not clash with any future public module. You    can do this either by using the reserved Local::* category or by    using an underscore in the top level name like Foo_Corp::*.         To be portable each component of a module name should be limited to    11 characters. If it might be used on DOS then try to ensure each is    unique in the first 8 characters. Nested modules make this easier.        2.6 Have you got it right?     How do you know that you've made the right decisions? Have you    picked an interface design that will cause problems later? Have    you picked the most appropriate name? Do you have any questions?         The best way to know for sure, and pick up many helpful suggestions,    is to ask someone who knows. The comp.lang.perl.modules Usenet    newsgroup is read by just about all the people who develop modules    and it's generally the best place to ask first. If you need more    help then try    modules@perl.org      .         All you need to do is post a short summary of the module, its    purpose and interfaces. A few lines on each of the main methods is    probably enough. (If you post the whole module it might be ignored    by busy people - generally the very people you want to read it!)         Don't worry about posting if you can't say when the module will be    ready - just say so in the message. It might be worth inviting    others to help you, they may be able to complete it for you!        2.7 README and other Additional Files.     It's well known that software developers usually fully document the    software they write. If, however, the world is in urgent need of    your software and there is not enough time to write the full    documentation please at least provide a README file containing:        A description of the module/package/extension etc.  A copyright notice - see below.  Prerequisites - what else you may need to have.  How to build it - possible changes to Makefile.PL etc.  How to install it.  Recent changes in this release, especially incompatibilities  Changes / enhancements you plan to make in the future.         If the README file seems to be getting too large you may wish to    split out some of the sections into separate files: INSTALL,    Copying, ToDo etc.        2.8 Adding a Copyright Notice.     How you choose to licence your work is a personal decision.    The general mechanism is to assert your Copyright and then make    a declaration of how others may copy/use/modify your work.         Perl, for example, is supplied with two types of licence: The GNU    GPL and The Artistic License (see the files README, Copying and    Artistic).  Larry has good reasons for NOT just using the GNU GPL.         My personal recommendation, out of respect for Larry, Perl and the    perl community at large is to simply state something like:            Copyright (c) 1997 Your Name. All rights reserved.      This program is free software; you can redistribute it and/or      modify it under the same terms as Perl itself.       This statement should at least appear in the README file. You may    also wish to include it in a Copying file and your source files.    Remember to include the other words in addition to the Copyright.        2.9 Give the module a version/issue/release number.     To be fully compatible with the Exporter and MakeMaker modules you    should store your module's version number in a non-my package    variable called $VERSION.  This should be a valid floating point    number with at least two digits after the decimal (ie hundredths,    e.g, $VERSION = ""0.01"").  See Exporter.pm for details.         Don't use a ""1.3.2"" style version directly. If you use RCS or a    similar system which supports multilevel versions/branches you can    use this (but put it all on one line for MakeMaker VERSION_FROM):          $VERSION = do { my @r=(q$Revision: 3.112 $=~/\d+/g);                     sprintf ""%d."".""%03d""x$#r,@r };         It may be handy to add a function or method to retrieve the number.    Use the number in announcements and archive file names when    releasing the module (ModuleName-1.02.tar.gz).    See perldoc ExtUtils::MakeMaker.pm for details.        2.10 Listing Prerequisites in a Bundle module     If your module needs some others that are available on CPAN, you    might consider creating a 'bundle' module that lists all the    prerequisites in a standardized way. Automatic installation software    such as the CPAN.pm module can take advantage of such a listing and    enable your users to install all prerequisites and your own module    with one single command. See the CPAN.pm module for details.        2.11 How to release and distribute a module.     By far the best way to release modules is to register yourself with    the Perl Authors Upload Server (PAUSE). By registering with PAUSE    you will be able to easily upload (or mirror) your modules to the    PAUSE server from where they will be mirrored to CPAN sites across    the planet.         It's good idea to post an announcement of the availability of your    module to the comp.lang.perl.announce Usenet newsgroup.  This will    at least ensure very wide once-off distribution.         If not using PAUSE you should place the module into a major ftp    archive and include details of it's location in your announcement.    Some notes about ftp archives: Please use a long descriptive file    name which includes the version number. Most incoming directories    will not be readable/listable, i.e., you won't be able to see your    file after uploading it. Remember to send your email notification    message as soon as possible after uploading else your file may get    deleted automatically. Allow time for the file to be processed    and/or check the file has been processed before announcing its    location.         FTP Archives for Perl Modules:         Follow the instructions and links on       http://www.cpan.org/modules/04pause.html          or upload to:       ftp://pause.kbx.de/incoming          and notify    upload@pause.kbx.de      .         By using the PAUSE WWW interface you can ask the Upload Server to    mirror your modules from your ftp or WWW site into your own    directory on CPAN. Please remember to send us an updated entry for    the Module list!        2.12 Take care when changing a released module.     Always strive to remain compatible with previous released versions    (see 2.2 above) Otherwise try to add a mechanism to revert to the    old behaviour if people rely on it. Document incompatible changes.        3) Guidelines for Converting Perl 4 Library Scripts into Modules   3.1 There is no requirement to convert anything.     If it ain't broke, don't fix it! Perl 4 library scripts should    continue to work with no problems. You may need to make some minor    changes (like escaping non-array @'s in double quoted strings) but    there is no need to convert a .pl file into a Module for just that.    See perltrap.pod for details of all known perl4-to-perl5 issues.        3.2 Consider the implications.     All the perl applications which make use of the script will need to    be changed (slightly) if the script is converted into a module.  Is    it worth it unless you plan to make other changes at the same time?        3.3 Make the most of the opportunity.     If you are going to convert the script to a module you can use the    opportunity to redesign the interface. The 'Guidelines for Module    Creation' above include many of the issues you should consider.        3.4 The pl2pm utility will get you started.     This utility will read *.pl files (given as parameters) and write   corresponding *.pm files. The pl2pm utilities does the following:  Adds the standard Module prologue lines  Converts package specifiers from ' to ::  Converts die(...) to croak(...)  Several other minor changes    Being a mechanical process pl2pm is not bullet proof. The converted   code will need careful checking, especially any package statements.   Don't delete the original .pl file till the new .pm one works!      4) Guidelines for Reusing Application Code  4.1 Complete applications rarely belong in the Perl Module Library.    4.2 Many applications contain some perl code which could be reused.     Help save the world! Share your code in a form that makes it easy     to reuse.      4.3 Break-out the reusable code into one or more separate module files.    4.4 Take the opportunity to reconsider and redesign the interfaces.    4.5 In some cases the 'application' can then be reduced to a small     fragment of code built on top of the reusable modules. In these     cases the application could invoked as:        5) Namespace Coordination  The maintainers of the module list are not the Internic for perl namespaces. They do neither sell namespaces nor can they establish property rights. What they try to do is to minimize namespace clashes and maximize usablility of the CPAN archive by setting up a catalogue of modules and control the indexers. Time permitting, they will also try to give advice for what they think is a proper usage of the namespace.      It is an important part of the namespace concept that the module list maintainers do not guarantee to you that somebody else won't use the, say, Foo::Bar namespace. The upload area is not censored except for abuse. People are free to upload any modules they like. Instead, there are several levels of protection for your namespaces:      a) The most important is the module list which actually lists and    proclaims your namespace.      b) The second is the indexing mechanism of the CPAN. Modules are    indexed on a first-come-first-serve basis. The module namespace    that is uploaded for the first time ever gets indexed, but not the    module of the second one who tries to use the same namespace.      c) As the whole process is trying to benefit the community, all    parties are subject to a wider monitoring within the community.    This is sometimes referred to as security by visibility.      d) So the next level of namespace protection is the common sense. Your    own common sense. Help to save the world. If you get the impression    that something goes wrong with regard to namespaces, please write    to    modules@perl.org       and let them know.      e) The perhaps most interesting namespace protection is provided by    the perl symbol table itself. A namespace Foo:: is just a package    name and its relationship to a namespace Foo::Bar:: is not    predetermined whatsoever. The two namespaces can be closely or    loosely related or not related at all, but what's most important,    they can be writen by different authors who may work rather    independently from each other. So if you have registered any    namespace, it does not mean that you own the whole namespace tree    that starts there. If you are registered as the contact for    Foo::Bar, you are not necessarily also associated with    Foo::Bar::Baz.      f) In a few rare cases the module list people restrict indexing of    certain categories. For example:      DBI::* under the control of Tim Bunce      Sun::* under the control of Sun Microsystems              Part 2 - The Perl 5 Module List   The remainder of this document is divided up into sections. Each section deals with a particular topic and lists all known modules related to that topic.  Modules are only listed in one section so check all sections that might related to your particular needs.      All the information corresponds to the latest updates we have received. We don't record the version number or release dates of the listed Modules. Nor do we record the locations of these Modules. Consult the contact, try the usual perl CPAN sites or ask in comp.lang.perl.modules. Please do *not* ask us directly, we simply don't have the time. Sorry.        1) Module Listing Format  Each Module listing is very short. The main goal is to simply publish the existence of the modules, or ideas for modules, and enough contact information for you to find out more. Each listing includes some characters which convey (approximate) basic status information.       For example:   Name           DSLIP  Description                                  Info -------------  -----  -------------------------------------------- ----- Fcntl          Sdcfp  Defines fcntl() constants (see File::Lock)   JHI       Where the 'DSLIP' characters have the following meanings:     D - Development Stage  (Note: *NO IMPLIED TIMESCALES*):     i   - Idea, listed to gain consensus or as a placeholder     c   - under construction but pre-alpha (not yet released)     a/b - Alpha/Beta testing     R   - Released     M   - Mature (no rigorous definition)     S   - Standard, supplied with Perl 5     S - Support Level:     m   - Mailing-list     d   - Developer     u   - Usenet newsgroup comp.lang.perl.modules     n   - None known, try comp.lang.perl.modules     L - Language Used:     p   - Perl-only, no compiler needed, should be platform independent     c   - C and perl, a C compiler will be needed     h   - Hybrid, written in perl with optional C code, no compiler needed     +   - C++ and perl, a C++ compiler will be needed     o   - perl and another language other than C or C++     I - Interface Style     f   - plain Functions, no references used     h   - hybrid, object and function interfaces available     n   - no interface at all (huh?)     r   - some use of unblessed References or ties     O   - Object oriented using blessed references and/or inheritance     P - Public License     p   - Standard-Perl: user may choose between GPL and Artistic     g   - GPL: GNU General Public License     l   - LGPL: ""GNU Lesser General Public License"" (previously known as ""GNU Library          General Public License"")     b   - BSD: The BSD License     a   - Artistic license alone     o   - other (but distribution allowed without restrictions)  DISCLAIMER: The status of the Public License field is there for informational purpose only and does not constitute a legal binding of any kind. To obtain proper information about the Licencing terms of a module and its accompanying files, please refer to the distribution of the modules or contact the author as appropriate. Please inform    modules@perl.org       if you encounter any mismatch between the contents of the Public License field and what the distribution actually says about it.      Where letters are missing they can usually be inferred from the others.  For example 'i' implies 'id', 'S' implies 'Su'.      The Info column gives a contact reference 'tag'. Lookup this tag in the ""Information / Contact Reference Details"" section in Pert 3 of this document. If no contact is given always try asking in comp.lang.perl.modules.      Most Modules are nested in categories such as IPC::Open2 and IPC::Open3. These are shown as 'IPC::' on one line then each module listed below with a '::' prefix.        Ideas For Adoption  Modules listed as in the 'i' Development Stage with no contact reference are ideas without an owner. Feel free to 'adopt' these but please let me know so that we can update the list and thus inform anyone else who might be interested. Adoption simply means that you either hope to implement the module one day or would like to cooperate with anyone else who might be interested in implementing it.        Cooperation  Similarly, if an idea that interests you has been adopted by someone please contact them so you can share ideas.  Just because an idea has been adopted does NOT imply that it's going to be implemented. Just because a module is listed and being implemented does NOT mean it'll get finished. Waiting silently in the hope that the Module will appear one day is unlikely to be fruitful! Offer to help. Cooperate. Pool your efforts. Go on, try it!      The same applies to modules in all states. Most modules are developed in limited spare time. If you're interested in a module don't just wait for it to happen, offer to help.      Module developers should feel free to announce incomplete work early. If you're not going to be able to spend much time on something then say so. If you invite cooperation maybe someone will implement it for you!             2) Perl Core Modules, Perl Language Extensions and Documentation Tools   Name                DSLIP  Description                                  Info ------------       ----- -------------------------------------------- ---- CORE               Sucf? Internal package for perl native functions    P5P   UNIVERSAL           SucOp Internal universal base-class                 P5P  SUPER              SucO? Internal class to access superclass methods   P5P   DynaLoader          SucO? Dynamic loader for shared libraries           P5P   AutoLoader          SupO? Automatic function loader (using AutoSplit)   P5P   SelfLoader          SupO? Automatic function loader (using __DATA__)    P5P   Exporter            SupO? Implements default import method for modules  P5P   Carp                Supf? Throw exceptions outside current package      P5P  Config             Supf? Stores details of perl build configuration    P5P   English             Supf? Defines English names for special variables   P5P   Symbol              SupO? Create 'anonymous' symbol (typeglobs) refs    CHIPS   Opcode              Supf? Disable named opcodes when compiling code     P5P   Taint               bdpf? Utilities related to tainting                 PHOENIX   Perl Pragmatic Modules   constant            Supf? Define compile-time constants                 P5P   diagnostics         Sdpf? For reporting perl diagnostics in full form   TOMC   enum                cdpf? resemble enumerated types in C                ZENIN   integer             Supf? Controls float vs. integer arithmetic         P5P   less                Supf? Controls optimisations (yet unimplemented)    P5P   lib                 Supf? Simple way to add/delete directories in @INC  P5P   namespace           Rdpnp Perl pragma to use like C++ namespace alias   AMICHAUER   overload            SdpO? Overload perl operators for new data types    ILYAZ   sigtrap             Supf? For trapping an abort and giving a traceback  P5P   strict              Supf? Controls averments (similar to pragmas)       P5P   subs                Supf? use subs qw(x y); is short for sub x; sub y;  P5P   vars                Supf? predeclare variable names                     P5P   Experimental pragmatic modules live in the ex:: namespace   ex::  ::implements        RdpO? Study in Polymorphism                         PDCAWLEY   ::interface         RdpO? Another study in polymorphism                 PDCAWLEY   ::override          Rdpf? perl pragma to override core functions        CTWETEN  ::caution          bdpn? Same as use warnings; use strict;             YVES   ex::constant::  ::vars              Rdph? Perl pragma to create readonly variables      CTWETEN   Perl Language Extensions   Alias               bdcf? Convenient access to data/code via aliases    GSAR   End                 RdpO? Generalized END {}.                           ABIGAIL   Error               adpOp Error/exception handling in an OO-ish way     UARUN   NEXT                RdpO? Perl5 implementation of NEXT (RFC190)         DCONWAY   Perl                adcO? Create Perl interpreters from within Perl     GSAR  Protect            bdpf? declare subs private or member                JDUNCAN   Safe                SdcO? Restrict eval'd code to safe subset of ops    MICB   Softref             bdcf? Extension for weak/soft referenced SVs        ILYAZ   Attribute::  ::Handlers          RdpO? Simpler definition of attribute handlers      ABERGMAN   ::Types             RdpO? Attributes that confer type on variables      DCONWAY   ::Memoize           RdpOp Attribute interface to Memoize.pm             MARCEL   ::TieClasses        RdpOp attribute wrappers for CPAN Tie classes       MARCEL   ::Abstract          RdpOp implement abstract methods with attributes    MARCEL   ::Overload          RdpOp Attribute that makes overloading easier       MARCEL   ::Deprecated        RdpOp Mark deprecated methods                       KASEI   ::Signature         bdphp Signatures on methods and subroutines         JDUNCAN   Exporter:: ::Import           Rdpn? Alternate symbol exporter                     GARROW  ::Options          adpO? Extends Exporter to handle use-line options   YSTH  ::PkgAlias         adpf? Load a module into multiple namespaces        JDPORTER   Inline              bdp?p Write Perl subroutines in other languages     INGY  Inline::  ::CPR               adpn? C Perl Run - Embed Perl in C, ala Inline      INGY   ::C                 bdpnp Write Perl subroutines in C                   INGY   ::CPP               bdpO? Easy implementation of C++ extensions         NEILW   ::Python            adcO? Easy implementation of Python extensions      NEILW   ::Tcl               adcf? Write Perl subroutines in Tcl                 RRS   ::Java              amhpp Easy implementation of Java extensions        PATL   ::ASM               adpO? Write Perl subroutines in Assembler           NEILW   ::Struct            adpO? Bind C structures directly to Perl.           NEILW   ::Files             RdpO? Multiple virtual files after __END__          DCONWAY   ::Guile             amhhp Inline module for Guile Scheme interpreter    SAMTREGAR   Regexp::  ::Common            RdpO? Provide commonly requested regular expr.      ABIGAIL   ::Shellish          RdpO? Shell-like regular expressions                RBS  ::Func             adpf? Replace =~, !~, m//, s/// with functions      NWIGER   Safe::  ::Hole              bdcO? Exec subs in the original package from Safe   SEYN   Symbol:: ::Table            RdpO? OO interface to package symbols               GARROW   Symbol::Approx::  ::Sub               Rmphp Call subroutines using approximate names      DAVECROSS   The Perl Compiler   B                   aucO? The Perl Compiler                             MICB   O                   aucO? Perl Compiler frontends                       MICB   B::  ::Fathom            bdpO? Estimate the readability of Perl code         KSTAR   ::Graph             bdpr? Perl Compiler backend to diagram OP trees     SMCCAM   ::LexInfo           bdcO? Show info about subroutine lexical variables  DOUGM   ::Size              bdcO? Measure size of Perl OPs and SVs              DOUGM   ::TerseSize         bdpO? Info about ops and their (estimated) size     DOUGM   Source Code Filters   Filter::Util::  ::Exec              bdcf? Interface for creation of coprocess Filters   PMQS   ::Call              bdcf? Interface for creation of Perl Filters        PMQS   Filter::  ::exec              bdcf? Filters script through an external command    PMQS   ::sh                bdcf? Filters script through a shell command        PMQS   ::cpp               bdcf? Filters script through C preprocessor         PMQS   ::tee               bdcf? Copies to file perl source being compiled     PMQS   ::decrypt           bdcf? Template for a perl source decryption filter  PMQS   ::Simple            RdpO? Simplified source filtering                   DCONWAY  ::constant         idpnp constant mod working like real Pre Processor  MZSANFORD   ::Trigraph          bdpnp Understand ANSI C trigraphs in Perl source.   KASEI   PerlIO              Rucnp On demand loader for PerlIO layers            P5P   PerlIO::  ::gzip              RdcO? provide a PerlIO layer to gzip/gunzip         NWCLARK   Thread support (note that these are experimental, i.e. pre-alpha)   Thread              cuhO? Manipulate threads in Perl (EXPERIMENTAL)     P5P   Thread:: ::Group            bdph? Wait()-like and grouping functions            DSUGAL   ::Pool              bdpOp Worker pools to run Perl code asynchronously  ELIZABETH   ::Queue             cuph? Thread-safe queues                            P5P   ::Semaphore         cuph? Thread-safe semaphores                        P5P   ::Signal            cuhh? A thread which runs signal handlers reliably  P5P   ::Specific          cuhh? Thread-specific keys                          P5P   ::RWLock            RdpOp rwlock implementation for perl threads        AFERBER  ::IO               i   ? IO routines                                   DSUGAL  ::Object           i   ? OO routines                                   DSUGAL   Module Support   Module::  ::Reload            Rdpf? Reloads files in %INC based on timestamps     JPRIT   ::InstalledVersion  bdpOp Find version number of installed module       SKUD   ::Use               bdpnp Tracks modules loaded by a script             JSMITH   ::Signature         cdpfp Module signature file manipulation            AUTRIJUS   Documentation Tools:   Pod::  ::Diff              cdpf? compare two POD files and report diff         IANC   ::DocBook           adpO? convert POD to and from DocBook               MBERENDS   ::HTML              cdpr? converter to HTML                             KJALB   ::HTML2Pod          RdpOp Translate HTML into POD                       SBURKE   ::Hlp               RdpO? Convert POD to formatted VMS Help text        PVHP  ::Index            cdpr? index generator                               KJALB   ::LaTeX             bdpOp Converts pod to latex with Pod::Parser        TJENNESS  ::Latex            cdpr? converter to LaTeX                            KJALB   ::Lyx               adpO? A pod to LyX format conversion class          RICHARDJ  ::MIF              adpO? converter to FrameMaker MIF                   JNH   ::Man               cdpr? converter to man page                         KJALB   ::PP                adpOa A Pod pre-processor                           RAM   ::Parser            bdpO? Base class for parsing pod syntax             BRADAPP   ::Pdf               bdpf? Converter to PDF                              AJFRY  ::Pod              cdpr? converter to canonical pod                    KJALB   ::RTF               cdpr? converter to RTF                              KJALB   ::Rtf               RdpO? Converter from POD to Rich Text Format        PVHP   ::Sdf               cdpf? converter to SDF                              IANC   ::Select            bdpf? Print only selected sections of pod docs      BRADAPP   ::Simplify          cdpr? Common pod parsing code                       KJALB  ::Texinfo          cdpr? converter to texinfo                          KJALB   ::Text              Supf? convert POD data to formatted ASCII text      TOMC   ::Usage             bdpf? Print Usage messages based on your own pod    BRADAPP   ::XML               RdpO? Generate XML from POD                         MSERGEANT   ::Tree              RdpOp Create a static syntax tree for a POD         SWMCD   ::Checker           RdpO? Check pod documents for syntax errors         BRADAPP   ::POM               RdpOp Pod Object Model                              ABW   Perl6::  ::Variables         RdpO? Perl 6 variable syntax for Perl 5             DCONWAY   ::Interpolators     bdpnp Use Perl 6 function-interpolation syntax      BRENTDAX   ::Parameters        bdpnp Use Perl 6-style named parameters             BRENTDAX   Concurrent         adpOp Concurrent and Remotable Objects in Perl      VIPUL   Acme::  ::Buffy             Rdphp An encoding scheme for Buffy fans             LBROCARD   Acme::Morse::  ::Audible           Rdpnp Audio(Morse) Programming with Perl            ITRIVIZKI       3) Development Support   Name                DSLIP  Description                                  Info ------------       ----- -------------------------------------------- ----  AutoSplit           Supf? Splits modules into files for AutoLoader      P5P  Bleach             RdpO? For really clean programs                     DCONWAY   Continuus           adpO? Interface to Continuus Code Management tool   HENKE   Coy                 Rdpn? Like Carp - only prettier                     DCONWAY   FindBin             adpf? Locate current script bin directory           P5P   Include             adpO? Parse C header files for use in XS            GBARR   Make                adpO? Makefile parsing, and 'make' replacement      NI-S   Perlbug             RdpOp Database driven bug tracking system (mysql)   RFOLEY   Rcs                 adcf? Alternate RCS interface (see VCS::RCS)        CFRETER  Smirch             Rdpfa For really dirty programs                     JNAGRA   Usage               bnpr? Type and range checking on subroutine args    JACKS   VCS                 ampOp Generic interface to Version Control Systems  LBROCARD   Benchmark           Supf? Easy way to time fragments of perl code       P5P  Benchmark::  ::Timer             RdpO? Perl code benchmarking tool                   ANDREWHO   ExtUtils::  ::DynaGlue          adcr? Methods for generating Perl extension files   DOUGM   ::MakeMaker         SupO? Writes Makefiles for extensions               MMML   ::Manifest          Supf? Utilities for managing MANIFEST files         MMML   ::Embed             Sdpf? Utilities for embedding Perl in C/C++ apps    DOUGM   ::F77               RdpO? Facilitate use of FORTRAN from Perl/XS code   KGB   ::configPL          adpOp configures .PL files                          PEASE   Carp::  ::Assert            adpf? Stating the obvious to let the computer know  MSCHWERN  ::CheckArgs        Rdpf? Check subroutine argument types               GARROW   ::Datum             adpfa Debugging And Tracing Ultimate Module         SQUIRREL   ClearCase          idcf? Environment for ClearCase revision control    BRADAPP  ClearCase::   Conjury::  ::C                 Rdph? Generic software construction toolset         JWOODYATT   ::Core              Rdph? Generic software construction toolset         JWOODYATT   ::Stage             Rdph? Generic software construction toolset         JWOODYATT   Devel::  ::CallerItem        RnpO? 'caller()' Object wrapper + useful methods    JACKS   ::CoreStack         adpf? generate a stack dump from a core file        ADESC   ::Cover             adchp Code coverage metrics for Perl                PJCJ   ::Coverage          adpf? Coverage analysis for Perl code               RJRAY   ::DProf             Rdcf? Execution profiler                            DMR  ::DebugAPI         bdpf? Interface to the Perl debug environment       JHA   ::DebugInit         bdpf? Create a .gdbinit or similar file             JASONS   ::DumpStack         Rnpf? Dumping of the current function stack         JACKS   ::Leak              Rdcf? Find perl objects that are not reclaimed      NI-S   ::Modlist           Rdpf? Collect module use information                RJRAY   ::PPPort            bdcn? Portability aid for your XS code              PMQS   ::Peek              adcf? Peek at internal representation of Perl data  ILYAZ   ::RegExp            adcO? Access perl internal regex functions          ILYAZ   ::SearchINC         Rdpnp loading Perl modules from development dirs    MARCEL   ::SmallProf         Rdpf? Line-by-line profiler                         ASHTED   ::StackTrace        RdpOp Stacktrace object w/ info form caller()       DROLSKY   ::Symdump           RdpO? Perl symbol table access and dumping          ANDK   ::TraceFuncs        adpO? Trace funcs by using object destructions      JOEHIL   ::TraceLoad         Rdpfp Traces the loading of perl source code        PVERD   ::TraceMethods      bdpOp Perl module for tracing module calls          CHROMATIC   ::Constants         bdpfp Resolve Constants back to their names         CHROMATIC   ::Messenger         bdpfp Let Your Code Talk to You                     KOLIBRIE   Perf::            Performance measurement other than benchmarks  ::ARM               adcf? Application Response Measurement              BBACKER   Sub::  ::Curry             Rdpfp Cute module to curry functions                DAVIDH   ::Quotelike         bdppp Allow to define quotelike functions           RGARCIA   Test                Sdpf? Utilities for writing test scripts            SBURKE  Test::  ::Cmd               RdpO? Portable test infrastructure for commands     KNIGHT   ::Harness           Suphp Executes perl-style tests                     MSCHWERN   ::Unit              bmpOp framework for XP style unit testing           ASPIERS  ::Suite            cdpO? Represents a collection of Test::Cases        HENKE  ::Case             cdpO? Represent a single test case                  HENKE   ::Mail              bdpOp Test framework for email applications         SKUD   ::Simple            bmpfp Basic utilities for writing tests             MSCHWERN   ::Exception         Rdpfp Functions for testing exception-based code    ADIE   ::More              RdpOp More functions for writing tests              MSCHWERN  ::Litmus           bdpOo Submit test results to the litmus webtool     ZLIPTON   ::Reporter          bdpOp sends test results to cpan-testers@perl.org   AFOXSON   ::Pod               adpOp test POD files for errors and warnings        BDFOY   ::Manifest          bdpfp configure which test files to run             BDFOY   VCS:: ::RCS              idpf? Interface layer over RCS (See also Rcs)       RJRAY  ::RCE              idcf? Perl layer over RCE C API                     RJRAY   ::StarTeam          bdpfp Provides an interface to StarBase's StarTeam  JOEPHAYES   ::PVCS              i   ? PVCS Version Manager (intersolv.com)          BMIDD   Oak                bmpOp Oak Perl Compoment Tree                       DRUOSO   Debug::  ::FaultAutoBT       adhOa Automatic Backtrace Extractor on SIG Faults   STAS       4) Operating System Interfaces, Hardware Drivers   Name                DSLIP  Description                                  Info ------------       ----- -------------------------------------------- ----  Env                 Supf? Alias environment variables as perl vars      P5P   Errno               cdpf? Constants from errno.h EACCES, ENOENT etc     P5P   Fcntl               Sdcf? Defines fcntl() constants (see File::Lock)    JHI  Ioctl              adcf? ioctl(2) constants                            JPRIT   POSIX               SupO? An interface to most (all?) of POSIX.1        P5P   Shell               Supf? Run shell commands transparently within perl  P5P   Async::  ::Group             adpO? Deal with simultaneous asynchronous calls     DDUMONT  ::Process          i   ? class to run sub-processes                    DDUMONT   BSD::  ::Ipfwgen           bdpf? Generate ipfw(8) filters                      MUIR   ::Resource          Rdcf? getrusage(), s/getrlimit(), s/getpriority()   JHI  ::HostIdent        i   ? s/gethostname(), s/gethostid()                JHI   Env::  ::Path              adpO? Advanced operations on path variables         DSB   ::Modulecmd         Rdphg Interface to modulecmd from Perl              ISAACSON   Proc::  ::Background        RdpO? OS independent background process objects     BZAJAC  ::ExitStatus       Rdpf? Interpret and act on wait() status values     ROSCH   ::Forkfunc          Rdpf? Simple lwall-style fork wrapper               MUIR   ::ProcessTable      bdcO? Unix process table information                DURIST   ::SafePipe          bdpf? popen() and `` without calling the shell      ROSCH   ::Short             adpO? System calls with timeout option              JHKIM   ::Simple            adpO? Fork wrapper with objects                     MSCHILLI   ::Spawn             Rdpfp Run external programs                         GARROW   ::SyncExec          Rdpf? Spawn processes but report exec() errors      ROSCH  ::times            adpf? By-name interface to process times function   TOMC   ::Queue             Rdpfp limits number of concurrent forked processes  SALVA   GTop                bdcO? Perl interface to libgtop                     DOUGM   Schedule::        See also Schedule:: in chapter 23  ::At                Rdpf? OS independent interface to the at command    JOSERODR   ::ByClock           RdpOp Return to caller at given seconds/minutes     SCHAFFTER   ::Cron              bdpOp cron-like scheduler for perl subroutines      ROLAND   ::Load              RdpOp Remote system load, processes, scheduling     WSNYDER   Quota               Rdcfp Disk quota system functions, local & remote   TOMZO   Shell::  ::Source            bdpOp Run programs and inherit environment changes  PJCJ   Sys::  ::AlarmCall         Rupf? Timeout on any sub. Allows nested alarms      JACKS   ::Hostname          Supf? Implements a portable hostname function       P5P  ::Sysconf          bdpf? Defines constants for POSIX::sysconf()        NI-S   ::Syslog            Supf? Provides same functionality as BSD syslog     P5P   ::CPU               RdpO? Access CPU info. number, etc on Win and UNIX  MZSANFORD   ::Lastlog           RdcO? Provide a moderately Object Oreiented Interf  JSTOWE   ::Utmp              RdcO? Object(ish) Interface to UTMP files.          JSTOWE   Sys::Hostname::  ::Long              adpOa Return the hosts fully qualified name         SCOTT       Note: The Sys:: namespace is considered harmful as it is giving no     clue about which system. Placing additional modules into this     namespace is discouraged.   Platform Specific Modules   Be::  ::Attribute         Rd+f? Manipulate BeOS BFS MIME file attributes      TSPIN   ::Query             Rd+f? Query a BeOS file system                      TSPIN   FreeBSD:: ::SysCalls         cdcf? FreeBSD-specific system calls                 GARY   HPUX::  ::Ioscan            bdpf? Perl function to handle HPUX ioscan command   DDUMONT   Linux::  ::AIO               adcfp asynchronous I/O using linux/clone            MLEHMANN   ::Cpuinfo           RdpO? Object Oriented Interface to /proc/cpuinfo    JSTOWE   ::Fuser             RdpO? Determine which processes have a file open    JSTOWE   ::Svgalib           RdcO? Object Oriented Perl interface to svgalib     JSTOWE   ::Pid               Rdpfp Interface to Linux getpp?id functions         RGARCIA   Mac:: ::AppleEvents      bmcO? AppleEvent manager and AEGizmos               MCPL   ::AssistantFrames   RdpOp Easy creation of assistant dialogs            GBAUER  ::Components       bmcO? (QuickTime) Component manager                 MCPL   ::DtfSQL            Rdcf? Perl interface to the dtF/SQL DB engine       TWEGNER  ::Files            bmcO? File manager                                  MCPL  ::Gestalt          bmcO? Gestalt manager: Environment enquiries        MCPL   ::Glue              RmpOp Control apps with AppleScript terminology     CNANDOR   ::Macbinary         bdpO? Decodes MacBinary files.                      MIYAGAWA  ::Memory           bmcO? Memory manager                                MCPL  ::MoreFiles        bmcO? Further file management routines              MCPL  ::OSA              bmcO? Open Scripting Architecture                   MCPL  ::Processes        bmcO? Process manager                               MCPL  ::Resources        bmcO? Resource manager                              MCPL  ::Serial           bdpO? Interface to Macintosh serial ports           DIVERDI  ::Types            bmcO? (Un-)Packing of Macintosh specific types      MCPL   Mac::AppleEvents::  ::Simple            Rmphp Simple access to Mac::AppleEvents             CNANDOR   Mac::Apps::  ::Anarchie          RdpO? Control Anarchie 2.01+                        CNANDOR   ::Launch            Rdpf? MacPerl module to launch / quit apps          CNANDOR   ::MacPGP            RdpO? Control MacPGP 2.6.3                          CNANDOR   ::PBar              RdpO? Control Progress Bar 1.0.1                    CNANDOR   Mac::Comm::  ::OT_PPP            RdpO? Control Open Transport PPP / Remote Access    CNANDOR   Mac::FileSpec::  ::Unixish           Mdpfp Unixish-compatability in filespecs            SBURKE   Mac::OSA::  ::Simple            Rmphp Simple access to Mac::OSA                     CNANDOR   MSDOS::  ::Attrib            bdcf? Get/set DOS file attributes in OS/2 or Win32  CJM   ::Descript          bdpO? Manage 4DOS style DESCRIPT.ION files          CJM  ::SysCalls         adcf? MSDOS interface (interrupts, port I/O)        DMO   MVS::  ::VBFile            bdpf? Read MVS VB (variable-length) files           GROMMEL   OS2::  ::ExtAttr           RdcO? (Tied) access to extended attributes          ILYAZ   ::FTP               bncf? Access to ftplib interface                    ILYAZ   ::PrfDB             RdcO? (Tied) access to .INI-style databases         ILYAZ   ::REXX              RdcO? Access to REXX DLLs and REXX runtime          ILYAZ   ::UPM               bncf? User Profile Management                       ILYAZ   Riscos             i   ? Namespace for Risc-OS (Acorn et.al.)          RISCOSML   SGI::  ::SysCalls          cdcf? SGI-specific system calls                     AMOSS   ::GL                adcr? SGI's Iris GL library                         AMOSS   ::FM                adcr? SGI's Font Management library                 AMOSS   ::FAM               RdcO? Interface to SGI/Irix File Access Monitor     JGLICK   Solaris::  ::ACL               Rdchp Provides access to ACLs in Solaris            IROBERTS  ::Kmem             idcf? Read values from the running kernel           ABURLISON   ::Kstat             adcO? Access kernel performance statistics          ABURLISON  ::MIB              idcO? Access STREAMS network statistics             ABURLISON   ::MapDev            bdpf? Maps sdNN disk names to cNtNdN disk names     ABURLISON  ::NDD              idcO? Access network device statistics              ABURLISON   ::Procfs            adhh? Access to the Solaris /proc filesystem        JNOLAN   ::InstallDB         bdp?? Searches for Solaris package/system info      CHRISJ   ::Package           bdpO? Access a Solaris package pkginfo file         CHRISJ   ::Contents          bdp?? Access a Solaris contents file                CHRISJ   Unix::  ::ConfigFile        adpO? Abstract interfaces to Unix config files      SSNODGRA   ::Processors        RdcOp Interface to per-processor information        WSNYDER   ::Syslog            Rdcfa Interface to syslog functions in a C-library  MHARNISCH  ::UserAdmin        Rdpf? Interface to Unix Account Information         JZAWODNY   ::Login             bdph? Customizable Unix login prompt / validation   NWIGER   VMS::  ::Device            Rdcr? Access info about any device on a VMS system  DSUGAL   ::Filespec          Sdcf? VMS and Unix file name syntax                 CBAIL   ::ICC               bdcr? Interface to the ICC facilities in VMS 7.2+   DSUGAL   ::Lock              RncO? Object interface to $ENQ (VMS lock mgr)       BHUGHES   ::Misc              Rdcr? Miscellaneous VMS utility routines            DSUGAL   ::Monitor           Rdcr? Access VMS system performance info            DSUGAL   ::Persona           Rdcf? Interface to the VMS Persona services         DSUGAL   ::Priv              Rdcf? Access VMS Privileges for processes           DSUGAL   ::Process           Rdcf? Process management on VMS                     DSUGAL   ::Queue             bdcf? Manage queues and entries                     DSUGAL   ::System            Rdcf? VMS-specific system calls                     DSUGAL   ::User              bdcr? Read access to system UAF data                DSUGAL   ::Mail              cdcO? Perl module for accessing callable VMS mail   DNORTH  ::SysCalls         i   ? VMS-specific system calls                     CBAIL   VMS::Fileutils:: ::Root             RdpO? Evade VMS's 8 level directory restrictions    CLANE  ::SafeName         Rdpf? Transform filenames to ""VMS safe"" form        CLANE   Portable Digital Assistants   PDA:: ::Pilot            amcO? Interface to pilot-link library               KJALB  ::PilotDesktop     i   ? Managing Pilot Desktop databases software     JWIEGLEY   Hardware related modules   Hardware:: ::Simulator        adpf? Simulate different pieces of hardware         GSLONDON   Device::  ::SerialPort        bdpO? POSIX clone of Win32::SerialPort              COOK  ::SVGA             c   ? SVGA Graphic card driver                      SCOTTVR   ::ParallelPort      adpOa Low Level access to Parallel Port             SCOTT   Device::ISDN::  ::OCLM              bd??? Perl interface to the 3com OCLM ISDN TA       MERLIN   AudioCD             bdpO? Extension for controlling Audio CDs           SDERLE  AudioCD::  ::Mac               bdcO? Extension for controlling Audio CDs on MacOS  AJFRY       5) Networking, Device Control (modems) and InterProcess Communication   Name                DSLIP  Description                                  Info ------------       ----- -------------------------------------------- ----  Socket              Smcf? Defines socket-related constants              GNAT   Socket6             adcf? getaddrinfo/getnameinfo support module        UMEMOTO   Ptty                adcf? Pseudo terminal interface functions           NI-S   Socket::  ::PassAccessRights  adcf? Pass file descriptor via Unix domain socket   SAMPO   Net::  ::ACAP              adpO? Interface to ACAP Protocol (Internet-Draft)   KJOHNSON   ::AIM               adpO? AOL Instant Messenger TOC protocol            ARYEH   ::AOLIM             RdpO? AOL Instant Messenger OO Interface (TOC)      RWAHBY   ::Bind              adpOp Interface to bind daemon related files        BBB  ::CDDB             cdpr? Interface to the CDDB (CD Database)           DSTALDER   ::Cmd               cdpO? For command based protocols (FTP, SMTP etc)   GBARR   ::DHCPClient        bdpOp Interface to DHCP as a client                 JWALGENB   ::DLookup           adpO? Lookup domains on Internic and 2-letter TLDs  DJASMINE   ::DNS               RmpOp Interface to the DNS resolver                 CREIN   ::DNSServer         cnpOa Secure and Extensible Name Server             BBB   ::Daemon            adpO? Abstract base class for portable servers      JWIED   ::Dnet              cdcO? DECnet-specific socket usage                  SPIDB   ::Domain            adpf? Try to determine TCP domain name of system    GBARR   ::FTP               adpf? Interface to File Transfer Protocol           GBARR   ::Gen               RdcOp Generic support for socket usage              SPIDB   ::Gnutella          bdpO? Gnutella network (v0.4) interface             IWADE   ::Goofey            RdpO? Communicate with a Goofey server              GOSSAMER   ::HTTPTunnel        adpO? Tunnel through HTTP proxies with CONNECT      RWAHBY   ::Hesiod            bdchp Interface to Hesiod library API               PAYERLE   ::Hotline           RdpO? Interface to the Hotline protocol             JSIRACUSA  ::ICAP             adpO? Interface to ICAP Protocol (Internet-Draft)   KJOHNSON   ::ICB               bdpO? ICB style chat server interface               JMV   ::ICQ               bmpO? Client interface to ICQ messaging             JMUHLICH   ::ICal              ampOp RFC2445 (iCalendar) protocol tools            SRL   ::IMAP              adpO? Interface to IMAP Protocol (RFC2060)          KJOHNSON  ::IMIP             impO? RFC2447 tools for event scheduling            SRL   ::IRC               cdpO? Internet Relay Chat interface                 JEEK  ::ITIP             cmpO? RFC2446 tools for scheduling events           SRL   ::Ident             RdpO? Performs ident (rfc1413) lookups              JPC   ::Inet              RdcOp Internet (IP) socket usage                    SPIDB   ::Interface         adcO? ifconfig(1) implementation                    SRZ   ::Jabber            RdpOl Access to the Jabber protocol                 REATMON   ::LDAP              ampOp Interface to LDAP Protocol (RFC1777)          PLDAP   ::LDAPapi           Rdcf? Interface to UMICH and Netscape LDAP C API    CDONLEY   ::LMTP              RdpOp LMTP Protocol - RFC2033                       LHOWARD  ::MsgLink          cdpO? Abstraction of ""user"" part for message link   RAM   ::NIS               adcO? Interface to Sun's NIS                        ESM   ::NISPlus           adcO? Interface to Sun's NIS+                       RIK   ::NNTP              adpO? Client interface to NNTP protocol             GBARR   ::Netmask           RdpO? Understand and manipulate network blocks      MUIR   ::Netrc             adpO? Support for .netrc files                      GBARR   ::PH                RdpO? CCSO Nameserver Client class                  GBARR   ::POP3              adpO? Client interface to POP3 protocol             GBARR   ::Pager             RdpO? Send Numeric/AlphaNumeric Pages to any pager  ROOTLEVEL   ::ParseWhois        RmpO? Get+Parse ""whois"" domain data                 ABEROHAM   ::Patricia          RdcO? Patricia Trie perl module for fast IP addres  PLONKA   ::Pcap              adcr? An interface for LBL's packet capture lib     PLISTER   ::Peep              RdpO? Clients for Peep: The Network Auralizer       STARKY   ::Ping              SupOp TCP, UDP, or ICMP ping                        BBB   ::Printer           RdpO? Direct to lpd printing                        CFUHRMAN   ::SCP               Rdphp Perl extension for secure copy protocol       IVAN   ::SFTP              bdpOp Secure File Transfer Protocol client          BTROTT   ::SMPP              cdpO? Protocol for sending SMS (to GSM or CDMA).    SAMPO   ::SMS               RdpOp Send SMS wireless text-messages.              ROOTLEVEL   ::SMTP              adpf? Interface to Simple Mail Transfer Protocol    GBARR   ::SNMP              MdpOp Object oriented interface to SNMP             DTOWN   ::SNPP              cdpO? Client interface to SNPP protocol             DREDD   ::SOCKS             cdcf? TCP/IP access through firewalls using SOCKS   SCOOPER   ::SSH               Rdphp Perl extension for secure shell               IVAN   ::SSL               RdcO? Glue that enables LWP to access https URIs    CHAMAS   ::SSLeay            bmhf? Secure Socket Layer (based on OpenSSL)        SAMPO   ::Server            bdpOp Extensible (class) oriented internet server   RHANDOM   ::Syslog            RdpOp Forwarded syslog protocol                     LHOWARD   ::TCP               RdcOp TCP-specific socket usage                     SPIDB   ::TFTP              cdpf? Interface to Trivial File Transfer Protocol   GSM   ::Telnet            RdpO? Interact with TELNET port or other TCP ports  JROGERS   ::Time              adpf? Obtain time from remote machines              GBARR   ::Traceroute        bdpOo Trace routes in IPv4, v6                      HAG   ::UDP               RdcOp UDP-specific socket usage                     SPIDB  ::VNC              i???? Interface VNC remote frame buffer protocol    BRONG   ::Whois             RdpO? Get+parse ""whois"" domain data from InterNIC   DHUDES   ::XWhois            RdpO? Whois Client Interface for Perl5.             VIPUL   ::Z3950             RmcO? OO interface (ZOOM) to Yaz Z39.50 toolkit     MIRK   ::hostent           adpf? A by-name interface for hosts functions       TOMC   ::netent            adpf? A by-name interface for networks functions    TOMC   ::protoent          adpf? A by-name interface for protocols functions   TOMC   ::servent           adpf? A by-name interface for services functions    TOMC   ::xAP               adpO? Interface to IMAP,ACAP,ICAP substrate         KJOHNSON   ::OSCAR             bmpOp AOL Instant Messenger OSCAR protocol          MATTHEWG   ::CIDR              Rdpfp Manipulate netblock lists in CIDR notation    MRSAM   ::CDDBScan          bdpOp String search interface to CDDB datbase       DSHULTZ   ::FTPServer         RdcO? Secure, extensible, configurable FTP server   RWMJ   ::Traceroute6       adphb Interface to IPv6 traceroute                  MOHACSI   ::QMQP              adpOp Interface to Quick Mail Queueing Protocol     KOBAYASI   ::ICQV5             Rnpfg Module to send and receive ICQ messages.      SNEMAROV   ::ICQV5CD           Rnpfg Crypt/decrypt ICQ protocol V5 packets         SNEMAROV  ::ICQ2000          inpfg allows send and receive ICQ messages.         SNEMAROV   ::FreeDB            bdhOp OOP interface to the FreeDB database          DSHULTZ   ::Google            bdpOp Simple OOP-ish interface to the Google API    ASCOPE   Net::Daemon::  ::SSL               RdpO? SSL extension for Net::Daemon                 MKUL   Net::DHCP::  ::Watch             bdpOp A class for monitoring a remote DHCPD server  EJDRS   Net::DNS:: ::SEC              RdpOd DNSSEC extension to Net::DNS                  OLAF   Net::IMAP::  ::Simple            bdpO? Only implements the basic IMAP features       JPAF   Net::Ping::  ::External          adpf? Cross-platform interface to ""ping"" utilities  COLINM   Net::SMS::  ::Genie             RdpOp Send SMS messages using the Genie gateway     AWRIGLEY   ::Web               adpOp generic module for sending SMS via web        AWRIGLEY   Net::SNMP::  ::Interfaces        RdpOp Obtain IfTable entries via SNMP               JSTOWE   Net::SSH::  ::Perl              bdpOp Perl client Interface to SSH                  BTROTT   Net::Telnet::  ::Cisco             RmpOp Automate telnet sessions w/ routers&switches  JOSHUA   Net::Whois::  ::RIPE              MmpOg class implementing a RIPE whois client        PAULG   NetAddr::  ::IP                RdpOp Manipulation and operations on IP addresses   LUISMUNOZ   NetAddr::IP::  ::Find              adpfp Find IP addresses in plain text               MIYAGAWA   DNS::  ::ZoneParse         RdpOp Parse and manipulate DNS Zone files           SIMONFLK   IPC::  ::Cache             adpO? Shared-memory object cache                    DCLINTON   ::ChildSafe         RdcO? Control child process w/o risk of deadlock    DSB  ::Globalspace      cnpO? Multi-process shared hash and shared events   JACKS   ::LDT               RdpOa Implements a length based IPC protocol        JSTENZEL   ::Locker            RdpOp Shared semaphore locks across a network       WSNYDER  ::Mmap             i   ? Interface to Unix's mmap() shared memory      MICB   ::Open2             Supf? Open a process for both reading and writing   P5P   ::Open3             Supf? Like IPC::Open2 but with error handling       P5P   ::Run               bdph? Child procs w/ piping, redir and psuedo-ttys  RBS   ::Session           bnpO? remote shell session mgr; wraps open3()       STEVEGT   ::Shareable         bdpr? Tie a variable to shared memory               BSUGARS   ::SharedCache       Rmpr? Manage a cache in SysV IPC shared memory      SAMTREGAR   ::Signal            Rdpf? Translate signal names to/from numbers        ROSCH   ::SysV              Sucr? shared memory, semaphores, messages etc       P5P   ::XPA               adch? Interface to SAO XPA messaging system         DJERIUS   Replication::Recall::  ::Client            adhfo Recall replication library client interface   AGUL   ::Server            adhfo Recall replication library server interface   AGUL   ::DBServer          adpOp Database replication server using Recall      AGUL   RPC::             Remote Procedure Calls (see also DCE::RPC)  ::PlServer          RdpO? Interface for building Perl Servers           JWIED   ::PlClient          RdpO? Interface for building pServer Clients        JWIED   ::ONC               adcO? ONC RPC interface (works with perlrpcgen)     JAKE   ::Simple            adpO? Simple OO async remote procedure calls        DDUMONT   DCE::             Distributed Computing Environment (OSF)  ::ACL               bdcO? Interface to Access Control List protocol     PHENSON   ::DFS               bdcO? DCE Distributed File System interface         PHENSON   ::Login             bdcO? Interface to login functions                  PHENSON  ::RPC              c   ? Remote Procedure Calls                        PHENSON   ::Registry          bdcO? DCE registry functions                        PHENSON   ::Status            bdpr? Make sense of DCE status codes                PHENSON   ::UUID              bdcf? Misc uuid functions                           PHENSON   NetPacket::  ::ARP               adpO?  Address Resolution Protocol                  TIMPOTTER   ::Ethernet          adpO?  Ethernet framed data                         TIMPOTTER   ::IGMP              adpO?  Internet Group Management Protocol           TIMPOTTER   ::IP                adpO?  Internet Protocol                            TIMPOTTER   ::TCP               adpO?  Transmission Control Protocol                TIMPOTTER   ::UDP               adpO?  User Datagram Protocol                       TIMPOTTER   Proxy              i   ? Transport-independent remote processing       MICB  Proxy:: ::Tk               ?   ? Tk transport class for Proxy (part of Tk)     MICB   Fwctl               bmpO? Interface to Linux packet filtering firewall  FRAJULAC  LSF                cdcOp Interface to the Load Sharing Facility API    DXIAO   TFTP                bdpO? Interface to TFTP (rfc1350)                   GSM  ToolTalk           adcr? Interface to the ToolTalk messaging service   MARCP   SOAP                cmpO? SOAP/Perl language mapping                    KBROWN   IPChains            RdcO? Create and Manipulate ipchains                JESSICAQ  IPChains::  ::PortFW            bdpO? Interface to ipmasqadm portfw command         FRAJULAC   SNMP                RdcO? Interface to the UCD SNMP toolkit             GSM  SNMP::  ::Monitor           adpO? Accounting and graphical display              JWIED   ::Util              RdpO? Perform SNMP set,get,walk,next,walk_hash,...  WMARQ  ::NPAdmin          adpO? Perl API to query printers via SNMP.          BOZZIO   ::BridgeQuery       bdpfp Query bridge/switch for forwarding database   JSHEARER   Mon::  ::Client            RdpO? Network monitoring client                     TROCKIJ   ::SNMP              RdpO? Network monitoring suite                      TROCKIJ   Parallel::  ::ForkManager       RdpOp A simple parallel processing fork manager     DLUX   ::Pvm               bdcf? Interface to the PVM messaging service        DLECONTE   CORBA::  ::IOP::IOR          adpO? Decode, munge, and re-encode CORBA IORs       PHILIPA   ::IDLtree           Rdpf? IDL to symbol tree translator                 OMKELLOGG   Modem::  ::VBox              RdpOp Perl module for creation of voiceboxes        MLEHMANN   ::Vgetty            bdpO? Interface to voice modems using vgetty        YENYA   ControlX10:: ::CM10             RmpO? Control unit for X10 modules                  BBIRTH   ::CM17              RmpO? inexpensive RF transmit-only X10              BBIRTH   RAS::  ::PortMaster        RdpO? Interface to Livingston PortMaster            STIGMATA   ::AS5200            RdpO? Interface to Cisco AS5200 dialup server       STIGMATA   ::HiPerARC          RdpO? Interface to 3Com TotalControl HiPerARC       STIGMATA   IPTables::IPv4::  ::IPQueue           RdcOg IPTables userspace packet queuing             JMORRIS       6) Data Types and Data Type Utilities (see also Database Interfaces)   Name                DSLIP  Description                                  Info ------------       ----- -------------------------------------------- ---- Math::  ::Amoeba            Rdpr? Multidimensional Function Minimisation        JARW   ::Approx            adpO? Approximate x,y-values by a function          ULPFR   ::BaseCalc          RdpOp Convert numbers between various bases         KWILLIAMS   ::BigFloat          SupO? Arbitrary size floating point math package    TELS   ::BigInt            SupO? Arbitrary size integer math package           TELS   ::BigInteger        adc ? Arbitrary size integer as XS extension        GARY   ::BigRat            RdpOp Arbitrary size rational numbers (fractions)   TELS   ::Brent             Rdpr? One-dimensional Function Minimisation         JARW   ::CDF               bdch? Cumulative Distribution Functions             CALLAHAN   ::Cephes            adcf? Interface to St. Moshier's Cephes library     RKOBES   ::Complex           SdpOp Complex number data type                      RAM   ::Derivative        Rdpr? 1st and 2nd order differentiation of data     JARW   ::Expr              adpO? Parses agebraic expressions                   HAKANARDO   ::Fortran           Rdpf? Implements Fortran log10 & sign functions     JARW   ::Fraction          bdpO? Fraction Manipulation                         KEVINA   ::Geometry          adpf? 2D and 3D algorithms                          GMCCAR  ::Interpolate      Rdpr? Polynomial interpolation of data              MATKIN  ::LinearProg       idp ? Linear programming utilities                  JONO   ::Logic             RdpO? Provides pure 2, 3 or multi-value logic       SUMMER   ::Matrix            adpO? Matrix data type (transpose, multiply etc)    ULPFR   ::MatrixBool        RdhOp Matrix of booleans (Boolean Algebra)          STBEY  ::MatrixCplx       idpOp Matrix data type for Complex Numbers          STBEY   ::Pari              adcf? Interface to the powerful PARI library        ILYAZ   ::Polynomial        RdpO? Polynomials as objects                        MATKIN   ::Round             bdpfp Perl extension for rounding numbers           GROMMEL   ::SigFigs           Rdpfp Math using scientific significant figures     SBECK   ::Spline            RdpO? Cubic Spline Interpolation of data            JARW   ::Trig              bdpf? tan asin acos sinh cosh tanh sech cosech      JARW   ::VecStat           Rdpr? Some basic numeric stats on vectors           ASPINELLI   ::ematica           adcO? Interface to the powerful Mathematica system  ULPFR   ::Libm              RdcO? Perl extension for the C math library, libm   DSLEWART   ::FFT               adcO? Perl extension for Fast Fourier Transforms    RKOBES   ::BooleanEval       bdpO? Parsing and evaluating Boolean expressions    MIKO   ::BigIntFast        RdhOp Efficient big integer arithmetic (in C)       STBEY  ::QuadTree         cdpO? Quad Edge data structure for 2D manifolds     FRED   ::Fleximal          adpO? Arithmetic with any base representation       TILLY   ::Project           RdpOp Compute intersection with upright line        MILSO   ::VectorReal        RdpOp Handling 3D Vector Mathematics                ANTHONY   ::RPN               Rdpf? Reverse Polish Notation Expression Evaluator  OWEN  ::SimpleInterest   Rnpfp Functions for Simple Interest calculations    BYOURTH   ::Random            Rdcfd Random Number Generators                      GROMMEL  ::Prime            i   ? Prime number testing                          GARY  ::RandomPrime      i   ? Generates random primes of x bits             GARY   ::TrulyRandom       i   ? based on interrupt timing discrepancies       GARY  ::Fourier          i   ? Fast Fourier Transforms                       AQUMSIEH  ::Integral         i   ? Integration of data                           AQUMSIEH   ::Bezier            RdpOp Solution of Bezier curves                     ABW   Math::Bezier::  ::Convert           adpfp convert cubic and quadratic bezier curve      YSAS   Math::BigInt::  ::BitVect           Rdphp Use Bit::Vector for Math::BigInt routines     TELS   ::Pari              Rdphp Use Math::Pari for Math::BigInt routines      TELS   Math::Business::  ::EMA               MdpOg An Exponential Moving Average Calculator      JETTERO   ::BlackScholes      Rdpfp Black-Scholes option price model functions    ANDERS   Math::Calc::  ::Units             bdpfp Unit-aware calculator with readable output    SFINK   Math::  ::MatrixReal        RdpOp Manipulate NxN matrices                       LETO   Math::MatrixReal::  ::Ext1              RdpO? Convenience extensions for Math::MatrixReal   MSOUTH   Math::Polynomial::  ::Solve             Rdpf? Solve polynomials up to degree 4              JGAMBLE   Math::Random::  ::MT                Rdcha The Mersenne Twister PRNG                     AMS   Statistics::  ::ChiSquare         Rdpf? Chi Square test - how random is your data?    JONO   ::ConwayLife        RdpO? Simulates life using Conway's algorithm       DANB   ::Descriptive       RdpO? Descriptive statistical methods               COLINK   ::LTU               RdpO? Implements Linear Threshold Units             TOMFA   ::MaxEntropy        Rdpf? Maximum Entropy Modeling                      TERDOEST   ::OLS               bdpO? ordinary least squares (curve fitting)        SMORTON   ::ROC               bdpf? ROC curves with nonparametric conf. bounds    HAKESTLER   ::Distributions     RdpO? Perl module for calculating critical values   MIKEK   Algorithm::  ::Diff              Rdpfp Diff (also Longest Common Subsequence)        NEDKONZ   ::Permute           bdcO? Handy and fast permutation with OO interface  EDPRATOMO   ::SISort            Rdcrp Select And Insert sorting algorithm           HRAFNKELL   ::LUHN              Rdpf? Calculate mod 10 Double Add Double checksum   TAYERS   Algorithm::Graphs::  ::TransitiveClosure  RdpO? Calculates the transitive closure            ABIGAIL   Algorithm::Numerical::  ::Shuffle           Rdph? Knuth's shuffle algorithm                     ABIGAIL   ::Sample            RDph? Knuth's sample algorithm                      ABIGAIL   PDL                 amcf? Perl Data Language - numeric analysis env     PERLDL   PDL:: ::Audio            bdchp Sound synthesis and editing with PDL          MLEHMANN   ::Meschach          amcf? Links PDL to meschach matrix library          EGROSS   ::NetCDF            RdcOp Reads/Writes NetCDF files from/to PDL objs    DHUNT   ::Options           Rdphp Provides hash options handling for PDL        TJENNESS   ::PP                amcf? Automatically generate C code for PDL         PERLDL  ::Slatec           amof? Interface to slatec (linpack+eispack) lib.    PERLDL   ::NiceSlice         bmpfp a nicer slicing syntax for PDL                CSOE   PDL::IO:: ::HDF5             bdcOp PDL Interface to the HDF5 Data Format         CERNEY   Quantum::  ::Superpositions    Rdpf? QM-like superpositions in Perl                LEMBARK   ::Entanglement      Rdph? QM entanglement of variables in perl          AJGOUGH   ::Usrn              Rdp?p Square root of not.                           KASEI   Array::  ::Compare           RdpOp Class to compare two arrays                   DAVECROSS  ::Heap             cdpf? Manipulate array elements as a heap           JMM   ::IntSpan           RdpO? Handling arrays using IntSpan techniques      TEVERETT   ::PrintCols         adpf? Print elements in vertically sorted columns   AKSTE  ::Substr           idp ? Implement array using substr()                LWALL  ::Vec              idp ? Implement array using vec()                   LWALL  ::Virtual          idp ? Implement array using a file                  LWALL   ::Reform            RdpO? Convert an array into N-sized array of array  TBONE   Hash::  ::NoVivify          Rdcf? Provide non-autovivifying hash functions      BPOWERS   Heap                bdpO? Define Heap interface                         JMM  Heap::  ::Binary            bdpO? Implement Binary Heap                         JMM   ::Binomial          bdpO? Implement Binomial Heap                       JMM   ::Fibonacci         bdpO? Implement Fibonacci Heap                      JMM   ::Elem              bdpO? Heap Element interface, ISA                   JMM  Heap::Elem::  ::Num               bdpO? Numeric heap element container                JMM   ::NumRev            bdpO? Numeric element reversed order                JMM   ::Str               bdpO? String heap element container                 JMM   ::StrRev            bdpO? String element reversed order                 JMM   ::Ref               bdpO? Obj ref heap element container                JMM   ::RefRev            bdpO? Obj ref element reversed order                JMM   Scalar::  ::Util              bdcf? Scalar utilities (dualvar reftype etc)        GBARR   ::Properties        RdpOp run-time properties on scalar variables       MARCEL   List::  ::Util              bdcf? List utilities (eg min, max, reduce)          GBARR   ::Intersperse       Rdpf? Intersperse / unsort / disperse a list        TAYERS   Bit::  ::Vector            RdcOp Fast virtual arbitrary-size-machineword CPU   STBEY   Set::  ::Bag               RdpO? Bag (multiset) class                          JHI   ::IntRange          RdhOp Set of integers (arbitrary intervals, fast)   STBEY   ::IntSpan           RdpOp Set of integers newsrc style '1,5-9,11' etc   SWMCD   ::NestedGroups      RdpO? Grouped data eg ACL's, city/state/country     ABARCLAY   ::Object            bdcO? Set of Objects (smalltalkish: IdentitySet)    JLLEROY   ::Scalar            adpO? Set of scalars (inc references)               JHI   ::Window            RdpOp Manages an interval on the integer line       SWMCD   ::CheckList         adph? Maintain a list of ""to-do"" items              MIKO   ::Crontab           RdpOa Expand crontab(5)-style integer lists         AMS   ::Infinite          bdpOp Infinite Set Theory module, with Date, Time   FGLOCK   ::CrossProduct      RdpOp interact with the cartesian product of sets   BDFOY   Graph               RdpO? Data structure and ops for directed graphs    JHI  Graph::  ::Kruskal           Rdpfp Kruskal Algorithm for Minimal Spanning Trees  STBEY   ::Reader            RdpO? Base class for graph file format reader       NEILB   ::Writer            RdpO? Base class for graph file format writer       NEILB   Graph::Reader::  ::XML               RdpO? Read a Graph from simple XML format           NEILB   Graph::Writer::  ::XML               RdpO? Write a Graph in a simple XML format          NEILB   ::Dot               RdpO? Write a Graph in file format used by Dot      NEILB   ::VCG               RdpO? Write a Graph in file format used by VCG      NEILB   ::daVinci           cdpO? Write a Graph in file format used by daVinci  NEILB   Decision::  ::Markov            bdpO? Build/evaluate Markov models for decisions    ALANSZ   ::ACL               adpOp Manage and Build Access Control Lists         BBEAUSEJ   Date::  ::Calc              Rdhhp Gregorian calendar date calculations          STBEY   ::Convert           cdpO? Conversion between Gregorian, Hebrew, more?   MORTY   ::Format            Rdpf? Date formatter ala strftime                   GBARR   ::Interval          idpO? Lightweight normalised interval data type     KTORP   ::Language          adpO? Multi-language date support                   GBARR   ::Manip             Rdpfp Complete date/time manipulation package       SBECK   ::Parse             Rdpf? ASCII Date parser using regexp's              GBARR  ::Time             idpO? Lightweight normalised datetime data type     TOBIX   ::ISO               Rdpfp Calculate dates in the ISO calendar           RBOW   ::Discordian        Rdpfp Calculate dates in the Discordian calendar    RBOW   ::DayOfWeek         Rdpfp Calculate day of week for Gregorian dates     RBOW   ::Easter            Rdpfp Calculate the date of Easter                  RBOW   ::ICal              bdpOp Class for ICal date objects                   RBOW   ::Handler           RdpOp Simple Object oriented Date Handling          BBEAUSEJ   ::SundayLetter      cdpfp Calculates the Sunday Letters for a given ye  RBOW   ::Doomsday          cdpfp Determine doomsday for a given year           RBOW   ::Simple            RdpOp A simple date object                          KASEI  ::Bahai            impOp Calculate dates in the Bahai calendar         RBOW  ::Persian          impOp Calculate dates in the Persian calendar       RBOW  ::Japanese         impOp Calculate dates in the Japanese calendar      RBOW  ::Hindu            impOp Calculations in the Hindu calendar            RBOW   ::Passover          impfp Calculate date of Passover or Rosh Hashanah   RBOW   ::Chinese           impOp Calculations in the Chinese calendar          RBOW  ::Ethiopic         impOp Calculations in the Ethiopic calendar         RBOW  ::Egyptian         impOp Calculations in the Egyptian calendar         RBOW   ::Gregorian         bdpOp Gregorian calendar                            MHASCH   ::Roman             RdpOa Manipulating Roman-style dates                HOBBIT   Date::Convert::  ::French_Rev        adpOp From/to French Revolutionary Calendar         JFORGET   Date::Japanese::  ::Era               adpOp Year conversion for Japanese Era              MIYAGAWA   Date::Tolkien::  ::Shire             RdpOp J.R.R. Tolkien's hobbit calendar              TBRAUN   Time::  ::Avail             Rdpf? Calculate min. remaining in time interval     PSANTORO   ::CTime             Rdpf? Format Times ala ctime(3) with many formats   MUIR   ::DaysInMonth       Rdpf? Returns the number of days in a month         MUIR   ::HiRes             Rdcf? High resolution time, sleep, and alarm        JHI   ::JulianDay         Rdpf? Converts y/m/d into seconds                   MUIR   ::Local             Supf? Implements timelocal() and timegm()           P5P   ::Object            adpO? Object Oriented time objects                  MSERGEANT   ::ParseDate         Rdpf? Parses many forms of dates and times          MUIR   ::Period            Rdpf? Code to deal with time periods                PRYAN   ::Timezone          Rdpf? Figures out timezone offsets                  MUIR   ::Zone              Rdpf? Timezone info and translation routines        GBARR   ::gmtime            Supf? A by-name interface for gmtime                TOMC   ::localtime         Supf? A by-name interface for localtime             TOMC   ::Seconds           RdcO? API to convert seconds to other date values   MSERGEANT   ::Stopwatch         Rdprp Tied variables that count seconds             ILTZU   ::Unix              RdpO? Force time() to return secs since UNIX epoch  NWIGER   ::TAI64             bdcfp Time manipulation in the TAI64* formats       SPOON   Time::Piece::  ::MySQL             RdpOp MySQL-specific functions for Time::Piece      DROLSKY   Calendar::  ::CSA               adcO? interface with calenders such as Sun and CDE  KJALB  ::Hebrew           cdpO? Hebrew calendar conversion/manipulation       YSTH  ::RCM              i   ? Russell Calendar Manager                      HTCHAPMAN   Tie::  ::AliasHash         Rdprp Hash with key aliases                         ACALPINI   ::Array             Supr? Base class for implementing tied arrays       P5P   ::CPHash            bdpO? Case preserving but case insensitive hash     CJM   ::Cache             Mdprp In memory size limited LRU cache              CHAMAS   ::CharArray         Rdprp Manipulate strings as arrays of characters    ILTZU   ::Cycle             RdpO? Cycle through a list of values via a scalar.  BDFOY   ::DBI               RdpO? Tie hash to a DBI handle                      LDS   ::DB_FileLock       Rdpr? Locking access to Berkeley DB 1.x.            JMV   ::DB_Lock           Rdprp Tie DB_File with automatic locking            KWILLIAMS   ::Dir               adpr? Tie hash for reading directories              GBARR   ::Discovery         Rdpr? Discover data by caching sub results          SIMON   ::DxHash            Rdprp Keeps insertion order; allows duplicate keys  KRUSCOE   ::File              Rdprp Tie array to lines of a file                  MJD   ::FileLRUCache      bdph? File based persistent LRU cache               SNOWHARE   ::Handle            RdpOp Base class for implementing tied filehandles  STBEY   ::Hash              Supr? Base class for implementing tied hashes       P5P   ::HashDefaults      adpr? Let a hash have default values                JDPORTER   ::IxHash            RdpO? Indexed hash (ordered array/hash composite)   GSAR   ::LDAP              bdpr? Ties LDAP database to Perl hash               TAIY   ::LLHash            Rdprp Fast ordered hashes via linked lists          KWILLIAMS   ::ListKeyedHash     Rdpr? Use lists to key multi-level hashes           SNOWHARE  ::Mem              adcO? Bind perl variables to memory addresses       PMQS   ::MmapArray         bdcr? Ties a file to an array                       ANDREWF   ::Multidim          adpr? ""tie""-like multidimensional data structures   JDPORTER   ::OffsetArray       adpr? Tie one array to another, with index offset   JDPORTER   ::Persistent        Rdprp Persistent data structures via tie made easy  RGIERSIG   ::RDBM              RdpO? Tie hashes to relational databases            LDS   ::RangeHash         Rdpha Hashes with 'low,high' ranges as keys         RRWO   ::RegexpHash        adpha Use regular expressions as hash keys          RRWO  ::RndHash          bdpO? choose a random key of a hash in O(1) time    DFAN   ::Scalar            Supr? Base class for implementing tied scalars      P5P   ::SecureHash        RdpO? Enforced encapsulation of Perl objects        DCONWAY   ::SentientHash      bdpr? Tracks changes to nested data structures      ANDREWF   ::ShadowHash        adpOp Merge multiple data sources into a hash       RRA   ::SortHash          Rdpr? Provides persistent sorting for hashes        CTWETEN   ::StrictHash        RdpO? A hash with strict-like semantics             KVAIL   ::SubstrHash        SdpO? Very compact hash stored in a string          LWALL   ::TextDir           Rdprp ties a hash to a directory of textfiles       KWILLIAMS   ::WarnGlobal        adpr? Ties variables to functions, warns on use     STEPHEN   ::Watch             bdpO? Watch variables, run code when read/written   LUSOL   ::GHash             adcfp A smaller hash; interface to Gnome glib hash  LBROCARD   ::TransactHash      RupOg Allows edits on a hash without disturbing it  MIKEDLR  ::Concurrent       bdprp Retie a hash when reading/writing.            GWYN  ::ShiftSplice      i   ? Defines shift et al in terms of splice        LWALL  ::Quick            i   ? Simple way to create ties                     P5P   ::Toggle            Rdprp a scalar flip-flops between two values        BDFOY   Tie::Scalar::  ::Timeout           adpr? Scalar variables that time out                MARCEL   Tie::Cache::  ::LRU               adpr? A Least-Recently Used cache                   MSCHWERN   Tie::Hash::  ::Regex             Rdprp Look up values in hashes using regexes        DAVECROSS   ::Stack             bdpra Maintains an array of hashes like a stack     MNEYLON   Class::  ::Accessor          bdpO? Automated accessor generation                 MSCHWERN   ::BlackHole         RdpOp treat unhandled method calls as no-op         SBURKE   ::Classless         MdpOp Framework for classless OOP                   SBURKE   ::Contract          RdpO? Design-by-Contract OO in Perl.                GGOEBEL   ::DBI               adpOp Simple SQL-based object persistance           TMTM   ::Delegate          bdpO? Easy-to-use object delegation                 KSTAR  ::Eroot            RdpO? Eternal Root - Object persistence             DMR   ::Fields            bdph? Inspect the fields of a class                 MSCHWERN   ::ISA               Mdpfp Report the search path thru an ISA tree       SBURKE   ::MethodMaker       MdpOp Create generic class methods                  FLUFFY   ::Multimethods      Rdpf? A multiple dispatch mechanism for Perl        DCONWAY   ::Mutator           bdpO? Dynamic polymorphism implemented in Perl      GMCCAR   ::NamedParms        MdpO? A named parameter accessor base class         SNOWHARE   ::ObjectTemplate    bdpOp Optimized template builder base class         JASONS   ::ParamParser       RdpOp Provides complex parameter list parsing       DUNCAND   ::ParmList          MdpO? A named parameter list processor              SNOWHARE  ::PublicInternal   adpO? Keep separate hashes of public/internal data  MIKO   ::Singleton         bdpO? Implementation of a ""Singleton"" class         ABW   ::StructTemplate    adpO? Facilitates creation of public class-data     HEIKOWU  ::TOM              RmpO? Transportable Object Model for perl           JDUNCAN   ::Template          Rdpr? Struct/member template builder                DMR   ::Translucent       RdpO? Translucent (ala perltootc) method creation   GED   ::Tree              MdpO? C++ class hierarchies & disk directories      RSAVAGE   ::WhiteHole         RdpO? Treat unhandled method calls as errors        MSCHWERN   ::Handler           bdpO? Make Apache-like pseudoclass event handlers   NWIGER   ::Loader            bdpO? Load modules & construct objects on demand.   VIPUL   ::Date              RdhOp a full-featured date and time class for perl  DLUX   ::ArrayObjects      Rdphp Utility class for array based objects         RBERJON   ::MethodMapper      RdpO? Abstract Class wrapper for AutoLoader         LENZO   ::MakeMethods       bdpOp Generate common types of methods              EVO  ::Flyweight        adpOp implement the flyweight pattern in OO perl    DKUBB   ::Prototyped        bdpOp Fast prototype-based OO programming in Perl   TEVERETT   ::Holon             RdpO? Declare hierarchical classes with one line    GSLONDON   ::PseudoHash        bmprp Emulates Pseudo-Hash behaviour via overload   AUTRIJUS   ::Tangram           bdpOa Automated class accessors, Tangram friendly   SAMV   ::Facade            bdpOp Interface to one or more delegates            ABW   Class::DBI::  ::mysql             RdpOp Extensions to Class::DBI for MySQL            TMTM   Class::ObjectTemplate::  ::DB                bdpOp Template base class for database objects      JASONS   Object::  ::Info              Rnpf? General info about objects (is-a, ...)        JACKS   ::Transaction       bdpO? Transactions on serialized HASH files         MUIR   Object::Realize::  ::Later             MdpOp Delay construction of real data until used    MARKOV   POE::             Perl Object Environment  ::Kernel            RdpO? An event queue that dispatches events         RCAPUTO   ::Session           RdpO? state machine running on POE::Kernel events   RCAPUTO   POE::Component::  ::RSS               bdp?? Event based RSS interface                     MSTEVENS   ::SubWrapper        bdp?? Event based Module interface                  MSTEVENS   ::UserBase          RdpO? A component to manage user authentication     JGOFF   ::Pcap              adhOp POE Interface to Net::Pcap                    FLETCH   ::MPG123            RdpOb POE Component for accessing and working wit   MCASHNER   POE::Component::Client::  ::UserAgent         bdpOp LWP and LWP::Parallel based POE web client    RCAPUTO   ::FTP               adpOp POE FTP client                                MCHING   POE::Component::IRC::  ::Onjoin            RdpO? Provides IRC moved message & onjoin services  AFOXSON  ::SearchEngine     bdpO? Search Engine for IRC                         AFOXSON   POE::Component::Server::  ::HTTP              bdphp POE Web componenet                            ABERGMAN   MOP                bdp ? Meta Object Protocol (Tool collection)        ORTALO   Ref                 RdpO? Print, compare, and copy perl structures      MUIR  SOOP               RdpO? Safe Object Oriented Programming              GARROW   Sort::  ::Fields            bdpf? sort text lines by alpha or numeric fields    JNH  ::PolySort         bdpO? general rules-based sorting of lists          DMACKS   ::Versions          Rdpf? sorting of revision (and similar) numbers     EDAVIS   Data Type Marshaling (converting to/from strings) and Persistent Storage   Clone               idch? Recursive copy of nested objects              RDF   FreezeThaw          bdpf? Convert arbitrary objects to/from strings     ILYAZ  Persistence:: ::Object           adpO? Store Object definitions with Data::Dumper    VIPUL   Storable            Smcrp Persistent data structure mechanism           AMS  Marshal:: ::Dispatch         cdpO? Convert arbitrary objects to/from strings     MUIR  ::Packed           cdpO? Run-length coded version of Marshal module    MUIR  ::Eval             cdpO? Undo serialization with eval                  MUIR   Tangram             RmpO? Object persistence in relational databases    JLLEROY   Persistent::  ::Base              bdpO? Persistent base classes (& DBM/File classes)  DWINTERS   ::DBI               bdpO? Persistent abstract class for DBI databases   DWINTERS   ::MySQL             bdpO? Persistent class for MySQL databases          DWINTERS   ::Oracle            bdpO? Persistent class for Oracle databases         DWINTERS   ::Sybase            bdpO? Persistent class for Sybase databases         DWINTERS   ::mSQL              bdpO? Persistent class for mSQL databases           DWINTERS   ::LDAP              bdpO? Persistent class for LDAP directories         DWINTERS   Data:: ::Check            cdpO? Checks values for various data formats        KENHOLM   ::DRef              adph? Nested data access using delimited strings    EVO   ::Dumper            RdpO? Convert data structure into perl code         GSAR   ::Flow              RdpO? Acquire data based on recipes                 ILYAZ   ::Locations         RdhOp Insert data into other data w/o temp files    STBEY   ::Reporter          RdcO? Ascii Report Generator                        RVAZ   ::Walker            RdpO? Navigate through Perl data structures         JNOLAN   ::Random            adpfp Generate random sets of data                  ADEO   ::JavaScript        Rdpr? Dumps structures into JavaScript code         SCHOP   ::MultiValuedHash   RdpOp Hash whose keys have multiple ordered values  DUNCAND   ::Iterator          RupO? Simple iteration over complex data strucures  HCAMP   ::Buffer            bdpOp Read/write buffer class                       BTROTT   ::Lazy              Rdprp provides ""lazy"" scalars, arrays and hashes    JENDA   ::Denter            RdpO? An alternative to Data::Dumper and Storable.  INGY   ::Compare           RdpO? Compare perl data structures                  FTASSIN   ::HexDump           RdpO? Hexadecial Dumper                             FTASSIN   ::Hexdumper         Rdpfa Display binary data in multiple formats       DCANTRELL  ::Stash            bdpf? Data structures in simple text format         HRANICKY  ::BinStruct        bdpO? OO access to binary data structures           DJHD   ::MaskPrint         bdpOp Allows for exact formatting of data           ILYAVERL   ::Serializer        RdpOp Generic interface to serializer modules       NEELY   Data::Tabular:: ::Dumper           bdpOp Automate dumping of data to XML, XSL and CSV  GWYN   Tree::  ::Base              cdpO? Defines a basic binary search tree            MSCHWERN   ::Fat               Rdcf? Embeddable F-Tree algorithm suite             JPRIT   ::Smart             cdpO? Splay tree, fastest for commonly accessed ke  MSCHWERN   ::Ternary           bdpOp Perl implementation of ternary search trees   MROGASKI   ::Ternary_XS        adcOp XS implementation of ternary search trees     LBROCARD   ::Trie              bdpO? An implementation of the Trie data structure  AVIF   ::Nary              RdpO? Perl implementation of N-ary search trees     FSORIANO   ::DAG_Node          MdpOp base class for trees                          SBURKE   ::M                 ad+Od M-trees provide efficient metric searches     MLEHMANN   DFA::  ::Command           MdpO? Discrete Finite Automata command processor    RSAVAGE   ::Kleene            Rdpfp Kleene's Algorithm for DFA                    STBEY   ::Simple            cdpO? An ""augmented transition network""             RANDYM   X500::  ::DN                adpOp Handle X.500 DNs (Distinguished Names)        RJOOP   ::RDN               adpOp handle X.500 Relative Distinguished Names     RJOOP   X500::DN::  ::Parser            MdpO? X500 Distinguished Name parser                RSAVAGE   Boulder            MdpO? Generalized tag/value data objects            LDS   Thesaurus           RdpOp Create associations between related things    DROLSKY  BabelObjects       cdpf? Web Service Framework                         KERMAGO   YAML                adphp YAML Ain't Markup Language (tm)               INGY   GDS2                bdpOa manipulate GDS2 stream format files           SCHUMACK   ADT                cdhhp Abstract Data Type top level                  ABERGMAN   ADT::Queue:: ::Priority         cnphp Abstract Data Type Priority Queue             ABERGMAN       7) Database Interfaces (see also Data Types)   Name                DSLIP  Description                                  Info ------------       ----- -------------------------------------------- ----  DBI                 MmcOp Generic Database Interface (see DBD modules)  DBIML   DBI::  ::Format            bmpO? Defined display formats for data from DBI     TLOWERY   DBIx -- Extensions to the DBI   DBIx::  ::Abstract          RmpO? Wrapper for DBI that generates SQL            TURNERA   ::AnyDBD            bdpO? Module to make cross db applications easier   MSERGEANT   ::CGITables         adpO? Easy DB access from a CGI                     TOBIX   ::Copy              adpO? Copying databases                             TOBIX   ::FullTextSearch    bmpOp Index documents with MySQL as storage         TJMATHER   ::glueHTML          bdpO? CGI interface to DBI databases                JFURNESS   ::HTMLView          cdpO? Creating web userinterfaces to DBI dbs        HAKANARDO   ::OracleSequence    adpOp OO access to Oracle sequences via DBD-Oracle  BLABES   ::Password          MdpO? Abstration layer for database passwords       KROW   ::Recordset         bmpO? DB-Abtractionlayer / Access via Arrays/Hashs  GRICHTER   ::Table             bdpO? OO access to DBI database tables              DLOWE  ::TableAdapter     adpOa A object-relational table adapter class       GED   ::Tree              adpO? Expand self-referential table into a tree     BJEPS   ::XML_RDB           ????? Creates XML from DBI datasources              MSERGEANT   ::DBSchema          bmpOp Database-independent schema objects           IVAN  ::XMLMEssage       bdpOp Exchange of XML messages between DBI sources  ANDREIN   ::Browse            bdpOg A class to browse related tables via CGI/Web  EJDRS   ::XHTML_Table       RdpOp SQL query result set to XHTML table           JEFFA  ::SchemaView       adpf? Retrieving and drawing of DB schema (Tk)      MILSO   ::SystemCatalog     RdpO? Accessing system catalog in common databases  MILSO   ::dbMan             bmpOp Tk/cmdline database manipulating tool         MILSO   ::Sequence          MdpOp Database independent ID generation            BBEAUSEJ   ::TextIndex         bdpOp Creates fulltext indexes of SQL text columns  DKOCH   ::FetchLoop         RdpOg Fetch with change detection and aggregates    BITS   DBIx::Lookup::  ::Field             Rdpfp Create a lookup hash from a database table    MARCEL   DBD::  ::ASAny             adcO? Adaptive Server Anywhere Driver for DBI       SMIRNIOS  ::Altera           bdpO? Altera SQL Server for DBI - pure Perl code    DSOUFLIS   ::CSV               adcO? SQL engine and DBI driver for CSV files       JZUCKER   ::DB2               adcO? DB2 Driver for DBI                            MHM   ::Empress           adcO? Empress RDBMS Driver                          SWILLIAM  ::FreeTDS          adcO? DBI driver for MS SQLServer and Sybase        SPANNRING   ::SearchServer      cdcO? PCDOCS/Fulcrum SearchServer Driver for DB     SHARI   ::Illustra          bmcO? Illustra Driver for DBI                       PMH   ::Informix          amcO? Informix Driver for DBI                       JOHNL   ::Informix4         adcO? DBI driver for Informix SE 4.10               GTHYNI   ::Ingres            bmcO? Ingres Driver for DBI                         HTOUG   ::Multiplex         RmpO? Spreading database load across servers        TKISHEL   ::ODBC              amcO? ODBC Driver for DBI                           DBIML   ::Oracle            MmcO? Oracle Driver for DBI                         DBIML   ::QBase             amcO? QBase Driver for DBI                          BENLI   ::RAM               bmpO? a DBI driver for files and data structures    JZUCKER  ::SQLrelay         bdpO? SQLrelay driver for DBI                       DMOW   ::Solid             amcO? Solid Driver for DBI                          TWENRICH   ::Sqlflex           RdcO? SQLFLEX driver for DBI                        INFOFLEX   ::Sybase            bmcO? Sybase Driver for DBI                         MEWP   ::Unify             bdcO? Unify driver for DBI                          HMBRAND   ::XBase             RmpO? XBase driver for DBI                          JANPAZ   ::mSQL              RmcO? Msql Driver for DBI                           JWIED   ::mysql             RmcO? Mysql Driver for DBI                          JWIED   ::pNET              amcO? DBD proxy driver                              JWIED   ::InterBase         bmcO? DBI driver for InterBase RDBMS server         EDPRATOMO   ::RDB               Rdof? DBI driver for Oracle RDB (OpenVMS only)      ASTILLER   ::DtfSQLmac         RdpO? dtF/SQL (Mac OS edition) driver for DBI       TWEGNER   ::ADO               bmpO? Database interface modules of MS ADO for DBI  TLOWERY   ::Excel             adpO? Excel database driver for the DBI module      KWITKNR  ::Recall           adpOp Transparent database replication layer        AGUL   ::Sprite            RdpO? Sprite driver                                 TURNERJW   ::PrimeBase         bmc?p A primeBase database interface                PRIMEBASE   ::mysqlPP           bdpOp Pure Perl MySQL driver for the DBI            OYAMA   ::PgPP              bdpOp Pure Perl PostgreSQL driver for the DBI       OYAMA   Oraperl             Rmpf? Oraperl emulation interface for DBD::Oracle   DBIML   Ingperl             bmpf? Ingperl emulation interface for DBD::Ingres   HTOUG   DDL::  ::Oracle            RdpO? Reverse engineers object DDL; also defrags    RVSUTHERL   MSSQL::  ::DBlib             Md+O? Access MS SQL Server through DB-Library.      SOMMAR   ::Sqllib            MdpO? High-level interface using MSSQL::DBlib.      SOMMAR   Oracle:: ::OCI              bmcr? Raw interface to the Oracle OCI API           TIMB   Sybase:: ::Async            cdpO? interact with a Sybase asynchronously         WORENKD   ::BCP               RdcOp Sybase BCP interface                          MEWP  ::DBlib            RdcO? Sybase DBlibrary interface                    MEWP   ::Simple            bdpOp Simplified db access using Sybase::CTlib      MEWP   ::Sybperl           Rdpf? sybperl 1.0xx compatibility module            MEWP  ::CTlib            RdcO? Sybase CTlibrary interface                    MEWP   ::Xfer              RdpO? Transfer data between sybase servers          SPRAGST   Ace                 RdpOp Interface to ACEDB (Popular Genome DB)        LDS   BBDB                Rdph? Insiduous big brother database                LAXEN  DTREE              cdcf? Interface to Faircom DTREE multikey ISAM db   JWAT  Datascope          Rdcf? Interface to Datascope RDBMS                  DANMQ  Fame               MdcOp Interface to FAME database and language       TRIAS  LotusNotes         i   ? Interface to Lotus Notes C/C++ API            MBRECH   Msql                RmcO? Mini-SQL database interface                   JWIED   Mysql               RmcO? mysql database interface                      JWIED  NetCDF             bmcr? Interface to netCDF API for scientific data   SEMM   ObjStore            Rm+O? ObjectStore OODBMS Interface                  JPRIT   Pg                  Rdcf? PostgreSQL SQL database interface             MERGL   PgSQL               adpO? ""Pure perl"" interface to PostgreSQL           GTHYNI   Pogo                ad+O? Interface for GOODS object database           SEYN   Postgres            RncO? PostgreSQL interface with Perl5 coding style  DAVEHOLL   Sprite              RdpO? Limited SQL interface to flat file databases  SHGUN  VDBM               cdph? Client/server-layers on top of DBM files      RAM   WAIT                adhO? A rewrite of the freeWAIS-sf engine in Perl   ULPFR   Wais                Rdcf? Interface to the freeWAIS-sf libraries        ULPFR   XBase               RdpO? Read/write interface to XBase files           JANPAZ   Xbase               bdpf? Read Xbase files with simple IDX indexes      PRATP   MySQL::  ::TableInfo         RdpOp Access to MySQL table's meta data             SHERZODR   Tied Hash File Interfaces:   AnyDBM_File         Sup ? Uses first available *_File module above      P5P   BerkeleyDB          RdcO? Interface to Berkeley DB version 2, 3 or 4    PMQS   CDB_File            adc ? Tie to CDB (Bernstein's constant DB) files    TIMPX   DBZ_File            adc ? Tie to dbz files (mainly for news history)    IANPX   DWH_File            adpO? DBM storage of complex data and objects       SUMUS   DB_File             Suc ? Tie to DB files                               PMQS   GDBM_File           Suc ? Tie to GDBM files                             P5P   NDBM_File           Suc ? Tie to NDBM files                             P5P   ODBM_File           Suc ? Tie to ODBM files                             P5P   SDBM_File           Suc ? Tie to SDBM files                             P5P   CDB_File::  ::BiIndex           aupOl Two directional index based on CDB File       MIKEDLR   ::Generator         iupOg CDB_File::Generator                           MIKEDLR   CDB_File::BiIndex::  ::Generator         aupOl Creates for CDB_File::BiIndexes               MIKEDLR   DB_File::  ::Lock              RdpO? DB_File wrapper with flock-based locking      DHARRIS   ::DB_Database       RdpOn DB_File to MultiField Table with Index        RANN   MLDBM               RdpO? Transparently store multi-level data in DBM   GSAR  MLDBM::  ::Sync              Rdprp MLDBM wrapper to serialize concurrent access  CHAMAS   DBM::  ::DBass             adpf? DBM with hashes, locking and XML records      SPIDERBOY   AsciiDB::  ::TagFile           RdpOp Tie class for a simple ASCII database         JOSERODR  ::Parse            i   ? Generic text database parsing                 MICB   Db::  ::Ctree             Rdcrp Faircom's CTREE+ database interface           REDEN  ::dmObject         cdpO? Object-based interface to Documentum EDMS     JGARRISON   DbFramework::  ::Attribute         adpO? Relational attribute class                    PSHARPE   ::DataModel         adpO? Relational data model/schema class            PSHARPE   ::DataType          adpO? Attribute data type class                     PSHARPE   ::ForeignKey        adpO? Relational foreign key class                  PSHARPE   ::Key               adpO? Relational key class                          PSHARPE   ::Persistent        adpO? Persistent object class                       PSHARPE   ::PrimaryKey        adpO? Relational primary key class                  PSHARPE   ::Table             adpO? Relational table/entity class                 PSHARPE   ::Util              adhO? Utility functions/methods                     PSHARPE   BTRIEVE::  ::SAVE              bdpO? Read-write access to BTRIEVE SAVE files       DLANE   MARC                bmpO? MAchine Readable Catalog (library bib. data)  PERL4LIB  MARC::  ::XML               ampO? MAchine Readable Catalog / XML Extension      PERL4LIB   ::Record            RmpOp MARC manipulation (library bibliographic)     PETDANCE   Metadata::  ::Base              bdpO? Base metadata functionality                   DJBECKETT   ::IAFA              bdpO? IAFA templates metadata                       DJBECKETT   ::SOIF              bdpO? Harvest SOIF metadata                         DJBECKETT   OLE::  ::PropertySet       aupO? Property Set interface                        MSCHWARTZ   ::Storage           aupO? Structured Storage / OLE document interface   MSCHWARTZ   ::Storage_Lite      adpO? Simple Class for OLE document interface       KWITKNR   Spectrum::  ::CLI               RdpO? API for Spectrum Enterprise Mgr. CLI          PLONKA   Spreadsheet::  ::WriteExcel        RupO? Write cross-platform Excel binary file.       JMCNAMARA   ::ParseExcel        RdpO? Get information from Excel file               KWITKNR  ::Excel            i   ? Interface to Excel spreadsheets               RRAWLINGS  ::Lotus            i   ? Interface to Lotus 1-2-3 spreadsheets         RRAWLINGS   Alzabo              RdpOp A data modelling tool and RDBMS-OO mapper     DROLSKY   Gemstone           RdpO? Interface to a GemStone object database       YOUD   FameHLI            bdcfg Ports Fame's C-API to Perl                    DAVEO   Splash:: ::DB               ????? ?                                             BEN   PApp::  ::SQL               Mdchp easy yet fast and powerful dbi sql wrapper    MLEHMANN   CDDB                RdpOp high-level interface to cddb/freedb protocol  RCAPUTO   Palm::  ::ThinkDB           cdpOa Manipulate ThinkDB TinyBytes for PalmOS       EARNESON   Relations           adphp Database, CGI, and Graph Interfunctionality   GAFFER   Stanza             i   ? Text format database used by OSF and IBM      JHI       8) User Interfaces (Character and Graphical)   Name                DSLIP  Description                                  Info ------------       ----- -------------------------------------------- ---- Term::  ::ANSIColor         Sdpfp Color output using ANSI escape sequences      RRA   ::ANSIScreen        bdpf? Terminal control using ANSI escape sequences  AUTRIJUS   ::Cap               Supf? Basic termcap: Tgetent, Tputs, Tgoto          TSANDERS   ::Complete          Supf? Tab word completion using stty raw            WTOMPSON  ::Control          idpf? Basic curses-type screen controls (gotxy)     KJALB   ::Gnuplot           adcf? Draw vector graphics on terminals etc         ILYAZ   ::Info              adpf? Terminfo interface (currently just Tput)      KJALB   ::ProgressBar       RdpOp Progress bar in just ASCII / using Term       FLUFFY   ::Prompt            adpf? Prompt a user                                 ALLENS   ::Query             Rdpf? Intelligent user prompt/response driver       AKSTE   ::ReadKey           Rdcf? Read keystrokes and change terminal modes     KJALB   ::ReadLine          Sdcf? Common interface for various implementations  ILYAZ   ::Screen            RdpOp Basic screen + input class (uses Term::Cap)   JSTOWE   ::Size              adcf? Simple way to get terminal size               TIMPX   ::TUI               bdpfp User interface based on Term::ReadLine        SBECK   ::VT102             bdpOa Emulates a colour VT102 terminal in memory    AJWOOD   ::Interact          bdpOp Get Data Interactively From User              PRL   Term::ReadLine::  ::Perl              RdpO? GNU Readline history and completion in Perl   ILYAZ   ::Gnu               RdcOp GNU Readline XS library wrapper               HAYASHI   Major Character User Interface Modules:   Cdk                 RdcO? Collection of Curses widgets                  GLOVER   Curses              Rdcfp Character screen handling and windowing       WPS   Dialog              bdch? interface library to libdialog                UNCLE   PV                  bdpOp Text-mode user interface widgets              AGUL  PerlMenu           Mdpf? Curses-based menu and template system         SKUNZ   Curses::  ::Forms             adpO? Form management for Curses::Widgets           CORLISS   ::Widgets           RmpOg Assorted widgets for rapid interface design   CORLISS   Emacs               adpf? Support for Perl embedded in GNU Emacs        JTOBEY  Emacs::  ::Lisp              bdch? Perl-to-Emacs-Lisp glue                       JTOBEY   Tk X Windows User Interface Modules   Tk                  bmcO? Object oriented version of Tk v4              TKML   Tk::  ::TextANSIColor     bdpOp use ANSI color codes in Text widget           TJENNESS   ::Autoscroll        adpfp Alternative way to scroll                     SREZIC   ::Axis              RmpO? Canvas with Axes                              TKML   ::CheckBox          RdpO? A radio button widget that uses a checkmark   DKWILSON   ::ChildNotification  RdpO? Alert widget when child is created           DKWILSON   ::Clock             RdpO? Canvas based Clock widget                     HMBRAND   ::Cloth             RdpO? Object interface to Tk::Canvas and items      ACH   ::Columns           RdpO? Multi column lists w/ resizable borders       DKWILSON   ::ComboEntry        RdpO? Drop down list + entry widget                 DKWILSON   ::ContextHelp       adpOp A context-sensitive help system               SREZIC   ::Dial              RmpO? An alternative to the Scale widget            TKML   ::Date              bdpOp A date/time widget                            SREZIC   ::Enscript          cdpfp Create postscript from text files using Tk    SREZIC   ::FcyEntry          adpO? Entry with bg color depending on -state       ACH   ::FileDialog        RdpO? A highly configurable file selection widget   BPOWERS   ::FileEntry         adpO? Primitive clone of Tix FileEntry widget       ACH   ::FireButton        RdpO? Keeps invoking callback when pressed          ACH  ::FlatCheckbox     adpOp A checkbox suitable for flat reliefs          SREZIC   ::FontDialog        bdpOp A font dialog widget for perl/Tk              SREZIC   ::Getopt            adpOp Configuration interface to Getopt::Long       SREZIC   ::HistEntry         adpOp An entry widget with history capability       SREZIC   ::HTML              bdpO? View HTML in a Tk Text widget                 NI-S   ::IconCanvas        RdpO? Canvas with movable iconic interface          DKWILSON   ::JPEG              RdcO? JPEG loader for Tk::Photo                     NI-S   ::LockDisplay       RdpO? Screen saver/lock widget with animation       LUSOL  ::Login            cdpO? A Login widget (name, passwd, et al)          BPOWERS   ::Menustrip         RdpO? Another MenuBar                               DKWILSON   ::More              adpO? A more (or less) like text widget             ACH  ::Multi            bdpO? Manages several Text or Canvas widgets        DDUMONT   ::NumEntry          RdpO? Numerical entry widget with up/down buttons   ACH   ::ObjScanner        RdpO? Tk data or object scanner                     DDUMONT  ::Olwm             RmpO? Interface to OpenLook toplevels properties    TKML   ::Pane              RdpO? A Frame that can be scrolled                  TKML   ::PNG               RdcO? PNG loader for Tk::Photo                      NI-S   ::Pod               ?mpO? POD browser toplevel widget                   TKML   ::ProgressBar       RdpO? Status/progress bar                           TKML  ::ProgressMeter    cdpO? Simple thermometer-style widget w/callbacks   BPOWERS   ::RotCanvas         RdpO? Canvas with arbitrary rotation support        AQUMSIEH   ::SplitFrame        RdpO? A sliding separator for two child widgets     DKWILSON   ::TabFrame          RdpO? A tabbed frame geometry manager               DKWILSON   ::TabbedForm        RdpO? Ext. TabFrame, allowing managed subwidgets    DKWILSON   ::TableEdit         RdpO? Simplified interface to a flat file database  DKWILSON   ::TableMatrix       bdcO? Display data in Table/Spreadsheet format      CERNEY   ::TiedListbox       RmpO? Gang together Listboxes                       TKML   ::TFrame            RdpO? A Frame with a title                          ACH   ::TIFF              adpOp TIFF loader for Tk::Photo                     SREZIC   ::Tree              RdpO? Create and manipulate Tree widgets            CTDEAN   ::TreeGraph         RdpO? Widget to draw a tree in a Canvas             DDUMONT   ::WaitBox           RdpO? A Wait dialog, of the ""Please Wait"" variety   BPOWERS   ::XMLViewer         adpOp Tk widget to display XML                      SREZIC   ::ObjEditor         bdpO? Tk widget to edit data or objects             DDUMONT   ::ObjEditorDialog   bdpO? Tk popup dialog to edit data or objects       DDUMONT   ::Pgplot            bdcfp Pgplot widget for Tk                          CPHIL   ::PathEntry         adpOp Entry for selecting paths with completion     SREZIC   ::JComboBox         bdpOp another combo box (similar to the java comp)  RCS   ::Workspace         RdpO? Persistent Text/Shell/Command Widgets         RKIES   ::DateEntry         RdpO? Drop down calendar for selecting dates        SREZIC   ::MListbox          RdpO? Multicolumn Listbox.                          RCS   Modules in the realm of Tk but with a separate namespace   Log::Dispatch::  ::ToTk              RdpOp Interface class between Log::Dispatch and Tk  DDUMONT   ::TkText            RdpOp Text widget to log Log::Dispatch messages     DDUMONT   Puppet::  ::Body              adpO? Base class for persistent data                DDUMONT   ::Log               bdpO? Logging facility based on Tk                  DDUMONT   ::Any               adpO? Base class for an optionnal GUI               DDUMONT   Puppet::VcsTools::  ::History           bdpO? VCS (RCS HMS) history viewer based on Canvas  DDUMONT   ::File              adpO? VCS (RCS HMS) file manager                    DDUMONT   Orac               RdpO? DBA GUI tool for Oracle, Informix and Sybase  ANDYDUNC   PPresenter          MdpOp Create presentations with Tk in Perl or XML   MARKOV   Other Major X Windows User Interface Modules:   Gtk                 bdcO? binding of the Gtk library used by GIMP       KJALB   Gtk:: ::Dialog           adph? Simple interface to create dialogs in Gtk     ALISTAIRC   Fresco             cd+O? Interface to Fresco (post X11R6 version)      BPETH  Glade              bdphp Glade/Gtk+/Gnome UI source code generator     DMUSGR   Gnome               bdcO? Bindings to the Gnome Desktop Toolkit         KJALB   Qt                  ad+O? Interface to the Qt toolkit                   AWIN   Sx                  Rdcf? Simple Athena widget interface                FMC   X11::  ::Auth              adpO? Read and handle X11 '.Xauthority' files       SMCCAM   ::Fvwm              RdcO? interface to the FVWM window manager API      RJRAY   ::Keysyms           adpf? X11 key symbols (translation of keysymdef.h)  SMCCAM   ::Lib               bdcO? X11 library interface                         KENFOX   ::Motif             bdcO? Motif widget set interface                    KENFOX   ::Protocol          adpO? Raw interface to X Window System servers      SMCCAM   ::Toolkit           bdcO? X11 Toolkit library interface                 KENFOX   ::Wcl               bdcO? Interface to the Widget Creation Library      JHPB   ::XEvent            bdcO? provides perl OO acess to XEvent structures   MARTINB   ::XFontStruct       bdcO? provides perl OO access to XFontStruct        MARTINB  ::XRT              adcO? XRT widget set (commercial) interface         KENFOX   ::Xbae              adcO? Xbae matrix (spreadsheet like) interface      KENFOX  ::Xforms           bdcO? provides the binding to the xforms library    MARTINB   ::Xpm               adcf? X Pixmap library interface                    KENFOX   Abstract Graphical User Interfaces modules   GUI:: ::Guido            i   ? bd+O Communicate with objects in a GUI        TBRADFUTE   Cmenu               bdpfg Curses-based menu and data entry functions    DREWF   Prima               Rmchb A perl GUI toolkit                            KARASIK       9) Interfaces to or Emulations of Other Programming Languages   Name                DSLIP  Description                                  Info ------------       ----- -------------------------------------------- ---- Clips              adpO? Interface to the Expert System Clips          MSULLIVAN   Java                RdhOl A Perl front-end for JVM communication        METZZO   Rc                  cdcO? Perl interface for the Rc shell               JPRIT  SICStus            adcO? Interface to SICStus Prolog Runtime           CBAIL   Java::JVM::  ::Classfile         RdpO? Parse JVM Classfiles                          LBROCARD   Language::  ::Basic             adpO? Implementation of BASIC                       AKARGER  ::ML               cdpf? Implementation of ML                          DSPARLING  ::PGForth          i   ? Peter Gallasch's Forth implementation         PETERGAL   ::Prolog            anpO? An implementation of Prolog                   JACKS  ::Style            cdcOa Interpreter/Compiler for the Style Language   EKMETT  ::VBParser         adp?g Visual Basic 6 source parser                  FRETT   Language::DATR::  ::DATR2XML          RdpOp Convert DATR to XML and back, wth XSLT & DTD  LGODDARD   Blatte              bdph? Utilities for Blatte language interpreters    BOBG  Blatte::  ::Builtins          bdph? Blatte language standard intrinsics           BOBG   ::Compiler          bdph? Convenient interface for compiling Blatte     BOBG   ::Parser            bdph? Blatte language parser                        BOBG   ::Syntax            bdph? Internal Blatte parse-tree objects            BOBG   ::Ws                bdph? Internal Blatte whitespace handler            BOBG   ::HTML              bdph? Intrinsics for writing HTML in Blatte         BOBG   C::  ::DynaLib           bdcO? Allows direct calls to dynamic libraries      JTOBEY   ::Scan              RdpO? Heuristic parse of C files"
GX059-29-12418706	"NCBI Home       IEB Home       C++ Toolkit docs       C Toolkit source browser       C Toolkit source browser (2)               NCBI C++ Toolkit Cross Reference       C++ / compilers / mac_prj / db.h                  source navigation    diff markup    identifier search    freetext search    file search                   1   /*     2    * See the file LICENSE for redistribution information.     3    *     4    * Copyright (c) 1996-2002     5    *      Sleepycat Software.  All rights reserved.     6    *     7    * $Id: db.h,v 1.1 2003/07/07 18:17:02 rsmith Exp $     8    *     9    * db.h include file layout:    10    *      General.    11    *      Database Environment.    12    *      Locking subsystem.    13    *      Logging subsystem.    14    *      Shared buffer cache (mpool) subsystem.    15    *      Transaction subsystem.    16    *      Access methods.    17    *      Access method cursors.    18    *      Dbm/Ndbm, Hsearch historic interfaces.    19    */    20     21  #ifndef  _DB_H_    22  #define  _DB_H_    23     24  #ifndef __NO_SYSTEM_INCLUDES   25  #include <sys/types.h>   26     27  #include <stdio.h>   28  #endif   29     30  #if defined(__cplusplus)   31  extern  ""C""  {   32  #endif   33     34   /*    35    * XXX    36    * Handle function prototypes and the keyword ""const"".  This steps on name    37    * space that DB doesn't control, but all of the other solutions are worse.    38    *    39    * XXX    40    * While Microsoft's compiler is ANSI C compliant, it doesn't have _STDC_    41    * defined by default, you specify a command line flag or #pragma to turn    42    * it on.  Don't do that, however, because some of Microsoft's own header    43    * files won't compile.    44    */    45  #undef   __P    46  #if defined(__STDC__) || defined(__cplusplus) || defined(_MSC_VER)   47  #define  __P (protos)     protos           /* ANSI C prototypes */    48  #else   49  #define const   50  #define  __P (protos)     ()               /* K&R C preprocessor */    51  #endif   52     53   /*    54    * Berkeley DB version information.    55    */    56  #define  DB_VERSION_MAJOR         4   57  #define  DB_VERSION_MINOR         1   58  #define  DB_VERSION_PATCH         25   59  #define  DB_VERSION_STRING         ""Sleepycat Software: Berkeley DB 4.1.25: (December 19, 2002)""    60     61   /*    62    * !!!    63    * Berkeley DB uses specifically sized types.  If they're not provided by    64    * the system, typedef them here.    65    *    66    * We protect them against multiple inclusion using __BIT_TYPES_DEFINED__,    67    * as does BIND and Kerberos, since we don't know for sure what #include    68    * files the user is using.    69    *    70    * !!!    71    * We also provide the standard u_int, u_long etc., if they're not provided    72    * by the system.    73    */    74  #ifndef  __BIT_TYPES_DEFINED__    75  #define  __BIT_TYPES_DEFINED__    76     77     78     79     80     81  #endif   82     83     84     85     86     87     88     89   /* Basic types that are exported or quasi-exported. */    90  typedef u_int32_t        db_pgno_t ;       /* Page number type. */    91  typedef u_int16_t        db_indx_t ;       /* Page offset type. */    92  #define  DB_MAX_PAGES     0xffffffff       /* >= # of pages in a file */    93     94  typedef u_int32_t        db_recno_t ;      /* Record number type. */    95  #define  DB_MAX_RECORDS   0xffffffff       /* >= # of records in a tree */    96     97  typedef u_int32_t        db_timeout_t ;    /* Type of a timeout. */    98     99   /*   100    * Region offsets are currently limited to 32-bits.  I expect that's going   101    * to have to be fixed in the not-too-distant future, since we won't want to   102    * split 100Gb memory pools into that many different regions.   103    */   104  typedef u_int32_t  roff_t ;  105    106   /*   107    * Forward structure declarations, so we can declare pointers and   108    * applications can get type checking.   109    */   110  struct  __db ;            typedef struct  __db   DB ;  111  struct  __db_bt_stat ;    typedef struct  __db_bt_stat   DB_BTREE_STAT ;  112  struct  __db_cipher ;     typedef struct  __db_cipher   DB_CIPHER ;  113  struct  __db_dbt ;        typedef struct  __db_dbt   DBT ;  114  struct  __db_env ;        typedef struct  __db_env   DB_ENV ;  115  struct  __db_h_stat ;     typedef struct  __db_h_stat   DB_HASH_STAT ;  116  struct  __db_ilock ;      typedef struct  __db_ilock   DB_LOCK_ILOCK ;  117  struct  __db_lock_stat ;  typedef struct  __db_lock_stat   DB_LOCK_STAT ;  118  struct  __db_lock_u ;     typedef struct  __db_lock_u   DB_LOCK ;  119  struct  __db_lockreq ;    typedef struct  __db_lockreq   DB_LOCKREQ ;  120  struct  __db_log_cursor ; typedef struct  __db_log_cursor   DB_LOGC ;  121  struct  __db_log_stat ;   typedef struct  __db_log_stat   DB_LOG_STAT ;  122  struct  __db_lsn ;        typedef struct  __db_lsn   DB_LSN ;  123  struct  __db_mpool ;      typedef struct  __db_mpool   DB_MPOOL ;  124  struct  __db_mpool_fstat ;typedef struct  __db_mpool_fstat   DB_MPOOL_FSTAT ;  125  struct  __db_mpool_stat ; typedef struct  __db_mpool_stat   DB_MPOOL_STAT ;  126  struct  __db_mpoolfile ;  typedef struct  __db_mpoolfile   DB_MPOOLFILE ;  127  struct  __db_preplist ;   typedef struct  __db_preplist   DB_PREPLIST ;  128  struct  __db_qam_stat ;   typedef struct  __db_qam_stat   DB_QUEUE_STAT ;  129  struct  __db_rep ;        typedef struct  __db_rep   DB_REP ;  130  struct  __db_rep_stat ;   typedef struct  __db_rep_stat   DB_REP_STAT ;  131  struct  __db_txn ;        typedef struct  __db_txn   DB_TXN ;  132  struct  __db_txn_active ; typedef struct  __db_txn_active   DB_TXN_ACTIVE ;  133  struct  __db_txn_stat ;   typedef struct  __db_txn_stat   DB_TXN_STAT ;  134  struct  __db_txnmgr ;     typedef struct  __db_txnmgr   DB_TXNMGR ;  135  struct  __dbc ;           typedef struct  __dbc   DBC ;  136  struct  __dbc_internal ;  typedef struct  __dbc_internal   DBC_INTERNAL ;  137  struct  __fh_t ;          typedef struct  __fh_t   DB_FH ;  138  struct  __fname ;         typedef struct  __fname   FNAME ;  139  struct  __key_range ;     typedef struct  __key_range   DB_KEY_RANGE ;  140  struct  __mpoolfile ;     typedef struct  __mpoolfile   MPOOLFILE ;  141  struct  __mutex_t ;       typedef struct  __mutex_t   DB_MUTEX ;  142    143   /* Key/data structure -- a Data-Base Thang. */   144  struct  __db_dbt  {  145           /*   146            * data/size must be fields 1 and 2 for DB 1.85 compatibility.   147            */   148          void     *data;                  /* Key/data */   149          u_int32_t  size ;                  /* key/data length */   150    151          u_int32_t ulen;                  /* RO: length of user buffer. */   152          u_int32_t dlen;                  /* RO: get/put record length. */   153          u_int32_t doff;                  /* RO: get/put record offset. */   154    155  #define  DB_DBT_APPMALLOC         0x001    /* Callback allocated memory. */   156  #define  DB_DBT_ISSET             0x002    /* Lower level calls set value. */   157  #define  DB_DBT_MALLOC            0x004    /* Return in malloc'd memory. */   158  #define  DB_DBT_PARTIAL           0x008    /* Partial put/get. */   159  #define  DB_DBT_REALLOC           0x010    /* Return in realloc'd memory. */   160  #define  DB_DBT_USERMEM           0x020    /* Return in user's memory. */   161  #define  DB_DBT_DUPOK             0x040    /* Insert if duplicate. */   162          u_int32_t flags;  163  };  164    165   /*   166    * Common flags --   167    *      Interfaces which use any of these common flags should never have   168    *      interface specific flags in this range.   169    */   170  #define  DB_CREATE              0x000001   /* Create file as necessary. */   171  #define  DB_CXX_NO_EXCEPTIONS   0x000002   /* C++: return error values. */   172  #define  DB_FORCE               0x000004   /* Force (anything). */   173  #define  DB_NOMMAP              0x000008   /* Don't mmap underlying file. */   174  #define  DB_RDONLY              0x000010   /* Read-only (O_RDONLY). */   175  #define  DB_RECOVER             0x000020   /* Run normal recovery. */   176  #define  DB_THREAD              0x000040   /* Applications are threaded. */   177  #define  DB_TRUNCATE            0x000080   /* Discard existing DB (O_TRUNC). */   178  #define  DB_TXN_NOSYNC          0x000100   /* Do not sync log on commit. */   179  #define  DB_USE_ENVIRON         0x000200   /* Use the environment. */   180  #define  DB_USE_ENVIRON_ROOT    0x000400   /* Use the environment if root. */   181    182   /*   183    * Common flags --   184    *      Interfaces which use any of these common flags should never have   185    *      interface specific flags in this range.   186    *   187    * DB_AUTO_COMMIT:   188    *      DB_ENV->set_flags, DB->associate, DB->del, DB->put, DB->open,   189    *      DB->remove, DB->rename, DB->truncate   190    * DB_DIRTY_READ:   191    *      DB->cursor, DB->get, DB->join, DB->open, DBcursor->c_get,   192    *      DB_ENV->txn_begin   193    *   194    *         Shared flags up to 0x000400 */   195  #define  DB_AUTO_COMMIT       0x00800000   /* Implied transaction. */   196  #define  DB_DIRTY_READ        0x01000000   /* Dirty Read. */   197    198   /*   199    * Flags private to db_env_create.   200    */   201  #define  DB_CLIENT              0x000001   /* Open for a client environment. */   202    203   /*   204    * Flags private to db_create.   205    */   206  #define  DB_XA_CREATE           0x000001   /* Open in an XA environment. */   207    208   /*   209    * Flags private to DB_ENV->open.   210    *         Shared flags up to 0x000400 */   211  #define  DB_INIT_CDB            0x000800   /* Concurrent Access Methods. */   212  #define  DB_INIT_LOCK           0x001000   /* Initialize locking. */   213  #define  DB_INIT_LOG            0x002000   /* Initialize logging. */   214  #define  DB_INIT_MPOOL          0x004000   /* Initialize mpool. */   215  #define  DB_INIT_TXN            0x008000   /* Initialize transactions. */   216  #define  DB_JOINENV             0x010000   /* Initialize all subsystems present. */   217  #define  DB_LOCKDOWN            0x020000   /* Lock memory into physical core. */   218  #define  DB_PRIVATE             0x040000   /* DB_ENV is process local. */   219  #define  DB_RECOVER_FATAL       0x080000   /* Run catastrophic recovery. */   220  #define  DB_SYSTEM_MEM          0x100000   /* Use system-backed memory. */   221    222   /*   223    * Flags private to DB->open.   224    *         Shared flags up to 0x000400 */   225  #define  DB_EXCL                0x000800   /* Exclusive open (O_EXCL). */   226  #define  DB_FCNTL_LOCKING       0x001000   /* UNDOC: fcntl(2) locking. */   227  #define  DB_RDWRMASTER          0x002000   /* UNDOC: allow subdb master open R/W */   228  #define  DB_WRITEOPEN           0x004000   /* UNDOC: open with write lock. */   229    230   /*   231    * Flags private to DB_ENV->txn_begin.   232    *         Shared flags up to 0x000400 */   233  #define  DB_TXN_NOWAIT          0x000800   /* Do not wait for locks in this TXN. */   234  #define  DB_TXN_SYNC            0x001000   /* Always sync log on commit. */   235    236   /*   237    * Flags private to DB_ENV->set_encrypt.   238    */   239  #define  DB_ENCRYPT_AES         0x000001   /* AES, assumes SHA1 checksum */   240    241   /*   242    * Flags private to DB_ENV->set_flags.   243    *         Shared flags up to 0x000400 */   244  #define  DB_CDB_ALLDB           0x000800   /* Set CDB locking per environment. */   245  #define  DB_DIRECT_DB           0x001000   /* Don't buffer databases in the OS. */   246  #define  DB_DIRECT_LOG          0x002000   /* Don't buffer log files in the OS. */   247  #define  DB_NOLOCKING           0x004000   /* Set locking/mutex behavior. */   248  #define  DB_NOPANIC             0x008000   /* Set panic state per DB_ENV. */   249  #define  DB_OVERWRITE           0x010000   /* Overwrite unlinked region files. */   250  #define  DB_PANIC_ENVIRONMENT   0x020000   /* Set panic state per environment. */   251  #define  DB_REGION_INIT         0x040000   /* Page-fault regions on open. */   252  #define  DB_TXN_WRITE_NOSYNC    0x080000   /* Write, don't sync, on txn commit. */   253  #define  DB_YIELDCPU            0x100000   /* Yield the CPU (a lot). */   254    255   /*   256    * Flags private to DB->set_feedback's callback.   257    */   258  #define  DB_UPGRADE             0x000001   /* Upgrading. */   259  #define  DB_VERIFY              0x000002   /* Verifying. */   260    261   /*   262    * Flags private to DB_MPOOLFILE->open.   263    *         Shared flags up to 0x000400 */   264  #define  DB_DIRECT              0x000800   /* Don't buffer the file in the OS. */   265  #define  DB_EXTENT              0x001000   /* UNDOC: dealing with an extent. */   266  #define  DB_ODDFILESIZE         0x002000   /* Truncate file to N * pgsize. */   267    268   /*   269    * Flags private to DB->set_flags.   270    */   271  #define  DB_CHKSUM_SHA1         0x000001   /* Use SHA1 checksumming */   272  #define  DB_DUP                 0x000002   /* Btree, Hash: duplicate keys. */   273  #define  DB_DUPSORT             0x000004   /* Btree, Hash: duplicate keys. */   274  #define  DB_ENCRYPT             0x000008   /* Btree, Hash: duplicate keys. */   275  #define  DB_RECNUM              0x000010   /* Btree: record numbers. */   276  #define  DB_RENUMBER            0x000020   /* Recno: renumber on insert/delete. */   277  #define  DB_REVSPLITOFF         0x000040   /* Btree: turn off reverse splits. */   278  #define  DB_SNAPSHOT            0x000080   /* Recno: snapshot the input. */   279    280   /*   281    * Flags private to the DB->stat methods.   282    */   283  #define  DB_STAT_CLEAR          0x000001   /* Clear stat after returning values. */   284    285   /*   286    * Flags private to DB->join.   287    */   288  #define  DB_JOIN_NOSORT         0x000001   /* Don't try to optimize join. */   289    290   /*   291    * Flags private to DB->verify.   292    */   293  #define  DB_AGGRESSIVE          0x000001   /* Salvage whatever could be data.*/   294  #define  DB_NOORDERCHK          0x000002   /* Skip sort order/hashing check. */   295  #define  DB_ORDERCHKONLY        0x000004   /* Only perform the order check. */   296  #define  DB_PR_PAGE             0x000008   /* Show page contents (-da). */   297  #define  DB_PR_RECOVERYTEST     0x000010   /* Recovery test (-dr). */   298  #define  DB_PRINTABLE           0x000020   /* Use printable format for salvage. */   299  #define  DB_SALVAGE             0x000040   /* Salvage what looks like data. */   300   /*   301    * !!!   302    * These must not go over 0x8000, or they will collide with the flags   303    * used by __bam_vrfy_subtree.   304    */   305    306   /*   307    * Flags private to DB->set_rep_transport's send callback.   308    */   309  #define  DB_REP_PERMANENT         0x0001   /* Important--app. may want to flush. */   310    311   /*******************************************************   312    * Locking.   313    *******************************************************/   314  #define  DB_LOCKVERSION   1  315    316  #define  DB_FILE_ID_LEN           20       /* Unique file ID length. */   317    318   /*   319    * Deadlock detector modes; used in the DB_ENV structure to configure the   320    * locking subsystem.   321    */   322  #define  DB_LOCK_NORUN            0  323  #define  DB_LOCK_DEFAULT          1        /* Default policy. */   324  #define  DB_LOCK_EXPIRE           2        /* Only expire locks, no detection. */   325  #define  DB_LOCK_MAXLOCKS         3        /* Abort txn with maximum # of locks. */   326  #define  DB_LOCK_MINLOCKS         4        /* Abort txn with minimum # of locks. */   327  #define  DB_LOCK_MINWRITE         5        /* Abort txn with minimum writelocks. */   328  #define  DB_LOCK_OLDEST           6        /* Abort oldest transaction. */   329  #define  DB_LOCK_RANDOM           7        /* Abort random transaction. */   330  #define  DB_LOCK_YOUNGEST         8        /* Abort youngest transaction. */   331    332   /* Flag values for lock_vec(), lock_get(). */   333  #define  DB_LOCK_FREE_LOCKER      0x001    /* Internal: Free locker as well. */   334  #define  DB_LOCK_NOWAIT           0x002    /* Don't wait on unavailable lock. */   335  #define  DB_LOCK_RECORD           0x004    /* Internal: record lock. */   336  #define  DB_LOCK_REMOVE           0x008    /* Internal: flag object removed. */   337  #define  DB_LOCK_SET_TIMEOUT      0x010    /* Internal: set lock timeout. */   338  #define  DB_LOCK_SWITCH           0x020    /* Internal: switch existing lock. */   339  #define  DB_LOCK_UPGRADE          0x040    /* Internal: upgrade existing lock. */   340    341   /*   342    * Simple R/W lock modes and for multi-granularity intention locking.   343    *   344    * !!!   345    * These values are NOT random, as they are used as an index into the lock   346    * conflicts arrays, i.e., DB_LOCK_IWRITE must be == 3, and DB_LOCK_IREAD   347    * must be == 4.   348    */   349  typedef enum {  350          DB_LOCK_NG=0,                    /* Not granted. */   351          DB_LOCK_READ=1,                  /* Shared/read. */   352          DB_LOCK_WRITE=2,                 /* Exclusive/write. */   353          DB_LOCK_WAIT=3,                  /* Wait for event */   354          DB_LOCK_IWRITE=4,                /* Intent exclusive/write. */   355          DB_LOCK_IREAD=5,                 /* Intent to share/read. */   356          DB_LOCK_IWR=6,                   /* Intent to read and write. */   357          DB_LOCK_DIRTY=7,                 /* Dirty Read. */   358          DB_LOCK_WWRITE=8                 /* Was Written. */   359  }  db_lockmode_t ;  360    361   /*   362    * Request types.   363    */   364  typedef enum {  365          DB_LOCK_DUMP=0,                  /* Display held locks. */   366          DB_LOCK_GET=1,                   /* Get the lock. */   367          DB_LOCK_GET_TIMEOUT=2,           /* Get lock with a timeout. */   368          DB_LOCK_INHERIT=3,               /* Pass locks to parent. */   369          DB_LOCK_PUT=4,                   /* Release the lock. */   370          DB_LOCK_PUT_ALL=5,               /* Release locker's locks. */   371          DB_LOCK_PUT_OBJ=6,               /* Release locker's locks on obj. */   372          DB_LOCK_PUT_READ=7,              /* Release locker's read locks. */   373          DB_LOCK_TIMEOUT=8,               /* Force a txn to timeout. */   374          DB_LOCK_TRADE=9,                 /* Trade locker ids on a lock. */   375          DB_LOCK_UPGRADE_WRITE=10         /* Upgrade writes for dirty reads. */   376  }  db_lockop_t ;  377    378   /*   379    * Status of a lock.   380    */   381  typedef enum  {  382          DB_LSTAT_ABORTED=1,              /* Lock belongs to an aborted txn. */   383          DB_LSTAT_ERR=2,                  /* Lock is bad. */   384          DB_LSTAT_EXPIRED=3,              /* Lock has expired. */   385          DB_LSTAT_FREE=4,                 /* Lock is unallocated. */   386          DB_LSTAT_HELD=5,                 /* Lock is currently held. */   387          DB_LSTAT_NOTEXIST=6,             /* Object on which lock was waiting   388                                            * was removed */   389          DB_LSTAT_PENDING=7,              /* Lock was waiting and has been   390                                            * promoted; waiting for the owner   391                                            * to run and upgrade it to held. */   392          DB_LSTAT_WAITING=8               /* Lock is on the wait queue. */   393  } db_status_t ;  394    395   /* Lock statistics structure. */   396  struct  __db_lock_stat  {  397          u_int32_t st_id;                 /* Last allocated locker ID. */   398          u_int32_t st_cur_maxid;          /* Current maximum unused ID. */   399          u_int32_t st_maxlocks;           /* Maximum number of locks in table. */   400          u_int32_t st_maxlockers;         /* Maximum num of lockers in table. */   401          u_int32_t st_maxobjects;         /* Maximum num of objects in table. */   402          u_int32_t st_nmodes;             /* Number of lock modes. */   403          u_int32_t st_nlocks;             /* Current number of locks. */   404          u_int32_t st_maxnlocks;          /* Maximum number of locks so far. */   405          u_int32_t st_nlockers;           /* Current number of lockers. */   406          u_int32_t st_maxnlockers;        /* Maximum number of lockers so far. */   407          u_int32_t st_nobjects;           /* Current number of objects. */   408          u_int32_t st_maxnobjects;        /* Maximum number of objects so far. */   409          u_int32_t st_nconflicts;         /* Number of lock conflicts. */   410          u_int32_t st_nrequests;          /* Number of lock gets. */   411          u_int32_t st_nreleases;          /* Number of lock puts. */   412          u_int32_t st_nnowaits;           /* Number of requests that would have   413                                              waited, but NOWAIT was set. */   414          u_int32_t st_ndeadlocks;         /* Number of lock deadlocks. */   415           db_timeout_t  st_locktimeout;     /* Lock timeout. */   416          u_int32_t st_nlocktimeouts;      /* Number of lock timeouts. */   417           db_timeout_t  st_txntimeout;      /* Transaction timeout. */   418          u_int32_t st_ntxntimeouts;       /* Number of transaction timeouts. */   419          u_int32_t st_region_wait;        /* Region lock granted after wait. */   420          u_int32_t st_region_nowait;      /* Region lock granted without wait. */   421          u_int32_t st_regsize;            /* Region size. */   422  };  423    424   /*   425    * DB_LOCK_ILOCK --   426    *      Internal DB access method lock.   427    */   428  struct  __db_ilock  {  429           db_pgno_t  pgno;                  /* Page being locked. */   430          u_int8_t fileid[ DB_FILE_ID_LEN ]; /* File id. */   431  #define  DB_HANDLE_LOCK   1  432  #define  DB_RECORD_LOCK   2  433  #define  DB_PAGE_LOCK     3  434  #define  DB_TXN_LOCK      4  435          u_int32_t  type ;                  /* Type of lock. */   436  };  437    438   /*   439    * DB_LOCK --   440    *      The structure is allocated by the caller and filled in during a   441    *      lock_get request (or a lock_vec/DB_LOCK_GET).   442    */   443  struct  __db_lock_u  {  444          size_t          off;             /* Offset of the lock in the region */   445          u_int32_t       ndx;             /* Index of the object referenced by   446                                            * this lock; used for locking. */   447          u_int32_t       gen;             /* Generation number of this lock. */   448           db_lockmode_t     mode ;            /* mode of this lock. */   449  };  450    451   /* Lock request structure. */   452  struct  __db_lockreq  {  453           db_lockop_t       op;             /* Operation. */   454           db_lockmode_t      mode ;           /* Requested mode. */   455           db_timeout_t      timeout;        /* Time to expire lock. */   456           DBT              *obj;            /* Object being locked. */   457           DB_LOCK           lock;           /* Lock returned. */   458  };  459    460   /*******************************************************   461    * Logging.   462    *******************************************************/   463  #define  DB_LOGVERSION    7                /* Current log version. */   464  #define  DB_LOGOLDVER     7                /* Oldest log version supported. */   465  #define  DB_LOGMAGIC      0x040988  466    467   /* Flag values for log_archive(). */   468  #define  DB_ARCH_ABS              0x001    /* Absolute pathnames. */   469  #define  DB_ARCH_DATA             0x002    /* Data files. */   470  #define  DB_ARCH_LOG              0x004    /* Log files. */   471    472   /*   473    * A DB_LSN has two parts, a fileid which identifies a specific file, and an   474    * offset within that file.  The fileid is an unsigned 4-byte quantity that   475    * uniquely identifies a file within the log directory -- currently a simple   476    * counter inside the log.  The offset is also an unsigned 4-byte value.  The   477    * log manager guarantees the offset is never more than 4 bytes by switching   478    * to a new log file before the maximum length imposed by an unsigned 4-byte   479    * offset is reached.   480    */   481  struct  __db_lsn  {  482          u_int32_t        file ;            /* File ID. */   483          u_int32_t        offset ;          /* File offset. */   484  };  485    486   /*   487    * DB_LOGC --   488    *      Log cursor.   489    */   490  struct  __db_log_cursor  {  491           DB_ENV    *dbenv;                 /* Enclosing dbenv. */   492    493           DB_FH     *c_fh;                  /* File handle. */   494           DB_LSN     c_lsn;                 /* Cursor: LSN */   495          u_int32_t c_len;                 /* Cursor: record length */   496          u_int32_t c_prev;                /* Cursor: previous record's offset */   497    498           DBT        c_dbt;                 /* Return DBT. */   499    500  #define  DB_LOGC_BUF_SIZE         (32 * 1024)  501          u_int8_t *bp;                    /* Allocated read buffer. */   502          u_int32_t bp_size;               /* Read buffer length in bytes. */   503          u_int32_t bp_rlen;               /* Read buffer valid data length. */   504           DB_LSN     bp_lsn;                /* Read buffer first byte LSN. */   505    506          u_int32_t bp_maxrec;             /* Max record length in the log file. */   507    508                                           /* Methods. */   509          int (* close )  __P (( DB_LOGC  *, u_int32_t));  510          int (*get)  __P (( DB_LOGC  *,  DB_LSN  *,  DBT  *, u_int32_t));  511    512  #define  DB_LOG_DISK              0x01     /* Log record came from disk. */   513  #define  DB_LOG_LOCKED            0x02     /* Log region already locked */   514  #define  DB_LOG_SILENT_ERR        0x04     /* Turn-off error messages. */   515          u_int32_t flags;  516  };  517    518   /* Log statistics structure. */   519  struct  __db_log_stat  {  520          u_int32_t st_magic;              /* Log file magic number. */   521          u_int32_t st_version;            /* Log file version number. */   522          int st_mode;                     /* Log file mode. */   523          u_int32_t st_lg_bsize;           /* Log buffer size. */   524          u_int32_t st_lg_size;            /* Log file size. */   525          u_int32_t st_w_bytes;            /* Bytes to log. */   526          u_int32_t st_w_mbytes;           /* Megabytes to log. */   527          u_int32_t st_wc_bytes;           /* Bytes to log since checkpoint. */   528          u_int32_t st_wc_mbytes;          /* Megabytes to log since checkpoint. */   529          u_int32_t st_wcount;             /* Total writes to the log. */   530          u_int32_t st_wcount_fill;        /* Overflow writes to the log. */   531          u_int32_t st_scount;             /* Total syncs to the log. */   532          u_int32_t st_region_wait;        /* Region lock granted after wait. */   533          u_int32_t st_region_nowait;      /* Region lock granted without wait. */   534          u_int32_t st_cur_file;           /* Current log file number. */   535          u_int32_t st_cur_offset;         /* Current log file offset. */   536          u_int32_t st_disk_file;          /* Known on disk log file number. */   537          u_int32_t st_disk_offset;        /* Known on disk log file offset. */   538          u_int32_t st_regsize;            /* Region size. */   539          u_int32_t st_maxcommitperflush;  /* Max number of commits in a flush. */   540          u_int32_t st_mincommitperflush;  /* Min number of commits in a flush. */   541  };  542    543   /*******************************************************   544    * Shared buffer cache (mpool).   545    *******************************************************/   546   /* Flag values for DB_MPOOLFILE->get. */   547  #define  DB_MPOOL_CREATE          0x001    /* Create a page. */   548  #define  DB_MPOOL_LAST            0x002    /* Return the last page. */   549  #define  DB_MPOOL_NEW             0x004    /* Create a new page. */   550    551   /* Flag values for DB_MPOOLFILE->put, DB_MPOOLFILE->set. */   552  #define  DB_MPOOL_CLEAN           0x001    /* Page is not modified. */   553  #define  DB_MPOOL_DIRTY           0x002    /* Page is modified. */   554  #define  DB_MPOOL_DISCARD         0x004    /* Don't cache the page. */   555    556   /* Priority values for DB_MPOOLFILE->set_priority. */   557  typedef enum {  558          DB_PRIORITY_VERY_LOW=1,  559          DB_PRIORITY_LOW=2,  560          DB_PRIORITY_DEFAULT=3,  561          DB_PRIORITY_HIGH=4,  562          DB_PRIORITY_VERY_HIGH=5  563  }  DB_CACHE_PRIORITY ;  564    565   /* Per-process DB_MPOOLFILE information. */   566  struct  __db_mpoolfile  {  567           /* These fields need to be protected for multi-threaded support. */   568           DB_MUTEX  *mutexp;                /* Structure thread lock. */   569    570           DB_FH      *fhp;                  /* Underlying file handle. */   571    572          u_int32_t  ref;                  /* Reference count. */   573    574           /*   575            * !!!   576            * The pinref and q fields are protected by the region lock, not the   577            * DB_MPOOLFILE structure mutex.  We don't use the structure mutex   578            * because then I/O (which holds the structure lock held because of   579            * the race between the seek and write of the file descriptor) would   580            * block any other put/get calls using this DB_MPOOLFILE structure.   581            */   582          u_int32_t pinref;                /* Pinned block reference count. */   583    584           /*   585            * !!!   586            * Explicit representations of structures from queue.h.   587            * TAILQ_ENTRY(__db_mpoolfile) q;   588            */   589          struct {  590                  struct  __db_mpoolfile  *tqe_next;  591                  struct  __db_mpoolfile  **tqe_prev;  592          } q;                             /* Linked list of DB_MPOOLFILE's. */   593    594           /*   595            * These fields are not thread-protected because they are initialized   596            * when the file is opened and never modified.   597            */   598          int       ftype;                 /* File type. */   599           DBT       *pgcookie;              /* Byte-string passed to pgin/pgout. */   600          u_int8_t *fileid;                /* Unique file ID. */   601          int32_t   lsn_offset;            /* LSN offset in page. */   602          u_int32_t clear_len;             /* Cleared length on created pages. */   603    604           DB_MPOOL   *dbmp;                 /* Overlying DB_MPOOL. */   605           MPOOLFILE  *mfp;                  /* Underlying MPOOLFILE. */   606    607          void      *addr;                 /* Address of mmap'd region. */   608          size_t      len ;                  /* Length of mmap'd region. */   609    610                                           /* Methods. */   611          int  (* close )  __P (( DB_MPOOLFILE  *, u_int32_t));  612          int  (*get)  __P (( DB_MPOOLFILE  *,  db_pgno_t  *, u_int32_t, void *));  613          void (*get_fileid)  __P (( DB_MPOOLFILE  *, u_int8_t *));  614          void (*last_pgno)  __P (( DB_MPOOLFILE  *,  db_pgno_t  *));  615          int  (* open ) __P (( DB_MPOOLFILE  *, const char *, u_int32_t, int, size_t));  616          int  (*put)  __P (( DB_MPOOLFILE  *, void *, u_int32_t));  617          void (*refcnt)  __P (( DB_MPOOLFILE  *,  db_pgno_t  *));  618          int  (*set)  __P (( DB_MPOOLFILE  *, void *, u_int32_t));  619          int  (*set_clear_len)  __P (( DB_MPOOLFILE  *, u_int32_t));  620          int  (*set_fileid)  __P (( DB_MPOOLFILE  *, u_int8_t *));  621          int  (*set_ftype)  __P (( DB_MPOOLFILE  *, int));  622          int  (*set_lsn_offset)  __P (( DB_MPOOLFILE  *, int32_t));  623          int  (*set_pgcookie)  __P (( DB_MPOOLFILE  *,  DBT  *));  624          int  (*set_priority)  __P (( DB_MPOOLFILE  *,  DB_CACHE_PRIORITY ));  625          void (*set_unlink)  __P (( DB_MPOOLFILE  *, int));  626          int  (* sync )  __P (( DB_MPOOLFILE  *));  627    628           /*   629            * MP_OPEN_CALLED and MP_READONLY do not need to be thread protected   630            * because they are initialized when the file is opened, and never   631            * modified.   632            *   633            * MP_FLUSH, MP_UPGRADE and MP_UPGRADE_FAIL are thread protected   634            * becase they are potentially read by multiple threads of control.   635            */   636  #define  MP_FLUSH         0x001            /* Was opened to flush a buffer. */   637  #define  MP_OPEN_CALLED   0x002            /* File opened. */   638  #define  MP_READONLY      0x004            /* File is readonly. */   639  #define  MP_UPGRADE       0x008            /* File descriptor is readwrite. */   640  #define  MP_UPGRADE_FAIL  0x010            /* Upgrade wasn't possible. */   641          u_int32_t  flags;  642  };  643    644   /*   645    * Mpool statistics structure.   646    */   647  struct  __db_mpool_stat  {  648          u_int32_t st_gbytes;             /* Total cache size: GB. */   649          u_int32_t st_bytes;              /* Total cache size: B. */   650          u_int32_t st_ncache;             /* Number of caches. */   651          u_int32_t st_regsize;            /* Cache size. */   652          u_int32_t st_map;                /* Pages from mapped files. */   653          u_int32_t st_cache_hit;          /* Pages found in the cache. */   654          u_int32_t st_cache_miss;         /* Pages not found in the cache. */   655          u_int32_t st_page_create;        /* Pages created in the cache. */   656          u_int32_t st_page_in;            /* Pages read in. */   657          u_int32_t st_page_out;           /* Pages written out. */   658          u_int32_t st_ro_evict;           /* Clean pages forced from the cache. */   659          u_int32_t st_rw_evict;           /* Dirty pages forced from the cache. */   660          u_int32_t st_page_trickle;       /* Pages written by memp_trickle. */   661          u_int32_t st_pages;              /* Total number of pages. */   662          u_int32_t st_page_clean;         /* Clean pages. */   663          u_int32_t st_page_dirty;         /* Dirty pages. */   664          u_int32_t st_hash_buckets;       /* Number of hash buckets. */   665          u_int32_t st_hash_searches;      /* Total hash chain searches. */   666          u_int32_t st_hash_longest;       /* Longest hash chain searched. */   667          u_int32_t st_hash_examined;      /* Total hash entries searched. */   668          u_int32_t st_hash_nowait;        /* Hash lock granted with nowait. */   669          u_int32_t st_hash_wait;          /* Hash lock granted after wait. */   670          u_int32_t st_hash_max_wait;      /* Max hash lock granted after wait. */   671          u_int32_t st_region_nowait;      /* Region lock granted with nowait. */   672          u_int32_t st_region_wait;        /* Region lock granted after wait. */   673          u_int32_t st_alloc;              /* Number of page allocations. */   674          u_int32_t st_alloc_buckets;      /* Buckets checked during allocation. */   675          u_int32_t st_alloc_max_buckets;  /* Max checked during allocation. */   676          u_int32_t st_alloc_pages;        /* Pages checked during allocation. */   677          u_int32_t st_alloc_max_pages;    /* Max checked during allocation. */   678  };  679    680   /* Mpool file statistics structure. */   681  struct  __db_mpool_fstat  {  682          char * file_name ;                 /* File name. */   683          size_t st_pagesize;              /* Page size. */   684          u_int32_t st_map;                /* Pages from mapped files. */   685          u_int32_t st_cache_hit;          /* Pages found in the cache. */   686          u_int32_t st_cache_miss;         /* Pages not found in the cache. */   687          u_int32_t st_page_create;        /* Pages created in the cache. */   688          u_int32_t st_page_in;            /* Pages read in. */   689          u_int32_t st_page_out;           /* Pages written out. */   690  };  691    692   /*******************************************************   693    * Transactions and recovery.   694    *******************************************************/   695  #define  DB_TXNVERSION    1  696    697  typedef enum {  698          DB_TXN_ABORT=0,                  /* Public. */   699          DB_TXN_APPLY=1,                  /* Public. */   700          DB_TXN_BACKWARD_ALLOC=2,         /* Internal. */   701          DB_TXN_BACKWARD_ROLL=3,          /* Public. */   702          DB_TXN_FORWARD_ROLL=4,           /* Public. */   703          DB_TXN_GETPGNOS=5,               /* Internal. */   704          DB_TXN_OPENFILES=6,              /* Internal. */   705          DB_TXN_POPENFILES=7,             /* Internal. */   706          DB_TXN_PRINT=8                   /* Public. */   707  }  db_recops ;  708    709   /*   710    * BACKWARD_ALLOC is used during the forward pass to pick up any aborted   711    * allocations for files that were created during the forward pass.   712    * The main difference between _ALLOC and _ROLL is that the entry for   713    * the file not exist during the rollforward pass.   714    */   715  #define  DB_UNDO (op)     ((op) == DB_TXN_ABORT ||                        \  716                  (op) == DB_TXN_BACKWARD_ROLL || (op) == DB_TXN_BACKWARD_ALLOC)  717  #define  DB_REDO (op)     ((op) == DB_TXN_FORWARD_ROLL || (op) == DB_TXN_APPLY)  718    719  struct  __db_txn  {  720           DB_TXNMGR        *mgrp;           /* Pointer to transaction manager. */   721           DB_TXN           *parent;         /* Pointer to transaction's parent. */   722           DB_LSN           last_lsn;        /* Lsn of last log write. */   723          u_int32_t       txnid;           /* Unique transaction id. */   724           roff_t           off;             /* Detail structure within region. */   725           db_timeout_t     lock_timeout;    /* Timeout for locks for this txn. */   726           db_timeout_t     expire;          /* Time this txn expires. */   727          void            *txn_list;       /* Undo information for parent. */   728    729           /*   730            * !!!   731            * Explicit representations of structures from queue.h.   732            * TAILQ_ENTRY(__db_txn) links;   733            */   734          struct {  735                  struct  __db_txn  *tqe_next;  736                  struct  __db_txn  **tqe_prev;  737          } links;                         /* Links transactions off manager. */   738    739           /*   740            * !!!   741            * Explicit representations of structures from queue.h.   742            * TAILQ_HEAD(__events, __txn_event) events;   743            */   744          struct {  745                  struct __txn_event *tqh_first;  746                  struct __txn_event **tqh_last;  747          } events;  748    749           /*   750            * !!!   751            * Explicit representations of structures from queue.h.   752            * TAILQ_HEAD(__kids, __db_txn) kids;   753            */   754          struct __kids {  755                  struct  __db_txn  *tqh_first;  756                  struct  __db_txn  **tqh_last;  757          } kids;  758    759           /*   760            * !!!   761            * Explicit representations of structures from queue.h.   762            * TAILQ_ENTRY(__db_txn) klinks;   763            */   764          struct {  765                  struct  __db_txn  *tqe_next;  766                  struct  __db_txn  **tqe_prev;  767          } klinks;  768    769           /* API-private structure: used by C++ */   770          void    *api_internal;  771    772          u_int32_t       cursors;         /* Number of cursors open for txn */   773    774                                           /* Methods. */   775          int       (*abort)  __P (( DB_TXN  *));  776          int       (*commit)  __P (( DB_TXN  *, u_int32_t));  777          int       (*discard)  __P (( DB_TXN  *, u_int32_t));  778          u_int32_t (*id)  __P (( DB_TXN  *));  779          int       (*prepare)  __P (( DB_TXN  *, u_int8_t *));  780          int       (*set_timeout)  __P (( DB_TXN  *,  db_timeout_t , u_int32_t));  781    782  #define  TXN_CHILDCOMMIT  0x01             /* Transaction that has committed. */   783  #define  TXN_COMPENSATE   0x02             /* Compensating transaction. */   784  #define  TXN_DIRTY_READ   0x04             /* Transaction does dirty reads. */   785  #define  TXN_LOCKTIMEOUT  0x08             /* Transaction has a lock timeout. */   786  #define  TXN_MALLOC       0x10             /* Structure allocated by TXN system. */   787  #define  TXN_NOSYNC       0x20             /* Do not sync on prepare and commit. */   788  #define  TXN_NOWAIT       0x40             /* Do not wait on locks. */   789  #define  TXN_SYNC         0x80             /* Sync on prepare and commit. */   790          u_int32_t       flags;  791  };  792    793   /* Transaction statistics structure. */   794  struct  __db_txn_active  {  795          u_int32_t       txnid;           /* Transaction ID */   796          u_int32_t       parentid;        /* Transaction ID of parent */   797           DB_LSN           lsn;             /* LSN when transaction began */   798  };  799    800  struct  __db_txn_stat  {  801           DB_LSN     st_last_ckp;           /* lsn of the last checkpoint */   802          time_t    st_time_ckp;           /* time of last checkpoint */   803          u_int32_t st_last_txnid;         /* last transaction id given out */   804          u_int32_t st_maxtxns;            /* maximum txns possible */   805          u_int32_t st_naborts;            /* number of aborted transactions */   806          u_int32_t st_nbegins;            /* number of begun transactions */   807          u_int32_t st_ncommits;           /* number of committed transactions */   808          u_int32_t st_nactive;            /* number of active transactions */   809          u_int32_t st_nrestores;          /* number of restored transactions   810                                              after recovery. */   811          u_int32_t st_maxnactive;         /* maximum active transactions */   812           DB_TXN_ACTIVE  *st_txnarray;      /* array of active transactions */   813          u_int32_t st_region_wait;        /* Region lock granted after wait. */   814          u_int32_t st_region_nowait;      /* Region lock granted without wait. */   815          u_int32_t st_regsize;            /* Region size. */   816  };  817    818   /*   819    * Structure used for two phase commit interface.  Berkeley DB support for two   820    * phase commit is compatible with the X/open XA interface.  The xa #define   821    * XIDDATASIZE defines the size of a global transaction ID.  We have our own   822    * version here which must have the same value.   823    */   824  #define  DB_XIDDATASIZE   128  825  struct  __db_preplist  {  826           DB_TXN   *txn;  827          u_int8_t gid[ DB_XIDDATASIZE ];  828  };  829    830   /*******************************************************   831    * Replication.   832    *******************************************************/   833   /* Special, out-of-band environment IDs. */   834  #define  DB_EID_BROADCAST         -1  835  #define  DB_EID_INVALID           -2  836    837   /* rep_start flags values */   838  #define  DB_REP_CLIENT            0x001  839  #define  DB_REP_LOGSONLY          0x002  840  #define  DB_REP_MASTER            0x004  841    842   /* Replication statistics. */   843  struct  __db_rep_stat  {  844           /* !!!   845            * Many replication statistics fields cannot be protected by a mutex   846            * without an unacceptable performance penalty, since most message   847            * processing is done without the need to hold a region-wide lock.   848            * Fields whose comments end with a '+' may be updated without holding   849            * the replication or log mutexes (as appropriate), and thus may be   850            * off somewhat (or, on unreasonable architectures under unlucky   851            * circumstances, garbaged).   852            */   853          u_int32_t st_status;             /* Current replication status. */   854           DB_LSN  st_next_lsn;              /* Next LSN to use or expect. */   855           DB_LSN  st_waiting_lsn;           /* LSN we're awaiting, if any. */   856    857          u_int32_t st_dupmasters;         /* # of times a duplicate master   858                                              condition was detected.+ */   859          int st_env_id;                   /* Current environment ID. */   860          int st_env_priority;             /* Current environment priority. */   861          u_int32_t st_gen;                /* Current generation number. */   862          u_int32_t st_log_duplicated;     /* Log records received multiply.+ */   863          u_int32_t st_log_queued;         /* Log records currently queued.+ */   864          u_int32_t st_log_queued_max;     /* Max. log records queued at once.+ */   865          u_int32_t st_log_queued_total;   /* Total # of log recs. ever queued.+ */   866          u_int32_t st_log_records;        /* Log records received and put.+ */   867          u_int32_t st_log_requested;      /* Log recs. missed and requested.+ */   868          int st_master;                   /* Env. ID of the current master. */   869          u_int32_t st_master_changes;     /* # of times we've switched masters. */   870          u_int32_t st_msgs_badgen;        /* Messages with a bad generation #.+ */   871          u_int32_t st_msgs_processed;     /* Messages received and processed.+ */   872          u_int32_t st_msgs_recover;       /* Messages ignored because this site   873                                              was a client in recovery.+ */   874          u_int32_t st_msgs_send_failures; /* # of failed message sends.+ */   875          u_int32_t st_msgs_sent;          /* # of successful message sends.+ */   876          u_int32_t st_newsites;           /* # of NEWSITE msgs. received.+ */   877          int st_nsites;                   /* Current number of sites we will   878                                              assume during elections. */   879          u_int32_t st_nthrottles;         /* # of times we were throttled. */   880          u_int32_t st_outdated;           /* # of times we detected and returned   881                                              an OUTDATED condition.+ */   882          u_int32_t st_txns_applied;       /* # of transactions applied.+ */   883    884           /* Elections generally. */   885          u_int32_t st_elections;          /* # of elections held.+ */   886          u_int32_t st_elections_won;      /* # of elections won by this site.+ */   887    888           /* Statistics about an in-progress election. */   889          int st_election_cur_winner;      /* Current front-runner. */   890          u_int32_t st_election_gen;       /* Election generation number. */   891           DB_LSN  st_election_lsn;          /* Max. LSN of current winner. */   892          int st_election_nsites;          /* # of ""registered voters"". */   893          int st_election_priority;        /* Current election priority. */   894          int st_election_status;          /* Current election status. */   895          int st_election_tiebreaker;      /* Election tiebreaker value. */   896          int st_election_votes;           /* Votes received in this round. */   897  };  898    899   /*******************************************************   900    * Access methods.   901    *******************************************************/   902  typedef enum {  903          DB_BTREE=1,  904          DB_HASH=2,  905          DB_RECNO=3,  906          DB_QUEUE=4,  907          DB_UNKNOWN=5                     /* Figure it out on open. */   908  }  DBTYPE ;  909    910  #define  DB_RENAMEMAGIC   0x030800         /* File has been renamed. */   911    912  #define  DB_BTREEVERSION  9                /* Current btree version. */   913  #define  DB_BTREEOLDVER   8                /* Oldest btree version supported. */   914  #define  DB_BTREEMAGIC    0x053162  915    916  #define  DB_HASHVERSION   8                /* Current hash version. */   917  #define  DB_HASHOLDVER    7                /* Oldest hash version supported. */   918  #define  DB_HASHMAGIC     0x061561  919    920  #define  DB_QAMVERSION    4                /* Current queue version. */   921  #define  DB_QAMOLDVER     3                /* Oldest queue version supported. */   922  #define  DB_QAMMAGIC      0x042253  923    924   /*   925    * DB access method and cursor operation values.  Each value is an operation   926    * code to which additional bit flags are added.   927    */   928  #define  DB_AFTER                  1       /* c_put() */   929  #define  DB_APPEND                 2       /* put() */   930  #define  DB_BEFORE                 3       /* c_put() */   931  #define  DB_CACHED_COUNTS          4       /* stat() */   932  #define  DB_COMMIT                 5       /* log_put() (internal) */   933  #define  DB_CONSUME                6       /* get() */   934  #define  DB_CONSUME_WAIT           7       /* get() */   935  #define  DB_CURRENT                8       /* c_get(), c_put(), DB_LOGC->get() */   936  #define  DB_FAST_STAT              9       /* stat() */   937  #define  DB_FIRST                 10       /* c_get(), DB_LOGC->get() */   938  #define  DB_GET_BOTH              11       /* get(), c_get() */   939  #define  DB_GET_BOTHC             12       /* c_get() (internal) */   940  #define  DB_GET_BOTH_RANGE        13       /* get(), c_get() */   941  #define  DB_GET_RECNO             14       /* c_get() */   942  #define  DB_JOIN_ITEM             15       /* c_get(); do not do primary lookup */   943  #define  DB_KEYFIRST              16       /* c_put() */   944  #define  DB_KEYLAST               17       /* c_put() */   945  #define  DB_LAST                  18       /* c_get(), DB_LOGC->get() */   946  #define  DB_NEXT                  19       /* c_get(), DB_LOGC->get() */   947  #define  DB_NEXT_DUP              20       /* c_get() */   948  #define  DB_NEXT_NODUP            21       /* c_get() */   949  #define  DB_NODUPDATA             22       /* put(), c_put() */   950  #define  DB_NOOVERWRITE           23       /* put() */   951  #define  DB_NOSYNC                24       /* close() */   952  #define  DB_POSITION              25       /* c_dup() */   953  #define  DB_POSITIONI             26       /* c_dup() (internal) */   954  #define  DB_PREV                  27       /* c_get(), DB_LOGC->get() */   955  #define  DB_PREV_NODUP            28       /* c_get(), DB_LOGC->get() */   956  #define  DB_RECORDCOUNT           29       /* stat() */   957  #define  DB_SET                   30       /* c_get(), DB_LOGC->get() */   958  #define  DB_SET_LOCK_TIMEOUT      31       /* set_timout() */   959  #define  DB_SET_RANGE             32       /* c_get() */   960  #define  DB_SET_RECNO             33       /* get(), c_get() */   961  #define  DB_SET_TXN_NOW           34       /* set_timout() (internal) */   962  #define  DB_SET_TXN_TIMEOUT       35       /* set_timout() */   963  #define  DB_UPDATE_SECONDARY      36       /* c_get(), c_del() (internal) */   964  #define  DB_WRITECURSOR           37       /* cursor() */   965  #define  DB_WRITELOCK             38       /* cursor() (internal) */   966    967   /* This has to change when the max opcode hits 255. */   968  #define  DB_OPFLAGS_MASK  0x000000ff       /* Mask for operations flags. */   969   /*      DB_DIRTY_READ   0x01000000         Dirty Read. */   970  #define  DB_FLUSH         0x02000000       /* Flush data to disk. */   971  #define  DB_MULTIPLE      0x04000000       /* Return multiple data values. */   972  #define  DB_MULTIPLE_KEY  0x08000000       /* Return multiple data/key pairs. */   973  #define  DB_NOCOPY        0x10000000       /* Don't copy data */   974  #define  DB_PERMANENT     0x20000000       /* Flag record with REP_PERMANENT. */   975  #define  DB_RMW           0x40000000       /* Acquire write flag immediately. */   976  #define  DB_WRNOSYNC      0x80000000       /* Private: write, don't sync log_put */   977    978   /*   979    * DB (user visible) error return codes.   980    *   981    * !!!   982    * For source compatibility with DB 2.X deadlock return (EAGAIN), use the   983    * following:   984    *      #include <errno.h>   985    *      #define DB_LOCK_DEADLOCK EAGAIN   986    *   987    * !!!   988    * We don't want our error returns to conflict with other packages where   989    * possible, so pick a base error value that's hopefully not common.  We   990    * document that we own the error name space from -30,800 to -30,999.   991    */   992   /* DB (public) error return codes. */   993  #define  DB_DONOTINDEX            (-30999) /* ""Null"" return from 2ndary callbk. */   994  #define  DB_KEYEMPTY              (-30998) /* Key/data deleted or never created. */   995  #define  DB_KEYEXIST              (-30997) /* The key/data pair already exists. */   996  #define  DB_LOCK_DEADLOCK         (-30996) /* Deadlock. */   997  #define  DB_LOCK_NOTGRANTED       (-30995) /* Lock unavailable. */   998  #define  DB_NOSERVER              (-30994) /* Server panic return. */   999  #define  DB_NOSERVER_HOME         (-30993) /* Bad home sent to server. */   1000  #define  DB_NOSERVER_ID           (-30992) /* Bad ID sent to server. */   1001  #define  DB_NOTFOUND              (-30991) /* Key/data pair not found (EOF). */   1002  #define  DB_OLD_VERSION           (-30990) /* Out-of-date version. */   1003  #define  DB_PAGE_NOTFOUND         (-30989) /* Requested page not found. */   1004  #define  DB_REP_DUPMASTER         (-30988) /* There are two masters. */   1005  #define  DB_REP_HOLDELECTION      (-30987) /* Time to hold an election. */   1006  #define  DB_REP_NEWMASTER         (-30986) /* We have learned of a new master. */   1007  #define  DB_REP_NEWSITE           (-30985) /* New site entered system. */   1008  #define  DB_REP_OUTDATED          (-30984) /* Site is too far behind master. */   1009  #define  DB_REP_UNAVAIL           (-30983) /* Site cannot currently be reached. */   1010  #define  DB_RUNRECOVERY           (-30982) /* Panic return. */   1011  #define  DB_SECONDARY_BAD         (-30981) /* Secondary index corrupt. */   1012  #define  DB_VERIFY_BAD            (-30980) /* Verify failed; bad format. */   1013    1014   /* DB (private) error return codes. */   1015  #define  DB_ALREADY_ABORTED       (-30899)  1016  #define  DB_DELETED               (-30898) /* Recovery file marked deleted. */   1017  #define  DB_JAVA_CALLBACK         (-30897) /* Exception during a java callback. */   1018  #define  DB_LOCK_NOTEXIST         (-30896) /* Object to lock is gone. */   1019  #define  DB_NEEDSPLIT             (-30895) /* Page needs to be split. */   1020  #define  DB_SURPRISE_KID          (-30894) /* Child commit where parent   1021                                              didn't know it was a parent. */   1022  #define  DB_SWAPBYTES             (-30893) /* Database needs byte swapping. */   1023  #define  DB_TIMEOUT               (-30892) /* Timed out waiting for election. */   1024  #define  DB_TXN_CKP               (-30891) /* Encountered ckp record in log. */   1025  #define  DB_VERIFY_FATAL          (-30890) /* DB->verify cannot proceed. */   1026    1027   /* Database handle. */   1028  struct  __db  {  1029           /*******************************************************   1030            * Public: owned by the application.   1031            *******************************************************/   1032          u_int32_t pgsize;                /* Database logical page size. */   1033    1034                                           /* Callbacks. */   1035          int (*db_append_recno)  __P (( DB  *,  DBT  *,  db_recno_t ));  1036          void (*db_feedback)  __P (( DB  *, int, int));  1037          int (*dup_compare)  __P (( DB  *, const  DBT  *, const  DBT  *));  1038    1039          void    *app_private;            /* Application-private handle. */   1040    1041           /*******************************************************   1042            * Private: owned by DB.   1043            *******************************************************/   1044           DB_ENV   *dbenv;                  /* Backing environment. */   1045    1046           DBTYPE     type ;                   /* DB access method type. */   1047    1048           DB_MPOOLFILE  *mpf;               /* Backing buffer pool. */   1049           DB_CACHE_PRIORITY  priority;      /* Priority in the buffer pool. */   1050    1051           DB_MUTEX  *mutexp;                /* Synchronization for free threading */   1052    1053          u_int8_t fileid[ DB_FILE_ID_LEN ]; /* File's unique ID for locking. */   1054    1055          u_int32_t adj_fileid;            /* File's unique ID for curs. adj. */   1056    1057  #define  DB_LOGFILEID_INVALID     -1  1058           FNAME  *log_filename;             /* File's naming info for logging. */   1059    1060           db_pgno_t  meta_pgno;             /* Meta page number */   1061          u_int32_t lid;                   /* Locker id for handle locking. */   1062          u_int32_t cur_lid;               /* Current handle lock holder. */   1063          u_int32_t associate_lid;         /* Locker id for DB->associate call. */   1064           DB_LOCK  handle_lock;             /* Lock held on this handle. */   1065    1066          long     cl_id;                  /* RPC: remote client id. */   1067    1068           /*   1069            * Returned data memory for DB->get() and friends.   1070            */   1071           DBT       my_rskey;               /* Secondary key. */   1072           DBT       my_rkey;                /* [Primary] key. */   1073           DBT       my_rdata;               /* Data. */   1074    1075           /*   1076            * !!!   1077            * Some applications use DB but implement their own locking outside of   1078            * DB.  If they're using fcntl(2) locking on the underlying database   1079            * file, and we open and close a file descriptor for that file, we will   1080            * discard their locks.  The DB_FCNTL_LOCKING flag to DB->open is an   1081            * undocumented interface to support this usage which leaves any file   1082            * descriptors we open until DB->close.  This will only work with the   1083            * DB->open interface and simple caches, e.g., creating a transaction   1084            * thread may open/close file descriptors this flag doesn't protect.   1085            * Locking with fcntl(2) on a file that you don't own is a very, very   1086            * unsafe thing to do.  'Nuff said.   1087            */   1088           DB_FH    *saved_open_fhp;         /* Saved file handle. */   1089    1090           /*   1091            * Linked list of DBP's, linked from the DB_ENV, used to keep track   1092            * of all open db handles for cursor adjustment.   1093            *   1094            * !!!   1095            * Explicit representations of structures from queue.h.   1096            * LIST_ENTRY(__db) dblistlinks;   1097            */   1098          struct {  1099                  struct  __db  *le_next;  1100                  struct  __db  **le_prev;  1101          } dblistlinks;  1102    1103           /*   1104            * Cursor queues.   1105            *   1106            * !!!   1107            * Explicit representations of structures from queue.h.   1108            * TAILQ_HEAD(__cq_fq, __dbc) free_queue;   1109            * TAILQ_HEAD(__cq_aq, __dbc) active_queue;   1110            * TAILQ_HEAD(__cq_jq, __dbc) join_queue;   1111            */   1112          struct __cq_fq {  1113                  struct  __dbc  *tqh_first;  1114                  struct  __dbc  **tqh_last;  1115          } free_queue;  1116          struct __cq_aq {  1117                  struct  __dbc  *tqh_first;  1118                  struct  __dbc  **tqh_last;  1119          } active_queue;  1120          struct __cq_jq {  1121                  struct  __dbc  *tqh_first;  1122                  struct  __dbc  **tqh_last;  1123          } join_queue;  1124    1125           /*   1126            * Secondary index support.   1127            *   1128            * Linked list of secondary indices -- set in the primary.   1129            *   1130            * !!!   1131            * Explicit representations of structures from queue.h.   1132            * LIST_HEAD(s_secondaries, __db);   1133            */   1134          struct {  1135                  struct  __db  *lh_first;  1136          } s_secondaries;  1137    1138           /*   1139            * List entries for secondaries, and reference count of how   1140            * many threads are updating this secondary (see __db_c_put).   1141            *   1142            * !!!   1143            * Note that these are synchronized by the primary's mutex, but   1144            * filled in in the secondaries.   1145            *   1146            * !!!   1147            * Explicit representations of structures from queue.h.   1148            * LIST_ENTRY(__db) s_links;   1149            */   1150          struct {  1151                  struct  __db  *le_next;  1152                  struct  __db  **le_prev;  1153          } s_links;  1154          u_int32_t s_refcnt;  1155    1156           /* Secondary callback and free functions -- set in the secondary. */   1157          int     (*s_callback)  __P (( DB  *, const  DBT  *, const  DBT  *,  DBT  *));  1158    1159           /* Reference to primary -- set in the secondary. */   1160           DB       *s_primary;  1161    1162           /* API-private structure: used by DB 1.85, C++, Java, Perl and Tcl */   1163          void    *api_internal;  1164    1165           /* Subsystem-private structure. */   1166          void    *bt_internal;            /* Btree/Recno access method. */   1167          void    *h_internal;             /* Hash access method. */   1168          void    *q_internal;             /* Queue access method. */   1169          void    *xa_internal;            /* XA. */   1170    1171                                           /* Methods. */   1172          int  (*associate)  __P (( DB  *,  DB_TXN  *,  DB  *, int (*)( DB  *, const  DBT  *,  1173                  const  DBT  *,  DBT  *), u_int32_t));  1174          int  (* close )  __P (( DB  *, u_int32_t));  1175          int  (*cursor)  __P (( DB  *,  DB_TXN  *,  DBC  **, u_int32_t));  1176          int  (*del)  __P (( DB  *,  DB_TXN  *,  DBT  *, u_int32_t));  1177          void (* err )  __P (( DB  *, int, const char *, ...));  1178          void (*errx)  __P (( DB  *, const char *, ...));  1179          int  (* fd )  __P (( DB  *, int *));  1180          int  (*get)  __P (( DB  *,  DB_TXN  *,  DBT  *,  DBT  *, u_int32_t));  1181          int  (*pget)  __P (( DB  *,  DB_TXN  *,  DBT  *,  DBT  *,  DBT  *, u_int32_t));  1182          int  (*get_byteswapped)  __P (( DB  *, int *));  1183          int  (*get_type)  __P (( DB  *,  DBTYPE  *));  1184          int  (*join)  __P (( DB  *,  DBC  **,  DBC  **, u_int32_t));  1185          int  (*key_range)  __P (( DB  *,  1186                   DB_TXN  *,  DBT  *,  DB_KEY_RANGE  *, u_int32_t));  1187          int  (* open )  __P (( DB  *,  DB_TXN  *,  1188                  const char *, const char *,  DBTYPE , u_int32_t, int));  1189          int  (*put)  __P (( DB  *,  DB_TXN  *,  DBT  *,  DBT  *, u_int32_t));  1190          int  (* remove )  __P (( DB  *, const char *, const char *, u_int32_t));  1191          int  (*rename)  __P (( DB  *,  1192              const char *, const char *, const char *, u_int32_t));  1193          int  (*truncate)  __P (( DB  *,  DB_TXN  *, u_int32_t *, u_int32_t));  1194          int  (*set_append_recno)  __P (( DB  *, int (*)( DB  *,  DBT  *,  db_recno_t )));  1195          int  (*set_alloc)  __P (( DB  *, void *(*)(size_t),  1196                  void *(*)(void *, size_t), void (*)(void *)));  1197          int  (*set_cachesize)  __P (( DB  *, u_int32_t, u_int32_t, int));  1198          int  (*set_cache_priority)  __P (( DB  *,  DB_CACHE_PRIORITY ));  1199          int  (*set_dup_compare)  __P (( DB  *,  1200              int (*)( DB  *, const  DBT  *, const  DBT  *)));  1201          int  (*set_encrypt)  __P (( DB  *, const char *, u_int32_t));  1202          void (*set_errcall)  __P (( DB  *, void (*)(const char *, char *)));  1203          void (*set_errfile)  __P (( DB  *, FILE *));  1204          void (*set_errpfx)  __P (( DB  *, const char *));  1205          int  (*set_feedback)  __P (( DB  *, void (*)( DB  *, int, int)));  1206          int  (*set_flags)  __P (( DB  *, u_int32_t));  1207          int  (*set_lorder)  __P (( DB  *, int));  1208          int  (*set_pagesize)  __P (( DB  *, u_int32_t));  1209          int  (*set_paniccall)  __P (( DB  *, void (*)( DB_ENV  *, int)));  1210          int  (*stat)  __P (( DB  *, void *, u_int32_t));  1211          int  (* sync )  __P (( DB  *, u_int32_t));  1212          int  (*upgrade)  __P (( DB  *, const char *, u_int32_t));  1213          int  (* verify )  __P (( DB  *,  1214              const char *, const char *, FILE *, u_int32_t));  1215    1216          int  (*set_bt_compare)  __P (( DB  *,  1217              int (*)( DB  *, const  DBT  *, const  DBT  *)));  1218          int  (*set_bt_maxkey)  __P (( DB  *, u_int32_t));  1219          int  (*set_bt_minkey)  __P (( DB  *, u_int32_t));  1220          int  (*set_bt_prefix)  __P (( DB  *,  1221              size_t (*)( DB  *, const  DBT  *, const  DBT  *)));  1222    1223          int  (*set_h_ffactor)  __P (( DB  *, u_int32_t));  1224          int  (*set_h_hash)  __P (( DB  *,  1225              u_int32_t (*)( DB  *, const void *, u_int32_t)));  1226          int  (*set_h_nelem)  __P (( DB  *, u_int32_t));  1227    1228          int  (*set_re_delim)  __P (( DB  *, int));  1229          int  (*set_re_len)  __P (( DB  *, u_int32_t));  1230          int  (*set_re_pad)  __P (( DB  *, int));  1231          int  (*set_re_source)  __P (( DB  *, const char *));  1232          int  (*set_q_extentsize)  __P (( DB  *, u_int32_t));  1233    1234          int  (*db_am_remove)  __P (( DB  *,  1235               DB_TXN  *, const char *, const char *,  DB_LSN  *));  1236          int  (*db_am_rename)  __P (( DB  *,  DB_TXN  *,  1237              const char *, const char *, const char *));  1238    1239           /*   1240            * Never called; these are a place to save function pointers   1241            * so that we can undo an associate.   1242            */   1243          int  (*stored_get)  __P (( DB  *,  DB_TXN  *,  DBT  *,  DBT  *, u_int32_t));  1244          int  (*stored_close)  __P (( DB  *, u_int32_t));  1245    1246  #define  DB_OK_BTREE      0x01  1247  #define  DB_OK_HASH       0x02  1248  #define  DB_OK_QUEUE      0x04  1249  #define  DB_OK_RECNO      0x08  1250          u_int32_t       am_ok;           /* Legal AM choices. */   1251    1252  #define  DB_AM_CHKSUM             0x00000001  /* Checksumming. */   1253  #define  DB_AM_CL_WRITER          0x00000002  /* Allow writes in client replica. */   1254  #define  DB_AM_COMPENSATE         0x00000004  /* Created by compensating txn. */   1255  #define  DB_AM_CREATED            0x00000008  /* Database was created upon open. */   1256  #define  DB_AM_CREATED_MSTR       0x00000010  /* Encompassing file was created. */   1257  #define  DB_AM_DBM_ERROR          0x00000020  /* Error in DBM/NDBM database. */   1258  #define  DB_AM_DELIMITER          0x00000040  /* Variable length delimiter set. */   1259  #define  DB_AM_DIRTY              0x00000080  /* Support Dirty Reads. */   1260  #define  DB_AM_DISCARD            0x00000100  /* Discard any cached pages. */   1261  #define  DB_AM_DUP                0x00000200  /* DB_DUP. */   1262  #define  DB_AM_DUPSORT            0x00000400  /* DB_DUPSORT. */   1263  #define  DB_AM_ENCRYPT            0x00000800  /* Encryption. */   1264  #define  DB_AM_FIXEDLEN           0x00001000  /* Fixed-length records. */   1265  #define  DB_AM_INMEM              0x00002000  /* In-memory; no sync on close. */   1266  #define  DB_AM_IN_RENAME          0x00004000  /* File is being renamed. */   1267  #define  DB_AM_OPEN_CALLED        0x00008000  /* DB->open called. */   1268  #define  DB_AM_PAD                0x00010000  /* Fixed-length record pad. */   1269  #define  DB_AM_PGDEF              0x00020000  /* Page size was defaulted. */   1270  #define  DB_AM_RDONLY             0x00040000  /* Database is readonly. */   1271  #define  DB_AM_RECNUM             0x00080000  /* DB_RECNUM. */   1272  #define  DB_AM_RECOVER            0x00100000  /* DB opened by recovery routine. */   1273  #define  DB_AM_RENUMBER           0x00200000  /* DB_RENUMBER. */   1274  #define  DB_AM_REVSPLITOFF        0x00400000  /* DB_REVSPLITOFF. */   1275  #define  DB_AM_SECONDARY          0x00800000  /* Database is a secondary index. */   1276  #define  DB_AM_SNAPSHOT           0x01000000  /* DB_SNAPSHOT. */   1277  #define  DB_AM_SUBDB              0x02000000  /* Subdatabases supported. */   1278  #define  DB_AM_SWAP               0x04000000  /* Pages need to be byte-swapped. */   1279  #define  DB_AM_TXN                0x08000000  /* Opened in a transaction. */   1280  #define  DB_AM_VERIFYING          0x10000000  /* DB handle is in the verifier. */   1281          u_int32_t flags;  1282  };  1283    1284   /*   1285    * Macros for bulk get.  Note that wherever we use a DBT *, we explicitly   1286    * cast it; this allows the same macros to work with C++ Dbt *'s, as Dbt   1287    * is a subclass of struct DBT in C++.   1288    */   1289  #define  DB_MULTIPLE_INIT (pointer, dbt)                                  \  1290          (pointer = (u_int8_t *)(( DBT  *)(dbt))->data +                   \  1291              (( DBT  *)(dbt))->ulen - sizeof(u_int32_t))  1292  #define  DB_MULTIPLE_NEXT (pointer, dbt, retdata, retdlen)                \  1293          do {                                                            \  1294                  if (*((u_int32_t *)(pointer)) == (u_int32_t)-1) {       \  1295                          retdata =  NULL ;                                 \  1296                          pointer =  NULL ;                                 \  1297                          break;                                          \  1298                  }                                                       \  1299                  retdata = (u_int8_t *)                                  \  1300                      (( DBT  *)(dbt))->data + *(u_int32_t *)(pointer);     \  1301                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1302                  retdlen = *(u_int32_t *)(pointer);                      \  1303                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1304                  if (retdlen == 0 &&                                     \  1305                      retdata == (u_int8_t *)(( DBT  *)(dbt))->data)        \  1306                          retdata =  NULL ;                                 \  1307          } while (0)  1308  #define  DB_MULTIPLE_KEY_NEXT (pointer, dbt, retkey, retklen, retdata, retdlen) \  1309          do {                                                            \  1310                  if (*((u_int32_t *)(pointer)) == (u_int32_t)-1) {       \  1311                          retdata =  NULL ;                                 \  1312                          retkey =  NULL ;                                  \  1313                          pointer =  NULL ;                                 \  1314                          break;                                          \  1315                  }                                                       \  1316                  retkey = (u_int8_t *)                                   \  1317                      (( DBT  *)(dbt))->data + *(u_int32_t *)(pointer);     \  1318                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1319                  retklen = *(u_int32_t *)(pointer);                      \  1320                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1321                  retdata = (u_int8_t *)                                  \  1322                      (( DBT  *)(dbt))->data + *(u_int32_t *)(pointer);     \  1323                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1324                  retdlen = *(u_int32_t *)(pointer);                      \  1325                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1326          } while (0)  1327    1328  #define  DB_MULTIPLE_RECNO_NEXT (pointer, dbt, recno, retdata, retdlen)   \  1329          do {                                                            \  1330                  if (*((u_int32_t *)(pointer)) == (u_int32_t)0) {        \  1331                          recno = 0;                                      \  1332                          retdata =  NULL ;                                 \  1333                          pointer =  NULL ;                                 \  1334                          break;                                          \  1335                  }                                                       \  1336                  recno = *(u_int32_t *)(pointer);                        \  1337                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1338                  retdata = (u_int8_t *)                                  \  1339                      (( DBT  *)(dbt))->data + *(u_int32_t *)(pointer);     \  1340                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1341                  retdlen = *(u_int32_t *)(pointer);                      \  1342                  (pointer) = (u_int32_t *)(pointer) - 1;                 \  1343          } while (0)  1344    1345   /*******************************************************   1346    * Access method cursors.   1347    *******************************************************/   1348  struct  __dbc  {  1349           DB  *dbp;                         /* Related DB access method. */   1350           DB_TXN    *txn;                   /* Associated transaction. */   1351    1352           /*   1353            * Active/free cursor queues.   1354            *   1355            * !!!   1356            * Explicit representations of structures from queue.h.   1357            * TAILQ_ENTRY(__dbc) links;   1358            */   1359          struct {  1360                   DBC  *tqe_next;  1361                   DBC  **tqe_prev;  1362          } links;  1363    1364           /*   1365            * The DBT *'s below are used by the cursor routines to return   1366            * data to the user when DBT flags indicate that DB should manage   1367            * the returned memory.  They point at a DBT containing the buffer   1368            * and length that will be used, and ""belonging"" to the handle that   1369            * should ""own"" this memory.  This may be a ""my_*"" field of this   1370            * cursor--the default--or it may be the corresponding field of   1371            * another cursor, a DB handle, a join cursor, etc.  In general, it   1372            * will be whatever handle the user originally used for the current   1373            * DB interface call.   1374            */   1375           DBT       *rskey;                 /* Returned secondary key. */   1376           DBT       *rkey;                  /* Returned [primary] key. */   1377           DBT       *rdata;                 /* Returned data. */   1378    1379           DBT        my_rskey;              /* Space for returned secondary key. */   1380           DBT        my_rkey;               /* Space for returned [primary] key. */   1381           DBT        my_rdata;              /* Space for returned data. */   1382    1383          u_int32_t lid;                   /* Default process' locker id. */   1384          u_int32_t locker;                /* Locker for this operation. */   1385           DBT        lock_dbt;              /* DBT referencing lock. */   1386           DB_LOCK_ILOCK  lock;              /* Object to be locked. */   1387           DB_LOCK    mylock;                /* Lock held on this cursor. */   1388    1389          long      cl_id;                 /* Remote client id. */   1390    1391           DBTYPE     dbtype;                /* Cursor type. */   1392    1393           DBC_INTERNAL  *internal;          /* Access method private. */   1394    1395          int (*c_close)  __P (( DBC  *));     /* Methods: public. */   1396          int (*c_count)  __P (( DBC  *,  db_recno_t  *, u_int32_t));  1397          int (*c_del)  __P (( DBC  *, u_int32_t));  1398          int (*c_dup)  __P (( DBC  *,  DBC  **, u_int32_t));  1399          int (*c_get)  __P (( DBC  *,  DBT  *,  DBT  *, u_int32_t));  1400          int (*c_pget)  __P (( DBC  *,  DBT  *,  DBT  *,  DBT  *, u_int32_t));  1401          int (*c_put)  __P (( DBC  *,  DBT  *,  DBT  *, u_int32_t));  1402    1403                                           /* Methods: private. */   1404          int (*c_am_bulk)  __P (( DBC  *,  DBT  *, u_int32_t));  1405          int (*c_am_close)  __P (( DBC  *,  db_pgno_t , int *));  1406          int (*c_am_del)  __P (( DBC  *));  1407          int (*c_am_destroy)  __P (( DBC  *));  1408          int (*c_am_get)  __P (( DBC  *,  DBT  *,  DBT  *, u_int32_t,  db_pgno_t  *));  1409          int (*c_am_put)  __P (( DBC  *,  DBT  *,  DBT  *, u_int32_t,  db_pgno_t  *));  1410          int (*c_am_writelock)  __P (( DBC  *));  1411    1412           /* Private: for secondary indices. */   1413          int (*c_real_get)  __P (( DBC  *,  DBT  *,  DBT  *, u_int32_t));  1414    1415  #define  DBC_ACTIVE        0x0001          /* Cursor in use. */   1416  #define  DBC_COMPENSATE    0x0002          /* Cursor compensating, don't lock. */   1417  #define  DBC_DIRTY_READ    0x0004          /* Cursor supports dirty reads. */   1418  #define  DBC_OPD           0x0008          /* Cursor references off-page dups. */   1419  #define  DBC_RECOVER       0x0010          /* Recovery cursor; don't log/lock. */   1420  #define  DBC_RMW           0x0020          /* Acquire write flag in read op. */   1421  #define  DBC_TRANSIENT     0x0040          /* Cursor is transient. */   1422  #define  DBC_WRITECURSOR   0x0080          /* Cursor may be used to write (CDB). */   1423  #define  DBC_WRITEDUP      0x0100          /* idup'ed DBC_WRITECURSOR (CDB). */   1424  #define  DBC_WRITER        0x0200          /* Cursor immediately writing (CDB). */   1425  #define  DBC_MULTIPLE      0x0400          /* Return Multiple data. */   1426  #define  DBC_MULTIPLE_KEY  0x0800          /* Return Multiple keys and data. */   1427  #define  DBC_OWN_LID       0x1000          /* Free lock id on destroy. */   1428          u_int32_t flags;  1429  };  1430    1431   /* Key range statistics structure */   1432  struct  __key_range  {  1433          double less;  1434          double equal;  1435          double greater;  1436  };  1437    1438   /* Btree/Recno statistics structure. */   1439  struct  __db_bt_stat  {  1440          u_int32_t bt_magic;              /* Magic number. */   1441          u_int32_t bt_version;            /* Version number. */   1442          u_int32_t bt_metaflags;          /* Metadata flags. */   1443          u_int32_t bt_nkeys;              /* Number of unique keys. */   1444          u_int32_t bt_ndata;              /* Number of data items. */   1445          u_int32_t bt_pagesize;           /* Page size. */   1446          u_int32_t bt_maxkey;             /* Maxkey value. */   1447          u_int32_t bt_minkey;             /* Minkey value. */   1448          u_int32_t bt_re_len;             /* Fixed-length record length. */   1449          u_int32_t bt_re_pad;             /* Fixed-length record pad. */   1450          u_int32_t bt_levels;             /* Tree levels. */   1451          u_int32_t bt_int_pg;             /* Internal pages. */   1452          u_int32_t bt_leaf_pg;            /* Leaf pages. */   1453          u_int32_t bt_dup_pg;             /* Duplicate pages. */   1454          u_int32_t bt_over_pg;            /* Overflow pages. */   1455          u_int32_t bt_free;               /* Pages on the free list. */   1456          u_int32_t bt_int_pgfree;         /* Bytes free in internal pages. */   1457          u_int32_t bt_leaf_pgfree;        /* Bytes free in leaf pages. */   1458          u_int32_t bt_dup_pgfree;         /* Bytes free in duplicate pages. */   1459          u_int32_t bt_over_pgfree;        /* Bytes free in overflow pages. */   1460  };  1461    1462   /* Hash statistics structure. */   1463  struct  __db_h_stat  {  1464          u_int32_t hash_magic;            /* Magic number. */   1465          u_int32_t hash_version;          /* Version number. */   1466          u_int32_t hash_metaflags;        /* Metadata flags. */   1467          u_int32_t hash_nkeys;            /* Number of unique keys. */   1468          u_int32_t hash_ndata;            /* Number of data items. */   1469          u_int32_t hash_pagesize;         /* Page size. */   1470          u_int32_t hash_ffactor;          /* Fill factor specified at create. */   1471          u_int32_t hash_buckets;          /* Number of hash buckets. */   1472          u_int32_t hash_free;             /* Pages on the free list. */   1473          u_int32_t hash_bfree;            /* Bytes free on bucket pages. */   1474          u_int32_t hash_bigpages;         /* Number of big key/data pages. */   1475          u_int32_t hash_big_bfree;        /* Bytes free on big item pages. */   1476          u_int32_t hash_overflows;        /* Number of overflow pages. */   1477          u_int32_t hash_ovfl_free;        /* Bytes free on ovfl pages. */   1478          u_int32_t hash_dup;              /* Number of dup pages. */   1479          u_int32_t hash_dup_free;         /* Bytes free on duplicate pages. */   1480  };  1481    1482   /* Queue statistics structure. */   1483  struct  __db_qam_stat  {  1484          u_int32_t qs_magic;              /* Magic number. */   1485          u_int32_t qs_version;            /* Version number. */   1486          u_int32_t qs_metaflags;          /* Metadata flags. */   1487          u_int32_t qs_nkeys;              /* Number of unique keys. */   1488          u_int32_t qs_ndata;              /* Number of data items. */   1489          u_int32_t qs_pagesize;           /* Page size. */   1490          u_int32_t qs_extentsize;         /* Pages per extent. */   1491          u_int32_t qs_pages;              /* Data pages. */   1492          u_int32_t qs_re_len;             /* Fixed-length record length. */   1493          u_int32_t qs_re_pad;             /* Fixed-length record pad. */   1494          u_int32_t qs_pgfree;             /* Bytes free in data pages. */   1495          u_int32_t qs_first_recno;        /* First not deleted record. */   1496          u_int32_t qs_cur_recno;          /* Next available record number. */   1497  };  1498    1499   /*******************************************************   1500    * Environment.   1501    *******************************************************/   1502  #define  DB_REGION_MAGIC  0x120897         /* Environment magic number. */   1503    1504   /* Database Environment handle. */   1505  struct  __db_env  {  1506           /*******************************************************   1507            * Public: owned by the application.   1508            *******************************************************/   1509          FILE            *db_errfile;     /* Error message file stream. */   1510          const char      *db_errpfx;      /* Error message prefix. */   1511                                           /* Callbacks. */   1512          void (*db_errcall)  __P ((const char *, char *));  1513          void (*db_feedback)  __P (( DB_ENV  *, int, int));  1514          void (*db_paniccall)  __P (( DB_ENV  *, int));  1515    1516                                           /* App-specified alloc functions. */   1517          void *(*db_malloc)  __P ((size_t));  1518          void *(*db_realloc)  __P ((void *, size_t));  1519          void (*db_free)  __P ((void *));  1520    1521           /*   1522            * Currently, the verbose list is a bit field with room for 32   1523            * entries.  There's no reason that it needs to be limited, if   1524            * there are ever more than 32 entries, convert to a bit array.   1525            */   1526  #define  DB_VERB_CHKPOINT         0x0001   /* List checkpoints. */   1527  #define  DB_VERB_DEADLOCK         0x0002   /* Deadlock detection information. */   1528  #define  DB_VERB_RECOVERY         0x0004   /* Recovery information. */   1529  #define  DB_VERB_REPLICATION      0x0008   /* Replication information. */   1530  #define  DB_VERB_WAITSFOR         0x0010   /* Dump waits-for table. */   1531          u_int32_t         verbose ;        /* Verbose output. */   1532    1533          void            *app_private;    /* Application-private handle. */   1534    1535          int (*app_dispatch)              /* User-specified recovery dispatch. */   1536               __P (( DB_ENV  *,  DBT  *,  DB_LSN  *,  db_recops ));  1537    1538           /* Locking. */   1539          u_int8_t        *lk_conflicts;   /* Two dimensional conflict matrix. */   1540          u_int32_t        lk_modes;       /* Number of lock modes in table. */   1541          u_int32_t        lk_max;         /* Maximum number of locks. */   1542          u_int32_t        lk_max_lockers; /* Maximum number of lockers. */   1543          u_int32_t        lk_max_objects; /* Maximum number of locked objects. */   1544          u_int32_t        lk_detect;      /* Deadlock detect on all conflicts. */   1545           db_timeout_t      lk_timeout;     /* Lock timeout period. */   1546    1547           /* Logging. */   1548          u_int32_t        lg_bsize;       /* Buffer size. */   1549          u_int32_t        lg_size;        /* Log file size. */   1550          u_int32_t        lg_regionmax;   /* Region size. */   1551    1552           /* Memory pool. */   1553          u_int32_t        mp_gbytes;      /* Cachesize: GB. */   1554          u_int32_t        mp_bytes;       /* Cachesize: Bytes. */   1555          size_t           mp_size;        /* DEPRECATED: Cachesize: bytes. */   1556          int              mp_ncache;      /* Number of cache regions. */   1557          size_t           mp_mmapsize;    /* Maximum file size for mmap. */   1558    1559          int              rep_eid;        /* environment id. */   1560    1561           /* Transactions. */   1562          u_int32_t        tx_max;         /* Maximum number of transactions. */   1563          time_t           tx_timestamp;   /* Recover to specific timestamp. */   1564           db_timeout_t      tx_timeout;     /* Timeout for transactions. */   1565    1566           /*******************************************************   1567            * Private: owned by DB.   1568            *******************************************************/   1569          int              panic_errval;   /* Panic causing errno. */   1570    1571                                           /* User files, paths. */   1572          char            *db_home;        /* Database home. */   1573          char            *db_log_dir;     /* Database log file directory. */   1574          char            *db_tmp_dir;     /* Database tmp file directory. */   1575    1576          char           **db_data_dir;    /* Database data file directories. */   1577          int              data_cnt;       /* Database data file slots. */   1578          int              data_next;      /* Next Database data file slot. */   1579    1580          int              db_mode;        /* Default open permissions. */   1581    1582          void            *reginfo;        /* REGINFO structure reference. */   1583           DB_FH            *lockfhp;        /* fcntl(2) locking file handle. */   1584    1585          int           (**recover_dtab)   /* Dispatch table for recover funcs. */   1586                               __P (( DB_ENV  *,  DBT  *,  DB_LSN  *,  db_recops , void *));  1587          size_t           recover_dtab_size;  1588                                           /* Slots in the dispatch table. */   1589    1590          void            *cl_handle;      /* RPC: remote client handle. */   1591          long             cl_id;          /* RPC: remote client env id. */   1592    1593          int              db_ref;         /* DB reference count. */   1594    1595          long             shm_key;        /* shmget(2) key. */   1596          u_int32_t        tas_spins;      /* test-and-set spins. */   1597    1598           /*   1599            * List of open DB handles for this DB_ENV, used for cursor   1600            * adjustment.  Must be protected for multi-threaded support.   1601            *   1602            * !!!   1603            * As this structure is allocated in per-process memory, the   1604            * mutex may need to be stored elsewhere on architectures unable   1605            * to support mutexes in heap memory, e.g. HP/UX 9.   1606            *   1607            * !!!   1608            * Explicit representation of structure in queue.h.   1609            * LIST_HEAD(dblist, __db);   1610            */   1611           DB_MUTEX         *dblist_mutexp;  /* Mutex. */   1612          struct {  1613                  struct  __db  *lh_first;  1614          } dblist;  1615    1616           /*   1617            * XA support.   1618            *   1619            * !!!   1620            * Explicit representations of structures from queue.h.   1621            * TAILQ_ENTRY(__db_env) links;   1622            */   1623          struct {  1624                  struct  __db_env  *tqe_next;  1625                  struct  __db_env  **tqe_prev;  1626          } links;  1627          int              xa_rmid;        /* XA Resource Manager ID. */   1628           DB_TXN           *xa_txn;         /* XA Current transaction. */   1629    1630           /* API-private structure. */   1631          void            *api1_internal;  /* C++, Perl API private */   1632          void            *api2_internal;  /* Java API private */   1633    1634          char            *passwd;         /* Cryptography support. */   1635          size_t           passwd_len;  1636          void            *crypto_handle;  /* Primary handle. */   1637           DB_MUTEX         *mt_mutexp;      /* Mersenne Twister mutex. */   1638          int              mti;            /* Mersenne Twister index. */   1639          u_long          *mt;             /* Mersenne Twister state vector. */   1640    1641                                           /* DB_ENV Methods. */   1642          int  (* close )  __P (( DB_ENV  *, u_int32_t));  1643          int  (*dbremove)  __P (( DB_ENV  *,  1644               DB_TXN  *, const char *, const char *, u_int32_t));  1645          int  (*dbrename)  __P (( DB_ENV  *,  DB_TXN  *,  1646              const char *, const char *, const char *, u_int32_t));  1647          void (* err )  __P ((const  DB_ENV  *, int, const char *, ...));  1648          void (*errx)  __P ((const  DB_ENV  *, const char *, ...));  1649          int  (* open )  __P (( DB_ENV  *, const char *, u_int32_t, int));  1650          int  (* remove )  __P (( DB_ENV  *, const char *, u_int32_t));  1651          int  (*set_data_dir)  __P (( DB_ENV  *, const char *));  1652          int  (*set_alloc)  __P (( DB_ENV  *, void *(*)(size_t),  1653                  void *(*)(void *, size_t), void (*)(void *)));  1654          int  (*set_app_dispatch)  __P (( DB_ENV  *,  1655                  int (*)( DB_ENV  *,  DBT  *,  DB_LSN  *,  db_recops )));  1656          int  (*set_encrypt)  __P (( DB_ENV  *, const char *, u_int32_t));  1657          void (*set_errcall)  __P (( DB_ENV  *, void (*)(const char *, char *)));  1658          void (*set_errfile)  __P (( DB_ENV  *, FILE *));  1659          void (*set_errpfx)  __P (( DB_ENV  *, const char *));  1660          int  (*set_feedback)  __P (( DB_ENV  *, void (*)( DB_ENV  *, int, int)));  1661          int  (*set_flags)  __P (( DB_ENV  *, u_int32_t, int));  1662          int  (*set_paniccall)  __P (( DB_ENV  *, void (*)( DB_ENV  *, int)));  1663          int  (*set_rpc_server)  __P (( DB_ENV  *,  1664                  void *, const char *, long, long, u_int32_t));  1665          int  (*set_shm_key)  __P (( DB_ENV  *, long));  1666          int  (*set_tas_spins)  __P (( DB_ENV  *, u_int32_t));  1667          int  (*set_tmp_dir)  __P (( DB_ENV  *, const char *));  1668          int  (*set_verbose)  __P (( DB_ENV  *, u_int32_t, int));  1669    1670          void *lg_handle;                 /* Log handle and methods. */   1671          int  (*set_lg_bsize)  __P (( DB_ENV  *, u_int32_t));  1672          int  (*set_lg_dir)  __P (( DB_ENV  *, const char *));  1673          int  (*set_lg_max)  __P (( DB_ENV  *, u_int32_t));  1674          int  (*set_lg_regionmax)  __P (( DB_ENV  *, u_int32_t));  1675          int  (*log_archive)  __P (( DB_ENV  *, char **[], u_int32_t));  1676          int  (*log_cursor)  __P (( DB_ENV  *,  DB_LOGC  **, u_int32_t));  1677          int  (*log_file)  __P (( DB_ENV  *, const  DB_LSN  *, char *, size_t));  1678          int  (*log_flush)  __P (( DB_ENV  *, const  DB_LSN  *));  1679          int  (*log_put)  __P (( DB_ENV  *,  DB_LSN  *, const  DBT  *, u_int32_t));  1680          int  (*log_stat)  __P (( DB_ENV  *,  DB_LOG_STAT  **, u_int32_t));  1681    1682          void *lk_handle;                 /* Lock handle and methods. */   1683          int  (*set_lk_conflicts)  __P (( DB_ENV  *, u_int8_t *, int));  1684          int  (*set_lk_detect)  __P (( DB_ENV  *, u_int32_t));  1685          int  (*set_lk_max)  __P (( DB_ENV  *, u_int32_t));  1686          int  (*set_lk_max_locks)  __P (( DB_ENV  *, u_int32_t));  1687          int  (*set_lk_max_lockers)  __P (( DB_ENV  *, u_int32_t));  1688          int  (*set_lk_max_objects)  __P (( DB_ENV  *, u_int32_t));  1689          int  (*lock_detect)  __P (( DB_ENV  *, u_int32_t, u_int32_t, int *));  1690          int  (*lock_dump_region)  __P (( DB_ENV  *, char *, FILE *));  1691          int  (*lock_get)  __P (( DB_ENV  *,  1692                  u_int32_t, u_int32_t, const  DBT  *,  db_lockmode_t ,  DB_LOCK  *));  1693          int  (*lock_put)  __P (( DB_ENV  *,  DB_LOCK  *));  1694          int  (*lock_id)  __P (( DB_ENV  *, u_int32_t *));  1695          int  (*lock_id_free)  __P (( DB_ENV  *, u_int32_t));  1696          int  (*lock_id_set)  __P (( DB_ENV  *, u_int32_t, u_int32_t));  1697          int  (*lock_stat)  __P (( DB_ENV  *,  DB_LOCK_STAT  **, u_int32_t));  1698          int  (*lock_vec)  __P (( DB_ENV  *,  1699                  u_int32_t, u_int32_t,  DB_LOCKREQ  *, int,  DB_LOCKREQ  **));  1700          int  (*lock_downgrade)  __P (( DB_ENV  *,  1701                   DB_LOCK  *,  db_lockmode_t , u_int32_t));  1702    1703          void *mp_handle;                 /* Mpool handle and methods. */   1704          int  (*set_mp_mmapsize)  __P (( DB_ENV  *, size_t));  1705          int  (*set_cachesize)  __P (( DB_ENV  *, u_int32_t, u_int32_t, int));  1706          int  (*memp_dump_region)  __P (( DB_ENV  *, char *, FILE *));  1707          int  (*memp_fcreate)  __P (( DB_ENV  *,  DB_MPOOLFILE  **, u_int32_t));  1708          int  (*memp_nameop)  __P (( DB_ENV  *,  1709                  u_int8_t *, const char *, const char *, const char *));  1710          int  (*memp_register)  __P (( DB_ENV  *, int,  1711                  int (*)( DB_ENV  *,  db_pgno_t , void *,  DBT  *),  1712                  int (*)( DB_ENV  *,  db_pgno_t , void *,  DBT  *)));  1713          int  (*memp_stat)  __P (( DB_ENV  *,  1714                   DB_MPOOL_STAT  **,  DB_MPOOL_FSTAT  ***, u_int32_t));  1715          int  (*memp_sync)  __P (( DB_ENV  *,  DB_LSN  *));  1716          int  (*memp_trickle)  __P (( DB_ENV  *, int, int *));  1717    1718          void *rep_handle;                /* Replication handle and methods. */   1719          int  (*rep_elect)  __P (( DB_ENV  *, int, int, u_int32_t, int *));  1720          int  (*rep_flush)  __P (( DB_ENV  *));  1721          int  (*rep_process_message)  __P (( DB_ENV  *,  DBT  *,  DBT  *, int *));  1722          int  (*rep_start)  __P (( DB_ENV  *,  DBT  *, u_int32_t));  1723          int  (*rep_stat)  __P (( DB_ENV  *,  DB_REP_STAT  **, u_int32_t));  1724          int  (*set_rep_election)  __P (( DB_ENV  *,  1725                  u_int32_t, u_int32_t, u_int32_t, u_int32_t));  1726          int  (*set_rep_limit)  __P (( DB_ENV  *, u_int32_t, u_int32_t));  1727          int  (*set_rep_request)  __P (( DB_ENV  *, u_int32_t, u_int32_t));  1728          int  (*set_rep_timeout)  __P (( DB_ENV  *, u_int32_t, u_int32_t));  1729          int  (*set_rep_transport)  __P (( DB_ENV  *, int,  1730                  int (*) ( DB_ENV  *, const  DBT  *, const  DBT  *, int, u_int32_t)));  1731    1732          void *tx_handle;                 /* Txn handle and methods. */   1733          int  (*set_tx_max)  __P (( DB_ENV  *, u_int32_t));  1734          int  (*set_tx_timestamp)  __P (( DB_ENV  *, time_t *));  1735          int  (*txn_begin)  __P (( DB_ENV  *,  DB_TXN  *,  DB_TXN  **, u_int32_t));  1736          int  (*txn_checkpoint)  __P (( DB_ENV  *, u_int32_t, u_int32_t, u_int32_t));  1737          int  (*txn_id_set)  __P (( DB_ENV  *, u_int32_t, u_int32_t));  1738          int  (*txn_recover)  __P (( DB_ENV  *,  1739                   DB_PREPLIST  *, long, long *, u_int32_t));  1740          int  (*txn_stat)  __P (( DB_ENV  *,  DB_TXN_STAT  **, u_int32_t));  1741          int  (*set_timeout)  __P (( DB_ENV  *,  db_timeout_t , u_int32_t));  1742    1743  #define  DB_TEST_ELECTINIT         1       /* after __rep_elect_init */   1744  #define  DB_TEST_ELECTSEND         2       /* after REP_ELECT msgnit */   1745  #define  DB_TEST_ELECTVOTE1        3       /* after __rep_send_vote 1 */   1746  #define  DB_TEST_ELECTVOTE2        4       /* after __rep_wait */   1747  #define  DB_TEST_ELECTWAIT1        5       /* after REP_VOTE2 */   1748  #define  DB_TEST_ELECTWAIT2        6       /* after __rep_wait 2 */   1749  #define  DB_TEST_PREDESTROY        7       /* before destroy op */   1750  #define  DB_TEST_PREOPEN           8       /* before __os_open */   1751  #define  DB_TEST_POSTDESTROY       9       /* after destroy op */   1752  #define  DB_TEST_POSTLOG           10      /* after logging all pages */   1753  #define  DB_TEST_POSTLOGMETA       11      /* after logging meta in btree */   1754  #define  DB_TEST_POSTOPEN          12      /* after __os_open */   1755  #define  DB_TEST_POSTSYNC          13      /* after syncing the log */   1756  #define  DB_TEST_SUBDB_LOCKS       14      /* subdb locking tests */   1757          int              test_abort;     /* Abort value for testing. */   1758          int              test_copy;      /* Copy value for testing. */   1759    1760  #define  DB_ENV_AUTO_COMMIT       0x0000001  /* DB_AUTO_COMMIT. */   1761  #define  DB_ENV_CDB               0x0000002  /* DB_INIT_CDB. */   1762  #define  DB_ENV_CDB_ALLDB         0x0000004  /* CDB environment wide locking. */   1763  #define  DB_ENV_CREATE            0x0000008  /* DB_CREATE set. */   1764  #define  DB_ENV_DBLOCAL           0x0000010  /* DB_ENV allocated for private DB. */   1765  #define  DB_ENV_DIRECT_DB         0x0000020  /* DB_DIRECT_DB set. */   1766  #define  DB_ENV_DIRECT_LOG        0x0000040  /* DB_DIRECT_LOG set. */   1767  #define  DB_ENV_FATAL             0x0000080  /* Doing fatal recovery in env. */   1768  #define  DB_ENV_LOCKDOWN          0x0000100  /* DB_LOCKDOWN set. */   1769  #define  DB_ENV_NOLOCKING         0x0000200  /* DB_NOLOCKING set. */   1770  #define  DB_ENV_NOMMAP            0x0000400  /* DB_NOMMAP set. */   1771  #define  DB_ENV_NOPANIC           0x0000800  /* Okay if panic set. */   1772  #define  DB_ENV_OPEN_CALLED       0x0001000  /* DB_ENV->open called. */   1773  #define  DB_ENV_OVERWRITE         0x0002000  /* DB_OVERWRITE set. */   1774  #define  DB_ENV_PRIVATE           0x0004000  /* DB_PRIVATE set. */   1775  #define  DB_ENV_REGION_INIT       0x0008000  /* DB_REGION_INIT set. */   1776  #define  DB_ENV_REP_CLIENT        0x0010000  /* Replication client. */   1777  #define  DB_ENV_REP_LOGSONLY      0x0020000  /* Log files only replication site. */   1778  #define  DB_ENV_REP_MASTER        0x0040000  /* Replication master. */   1779  #define  DB_ENV_RPCCLIENT         0x0080000  /* DB_CLIENT set. */   1780  #define  DB_ENV_RPCCLIENT_GIVEN   0x0100000  /* User-supplied RPC client struct */   1781  #define  DB_ENV_SYSTEM_MEM        0x0200000  /* DB_SYSTEM_MEM set. */   1782  #define  DB_ENV_THREAD            0x0400000  /* DB_THREAD set. */   1783  #define  DB_ENV_TXN_NOSYNC        0x0800000  /* DB_TXN_NOSYNC set. */   1784  #define  DB_ENV_TXN_WRITE_NOSYNC  0x1000000  /* DB_TXN_WRITE_NOSYNC set. */   1785  #define  DB_ENV_YIELDCPU          0x2000000  /* DB_YIELDCPU set. */   1786          u_int32_t flags;  1787  };  1788    1789  #ifndef  DB_DBM_HSEARCH   1790  #define  DB_DBM_HSEARCH   0                /* No historic interfaces by default. */   1791  #endif  1792  #if  DB_DBM_HSEARCH  != 0  1793   /*******************************************************   1794    * Dbm/Ndbm historic interfaces.   1795    *******************************************************/   1796  typedef struct  __db   DBM ;  1797    1798  #define  DBM_INSERT       0                /* Flags to dbm_store(). */   1799  #define  DBM_REPLACE      1  1800    1801   /*   1802    * The DB support for ndbm(3) always appends this suffix to the   1803    * file name to avoid overwriting the user's original database.   1804    */   1805  #define  DBM_SUFFIX        "".db""   1806    1807  #if defined(_XPG4_2)  1808  typedef struct {  1809          char *dptr;  1810          size_t dsize;  1811  }  datum ;  1812  #else  1813  typedef struct {  1814          char *dptr;  1815          int dsize;  1816  }  datum ;  1817  #endif  1818    1819   /*   1820    * Translate NDBM calls into DB calls so that DB doesn't step on the   1821    * application's name space.   1822    */   1823  #define  dbm_clearerr (a)         __db_ndbm_clearerr(a)  1824  #define  dbm_close (a)            __db_ndbm_close(a)  1825  #define  dbm_delete (a,  b )        __db_ndbm_delete(a,  b )  1826  #define  dbm_dirfno (a)           __db_ndbm_dirfno(a)  1827  #define  dbm_error (a)            __db_ndbm_error(a)  1828  #define  dbm_fetch (a,  b )         __db_ndbm_fetch(a,  b )  1829  #define  dbm_firstkey (a)         __db_ndbm_firstkey(a)  1830  #define  dbm_nextkey (a)          __db_ndbm_nextkey(a)  1831  #define  dbm_open (a,  b ,  c )       __db_ndbm_open(a,  b ,  c )  1832  #define  dbm_pagfno (a)           __db_ndbm_pagfno(a)  1833  #define  dbm_rdonly (a)           __db_ndbm_rdonly(a)  1834  #define  dbm_store (a,  b ,  c ,  d ) \  1835          __db_ndbm_store(a,  b ,  c ,  d )  1836    1837   /*   1838    * Translate DBM calls into DB calls so that DB doesn't step on the   1839    * application's name space.   1840    *   1841    * The global variables dbrdonly, dirf and pagf were not retained when 4BSD   1842    * replaced the dbm interface with ndbm, and are not supported here.   1843    */   1844  #define  dbminit (a)      __db_dbm_init(a)  1845  #define  dbmclose         __db_dbm_close  1846  #if !defined(__cplusplus)  1847  #define  delete (a)       __db_dbm_delete(a)  1848  #endif  1849  #define  fetch (a)        __db_dbm_fetch(a)  1850  #define  firstkey         __db_dbm_firstkey  1851  #define  nextkey (a)      __db_dbm_nextkey(a)  1852  #define  store (a,  b )     __db_dbm_store(a,  b )  1853    1854   /*******************************************************   1855    * Hsearch historic interface.   1856    *******************************************************/   1857  typedef enum {  1858          FIND, ENTER  1859  }  ACTION ;  1860    1861  typedef struct  entry  {  1862          char *key;  1863          char *data;  1864  }  ENTRY ;  1865    1866  #define  hcreate (a)      __db_hcreate(a)  1867  #define  hdestroy         __db_hdestroy  1868  #define  hsearch (a,  b )   __db_hsearch(a,  b )  1869    1870  #endif  /* DB_DBM_HSEARCH */   1871    1872  #if defined(__cplusplus)  1873  }"
GX031-86-10006475	Next:   Thread Safety and the    Up:   The RNG Random Number    Previous:   Packing and Unpacking RNG           A Note on Mixing Generators       All of the random number generators currently implemented in the RNG library use the type Rng_Type, a 64-bit unsigned object, to implement the random number state. Each generator, however, spans its own range of values governed by the properties of its recurrence relation and any constraints on the starting value used.    The 64-bit lcg described in Section  3.1  spans all possible values of the 64-bit Rng_Type, zero included. The 48-bit lcg of Section  3.2  uses only 48 bits. The state, in this case, spans the range [0,2 48 ). The 48-bit CRI compatible LCG of Section  3.3  uses only 48 bits and the state, in this case, must be odd.  The prime modulus generators, with modulus P, produce state, x, which spans the range   1 x  <  P .    It is important that one does not mix generators for a given random number stream, for example initializing a Rng_Type with the 64-bit generator, and using one of the other generators to produce random values using this random number state. Results of such mixing between generators may be unpredictable.                             Next:   Thread Safety and the    Up:   The RNG Random Number    Previous:   Packing and Unpacking RNG
GX059-14-13398304	"NCBI Home       IEB Home       C++ Toolkit docs       C Toolkit source browser       C Toolkit source browser (2)               NCBI C++ Toolkit Cross Reference       C++ / compilers / mac_prj / makeLibs.met                  source navigation    diff markup    identifier search    freetext search    file search                   1      2      3  -- C++ libs --    4      5  property pRootFolderName : ""ncbi_cxx"" -- name of the toolkit directory    6  property pRootFolderPath : """" -- full path of the parent of the toolkit directory. Optional    7  property pFLTKRootFolder : """" -- full path of the FLTK directory. Optional.    8  property pBdbRootFolder : """" -- full path of the BDB source folder. Optional.    9  property pSqliteRootFolder : """" -- full path of the Sqlite source folder. Optional   10  property pDLRootFolder : ""sw:"" -- root folder for the dlcompat library & header file. Usually sw: or usr:.   11     12  property pSaveContinueOnErrors : false   13  -- true if we want to save compilation errors in a file and continue.   14  -- false if we want to stop on an error.   15     16  property pProjectFileExt : "".mcp""   17  property pAppExt : "".app""   18  property pCPlusPlusExt : "".cpp""   19  property pStaticLibExt : "".lib""   20  property pPluginExt : "".so""   21  property pDynaLibExt : "".dylib""   22     23  -- Whether to recreate existing project files.   24  property pAlwaysCreateProjects : false   25     26  -- whether to refresh the files and libraries in existing projects   27  property pUpdateExistingProjects : true   28     29  -- Whether to have the projects use CVS or not.   30  property pProjectsCVSEnabled : true   31     32  -- But profiling doesn't work for Mach-O Codewarrior projects currently.   33  property pCreateProfiledTargets : false   34     35  -- Whether to compile anything.   36  property pShouldBuild : true   37     38  -- Whether to create projects in the specified category.   39  property pCreateCoreLibs : true   40  property pCreateSocketLibs : true (* whether to create/compile socket libs *)   41  property pCreateObjectLibs : true (* whether to create/compile object libraries *)   42  property pCreateObjToolsLibs : true   43  property pCreateGuiLibs : true   44  property pCreatePluginLibs : true   45     46  property pStationeryName : ""LibraryStationery""   47  property pPluginStationeryName : ""PluginStationery""   48  property pDylibStationeryName : ""DLLStationery""   49     50  property pTargetKeyWords : {""BSD"", ""MSL"", ""Final"", ""Debug""}   51  property pDefaultTargets : {""BSD"", ""Debug""}   52     53  --   54  --  Set Global variables   55  --   56     57  global gHomeDir   58  global gDistribRoot   59  global gProjectsDir   60  global gPluginsDir   61  global gSourceDir   62  global gIncludeDir   63  global gRsrcsDir   64  global gMakeDir   65  global gLibsDir   66  global gFLTKRootFolder   67  global gBdbRootFolder   68  global gSqliteSrcFolder -- where sqlite source is located.   69  global gSqliteRootFolder -- sqlite install folder.  (not source).   70     71     72  global gProjectData   73     74  on ProjectData(projName, features, aFileData)   75             76          if (count characters of projName) > 25 then   77                  set projName to characters 1 through 25 of projName as string   78          end if   79             80          tell application ""CodeWarrior IDE""   81                     82                  if features does not contain ""C"" and features does not contain ""C++"" then   83                          copy ""C++"" to end of features   84                  end if   85                  set myFeatures to features   86                     87                  return {name:projName, features:myFeatures, rsrcs:{}, settings:   88                          {Prefix File:"""", ppcProject:{}}, projLibs:{}, dynaLibs:{}, sysPaths:{}, fileData:   89                          aFileData}   90                     91          end tell   92  end ProjectData   93     94  on AddProject(projData)   95          copy projData to end of gProjectData   96  end AddProject   97     98  on AddSimpleProject(projName, features, section)   99          AddProject(ProjectData(projName, features, {mkFileData(gSourceDir & section)}))  100  end AddSimpleProject  101    102  on AddSimpleProjectListFiles(projName, features, section, fileList)  103          AddProject(ProjectData(projName, features, {mkFileDataListFiles(gSourceDir & section, fileList)}))  104  end AddSimpleProjectListFiles  105    106  on AddSimpleProjectExceptFiles(projName, features, section, fileNotList)  107          AddProject(ProjectData(projName, features, {mkFileDataExceptFiles(gSourceDir & section, fileNotList)}))  108  end AddSimpleProjectExceptFiles  109    110  on mkFileData(fullPath)  111          if (fullPath does not end with "":"") then set fullPath to fullPath & "":""  112          return {projPath:fullPath, fileList:GetFileNames(fullPath), fileNotList:{}}  113  end mkFileData  114    115  on mkFileDataListFiles(fullPath, fileList)  116          if (fullPath does not end with "":"") then set fullPath to fullPath & "":""  117          return {projPath:fullPath, fileList:fileList, fileNotList:{}}  118  end mkFileDataListFiles  119    120  on mkFileDataExceptFiles(fullPath, fileNotList)  121          if (fullPath does not end with "":"") then set fullPath to fullPath & "":""  122          set theFileList to GetFileNames(fullPath)  123          set theRealFileList to {}  124          repeat with f in theFileList  125                  if fileNotList does not contain f then  126                          copy f to the end of theRealFileList  127                  end if  128          end repeat  129          return {projPath:fullPath, fileList:theRealFileList, fileNotList:fileNotList}  130  end mkFileDataExceptFiles  131    132  on ObjectFileData(objName, extraFileList)  133          set projPath to ""objects:"" & objName  134          set projFiles to {objName & ""__"", objName & ""___""} & extraFileList  135          return mkFileDataListFiles(gSourceDir & projPath, projFiles)  136  end ObjectFileData  137    138  on ObjectsFileData(nameList)  139          set fileData to {}  140          repeat with f in nameList  141                  copy ObjectFileData(f, {}) to end of fileData  142          end repeat  143          return fileData  144  end ObjectsFileData  145    146  on ObjectData(objName, extraFileList)  147          return ProjectData(objName, {}, {ObjectFileData(objName, extraFileList)})  148  end ObjectData  149    150  on AddObject(projName)  151          AddProject(ObjectData(projName, {}))  152  end AddObject  153    154  on GuiFileData(section)  155          if section does not start with ""gui:"" then  156                  set section to ""gui:"" & section  157          end if  158          -- Get all the files, minus those whose basename ends with an underscore.  159          set fileData to mkFileData(gSourceDir & section)  160          set newFileList to {}  161          repeat with f in fileList of fileData  162                  if f does not end with (""_"" & pCPlusPlusExt) then  163                          copy f as string to end of newFileList  164                  end if  165          end repeat  166          set fileList of fileData to newFileList  167          return fileData  168  end GuiFileData  169    170  on GuiFileDataExcept(section, notFiles)  171          if section does not start with ""gui:"" then  172                  set section to ""gui:"" & section  173          end if  174          -- Get all the files, minus those whose basename ends with an underscore.  175          set fileData to mkFileDataExceptFiles(gSourceDir & section, notFiles)  176          set newFileList to {}  177          repeat with f in fileList of fileData  178                  if f does not end with (""_"" & pCPlusPlusExt) then  179                          copy f as string to end of newFileList  180                  end if  181          end repeat  182          set fileList of fileData to newFileList  183          return fileData  184  end GuiFileDataExcept  185    186  on GuiFileDataList(section, fileList)  187          if section does not start with ""gui:"" then  188                  set section to ""gui:"" & section  189          end if  190          return mkFileDataListFiles(gSourceDir & section, fileList)  191  end GuiFileDataList  192    193  on GuiProjectData(projName, features, section)  194          if features does not contain ""fltk"" then  195                  copy ""fltk"" to end of features  196          end if  197          return (ProjectData(projName, features, {GuiFileData(section)}))  198  end GuiProjectData  199    200  on AddGuiProject(projName, features, section)  201          AddProject(GuiProjectData(projName, features, section))  202  end AddGuiProject  203    204  on AddPlugin(projName, features, section, staticLibs)  205          if features does not contain ""plugin"" then set features to features & {""plugin""}  206          set projData to GuiProjectData(projName, features, section)  207          AddProject(DataPlusLibs(projData, staticLibs, {""gui_core""}))  208  end AddPlugin  209    210  on DataPlusSources(dataRec, newSrcs)  211          repeat with i in newSrcs  212                  copy i to end of fileList of item 1 of fileData of dataRec  213          end repeat  214          return dataRec  215  end DataPlusSources  216    217  on DataPlusLibs(dataRec, newLibs, newDlls)  218          repeat with i in newLibs  219                  copy i to end of projLibs of dataRec  220          end repeat  221          repeat with i in newDlls  222                  copy i to end of dynaLibs of dataRec  223          end repeat  224          return dataRec  225  end DataPlusLibs  226    227  on HideFolder(folderPath)  228          tell application ""Finder""  229                  if exists folder folderPath then  230                          set theName to name of folder folderPath  231                          set name of folder folderPath to (""("" & theName & "")"")  232                  end if  233          end tell  234  end HideFolder  235    236  on GetFileNames(fullSourcePath)  237          set theFiles to list folder (fullSourcePath) without invisibles  238          set theCFiles to EndsWith(theFiles, "".c"")  239          set theCppFiles to EndsWith(theFiles, pCPlusPlusExt)  240          return theCFiles & theCppFiles  241  end GetFileNames  242    243  on EndsWith(aList, suffix)  244          set newList to {}  245          repeat with f in aList  246                  if (f ends with suffix) then  247                          copy (f as string) to end of newList  248                  end if  249          end repeat  250          return newList  251  end EndsWith  252    253  on SetProjectData()  254            255          if pCreateCoreLibs then  256                  AddSimpleProjectExceptFiles(""xncbi"", {""libdl""}, ""corelib"", {""test_mt.cpp"", ""ncbi_os_mac.cpp""})  257                  AddSimpleProjectExceptFiles(""xcgi"", {}, ""cgi"", {""fcgi_run.cpp"", ""fcgibuf.cpp""})  258                  AddSimpleProject(""dbapi"", {}, ""dbapi"")  259                  AddSimpleProject(""dbapi_driver"", {}, ""dbapi:driver"")  260                  AddSimpleProject(""xhtml"", {}, ""html"")  261                  AddSimpleProjectListFiles(""xcser"", {}, ""serial"", {""asntypes.cpp"", ""serialasn.cpp""})  262                  AddSimpleProjectExceptFiles(""xser"", {}, ""serial"",   263                          {""asntypes.cpp"", ""object.cpp"", ""objstrb.cpp"", ""rtti.cpp"", ""serialasn.cpp""})  264                    265                  AddSimpleProject(""xutil"", {}, ""util"")  266                  AddSimpleProject(""regexp"", {}, ""util:regexp"")  267                  AddSimpleProject(""ximage"", {}, ""util:image"")  268                  AddSimpleProjectExceptFiles(""z"", {}, ""util:compress:zlib"",   269                          {""example.c"", ""maketree.c"", ""minigzip.c""})  270                  AddSimpleProjectListFiles(""bz2"", {}, ""util:compress:bzip2"",   271                          {""blocksort.c"", ""huffman.c"", ""crctable.c"", ""randtable.c"", ""compress.c"", ""decompress.c"", ""bzlib.c""})  272                  AddSimpleProject(""xcompress"", {}, ""util:compress"")  273                  AddSimpleProjectListFiles(""tables"", {}, ""util:tables"", {""raw_scoremat.c""})  274                  AddSimpleProject(""sequtil"", {}, ""util:sequtil"")  275                    276                  AddSimpleProject(""bdb"", {""bdb""}, ""bdb"")  277                    278                  AddSimpleProject(""xalgoalign"", {}, ""algo:align"")  279                  AddSimpleProject(""xalgoseq"", {}, ""algo:sequence"")  280                  AddSimpleProject(""xalgognomon"", {}, ""algo:gnomon"")  281                  set xblastfiles to {  282                          mkFileDataExceptFiles(gSourceDir & ""algo:blast:api"", {""db_blast.cpp""}),   283                          mkFileData(gSourceDir & ""algo:blast:core"")   284                                  }  285                  AddProject(ProjectData(""xblast"", {}, xblastfiles))  286                  AddSimpleProject(""blast"", {}, ""algo:blast:core"")  287                    288                  AddSimpleProject(""xsqlite"", {""sqlite""}, ""sqlite"")  289                    290                  set libdbFiles to {  291                          mkFileData(gBdbRootFolder & ""btree""),   292                          mkFileDataExceptFiles(gBdbRootFolder & ""common"", {""util_arg.c""}),   293                          mkFileData(gBdbRootFolder & ""crypto""),   294                          mkFileData(gBdbRootFolder & ""crypto:mersenne""),   295                          mkFileData(gBdbRootFolder & ""crypto:rijndael""),   296                          mkFileData(gBdbRootFolder & ""db""),   297                          mkFileData(gBdbRootFolder & ""dbm""),   298                          mkFileData(gBdbRootFolder & ""dbreg""),   299                          mkFileData(gBdbRootFolder & ""env""),   300                          mkFileData(gBdbRootFolder & ""fileops""),   301                          mkFileData(gBdbRootFolder & ""hash""),   302                          mkFileData(gBdbRootFolder & ""hmac""),   303                          mkFileData(gBdbRootFolder & ""hsearch""),   304                          mkFileData(gBdbRootFolder & ""lock""),   305                          mkFileData(gBdbRootFolder & ""log""),   306                          mkFileData(gBdbRootFolder & ""mp""),   307                          mkFileDataListFiles(gBdbRootFolder & ""mutex"", {""mutex.c"", ""mut_pthread.c""}),   308                          mkFileData(gBdbRootFolder & ""os""),   309                          mkFileData(gBdbRootFolder & ""qam""),   310                          mkFileData(gBdbRootFolder & ""rep""),   311                          mkFileData(gBdbRootFolder & ""txn""),   312                          mkFileData(gBdbRootFolder & ""xa"")}  313                  AddProject(ProjectData(""libdb"", {""bdblib""}, libdbFiles))  314          end if  315            316          if pCreateSocketLibs then  317                  -- Not needed or wanted under Mach-O  318                  -- my HideFolder(gSourceDir & ""connect:mitsock"")  319                    320                  AddSimpleProjectExceptFiles(""xconnect"", {}, ""connect"",   321                          {""ncbi_lbsm_ipc.c"", ""ncbi_lbsm.c"", ""ncbi_lbsmd.c"", ""threaded_server.cpp""})  322                  AddSimpleProjectListFiles(""xthrserv"", {}, ""connect"", {""threaded_server.cpp""})  323          end if  324            325          if pCreateObjectLibs then  326                  AddObject(""access"")  327                  AddObject(""biblio"")  328                  AddSimpleProjectListFiles(""xnetblast"", {}, ""objects:blast"", {""blast__"", ""blast___""})  329                  AddSimpleProjectListFiles(""xnetblastcli"", {}, ""objects:blast"", {""blastclient"", ""blastclient_""})  330                  AddObject(""blastdb"")  331                  AddObject(""cdd"")  332                  AddObject(""cn3d"")  333                  AddObject(""docsum"")  334                  AddObject(""entrez2"")  335                  AddSimpleProjectListFiles(""entrez2cli"", {}, ""objects:entrez2"", {""entrez2_client"", ""entrez2_client_""})  336                  AddObject(""entrezgene"")  337                  AddObject(""featdef"")  338                  AddObject(""gbseq"")  339                  AddObject(""general"")  340                  AddObject(""id1"")  341                  AddSimpleProjectListFiles(""id1cli"", {}, ""objects:id1"", {""id1_client"", ""id1_client_""})  342                  AddObject(""id2"")  343                  AddObject(""medlars"")  344                  AddObject(""medline"")  345                  AddObject(""mim"")  346                  AddObject(""mla"")  347                  AddSimpleProjectListFiles(""mlacli"", {}, ""objects:mla"", {""mla_client"", ""mla_client_""})  348                  AddProject(ProjectData(""mmdb"", {}, ObjectsFileData({""mmdb1"", ""mmdb2"", ""mmdb3""})))  349                  AddObject(""mmdb1"")  350                  AddObject(""mmdb2"")  351                  AddObject(""mmdb3"")  352                  AddObject(""ncbimime"")  353                  AddObject(""objprt"")  354                  AddObject(""proj"")  355                  AddObject(""pub"")  356                  AddObject(""pubmed"")  357                  AddObject(""scoremat"")  358                  -- combine in seq: seq, seqalign, seqblock, seqfeat, seqloc, seqres  359                  set seqFileData to {  360                          ObjectFileData(""seq"", {""gencode"", ""seqport_util""}),   361                          ObjectFileData(""seqalign"", {}),   362                          ObjectFileData(""seqblock"", {}),   363                          ObjectFileData(""seqfeat"", {}),   364                          ObjectFileData(""seqloc"", {}),   365                          ObjectFileData(""seqres"", {})}  366                  AddProject(ProjectData(""seq"", {}, seqFileData))  367                    368                  AddObject(""seqset"")  369                  AddObject(""seqcode"")  370                  AddObject(""submit"")  371                  AddProject(ObjectData(""taxon1"", {""cache"", ""ctreecont"", ""taxon1"", ""utils""}))  372                  AddObject(""tinyseq"")  373          end if  374            375          if pCreateObjToolsLibs then  376                  AddSimpleProject(""xobjmgr"", {}, ""objmgr"")  377                  AddSimpleProject(""xobjutil"", {}, ""objmgr:util"")  378                  AddSimpleProject(""xalnmgr"", {}, ""objtools:alnmgr"")  379                  AddSimpleProject(""xcddalignview"", {}, ""objtools:cddalignview"")  380                  AddSimpleProject(""xflat"", {}, ""objtools:flat"")  381                  AddSimpleProject(""lds"", {}, ""objtools:lds"")  382                  AddSimpleProject(""lds_admin"", {}, ""objtools:lds:admin"")  383                  AddSimpleProject(""xvalidate"", {}, ""objtools:validator"")  384                  AddSimpleProject(""xobjmanip"", {}, ""objtools:manip"")  385                  AddSimpleProject(""xobjread"", {}, ""objtools:readers"")  386                  AddSimpleProject(""xformat"", {}, ""objtools:format"")  387                    388                  AddSimpleProject(""ncbi_xloader_lds"", {}, ""objtools:data_loaders:lds"")  389                  AddSimpleProject(""ncbi_xloader_table"", {}, ""objtools:data_loaders:table"")  390                  -- AddSimpleProject(""ncbi_xloader_blastdb"", {}, ""objtools:data_loaders:blastdb"")        -- needs bsd? ctools?  391                  AddSimpleProject(""xloader_cdd"", {}, ""objtools:data_loaders:cdd"")  392          end if  393            394          -- GUI libs.  395          if pCreateGuiLibs then  396                  -- GuiProject's automatically have 'fltk' feature.  397                    398                  AddGuiProject(""gui_utils"", {}, ""utils"")  399                  -- AddGuiProject(""gui_config"", {}, ""config"")  400                  AddProject(ProjectData(""gui_config"", {""fltk""},   401                          {GuiFileDataList(""config"", {""config_dlg.cpp"", ""feat_config.cpp"", ""config_mediator.cpp"", ""settings_set.cpp"", ""config___.cpp"", ""config__.cpp""})}))  402                    403                  AddGuiProject(""gui_dlg_entry_form"", {}, ""dialogs:entry_form"")  404                  AddGuiProject(""gui_multi_col_dlg"", {}, ""dialogs:col"")  405                  AddGuiProject(""gui_dlg_registry"", {}, ""dialogs:registry"")  406                  AddGuiProject(""gui_dlg_progress"", {}, ""dialogs:progress"")  407                  -- AddGuiProject(""gui_dlg_feature"", {}, ""dialogs:feature"") -- empty  408                  -- AddGuiProject(""gui_dlg_general"", {}, ""dialogs:general"") -- currently empty?  409                  AddGuiProject(""gui_opengl"", {}, ""opengl"")  410                  AddGuiProject(""gui_graph"", {}, ""graph"")  411                  AddGuiProject(""gui_print"", {}, ""print"")  412                    413                  -- widgets  414                  AddGuiProject(""w_fltk"", {}, ""widgets:fl"")  415                  AddGuiProject(""w_gl"", {}, ""widgets:gl"")  416                  AddGuiProject(""w_aln_crossaln"", {}, ""widgets:aln_crossaln"")  417                  AddGuiProject(""w_aln_dotmatrix"", {}, ""widgets:aln_dotmatrix"")  418                  -- AddGuiProject(""w_aln_multi"", {}, ""widgets:aln_multiple"")  419                  AddProject(ProjectData(""w_aln_multi"", {""fltk""},   420                          {GuiFileDataExcept(""widgets:aln_multiple"", {""alnmulti_base_pane.cpp"", ""alnmulti_edit_pane.cpp""})}))  421                  AddGuiProject(""w_aln_data"", {}, ""widgets:aln_data"")  422                  AddGuiProject(""w_aln_text"", {}, ""widgets:aln_textaln"")  423                  AddGuiProject(""w_flu"", {}, ""widgets:FLU"")  424                  AddGuiProject(""w_seq_graphic"", {}, ""widgets:seq_graphic"")  425                  AddGuiProject(""w_toplevel"", {}, ""widgets:toplevel"")  426                  AddGuiProject(""w_fltable"", {}, ""widgets:Fl_Table"")  427                  AddGuiProject(""w_hit_matrix"", {}, ""widgets:hit_matrix"")  428                  -- AddGuiProject(""w_flek"", {}, ""widgets:Flek"") -- use w_fltk instead.  429                  -- AddGuiProject(""w_seq"", {}, ""widgets:seq"") -- empty  430                  --AddGuiProject(""w_seq_icon"", {}, ""widgets:seq_icon"") -- empty  431                  --AddGuiProject(""w_seq_info"", {}, ""widgets:seq_info"") -- empty  432                  -- AddGuiProject(""w_table"", {}, ""widgets:table"") -- merged into w_fltk  433                    434                  -- FLTK library.  435                  set saveCppExt to pCPlusPlusExt  436                  set pCPlusPlusExt to "".cxx""  437                  AddProject(ProjectData(""fltk"", {""fltklib""}, {mkFileDataExceptFiles(gFLTKRootFolder & ""src"",   438                          {""cmap.cxx"", ""dump_compose.c"", ""fl_color_mac.cxx"", ""fl_color_win32.cxx"",   439                                  ""fl_dnd_mac.cxx"", ""fl_dnd_win32.cxx"", ""fl_dnd_x.cxx"", ""fl_draw_image_mac.cxx"",   440                                  ""fl_draw_image_win32.cxx"", ""fl_font_mac.cxx"", ""fl_font_win32.cxx"", ""fl_font_x.cxx"",   441                                  ""fl_font_xft.cxx"", ""Fl_get_key_mac.cxx"", ""Fl_get_key_win32.cxx"", ""Fl_mac.cxx"",   442                                  ""fl_read_image_mac.cxx"", ""fl_read_image_win32.cxx"", ""fl_set_fonts_mac.cxx"",   443                                  ""fl_set_fonts_win32.cxx"", ""fl_set_fonts_x.cxx"", ""fl_set_fonts_xft.cxx"",   444                                  ""fl_set_gray.cxx"", ""Fl_Sys_Menu_Bar.cxx"", ""Fl_win32.cxx"", ""scandir_win32.c""})}))  445                  set pCPlusPlusExt to saveCppExt  446                    447          end if  448            449          if pCreatePluginLibs then  450                    451                  -- Plugin's automatically have fltk and plugin features.  452                  -- Plugins and DLL's must be after statics and DLL's they depend on.  453                    454                  set SeqObjects to {""seq"", ""seqcode"", ""seqset"", ""sequtil""}  455                  set SomeObjects to {""biblio"", ""general"", ""medline"", ""pub"", ""entrez2"", ""entrez2cli""}  456                  set MostObjects to SeqObjects & SomeObjects &   457                          {""dbapi_driver"", ""id1"", ""id2"", ""xobjmgr"", ""xobjutil""}  458                  set ObjTools to {""xconnect"", ""xncbi"", ""xser"", ""xutil"", ""xobjread"", ""xalnmgr"", ""regexp"", ""tables""}  459                  set LdsLibs to {""bdb"", ""lds"", ""lds_admin"", ""libdb""}  460                  set CompressLibs to {""z"", ""bz2"", ""xcompress""}  461                  set UsualStatics to MostObjects & ObjTools  462                    463                  -- gui_core ( contains:  xgbplugin, gui_core)  464                  set gui_core_files to {  465                          GuiFileDataList(""gui:plugin"", {""plugin__.cpp"", ""plugin___.cpp""}),   466                          GuiFileDataExcept(""gui:core"", {""plugin_thread.cpp""})}  467                  set gui_core_data to ProjectData(""gui_core"", {""DLL"", ""fltk"", ""libdl""}, gui_core_files)  468                    469                  AddProject(DataPlusLibs(gui_core_data, UsualStatics & LdsLibs & CompressLibs & {""gui_dlg_entry_form"", ""gui_utils"", ""gui_config"", ""gui_opengl"", ""ximage"", ""submit"", ""w_toplevel"", ""w_fltk"", ""w_flu"", ""w_fltable"", ""gui_print"", ""fltk""}, {}))  470                    471                  -- PLUGINS --  472                    473                  -- Basic/Required plugins  474                  AddPlugin(""gui_doc_basic"", {}, ""plugins:doc:basic"",   475                          {""xflat"", ""ncbi_xloader_lds"", ""gbseq""})  476                  AddPlugin(""gui_ncbi_init"", {}, ""plugins:algo:init"", {""ncbi_xloader_lds""})  477                  AddPlugin(""gui_algo_basic"", {}, ""plugins:algo:basic"",   478                          {""xalgoseq"", ""gui_multi_col_dlg"", ""xloader_cdd"", ""cdd"", ""scoremat"", ""cn3d"", ""mmdb""})  479                    480                  -- Algorithm plugins  481                  AddPlugin(""gui_algo_align"", {}, ""plugins:algo:align"", {""xalgoalign"", ""scoremat"", ""xblast"", ""xnetblast"", ""xnetblastcli"", ""gui_dlg_progress""})  482                  AddPlugin(""gui_algo_validator"", {}, ""plugins:algo:validator"", {""xvalidate""})  483                  AddProject(DataPlusLibs(ProjectData(""gui_algo_external"",   484                          {""plugin"", ""fltk"", ""libdl""},   485                          {mkFileData(gSourceDir & ""gui:plugins:algo:external""),   486                                  mkFileDataListFiles(gSourceDir & ""gui:plugins:algo:basic"", {""output_dlg.cpp""})}),   487                          {""xalgoseq"", ""xcgi""}, {""gui_core""}))  488                  AddPlugin(""gui_algo_gnomon"", {}, ""plugins:algo:gnomon"",   489                          {""xalgognomon"", ""gui_multi_col_dlg""})  490                  -- AddPlugin(""gui_algo_blast"", {}, ""plugins:algo:blast"", {""xblast""}) -- empty.  491                  -- AddPlugin(""gui_net_blast"", {}, ""plugins:algo:net_blast"", {""scoremat"", ""xalgoalign"", ""xnetblast"", ""xnetblastcli""}) - empty  492                  -- AddPlugin(""gui_algo_external"", {}, ""plugins:algo:external"", {""xalgoseq"", ""xcgi""})  493                    494                  -- Document plugins  495                  --    496                  AddPlugin(""gui_doc_table"", {""sqlitelib""}, ""plugins:doc:table"",   497                          {""xsqlite"", ""ncbi_xloader_table"", ""xobjmanip""})  498                    499                  -- View plugins  500                  AddPlugin(""gui_view_align"", {}, ""plugins:view:align"",   501                          {""w_aln_crossaln"", ""w_aln_dotmatrix"", ""w_aln_multi"", ""w_aln_data"", ""gui_graph"", ""w_gl"", ""w_hit_matrix""})  502                  AddPlugin(""gui_view_graphic"", {}, ""plugins:view:graphic"",   503                          {""gui_dlg_feature"", ""w_seq_graphic"", ""w_gl""})  504                  -- AddPlugin(""gui_view_sequence"", {}, ""plugins:view:sequence"",  {}) -- empty  505                    506                  AddPlugin(""gui_view_table"", {}, ""plugins:view:table"",   507                          {})  508                  AddPlugin(""gui_view_text"", {}, ""plugins:view:text"",   509                          {""gbseq"", ""xflat"", ""xformat""})  510                  AddPlugin(""gui_view_validator"", {}, ""plugins:view:validator"", {""gbseq"", ""xvalidate""})  511                    512          end if  513            514  end SetProjectData  515    516    517  --  Set Global variables  518    519  on IsOSX()  520          tell application ""Finder""  521                  set vers to the version as text  522                  if second character of vers is equal to ""."" then  523                          set vers to ""0"" & vers  524                  end if  525                  return vers > 10 or vers = 10  526          end tell  527  end IsOSX  528    529  on HomeDir()  530          tell application ""Finder""  531                  return the home as string  532          end tell  533  end HomeDir  534    535  on ResolveAlias(pathname)  536          tell application ""Finder""  537                  if exists folder pathname then  538                          -- if pathname does not end with "":"" then set pathname to pathname & "":""  539                          return folder pathname as string  540                  end if  541                  if exists alias file pathname then return the original item of alias file pathname as string  542          end tell  543          return """"  544  end ResolveAlias  545    546  on ModuleRoot()  547          set modRoot to """"  548          try  549                  set modRoot to ResolveAlias(pRootFolderPath & pRootFolderName)  550          end try  551          if modRoot is """" then  552                  set modRoot to ResolveAlias(gHomeDir & pRootFolderName)  553          end if  554          return modRoot  555  end ModuleRoot  556    557  -- number of directories in a Posix path.  558  on PathLength(aPath)  559          set {stid, text item delimiters of AppleScript} to {text item delimiters of AppleScript, ""/""}  560          set n to length of (text items of aPath)  561          set text item delimiters of AppleScript to stid  562          return n  563  end PathLength  564    565  on IsSpecialFolder(aFolder, findit, filePattern)  566          set aFolder to ResolveAlias(aFolder)  567          if aFolder is """" then return """"  568          set pfolder to POSIX path of aFolder  569          if findit then  570                  set aRootFolder to do shell script (""ls -1r "" & pfolder & ""*/"" & filePattern & "" | head -1"")  571          else  572                  set aRootFolder to do shell script (""ls -1r "" & pfolder & filePattern & "" | head -1"")  573          end if  574          if aRootFolder is """" then return """"  575          set aRootFolder to (POSIX file aRootFolder) as string  576          set lastDirIndex to (PathLength(filePattern) + 1)  577          set text item delimiters of AppleScript to "":""  578          set aRootFolder to (text items 1 thru -lastDirIndex of aRootFolder) as string  579          set text item delimiters of AppleScript to """"  580          return aRootFolder & "":""  581  end IsSpecialFolder  582    583  on FindSpecialFolder(default, pattern)  584          -- look where specified.  585          set aSpecialFolder to IsSpecialFolder(default, false, pattern)  586          if aSpecialFolder is """" then  587                  -- look next to the C++ toolkit directory.  588                  set aSpecialFolder to IsSpecialFolder(pRootFolderPath, true, pattern)  589          end if  590          if aSpecialFolder is """" then  591                  -- look IN the C++ toolkit directory.  592                  set aSpecialFolder to IsSpecialFolder(gDistribRoot, true, pattern)  593          end if  594          if aSpecialFolder is """" then  595                  -- look in our home directory.  596                  set aSpecialFolder to IsSpecialFolder(gHomeDir, true, pattern)  597          end if  598          return aSpecialFolder  599  end FindSpecialFolder  600    601  on FindSqlite()  602          set gSqliteSrcFolder to my FindSpecialFolder(pSqliteRootFolder, ""src/sqlite.h.in"")  603          if gSqliteSrcFolder is """" then  604                  return """"  605          end if  606          set sqliteLibsFolder to (gLibsDir & ""sqlite:"")  607          return sqliteLibsFolder  608  end FindSqlite  609    610    611  on BuildSqlite()  612          if gSqliteSrcFolder is """" then  613                  return  614          end if  615            616          CreateFolder(gLibsDir)  617          -- shell script command name  618          set makeCommand to ""sh "" & POSIX path of (gMakeDir & ""makesqlite"")  619          -- command arguments:  620          -- source directory  621          set makeCommand to makeCommand & "" "" & (POSIX path of gSqliteSrcFolder)  622          -- build directory  623          set makeCommand to makeCommand & "" "" & (POSIX path of (gLibsDir & ""sqlite-build""))  624          -- install directory  625          set sqliteLibsFolder to (gLibsDir & ""sqlite:"")  626          set makeCommand to makeCommand & "" "" & (POSIX path of sqliteLibsFolder)  627            628          try  629                  do shell script makeCommand without altering line endings  630          on error errmsg number errnum  631                  if pSaveContinueOnErrors then  632                          -- copy results into an error file.  633                          set sqliteErrFileName to gProjectsDir & ""sqlitelib.errs""  634                          try  635                                  tell application ""Finder"" to delete file sqliteErrFileName  636                          end try  637                          set sqliteErrFile to open for access sqliteErrFileName with write permission  638                          write errmsg to sqliteErrFile  639                          close access sqliteErrFile  640                  else  641                          -- display results and stop.  642                          error ""Errors building sqlite: "" & return & errmsg number errnum  643                  end if  644          end try  645          -- return the standard output of the script which should be the install directory.  646          return  647  end BuildSqlite  648    649    650  on GetMyPath()  651          set myPath to path to me as string  652          if myPath contains ""Script Editor"" or   653                  myPath contains ""osascript"" or   654                  myPath contains ""Smile.app"" then  655                  -- Oops! running under script editor. 'me' is Script Editor not this script.  656                  -- use the location this script is supposed to be in.  657                  return gDistribRoot & ""compilers:mac_prj:""  658          else  659                  tell application ""Finder""  660                          return (container of myPath as string) & "":""  661                  end tell  662          end if  663  end GetMyPath  664    665  on SetGlobals()  666          tell application ""Finder""  667                    668                  set gProjectData to {}  669                    670                  set gHomeDir to my HomeDir()  671                  set gDistribRoot to my ModuleRoot()  672                  set gIncludeDir to gDistribRoot & ""include:""  673                  set gSourceDir to gDistribRoot & ""src:""  674                  set gProjectsDir to gDistribRoot & ""compilers:mac_prj:lib:""  675                  set gPluginsDir to gDistribRoot & ""compilers:mac_prj:plugins:""  676                  set gLibsDir to gProjectsDir  677                  set gRsrcsDir to gDistribRoot & ""compilers:mac_prj:""  678                  set gMakeDir to my GetMyPath()  679                  set gFLTKRootFolder to my FindSpecialFolder(pFLTKRootFolder, ""src/Fl.cxx"")  680                  if gFLTKRootFolder is """" and pCreateGuiLibs then  681                          set pCreateGuiLibs to false  682                          set pCreatePluginLibs to false  683                          display dialog ""Warning: Can't find FLTK. (download from www.fltk.org into your home directory or C++ toolkit directory). Not creating Gui libraries."" with icon caution  684                  end if  685                  set gBdbRootFolder to my FindSpecialFolder(pBdbRootFolder, ""dbinc/db_int.in"")  686                  if gBdbRootFolder is """" then  687                          display dialog ""Can't find bdb. (download from  http://www.sleepycat.com/  into your home directory or C++ toolkit directory). Some libraries will fail to build."" with icon caution  688                  end if  689                  set gSqliteRootFolder to my FindSqlite()  690                  if gSqliteRootFolder is """" then  691                          display dialog ""Can't find sqlite. (download from  http://www.sqlite.org/  into your home or C++ toolkit directory). Some plugins may fail to build."" with icon caution  692                  end if  693          end tell  694  end SetGlobals  695    696  on HeaderExists(header, headerDir)  697          tell application ""Finder""  698                  if headerDir is """" then set headerDir to folder gIncludeDir  699                  return exists file header of headerDir  700          end tell  701  end HeaderExists  702    703  on IsOlderThan(fileA, fileB)  704          tell application ""Finder""  705                  return (the modification date of fileA < the modification date of fileB)  706          end tell  707  end IsOlderThan  708    709  on UpdateRenameHeader(canonicalName, canonicalDir, dotHName, dotHDir)  710          tell application ""Finder""  711                    712                  set needRename to (dotHName is not """")  713                  if not needRename then set dotHName to canonicalName  714                  if dotHDir is """" then set dotHDir to folder gIncludeDir  715                    716                  -- This file is only present if the script was interrupted.  717                  if needRename and my HeaderExists(canonicalName, dotHDir) then  718                          delete file canonicalName of dotHDir  719                  end if  720                    721                  -- The native config file.  722                  -- If it's missing, assume this is a prepared distribution and the header is already up-to-date.  723                  if not my HeaderExists(canonicalName, canonicalDir) then return  724                  set canonicalFile to file canonicalName of canonicalDir  725                    726                  set needCopy to true  727                  if my HeaderExists(dotHName, dotHDir) then  728                          set dotHFile to file dotHName of dotHDir  729                          if my IsOlderThan(dotHFile, canonicalFile) then  730                                  delete dotHFile  731                          else  732                                  set needCopy to false  733                          end if  734                  end if  735                    736                  if needCopy then  737                          duplicate canonicalFile to dotHDir  738                          if needRename then set name of file canonicalName of dotHDir to dotHName  739                  end if  740                    741          end tell  742  end UpdateRenameHeader  743    744  on UpdateHeader(headerName, headerDir)  745          UpdateRenameHeader(headerName, headerDir, """", """")  746  end UpdateHeader  747    748  on CopyHeaders()  749          tell application ""Finder""  750                    751                  set confFolder to folder ""compilers"" of folder (my ModuleRoot())  752                  set prefixFolder to folder ""mac_prj"" of confFolder  753                    754                  -- my UpdateRenameHeader(""ncbiconf.mac"", confFolder, ""ncbiconf.h"", """")  755                  if gFLTKRootFolder is not """" then  756                          my UpdateRenameHeader(""fltk-config.h"", prefixFolder, ""config.h"", folder gFLTKRootFolder)  757                  end if  758                    759                  my UpdateHeader(""db.h"", prefixFolder)  760                  my UpdateHeader(""db_int.h"", prefixFolder)  761                  my UpdateHeader(""db_config.h"", prefixFolder)  762                    763                  my UpdateHeader(""debug.pfx"", prefixFolder)  764                  my UpdateHeader(""release.pfx"", prefixFolder)  765                  my UpdateHeader(""Carbon-debug.pfx"", prefixFolder)  766                  my UpdateHeader(""Carbon-release.pfx"", prefixFolder)  767                  my UpdateHeader(""Carbon-debugMSL.pfx"", prefixFolder)  768                  my UpdateHeader(""Carbon-releaseMSL.pfx"", prefixFolder)  769                  my UpdateHeader(""ncbi_mslextras.h"", prefixFolder)  770                    771          end tell  772  end CopyHeaders  773    774  on AppendAccessPath(aPath, isRecursive, isUserPath)  775          tell application ""CodeWarrior IDE""  776                  if (aPath does not end with "":"") then set aPath to aPath & "":""  777                    778                  set aPath to POSIX path of aPath  779                  set pathsToAdd to {{name:aPath, recursive:isRecursive, origin:root relative, root:""OS X Volume"", format:Unix Path}}  780                  if isUserPath then  781                          Set Preferences of panel ""Access Paths"" to {User Paths:pathsToAdd}  782                  else  783                          Set Preferences of panel ""Access Paths"" to {System Paths:pathsToAdd}  784                  end if  785          end tell  786  end AppendAccessPath  787    788  on PushAccessPath(aPath, isRecursive, isUserPath)  789          tell application ""CodeWarrior IDE""  790                  if (aPath does not end with "":"") then set aPath to aPath & "":""  791                    792                  set aPath to POSIX path of aPath  793                  set pathToAdd to {name:aPath, recursive:isRecursive, origin:root relative, root:""OS X Volume"", format:Unix Path}  794                  if isUserPath then  795                          set newPaths to Get Preferences of {User Paths} from panel ""Access Paths""  796                          copy pathToAdd to beginning of User Paths of newPaths  797                          Set Preferences of panel ""Access Paths"" to {User Paths:{}}  798                          Set Preferences of panel ""Access Paths"" to newPaths  799                  else  800                          set newPaths to Get Preferences of {System Paths} from panel ""Access Paths""  801                          copy pathToAdd to beginning of System Paths of newPaths  802                          Set Preferences of panel ""Access Paths"" to {System Paths:{}}  803                          Set Preferences of panel ""Access Paths"" to newPaths  804                  end if  805          end tell  806  end PushAccessPath  807    808  on SetupTarget(proj, targetIndex)  809          tell application ""CodeWarrior IDE""  810                    811                  set targetName to name of target targetIndex of project document 1  812                  set targetAPI to ""Mach-O""  813                  if targetName contains ""Carbon"" then  814                          return -- we are not supporting Carbon Libs.  815                  end if  816                    817                  if targetName contains ""Debug"" then  818                          set targetDebug to true  819                          if pCreateProfiledTargets then  820                                  set targetProfile to true  821                          else  822                                  set targetProfile to false  823                          end if  824                  else -- if targeName contains ""Final"" then  825                          set targetDebug to false  826                          set targetProfile to false  827                  end if  828                    829                  set libtype to ""BSD""  830                  if targetName contains ""MSL"" then  831                          set libtype to ""MSL""  832                  end if  833                    834                  -- NOTE: no Profile targets. if pCreateProfiledTargets, we make the debug targets also profile-able.  835                  -- and currently MW doesn't let you profile Mach-O targets!  836                    837                  set the current target of project document 1 to target targetIndex of project document 1  838                    839                  -- initialize variables  840                  set projRsrcs to {}  841                  set projFeatures to {}  842                  set sysPaths to {}  843                    844                  -- Grab the fields of our project record and store them in local variables.  845                  set projName to proj's name  846                  set projSettings to proj's settings  847                  try  848                          set projFeatures to proj's features  849                  end try  850                  try  851                          set sysPaths to proj's sysPaths  852                  end try  853                  try  854                          set projRsrcs to proj's rsrcs  855                  end try  856                  set projLibs to proj's projLibs  857                  set dynaLibs to proj's dynaLibs  858                  set projFileData to proj's fileData  859                    860                  -- Figure out what our output file and input libraries will be named.  861                  set fileNameSuffix to """"  862                    863                  if libtype is ""MSL"" then  864                          set fileNameSuffix to ""_"" & libtype  865                  end if  866                    867                  -- Debug or not.  868                  if not targetDebug then  869                          set fileNameSuffix to fileNameSuffix & ""_O"" -- for Optimized.  870                  else  871                          set fileNameSuffix to fileNameSuffix & ""_D""  872                  end if  873                    874                  -- non debug targets get different output names.  875                  set targetFilename to projName & fileNameSuffix  876                    877                  -- make sure target files have the right extension.  878                  if projFeatures contains ""DLL"" then  879                          set targetFilename to targetFilename & pDynaLibExt  880                  else if projFeatures contains ""plugin"" then  881                          set targetFilename to ""lib"" & targetFilename & pPluginExt  882                  else  883                          set targetFilename to targetFilename & pStaticLibExt  884                  end if  885                    886                  -- Get Preference Panel names.  887                  if targetAPI is ""Mach-O"" then  888                          set targetPanelName to ""PPC Mac OS X Project""  889                          set codeGenPanelName to ""PPC CodeGen Mach-O""  890                  end if  891                    892                  -- Set the name of the output file (the application)  893                  Set Preferences of panel targetPanelName to {File Name:targetFilename}  894                    895                  if projFeatures contains ""DLL"" then  896                          Set Preferences of panel targetPanelName to {Install Path:(POSIX path of gProjectsDir)}  897                  end if  898                  -- If we have any per-project override settings, set them.  899                  if (count ppcProject of projSettings) > 0 then  900                          Set Preferences of panel targetPanelName to ppcProject of projSettings  901                  end if  902                    903                  if projFeatures contains ""fltk"" or projFeatures contains ""fltklib"" then  904                          my AppendAccessPath(gFLTKRootFolder & ""FL:"", false, true)  905                          my AppendAccessPath(gFLTKRootFolder, false, false)  906                  end if  907                  if projFeatures contains ""bdblib"" then  908                          my AppendAccessPath(gDistribRoot & ""include:"", false, true)  909                          my AppendAccessPath(gBdbRootFolder, true, true)  910                  end if  911                  if projFeatures contains ""bdb"" then  912                          my PushAccessPath(gDistribRoot & ""include:"", false, false)  913                  end if  914                  if projFeatures contains ""sqlite"" then  915                          my AppendAccessPath(gSqliteRootFolder & ""include:"", false, false)  916                  end if  917                  if projFeatures contains ""sqlitelib"" then  918                          my AppendAccessPath(gSqliteRootFolder & ""lib:"", false, false)  919                  end if  920                    921                  -- Are we assuming a .c or a .cpp extension?  922                  if projFeatures contains ""C++"" then  923                          set fileExtension to pCPlusPlusExt  924                  else  925                          set fileExtension to "".c""  926                  end if  927                    928          end tell  929            930          -- Add source files  931          repeat with group in projFileData  932                  set projPath to projPath of group -- projPath is absolute,  not relative.  933                  my AppendAccessPath(projPath, true, true) -- add this folder to the access paths, as a recursive user path.  934                    935                  set fileList to group's fileList  936                    937                  set filesToAdd to {}  938                  repeat with i in fileList  939                          if i does not contain ""."" then set i to i & fileExtension  940                          try -- ignore it if the file doesn't exist.  941                                    942                                  -- NOTE: if the following line is within a tell ""Codewarrior"" block then  943                                  --  the following Add Files command will fail.  944                                  copy alias (projPath & i) to end of filesToAdd  945                                  -- Set the file's type so CW will have less problems with it.  946                                  tell application ""Finder""  947                                          set file type of file (projPath & i) to ""TEXT""  948                                          set creator type of file (projPath & i) to ""CWIE""  949                                  end tell  950                          end try  951                  end repeat  952                    953                  tell application ""CodeWarrior IDE""  954                          Add Files filesToAdd  955                            956                          -- Take out source files that do not belong.  957                          set fileNotList to group's fileNotList  958                          Remove Files fileNotList  959                  end tell  960          end repeat  961            962          my AppendAccessPath(gDistribRoot & ""include:"", true, false)  963            964          tell application ""CodeWarrior IDE""  965                    966                  -- take care of debugging and profiling settings  967                  if targetDebug then  968                          set the debug of every target file of target targetIndex   969                                  of project document 1 to true  970                  end if  971                    972                  -- Add user libraries.  973                  set filesToAdd to {}  974                  repeat with i in projLibs  975                          if exists file (gLibsDir & i & fileNameSuffix & pStaticLibExt) of application ""Finder"" then  976                                  copy (gLibsDir & i & fileNameSuffix & pStaticLibExt) to end of filesToAdd  977                          end if  978                  end repeat  979                  repeat with i in dynaLibs  980                          if exists file (gLibsDir & i & fileNameSuffix & pDynaLibExt) of application ""Finder"" then  981                                  copy (gLibsDir & i & fileNameSuffix & pDynaLibExt) to end of filesToAdd  982                          end if  983                  end repeat  984                    985                  if projFeatures contains ""libdl"" then  986                          my PushAccessPath(pDLRootFolder & ""include"", false, false)  987                          if projFeatures contains ""DLL"" or projFeatures contains ""plugin"" then  988                                  my PushAccessPath(pDLRootFolder & ""lib"", false, false)  989                                  copy (POSIX path of pDLRootFolder) & ""lib/libdl.a"" to end of filesToAdd  990                          end if  991                  end if  992                    993                  --try  994                  Add Files filesToAdd  995                  --on error errmsg number errnum  996                  -- ignore errors when none of those libraries exist.  997                  -- happens when populating a target when we haven't built any of the libraries for that target spec.  998                  --if errnum is not 9393 then error errmsg number errnum  999                  --end try  1000          end tell  1001            1002          -- add sqlite libraries.  1003          if projFeatures contains ""sqlitelib"" and   1004                  projFeatures contains ""DLL"" or projFeatures contains ""plugin"" then  1005                  set filesToAdd to {}  1006                  copy ""/usr/lib/libcc_dynamic.a"" to end of filesToAdd  1007                  copy gSqliteRootFolder & ""lib:libsqlite.a"" to end of filesToAdd  1008                  -- display dialog filesToAdd  1009                  tell application ""CodeWarrior IDE""  1010                          Add Files filesToAdd  1011                  end tell  1012          end if  1013            1014          -- Add resources.  1015          set filesToAdd to {}  1016          repeat with i in projRsrcs  1017                  copy gRsrcsDir & i to end of filesToAdd  1018          end repeat  1019            1020          tell application ""CodeWarrior IDE""  1021                  Add Files filesToAdd  1022                    1023                  Reset File Paths  1024          end tell  1025  end SetupTarget  1026    1027    1028  on GetTargetFiles(i)  1029          tell application ""CodeWarrior IDE""  1030                  -- get the target  1031                  if (i > (count of targets of project document 1)) then  1032                          return {}  1033                  end if  1034                  -- get references to all the targets files  1035                  set atarget to get target i of project document 1  1036                  set trefs to (target files of atarget whose linked is true)  1037          end tell  1038          set tfiles to {}  1039          if ((count of trefs)  0) then  1040                  repeat with tf in trefs  1041                          -- get locations of the targets files (as file objects)  1042                          tell application ""CodeWarrior IDE""  1043                                  set f to (location of tf)  1044                          end tell  1045                          tell application ""Finder""  1046                                  -- convert the file's to strings (colon style paths)  1047                                  try  1048                                          copy f as string to end of tfiles  1049                                  on error errmsg number errnum  1050                                          -- file in target but does not exist.  1051                                          if errnum  -2753 then -- variable not defined.  1052                                                  error errmsg number errnum  1053                                          end if  1054                                  end try  1055                          end tell  1056                  end repeat  1057          end if  1058          return tfiles  1059  end GetTargetFiles  1060    1061  on UpdateTarget(proj, targetIndex)  1062          tell application ""CodeWarrior IDE""  1063                    1064                  set targetName to name of target targetIndex of project document 1  1065                    1066                  if targetName contains ""Debug"" then  1067                          set targetDebug to true  1068                  else -- if targeName contains ""Final"" then  1069                          set targetDebug to false  1070                  end if  1071                    1072                  set libtype to ""BSD""  1073                  if targetName contains ""MSL"" then  1074                          set libtype to ""MSL""  1075                  end if  1076                    1077                  set the current target of project document 1 to target targetIndex of project document 1  1078                    1079                  -- initialize variables  1080                  set projFeatures to {}  1081                    1082                  -- Grab the fields of our project record and store them in local variables.  1083                  try  1084                          set projFeatures to proj's features  1085                  end try  1086                  set projLibs to proj's projLibs  1087                  set dynaLibs to proj's dynaLibs  1088                  set projFileData to proj's fileData  1089                    1090                  -- Figure out what our output file and input libraries will be named.  1091                  set fileNameSuffix to """"  1092                    1093                  if libtype is ""MSL"" then  1094                          set fileNameSuffix to ""_"" & libtype  1095                  end if  1096                    1097                  -- Debug or not.  1098                  if not targetDebug then  1099                          set fileNameSuffix to fileNameSuffix & ""_O"" -- for Optimized.  1100                  else  1101                          set fileNameSuffix to fileNameSuffix & ""_D""  1102                  end if  1103                    1104                  -- Are we assuming a .c or a .cpp extension?  1105                  if projFeatures contains ""C++"" then  1106                          set fileExtension to pCPlusPlusExt  1107                  else  1108                          set fileExtension to "".c""  1109                  end if  1110                    1111          end tell  1112            1113          -- Update source files  1114          set targetFileList to my GetTargetFiles(targetIndex)  1115          repeat with group in projFileData  1116                  set projPath to projPath of group -- projPath is absolute,  not relative.  1117                    1118                  set fileList to group's fileList  1119                    1120                  set filesToAdd to {}  1121                    1122                  repeat with i in fileList  1123                          if i does not contain ""."" then set i to i & fileExtension  1124                          set fileFullPath to projPath & i  1125                          set found to targetFileList contains fileFullPath  1126                          if (not found) then  1127                                  --try -- ignore it if the file doesn't exist.  1128                                    1129                                  -- NOTE: if the following line is within a tell ""Codewarrior"" block then  1130                                  --  the following Add Files command will fail.  1131                                    1132                                  copy alias fileFullPath to end of filesToAdd  1133                                  --end try  1134                          end if  1135                  end repeat  1136                    1137                  tell application ""CodeWarrior IDE""  1138                          if ((count of filesToAdd) is not 0) then  1139                                  --display dialog filesToAdd  1140                                  Add Files filesToAdd  1141                                  set targetFileList to my GetTargetFiles(targetIndex)  1142                          end if  1143                            1144                          -- Take out source files that do not belong.  1145                          set fileNotList to group's fileNotList  1146                          Remove Files fileNotList  1147                  end tell  1148          end repeat  1149            1150          -- Update libraries  1151          set filesToAdd to {}  1152          repeat with i in projLibs  1153                  set i to gLibsDir & i & fileNameSuffix & pStaticLibExt  1154                  set found to targetFileList contains i  1155                  if (not found) and (exists file (i) of application ""Finder"") then  1156                          copy (i) to end of filesToAdd  1157                  end if  1158          end repeat  1159            1160          repeat with i in dynaLibs  1161                  set i to gLibsDir & i & fileNameSuffix & pDynaLibExt  1162                  set found to targetFileList contains i  1163                  if (not found) and (exists file (i) of application ""Finder"") then  1164                          copy (i) to end of filesToAdd  1165                  end if  1166          end repeat  1167            1168            1169          tell application ""CodeWarrior IDE""  1170                  if ((count of filesToAdd) is not 0) then  1171                          Add Files filesToAdd  1172                          -- set targetFileList to my GetTargetFiles(targetIndex)  1173                  end if  1174                    1175                  Reset File Paths  1176                    1177          end tell  1178            1179  end UpdateTarget  1180    1181  on CreateFolder(folderPath)  1182          set text item delimiters of AppleScript to "":""  1183          -- strip off disk name.  1184          set folderPath to (rest of text items of folderPath) as string  1185          set pathSoFar to """"  1186          tell application ""Finder""  1187                  repeat with f in (text items of folderPath)  1188                          set longerPath to pathSoFar & "":"" & f  1189                          if not (exists folder (longerPath)) then  1190                                  make new folder at folder (pathSoFar) with properties {name:f}  1191                          end if  1192                          set pathSoFar to longerPath  1193                  end repeat  1194          end tell  1195          set text item delimiters of AppleScript to """"  1196  end CreateFolder  1197    1198  on CreateProject(proj)  1199          tell application ""CodeWarrior IDE""  1200                  try  1201                          get proj's name  1202                  on error  1203                          return  1204                  end try  1205                    1206                  set projFilename to proj's name & pProjectFileExt  1207                  set projPathname to gProjectsDir & projFilename  1208                  set openedProject to false  1209                  if pAlwaysCreateProjects or not (exists file projPathname of application ""Finder"") then  1210                            1211                          try  1212                                  close (the first project document whose name is projFilename)  1213                          end try  1214                            1215                          set stationeryName to my GetStationeryName(proj)  1216                            1217                          try  1218                                  tell application ""Finder"" to delete file (gProjectsDir & "".DS_Store"")  1219                          end try  1220                          Create Project projPathname from stationery alias stationeryName  1221                          set openedProject to false  1222                          if the name of window 1 is ""Project Messages"" then  1223                                  close first window -- ""close window 1"" becomes ""Close Window 1"" (different event)  1224                          end if  1225                            1226                          repeat with i from 1 to (count targets of project document 1)  1227                                  my SetupTarget(proj, i)  1228                          end repeat  1229                  else if pUpdateExistingProjects then  1230                          -- project already exists. Make sure it has all right files.  1231                          open (projPathname)  1232                          set openedProject to false  1233                          if the name of window 1 is ""Project Messages"" then  1234                                  close first window -- ""close window 1"" becomes ""Close Window 1"" (different event)  1235                          end if  1236                          repeat with i from 1 to (count targets of project document 1)  1237                                  my UpdateTarget(proj, i)  1238                          end repeat  1239                  end if  1240                  if openedProject then  1241                          if pProjectsCVSEnabled then  1242                                  --try  1243                                  Set Preferences of panel ""VCS Setup"" to {VCS Active:true, Connection Method:""mwCVS""}  1244                                  --end try  1245                          end if  1246                          set the current target of project document 1 to target 1 of project document 1  1247                          Close Project  1248                  end if  1249          end tell  1250  end CreateProject  1251    1252  on CreateAndBuildAllProjects()  1253          CreateFolder(gProjectsDir)  1254          CreateFolder(gPluginsDir)  1255          CleanupFiles(gProjectsDir)  1256          set targetSpecs to GetTargetSpecs()  1257            1258          my BuildSqlite()  1259            1260          tell application ""CodeWarrior IDE"" to activate  1261            1262          repeat with proj in gProjectData  1263                  CreateProject(proj)  1264                  if pShouldBuild then  1265                          try  1266                                  set projName to proj's name  1267                          on error  1268                                  return  1269                          end try  1270                          BuildProject(projName, targetSpecs)  1271                  end if  1272          end repeat  1273            1274  end CreateAndBuildAllProjects  1275    1276  (*  1277          a target spec is a string of words ""MSL Debug"", all of which appear on our list of keywords.  1278          Convert a Build file name to a target spec by filtering out non-keywords.  1279          Each Build file creates another target spec.  1280          A project target must match one of the target specs to compile.  1281          To match, a target's name must contain each of the words in the target spec.  1282          An empty target spec matches everything.  1283          An empty list of target specs (no Build files) matches nothing, but  1284                  we make sure that won't happen.  1285  *)  1286    1287  on GetTargetSpecs()  1288          set theFiles to (list folder gMakeDir without invisibles)  1289          set targetSpecs to {}  1290          repeat with f in theFiles  1291                  if (f begins with ""Build "") then  1292                          set targetSpecs to targetSpecs & MakeTargetSpec(f)  1293                  end if  1294          end repeat  1295          -- no Build files? Ask what to build.  1296          if (count items of targetSpecs) is 0 then  1297                  set targetSpecs to {AskForTargetSpec()}  1298          end if  1299          return targetSpecs  1300  end GetTargetSpecs  1301    1302  on AskForTargetSpec()  1303          try  1304                  choose from list pTargetKeyWords default items pDefaultTargets   1305                          with prompt ""Choose Target types to compile:"" cancel button name ""Build All"" with multiple selections allowed  1306          on error errmsg number errnum  1307                  if errnum is -1713 then -- no user interaction allowed.  1308                          set targ to pDefaultTargets -- build defaults  1309                  else  1310                          error errmsg number errnum  1311                  end if  1312          end try  1313          set targ to result  1314          if targ is false then -- cancel hit.  1315                  return """" -- build all  1316          end if  1317          set {stid, text item delimiters of AppleScript} to {text item delimiters of AppleScript, "" ""}  1318          set targ to targ as string  1319          set text item delimiters of AppleScript to stid  1320          return targ  1321  end AskForTargetSpec  1322    1323  on MakeTargetSpec(f)  1324          set tspec to """"  1325          repeat with w in (words of f)  1326                  if pTargetKeyWords contains w then  1327                          set tspec to tspec & w & "" ""  1328                  end if  1329          end repeat  1330          return tspec  1331  end MakeTargetSpec  1332    1333  on OkaytoBuild(targetName, targetSpecs)  1334          repeat with ts in targetSpecs  1335                  if MatchSpec2Target(ts, targetName) then return true  1336          end repeat  1337          return false  1338  end OkaytoBuild  1339    1340  on MatchSpec2Target(targSpec, targName)  1341          repeat with w in (words of targSpec)  1342                  if w is not in targName then return false  1343          end repeat  1344          return true  1345  end MatchSpec2Target  1346    1347    1348  on BuildProject(projName, targetSpecs)  1349          tell application ""CodeWarrior IDE""  1350                  open (gProjectsDir & projName & pProjectFileExt)  1351                  if the name of window 1 is ""Project Messages"" then  1352                          close first window -- ""close window 1"" becomes ""Close Window 1"" (different event)  1353                  end if  1354                  repeat with i from 1 to (count targets of project document 1)  1355                          -- do we want to build this target?  1356                          set thisTarget to name of target i of project document 1  1357                          if my OkaytoBuild(thisTarget, targetSpecs) then  1358                                    1359                                  set the current target of project document 1 to target i of project document 1  1360                                  if pSaveContinueOnErrors then  1361                                          try  1362                                                  Make Project  1363                                          on error errmsg number errnum  1364                                                  if (errnum = 5) then  1365                                                          set errFileName to (gProjectsDir & projName & ""-"" & i & "".errs"")  1366                                                          Save Error Window As (file errFileName)  1367                                                          close first window  1368                                                  else  1369                                                          error errmsg number errnum  1370                                                  end if  1371                                          end try  1372                                  else -- stop on any error.  1373                                          Make Project  1374                                  end if  1375                                  -- If there were compiler warnings, then a compiler window will be in front.  1376                                  -- For whatever reason, this causes the next ""set the current target..."" to fail.  1377                                  -- So check for the window and close it.  1378                                  if the name of window 1 is ""Errors & Warnings"" then  1379                                          close first window -- ""close window 1"" becomes ""Close Window 1"" (different event)  1380                                  end if  1381                          end if  1382                  end repeat  1383                  set the current target of project document 1 to target 1 of project document 1  1384                  Close Project  1385          end tell  1386  end BuildProject  1387    1388    1389  on GetStationeryName(proj)  1390          if proj's features contains ""DLL"" then  1391                  set stationeryDir to gProjectsDir & pDylibStationeryName & "":""  1392                  set stationeryName to pDylibStationeryName & pProjectFileExt  1393          else if proj's features contains ""plugin"" then  1394                  set stationeryDir to gProjectsDir & pPluginStationeryName & "":""  1395                  set stationeryName to pPluginStationeryName & pProjectFileExt  1396          else  1397                  set stationeryDir to gProjectsDir & pStationeryName & "":""  1398                  set stationeryName to pStationeryName & pProjectFileExt  1399          end if  1400            1401          CreateFolder(stationeryDir)  1402          tell application ""Finder""  1403                  -- does the Library Stationery already exist?  1404                  if not (exists file (stationeryDir & stationeryName)) then  1405                          -- copy it.  1406                          duplicate file (stationeryName) of folder gRsrcsDir to folder stationeryDir  1407                  end if  1408          end tell  1409          return (stationeryDir & stationeryName)  1410  end GetStationeryName  1411    1412  on CleanupFiles(thePath)  1413          -- get rid of all the files and folders starting with 'trashme' in thePath  1414          repeat with f in list folder (thePath) without invisibles  1415                  if ((f as string) begins with ""trashme"") then  1416                          try  1417                                  tell application ""Finder"" to delete folder (thePath & f)  1418                          end try  1419                          try  1420                                  tell application ""Finder"" to delete file (thePath & f)  1421                          end try  1422                  end if  1423          end repeat  1424          -- delete the stationery folders.  1425          try  1426                  tell application ""Finder"" to delete folder (thePath & pStationeryName)  1427          end try  1428          try  1429                  tell application ""Finder"" to delete folder (thePath & pPluginStationeryName)  1430          end try  1431          try  1432                  tell application ""Finder"" to delete folder (thePath & pDylibStationeryName)  1433          end try  1434  end CleanupFiles  1435    1436  on SignalCompletion()  1437          beep  1438  end SignalCompletion  1439    1440  with timeout of 60000 seconds  1441            1442          if not my IsOSX() then  1443                  error ""Only supported on Mac OSX systems. Sorry!""  1444          end if  1445          SetGlobals()  1446          SetProjectData()  1447          CopyHeaders()  1448            1449          CreateAndBuildAllProjects()  1450            1451          CleanupFiles(gProjectsDir)  1452            1453          SignalCompletion()  1454            1455  end timeout  1456          [  source navigation  ]    [  diff markup  ]    [  identifier search  ]    [  freetext search  ]    [  file search  ]                                    This page was automatically generated by the         LXR engine .               Visit the  LXR main site  for more       information."
GX031-88-15781634	Next:   64-bit Linear Congruential Generator    Up:   The RNG Random Number    Previous:   Design Requirements           Random Number Generators       The RNG library provides a family of linear congruential generators of the form             x [ n ] =  a   x [ n  - 1] +  b    ( mod m )   ,     (2)      wherein the random number state fits in a 64-bit unsigned word. The multiplier,  a , the addend,  b , and the modulus,  m , are chosen to provide a variety of high quality generators for the code developer to employ. Two power-of-two modulo generators, a Mersenne prime modulo generator, and several other prime modulo generators are provided. Generators using a modulus that is a power of two are the fastest, but suffer from a hierarchy of patterns [ 4 ] in the low order bits that may pose a problem for some applications. Generators using a prime modulus do not suffer from the hierarchy of patterns noted for a power of two modulus, with the choice of Mersenne primes [ 4 ] being particularly efficient. Patterns of a different form have been discovered for Mersenne primes [ 5 ], however. Primes of a slightly more complicated construction remove this defect while not being significantly more expensive for modular arithmetic.    The prime modulus generators provided in the RNG library have the useful feature that the value zero does not occur as a valid random number state. By carefully zeroing a random number state when it is copied or retired, the random number generator routines will trap on the invalid value should the retired random number state be recycled. This has proven to be very useful when debugging applications that implement per-particle random number state.    The interface routines for the random number generators in the RNG library take the general form:     Rng_Type Rng X Seed( Rng_UInt32 i, Rng_UInt32 j );       Rng_Type Rng X Spawn( Rng_Type *x );      int iRng X ( Rng_Type *x );       double dRng X ( Rng_Type *x );       float fRng X ( Rng_Type *x );      where  X  is replaced with a token that indicates the type of linear congruential recurrence relation being used for the random number generator.    The  Rng X Seed()  function creates a randomly selected state by passing the two integer arguments through the cryptographic hash function. The resulting random number state is returned.  Rng_Type ,  Rng_UInt32  and the function declarations are defined in the header file rng.h. The routine  Rng X Spawn()  takes an existing RNG state, called the parent, and  advances it.  A copy of the advanced parent state is then hashed to produce an uncorrelated child RNG state that is returned. As an example of the use of  Rng X Spawn() , consider the case where a ``parent particle'',  parent , spawns three ``child particles'',  child[3] . The particles are represented by a  struct  that has a Rng_Type member named  rng . Then, the following lines of code demonstrate the seeding of the children's RNG states using the parent's RNG state.     for( i = 0; i < 3; i++ ) {        child[i].rng = Rng X Spawn( &(parent.rng) );       }      Note that  parent.rng  is advanced three times in this example.  Finally, note that both  Rng X Seed()  and  Rng X Spawn()  take 64-bits values,   Rng X Seed()  in the form of two  32-bit unsigned integers, and hash them through the same hashing algorithm described in Section  4 .    The last three functions step the random number state and return uniformly distributed numbers in integer and floating point formats. The function  iRng X ()  returns a 31-bit integer in the range [0, 2 31 ). The function  dRng X ()  returns a double precision floating point value in the range [0,1). The function  fRng X ()  returns a single precision floating point value in the range [0,1). If one casts the value returned by  dRng X ()  to a  float , it is possible for the value 1.0 to occur due to rounding.         Subsections      64-bit Linear Congruential Generator   48-bit Linear Congruential Generator   48-bit CRI Linear Congruential Generator   61-bit Prime Modulus Linear Congruential Generator    2 64  -2 10  + 1 Modulus Linear Congruential Generator    2 62  -2 16  + 1 Modulus Linear Congruential Generator                               Next:   64-bit Linear Congruential Generator    Up:   The RNG Random Number    Previous:   Design Requirements
GX057-52-4573977	"Go to the  first ,  previous ,  next ,  last  section,  table of contents .      Random Number Generation           The library provides a large collection of random number generators which can be accessed through a uniform interface.  Environment variables allow you to select different generators and seeds at runtime, so that you can easily switch between generators without needing to recompile your program.  Each instance of a generator keeps track of its own state, allowing the generators to be used in multi-threaded programs.  Additional functions are available for transforming uniform random numbers into samples from continuous or discrete probability distributions such as the Gaussian, log-normal or Poisson distributions.      These functions are declared in the header file  `gsl_rng.h' .        General comments on random numbers     In 1988, Park and Miller wrote a paper entitled ""Random number generators: good ones are hard to find."" [Commun. ACM, 31, 1192--1201]. Fortunately, some excellent random number generators are available, though poor ones are still in common use.  You may be happy with the system-supplied random number generator on your computer, but you should be aware that as computers get faster, requirements on random number generators increase.  Nowadays, a simulation that calls a random number generator millions of times can often finish before you can make it down the hall to the coffee machine and back.      A very nice review of random number generators was written by Pierre L'Ecuyer, as Chapter 4 of the book: Handbook on Simulation, Jerry Banks, ed. (Wiley, 1997).  The chapter is available in postscript from from L'Ecuyer's ftp site (see references).  Knuth's volume on Seminumerical Algorithms (originally published in 1968) devotes 170 pages to random number generators, and has recently been updated in its 3rd edition (1997). It is brilliant, a classic.  If you don't own it, you should stop reading right now, run to the nearest bookstore, and buy it.      A good random number generator will satisfy both theoretical and statistical properties.  Theoretical properties are often hard to obtain (they require real math!), but one prefers a random number generator with a long period, low serial correlation, and a tendency  not  to ""fall mainly on the planes.""  Statistical tests are performed with numerical simulations.  Generally, a random number generator is used to estimate some quantity for which the theory of probability provides an exact answer.  Comparison to this exact answer provides a measure of ""randomness"".       The Random Number Generator Interface     It is important to remember that a random number generator is not a ""real"" function like sine or cosine.  Unlike real functions, successive calls to a random number generator yield different return values.  Of course that is just what you want for a random number generator, but to achieve this effect, the generator must keep track of some kind of ""state"" variable.  Sometimes this state is just an integer (sometimes just the value of the previously generated random number), but often it is more complicated than that and may involve a whole array of numbers, possibly with some indices thrown in.  To use the random number generators, you do not need to know the details of what comprises the state, and besides that varies from algorithm to algorithm.      The random number generator library uses two special structs,  gsl_rng_type  which holds static information about each type of generator and  gsl_rng  which describes an instance of a generator created from a given  gsl_rng_type .      The functions described in this section are declared in the header file  `gsl_rng.h' .       Random number generator initialization        Random:  gsl_rng *  gsl_rng_alloc   (const gsl_rng_type *  T )    This function returns a pointer to a newly-created instance of a random number generator of type  T . For example, the following code creates an instance of the Tausworthe generator,      gsl_rng * r = gsl_rng_alloc (gsl_rng_taus);      If there is insufficient memory to create the generator then the function returns a null pointer and the error handler is invoked with an error code of  GSL_ENOMEM .      The generator is automatically initialized with the default seed,  gsl_rng_default_seed .  This is zero by default but can be changed either directly or by using the environment variable  GSL_RNG_SEED  (see section  Random number environment variables ).      The details of the available generator types are described later in this chapter.           Random:  void  gsl_rng_set   (const gsl_rng *  r , unsigned long int  s )    This function initializes (or `seeds') the random number generator.  If the generator is seeded with the same value of  s  on two different runs, the same stream of random numbers will be generated by successive calls to the routines below.  If different values of  s  are supplied, then the generated streams of random numbers should be completely different.  If the seed  s  is zero then the standard seed from the original implementation is used instead.  For example, the original Fortran source code for the  ranlux  generator used a seed of 314159265, and so choosing  s  equal to zero reproduces this when using  gsl_rng_ranlux .           Random:  void  gsl_rng_free   (gsl_rng *  r )    This function frees all the memory associated with the generator  r .         Sampling from a random number generator     The following functions return uniformly distributed random numbers, either as integers or double precision floating point numbers.  To obtain non-uniform distributions see section  Random Number Distributions .         Random:  unsigned long int  gsl_rng_get   (const gsl_rng *  r )    This function returns a random integer from the generator  r .  The minimum and maximum values depend on the algorithm used, but all integers in the range [ min , max ] are equally likely.  The values of  min  and  max  can determined using the auxiliary functions  gsl_rng_max (r)  and  gsl_rng_min (r) .           Random:  double  gsl_rng_uniform   (const gsl_rng *  r )    This function returns a double precision floating point number uniformly distributed in the range [0,1).  The range includes 0.0 but excludes 1.0. The value is typically obtained by dividing the result of  gsl_rng_get(r)  by  gsl_rng_max(r) + 1.0  in double precision.  Some generators compute this ratio internally so that they can provide floating point numbers with more than 32 bits of randomness (the maximum number of bits that can be portably represented in a single  unsigned long int ).           Random:  double  gsl_rng_uniform_pos   (const gsl_rng *  r )    This function returns a positive double precision floating point number uniformly distributed in the range (0,1), excluding both 0.0 and 1.0. The number is obtained by sampling the generator with the algorithm of  gsl_rng_uniform  until a non-zero value is obtained.  You can use this function if you need to avoid a singularity at 0.0.           Random:  unsigned long int  gsl_rng_uniform_int   (const gsl_rng *  r , unsigned long int  n )    This function returns a random integer from 0 to  n-1  inclusive. All integers in the range [0, n-1 ] are equally likely, regardless of the generator used.  An offset correction is applied so that zero is always returned with the correct probability, for any minimum value of the underlying generator.      If  n  is larger than the range of the generator then the function calls the error handler with an error code of  GSL_EINVAL  and returns zero.         Auxiliary random number generator functions    The following functions provide information about an existing generator.  You should use them in preference to hard-coding the generator parameters into your own code.         Random:  const char *  gsl_rng_name   (const gsl_rng *  r )    This function returns a pointer to the name of the generator. For example,      printf(""r is a '%s' generator\n"",         gsl_rng_name (r));      would print something like  r is a 'taus' generator .           Random:  unsigned long int  gsl_rng_max   (const gsl_rng *  r )     gsl_rng_max  returns the largest value that  gsl_rng_get  can return.           Random:  unsigned long int  gsl_rng_min   (const gsl_rng *  r )     gsl_rng_min  returns the smallest value that  gsl_rng_get  can return.  Usually this value is zero.  There are some generators with algorithms that cannot return zero, and for these generators the minimum value is 1.           Random:  void *  gsl_rng_state   (const gsl_rng *  r )     Random:  size_t  gsl_rng_size   (const gsl_rng *  r )    These function return a pointer to the state of generator  r  and its size.  You can use this information to access the state directly.  For example, the following code will write the state of a generator to a stream,      void * state = gsl_rng_state (r); size_t n = gsl_rng_size (r); fwrite (state, n, 1, stream);            Random:  const gsl_rng_type **  gsl_rng_types_setup   (void)    This function returns a pointer to an array of all the available generator types, terminated by a null pointer. The function should be called once at the start of the program, if needed.  The following code fragment shows how to iterate over the array of generator types to print the names of the available algorithms,      const gsl_rng_type **t, **t0;  t0 = gsl_rng_types_setup ();  printf(""Available generators:\n"");  for (t = t0; *t != 0; t++)   {     printf(""%s\n"", (*t)->name);   }          Random number environment variables     The library allows you to choose a default generator and seed from the environment variables  GSL_RNG_TYPE  and  GSL_RNG_SEED  and the function  gsl_rng_env_setup .  This makes it easy try out different generators and seeds without having to recompile your program.         Function:  const gsl_rng_type *  gsl_rng_env_setup   (void)    This function reads the environment variables  GSL_RNG_TYPE  and  GSL_RNG_SEED  and uses their values to set the corresponding library variables  gsl_rng_default  and  gsl_rng_default_seed .  These global variables are defined as follows,      extern const gsl_rng_type *gsl_rng_default extern unsigned long int gsl_rng_default_seed      The environment variable  GSL_RNG_TYPE  should be the name of a generator, such as  taus  or  mt19937 .  The environment variable  GSL_RNG_SEED  should contain the desired seed value.  It is converted to an  unsigned long int  using the C library function  strtoul .      If you don't specify a generator for  GSL_RNG_TYPE  then  gsl_rng_mt19937  is used as the default.  The initial value of  gsl_rng_default_seed  is zero.        Here is a short program which shows how to create a global generator using the environment variables  GSL_RNG_TYPE  and  GSL_RNG_SEED ,      #include <stdio.h> #include <gsl/gsl_rng.h>  gsl_rng * r;  /* global generator */  int main (void) {   const gsl_rng_type * T;    gsl_rng_env_setup();    T = gsl_rng_default;   r = gsl_rng_alloc (T);      printf(""generator type: %s\n"", gsl_rng_name (r));   printf(""seed = %u\n"", gsl_rng_default_seed);   printf(""first value = %u\n"", gsl_rng_get (r));   return 0; }      Running the program without any environment variables uses the initial defaults, an  mt19937  generator with a seed of 0,      bash$ ./a.out  generator type: mt19937 seed = 0 first value = 2867219139      By setting the two variables on the command line we can change the default generator and the seed,      bash$ GSL_RNG_TYPE=""taus"" GSL_RNG_SEED=123 ./a.out  GSL_RNG_TYPE=taus GSL_RNG_SEED=123 generator type: taus seed = 123 first value = 2720986350       Saving and restoring random number generator state     The above methods ignore the random number `state' which changes from call to call.  It is often useful to be able to save and restore the state.  To permit these practices, a few somewhat more advanced functions are supplied.  These include:         Random:  int  gsl_rng_memcpy   (gsl_rng *  dest , const gsl_rng *  src )    This function copies the random number generator  src  into the pre-existing generator  dest , making  dest  into an exact copy of  src .  The two generators must be of the same type.           Random:  gsl_rng *  gsl_rng_clone   (const gsl_rng *  r )    This function returns a pointer to a newly created generator which is an exact copy of the generator  r .           Random:  void  gsl_rng_print_state   (const gsl_rng *  r )    This function prints a hex-dump of the state of the generator  r  to  stdout .  At the moment its only use is for debugging.         Random number generator algorithms     The functions described above make no reference to the actual algorithm used.  This is deliberate so that you can switch algorithms without having to change any of your application source code.  The library provides a large number of generators of different types, including simulation quality generators, generators provided for compatibility with other libraries and historical generators from the past.      The following generators are recommended for use in simulation.  They have extremely long periods, low correlation and pass most statistical tests.         Generator:   gsl_rng_mt19937      The MT19937 generator of Makoto Matsumoto and Takuji Nishimura is a variant of the twisted generalized feedback shift-register algorithm, and is known as the ""Mersenne Twister"" generator.  It has a Mersenne prime period of  2^19937 - 1 (about  10^6000) and is equi-distributed in 623 dimensions.  It has passed the DIEHARD statistical tests.  It uses 624 words of state per generator and is comparable in speed to the other generators.  The original generator used a default seed of 4357 and choosing  s  equal to zero in  gsl_rng_set  reproduces this.      For more information see,       Makoto Matsumoto and Takuji Nishimura, ""Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator"".  ACM Transactions on Modeling and Computer Simulation , Vol. 8, No. 1 (Jan. 1998), Pages 3-30      The generator  gsl_rng_19937  uses the second revision of the seeding procedure published by the two authors above in 2002.  The original seeding procedures could cause spurious artifacts for some seed values. They are still available through the alternate generators  gsl_rng_mt19937_1999  and  gsl_rng_mt19937_1998 .           Generator:   gsl_rng_ranlxs0     Generator:   gsl_rng_ranlxs1     Generator:   gsl_rng_ranlxs2           The generator  ranlxs0  is a second-generation version of the RANLUX algorithm of L@""uscher, which produces ""luxury random numbers"".  This generator provides single precision output (24 bits) at three luxury levels  ranlxs0 ,  ranlxs1  and  ranlxs2 . It uses double-precision floating point arithmetic internally and can be significantly faster than the integer version of  ranlux , particularly on 64-bit architectures.  The period of the generator is about  10^171.  The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of randomness. The higher luxury levels provide additional decorrelation between samples as an additional safety margin.           Generator:   gsl_rng_ranlxd1     Generator:   gsl_rng_ranlxd2           These generators produce double precision output (48 bits) from the RANLXS generator.  The library provides two luxury levels  ranlxd1  and  ranlxd2 .            Generator:   gsl_rng_ranlux     Generator:   gsl_rng_ranlux389           The  ranlux  generator is an implementation of the original algorithm developed by L@""uscher.  It uses a lagged-fibonacci-with-skipping algorithm to produce ""luxury random numbers"".  It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers.  This implementation is based on integer arithmetic, while the second-generation versions RANLXS and RANLXD described above provide floating-point implementations which will be faster on many platforms. The period of the generator is about  10^171.  The algorithm has mathematically proven properties and it can provide truly decorrelated numbers at a known level of randomness.  The default level of decorrelation recommended by L@""uscher is provided by  gsl_rng_ranlux , while  gsl_rng_ranlux389  gives the highest level of randomness, with all 24 bits decorrelated. Both types of generator use 24 words of state per generator.      For more information see,       M. L@""uscher, ""A portable high-quality random number generator for lattice field theory calculations"",  Computer Physics Communications , 79 (1994) 100-110.    F. James, ""RANLUX: A Fortran implementation of the high-quality pseudo-random number generator of L@""uscher"",  Computer Physics Communications , 79 (1994) 111-114            Generator:   gsl_rng_cmrg      This is a combined multiple recursive generator by L'Ecuyer.  Its sequence is,      z_n = (x_n - y_n) mod m_1      where the two underlying generators x_n and y_n are,      x_n = (a_1 x_{n-1} + a_2 x_{n-2} + a_3 x_{n-3}) mod m_1 y_n = (b_1 y_{n-1} + b_2 y_{n-2} + b_3 y_{n-3}) mod m_2      with coefficients  a_1 = 0,  a_2 = 63308,  a_3 = -183326, b_1 = 86098,  b_2 = 0, b_3 = -539608, and moduli  m_1 = 2^31 - 1 = 2147483647 and  m_2 = 2145483479.      The period of this generator is  2^205  (about  10^61).  It uses 6 words of state per generator.  For more information see,          P. L'Ecuyer, ""Combined Multiple Recursive Random Number Generators,""  Operations Research , 44, 5 (1996), 816--822.            Generator:   gsl_rng_mrg      This is a fifth-order multiple recursive generator by L'Ecuyer, Blouin and Coutre.  Its sequence is,      x_n = (a_1 x_{n-1} + a_5 x_{n-5}) mod m      with  a_1 = 107374182,  a_2 = a_3 = a_4 = 0,  a_5 = 104480 and  m = 2^31 - 1.      The period of this generator is about  10^46.  It uses 5 words of state per generator.  More information can be found in the following paper,       P. L'Ecuyer, F. Blouin, and R. Coutre, ""A search for good multiple recursive random number generators"",  ACM Transactions on Modeling and Computer Simulation  3, 87-98 (1993).            Generator:   gsl_rng_taus     Generator:   gsl_rng_taus2      This is a maximally equidistributed combined Tausworthe generator by L'Ecuyer.  The sequence is,      x_n = (s1_n ^^ s2_n ^^ s3_n)       where,      s1_{n+1} = (((s1_n&4294967294)<<12)^^(((s1_n<<13)^^s1_n)>>19)) s2_{n+1} = (((s2_n&4294967288)<< 4)^^(((s2_n<< 2)^^s2_n)>>25)) s3_{n+1} = (((s3_n&4294967280)<<17)^^(((s3_n<< 3)^^s3_n)>>11))      computed modulo  2^32.  In the formulas above  ^^ denotes ""exclusive-or"".  Note that the algorithm relies on the properties of 32-bit unsigned integers and has been implemented using a bitmask of  0xFFFFFFFF  to make it work on 64 bit machines.      The period of this generator is  2^88 (about 10^26).  It uses 3 words of state per generator.  For more information see,          P. L'Ecuyer, ""Maximally Equidistributed Combined Tausworthe Generators"",  Mathematics of Computation , 65, 213 (1996), 203--213.      The generator  gsl_rng_taus2  uses the same algorithm as  gsl_rng_taus  but with an improved seeding procedure described in the paper,          P. L'Ecuyer, ""Tables of Maximally Equidistributed Combined LFSR Generators"",  Mathematics of Computation , 68, 225 (1999), 261--269      The generator  gsl_rng_taus2  should now be used in preference to  gsl_rng_taus .           Generator:   gsl_rng_gfsr4      The  gfsr4  generator is like a lagged-fibonacci generator, and  produces each number as an  xor 'd sum of four previous values.      r_n = r_{n-A} ^^ r_{n-B} ^^ r_{n-C} ^^ r_{n-D}      Ziff (ref below) notes that ""it is now widely known"" that two-tap registers (such as R250, which is described below) have serious flaws, the most obvious one being the three-point correlation that comes from the definition of the generator.  Nice mathematical properties can be derived for GFSR's, and numerics bears out the claim that 4-tap GFSR's with appropriately chosen offsets are as random as can be measured, using the author's test.      This implementation uses the values suggested the the example on p392 of Ziff's article: A=471, B=1586, C=6988, D=9689.      If the offsets are appropriately chosen (such the one ones in this implementation), then the sequence is said to be maximal. I'm not sure what that means, but I would guess that means all states are part of the same cycle, which would mean that the period for this generator is astronomical; it is (2^K)^D \approx 10^{93334} where K=32 is the number of bits in the word, and D is the longest lag.  This would also mean that any one random number could  easily be zero; ie  0 <= r < 2^32.      Ziff doesn't say so, but it seems to me that the bits are completely independent here, so one could use this as an efficient bit generator; each number supplying 32 random bits.  The quality of the generated bits depends on the underlying seeding procedure, which  may need to be improved in some circumstances.      For more information see,       Robert M. Ziff, ""Four-tap shift-register-sequence random-number  generators"",  Computers in Physics , 12(4), Jul/Aug 1998, pp 385-392.          Unix random number generators     The standard Unix random number generators  rand ,  random  and  rand48  are provided as part of GSL. Although these generators are widely available individually often they aren't all available on the same platform.  This makes it difficult to write portable code using them and so we have included the complete set of Unix generators in GSL for convenience.  Note that these generators don't produce high-quality randomness and aren't suitable for work requiring accurate statistics.  However, if you won't be measuring statistical quantities and just want to introduce some variation into your program then these generators are quite acceptable.                    Generator:   gsl_rng_rand      This is the BSD  rand()  generator.  Its sequence is      x_{n+1} = (a x_n + c) mod m      with  a = 1103515245,  c = 12345 and  m = 2^31. The seed specifies the initial value,  x_1.  The period of this generator is  2^31, and it uses 1 word of storage per generator.           Generator:   gsl_rng_random_bsd     Generator:   gsl_rng_random_libc5     Generator:   gsl_rng_random_glibc2    These generators implement the  random()  family of functions, a set of linear feedback shift register generators originally used in BSD Unix.  There are several versions of  random()  in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older GNU/Linux systems) and a glibc2 version.  Each version uses a different seeding procedure, and thus produces different sequences.      The original BSD routines accepted a variable length buffer for the generator state, with longer buffers providing higher-quality randomness.  The  random()  function implemented algorithms for buffer lengths of 8, 32, 64, 128 and 256 bytes, and the algorithm with the largest length that would fit into the user-supplied buffer was used.  To support these algorithms additional generators are available with the following names,      gsl_rng_random8_bsd gsl_rng_random32_bsd gsl_rng_random64_bsd gsl_rng_random128_bsd gsl_rng_random256_bsd      where the numeric suffix indicates the buffer length.  The original BSD  random  function used a 128-byte default buffer and so  gsl_rng_random_bsd  has been made equivalent to  gsl_rng_random128_bsd .  Corresponding versions of the  libc5  and  glibc2  generators are also available, with the names  gsl_rng_random8_libc5 ,  gsl_rng_random8_glibc2 , etc.           Generator:   gsl_rng_rand48      This is the Unix  rand48  generator.  Its sequence is      x_{n+1} = (a x_n + c) mod m      defined on 48-bit unsigned integers with  a = 25214903917,  c = 11 and  m = 2^48.  The seed specifies the upper 32 bits of the initial value, x_1, with the lower 16 bits set to  0x330E .  The function  gsl_rng_get  returns the upper 32 bits from each term of the sequence.  This does not have a direct parallel in the original  rand48  functions, but forcing the result to type  long int  reproduces the output of  mrand48 .  The function  gsl_rng_uniform  uses the full 48 bits of internal state to return the double precision number x_n/m, which is equivalent to the function  drand48 .  Note that some versions of the GNU C Library contained a bug in  mrand48  function which caused it to produce different results (only the lower 16-bits of the return value were set).         Numerical Recipes generators        The following generators are provided for compatibility with  Numerical Recipes .  Note that the original Numerical Recipes functions used single precision while we use double precision.  This will lead to minor discrepancies, but only at the level of single-precision rounding error.  If necessary you can force the returned values to single precision by storing them in a  volatile float , which prevents the value being held in a register with double or extended precision.  Apart from this difference the underlying algorithms for the integer part of the generators are the same.         Generator:   gsl_rng_ran0    Numerical recipes  ran0  implements Park and Miller's MINSTD algorithm with a modified seeding procedure.           Generator:   gsl_rng_ran1    Numerical recipes  ran1  implements Park and Miller's MINSTD algorithm with a 32-element Bayes-Durham shuffle box.           Generator:   gsl_rng_ran2    Numerical recipes  ran2  implements a L'Ecuyer combined recursive generator with a 32-element Bayes-Durham shuffle-box.           Generator:   gsl_rng_ran3    Numerical recipes  ran3  implements Knuth's portable subtractive generator.         Other random number generators     The generators in this section are provided for compatibility with existing libraries.  If you are converting an existing program to use GSL then you can select these generators to check your new implementation against the original one, using the same random number generator.  After verifying that your new program reproduces the original results you can then switch to a higher-quality generator.      Note that most of the generators in this section are based on single linear congruence relations, which are the least sophisticated type of generator.  In particular, linear congruences have poor properties when used with a non-prime modulus, as several of these routines do (e.g. with a power of two modulus,  2^31 or  2^32).  This leads to periodicity in the least significant bits of each number, with only the higher bits having any randomness.  Thus if you want to produce a random bitstream it is best to avoid using the least significant bits.         Generator:   gsl_rng_ranf        This is the CRAY random number generator  RANF .  Its sequence is      x_{n+1} = (a x_n) mod m      defined on 48-bit unsigned integers with a = 44485709377909 and m = 2^48.  The seed specifies the lower 32 bits of the initial value,  x_1, with the lowest bit set to prevent the seed taking an even value.  The upper 16 bits of  x_1 are set to 0. A consequence of this procedure is that the pairs of seeds 2 and 3, 4 and 5, etc produce the same sequences.      The generator compatibile with the CRAY MATHLIB routine RANF. It produces double precision floating point numbers which should be identical to those from the original RANF.      There is a subtlety in the implementation of the seeding.  The initial state is reversed through one step, by multiplying by the modular inverse of a mod m.  This is done for compatibility with the original CRAY implementation.      Note that you can only seed the generator with integers up to 2^32, while the original CRAY implementation uses non-portable wide integers which can cover all  2^48 states of the generator.      The function  gsl_rng_get  returns the upper 32 bits from each term of the sequence.  The function  gsl_rng_uniform  uses the full 48 bits to return the double precision number x_n/m.      The period of this generator is  2^46.           Generator:   gsl_rng_ranmar      This is the RANMAR lagged-fibonacci generator of Marsaglia, Zaman and Tsang.  It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers.  It was included in the CERNLIB high-energy physics library.           Generator:   gsl_rng_r250        This is the shift-register generator of Kirkpatrick and Stoll.  The sequence is      x_n = x_{n-103} ^^ x_{n-250}      where  ^^ denote ""exclusive-or"", defined on 32-bit words.  The period of this generator is about  2^250 and it uses 250 words of state per generator.      For more information see,       S. Kirkpatrick and E. Stoll, ""A very fast shift-register sequence random number generator"",  Journal of Computational Physics , 40, 517-526 (1981)            Generator:   gsl_rng_tt800      This is an earlier version of the twisted generalized feedback shift-register generator, and has been superseded by the development of MT19937.  However, it is still an acceptable generator in its own right.  It has a period of  2^800 and uses 33 words of storage per generator.      For more information see,       Makoto Matsumoto and Yoshiharu Kurita, ""Twisted GFSR Generators II"",  ACM Transactions on Modelling and Computer Simulation , Vol. 4, No. 3, 1994, pages 254-266.            Generator:   gsl_rng_vax      This is the VAX generator  MTH$RANDOM .  Its sequence is,      x_{n+1} = (a x_n + c) mod m      with  a = 69069, c = 1 and  m = 2^32.  The seed specifies the initial value,  x_1.  The period of this generator is  2^32 and it uses 1 word of storage per generator.           Generator:   gsl_rng_transputer    This is the random number generator from the INMOS Transputer Development system.  Its sequence is,      x_{n+1} = (a x_n) mod m      with a = 1664525 and  m = 2^32. The seed specifies the initial value,  x_1.           Generator:   gsl_rng_randu      This is the IBM  RANDU  generator.  Its sequence is      x_{n+1} = (a x_n) mod m      with a = 65539 and  m = 2^31.  The seed specifies the initial value,  x_1.  The period of this generator was only  2^29.  It has become a textbook example of a poor generator.           Generator:   gsl_rng_minstd      This is Park and Miller's ""minimal standard"" MINSTD generator, a simple linear congruence which takes care to avoid the major pitfalls of such algorithms.  Its sequence is,      x_{n+1} = (a x_n) mod m      with a = 16807 and  m = 2^31 - 1 = 2147483647.  The seed specifies the initial value,  x_1.  The period of this generator is about  2^31.      This generator is used in the IMSL Library (subroutine RNUN) and in MATLAB (the RAND function).  It is also sometimes known by the acronym ""GGL"" (I'm not sure what that stands for).      For more information see,       Park and Miller, ""Random Number Generators: Good ones are hard to find"",  Communications of the ACM , October 1988, Volume 31, No 10, pages 1192-1201.            Generator:   gsl_rng_uni     Generator:   gsl_rng_uni32    This is a reimplementation of the 16-bit SLATEC random number generator RUNIF. A generalization of the generator to 32 bits is provided by  gsl_rng_uni32 .  The original source code is available from NETLIB.           Generator:   gsl_rng_slatec    This is the SLATEC random number generator RAND. It is ancient.  The original source code is available from NETLIB.            Generator:   gsl_rng_zuf    This is the ZUFALL lagged Fibonacci series generator of Peterson.  Its sequence is,      t = u_{n-273} + u_{n-607} u_n  = t - floor(t)      The original source code is available from NETLIB.  For more information see,       W. Petersen, ""Lagged Fibonacci Random Number Generators for the NEC SX-3"",  International Journal of High Speed Computing  (1994).            Generator:   gsl_rng_borosh13    This is the Borosh, Niederreiter random number generator. It is taken from Knuth's  Seminumerical Algorithms , 3rd Ed., pages 106-108. Its sequence is,      x_{n+1} = (a x_n) mod m      with a = 1812433253 and  m = 2^32. The seed specifies the initial value,  x_1.           Generator:   gsl_rng_coveyou    This is the Coveyou random number generator. It is taken from Knuth's  Seminumerical Algorithms , 3rd Ed., Section 3.2.2. Its sequence is,      x_{n+1} = (x_n (x_n + 1)) mod m      with  m = 2^32. The seed specifies the initial value,  x_1.           Generator:   gsl_rng_fishman18    This is the Fishman, Moore III random number generator. It is taken from Knuth's  Seminumerical Algorithms , 3rd Ed., pages 106-108. Its sequence is,      x_{n+1} = (a x_n) mod m      with a = 62089911 and  m = 2^31 - 1. The seed specifies the initial value,  x_1.           Generator:   gsl_rng_fishman20    This is the Fishman random number generator. It is taken from Knuth's  Seminumerical Algorithms , 3rd Ed., page 108. Its sequence is,      x_{n+1} = (a x_n) mod m      with a = 48271 and  m = 2^31 - 1. The seed specifies the initial value,  x_1.           Generator:   gsl_rng_fishman2x    This is the L'Ecuyer - Fishman random number generator. It is taken from Knuth's  Seminumerical Algorithms , 3rd Ed., page 108. Its sequence is,      z_{n+1} = (x_n - y_n) mod m      with  m = 2^31 - 1. x_n and y_n are given by the  fishman20   and  lecuyer21  algorithms. The seed specifies the initial value,  x_1.            Generator:   gsl_rng_knuthran2    This is a second-order multiple recursive generator described by Knuth in  Seminumerical Algorithms , 3rd Ed., page 108.  Its sequence is,      x_n = (a_1 x_{n-1} + a_2 x_{n-2}) mod m      with  a_1 = 271828183,  a_2 = 314159269,  and  m = 2^31 - 1.           Generator:   gsl_rng_knuthran    This is a second-order multiple recursive generator described by Knuth in  Seminumerical Algorithms , 3rd Ed., Section 3.6.  Knuth provides its C code.           Generator:   gsl_rng_lecuyer21    This is the L'Ecuyer random number generator. It is taken from Knuth's  Seminumerical Algorithms , 3rd Ed., page 106-108. Its sequence is,      x_{n+1} = (a x_n) mod m      with a = 40692 and  m = 2^31 - 249. The seed specifies the initial value,  x_1.           Generator:   gsl_rng_waterman14    This is the Waterman random number generator. It is taken from Knuth's  Seminumerical Algorithms , 3rd Ed., page 106-108. Its sequence is,      x_{n+1} = (a x_n) mod m      with a = 1566083941 and  m = 2^32. The seed specifies the initial value,  x_1.          Random Number Generator Performance     The following table shows the relative performance of a selection the available random number generators.  The simulation quality generators which offer the best performance are  taus ,  gfsr4  and  mt19937 .       1754 k ints/sec,    870 k doubles/sec, taus 1613 k ints/sec,    855 k doubles/sec, gfsr4 1370 k ints/sec,    769 k doubles/sec, mt19937  565 k ints/sec,    571 k doubles/sec, ranlxs0  400 k ints/sec,    405 k doubles/sec, ranlxs1  490 k ints/sec,    389 k doubles/sec, mrg  407 k ints/sec,    297 k doubles/sec, ranlux  243 k ints/sec,    254 k doubles/sec, ranlxd1  251 k ints/sec,    253 k doubles/sec, ranlxs2  238 k ints/sec,    215 k doubles/sec, cmrg  247 k ints/sec,    198 k doubles/sec, ranlux389  141 k ints/sec,    140 k doubles/sec, ranlxd2  1852 k ints/sec,    935 k doubles/sec, ran3  813 k ints/sec,    575 k doubles/sec, ran0  787 k ints/sec,    476 k doubles/sec, ran1  379 k ints/sec,    292 k doubles/sec, ran2       Examples     The following program demonstrates the use of a random number generator to produce uniform random numbers in range [0.0, 1.0),      #include <stdio.h> #include <gsl/gsl_rng.h>  int main (void) {   const gsl_rng_type * T;   gsl_rng * r;    int i, n = 10;    gsl_rng_env_setup();    T = gsl_rng_default;   r = gsl_rng_alloc (T);    for (i = 0; i < n; i++)      {       double u = gsl_rng_uniform (r);       printf(""%.5f\n"", u);     }    gsl_rng_free (r);    return 0; }      Here is the output of the program,      $ ./a.out  0.66758 0.36908 0.72483 0.68776 0.57365 0.81078 0.27108 0.83777 0.13736 0.95745      The numbers depend on the seed used by the generator.  The default seed can be changed with the  GSL_RNG_SEED  environment variable to produce a different stream of numbers.  The generator itself can be changed using the environment variable  GSL_RNG_TYPE .  Here is the output of the program using a seed value of 123 and the mutiple-recursive generator  mrg ,      $ GSL_RNG_SEED=123 GSL_RNG_TYPE=mrg ./a.out  GSL_RNG_TYPE=mrg GSL_RNG_SEED=123 0.33050 0.86631 0.32982 0.67620 0.53391 0.06457 0.16847 0.70229 0.04371 0.86374       References and Further Reading    The subject of random number generation and testing is reviewed extensively in Knuth's  Seminumerical Algorithms .          Donald E. Knuth,  The Art of Computer Programming: Seminumerical Algorithms  (Vol 2, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896842.      Further information is available in the review paper written by Pierre L'Ecuyer,       P. L'Ecuyer, ""Random Number Generation"", Chapter 4 of the Handbook on Simulation, Jerry Banks Ed., Wiley, 1998, 93--137.   http://www.iro.umontreal.ca/~lecuyer/papers.html  in the file  `handsim.ps' .      On the World Wide Web, see the pLab home page ( http://random.mat.sbg.ac.at/ ) for a lot of information on the state-of-the-art in random number generation, and for numerous links to various ""random"" WWW sites.      The source code for the DIEHARD random number generator tests is also available online.           DIEHARD source code  G. Marsaglia,     http://stat.fsu.edu/pub/diehard/        Acknowledgements    Thanks to Makoto Matsumoto, Takuji Nishimura and Yoshiharu Kurita for making the source code to their generators (MT19937, MM&TN; TT800, MM&YK) available under the GNU General Public License.  Thanks to Martin L@""uscher for providing notes and source code for the RANLXS and RANLXD generators.        Go to the  first ,  previous ,  next ,  last  section,  table of contents ."
GX049-86-12329699	MATLAB Function Reference      Go to function:          Search      Help Desk       ifft2       Examples     See Also               Inverse two-dimensional fast Fourier transform   Syntax   Y = ifft2(X)  Y = ifft2(X,m,n)    Description   Y = ifft2(X)    returns the two-dimensional inverse fast Fourier transform of matrix  X .    Y = ifft2(X,m,n)    returns the  m- by -n  inverse fast Fourier transform of matrix  X .   Examples   For any  X ,  ifft2(fft2(X))  equals  X  to within roundoff error. If  X  is real,  ifft2(fft2(X))  may have small imaginary parts.   Algorithm   The algorithm for  ifft2(X)  is the same as the algorithm for  fft2(X) , except for a sign change and scale factors of  [m,n]   =   size(X) . The execution time is fastest when  m  and  n  are powers of 2 and slowest when  they are  large primes.   See Also   dftmtx  and  freqz  in the Signal Processing Toolbox, and:   fft2 ,  fftshift ,  ifft        [  Previous  |  Help Desk  |  Next  ]
GX048-76-14630722	MATLAB Function Reference      Go to function:          Search      Help Desk       factor       Examples     See Also               Prime factors   Syntax   f = factor(n)  f = factor(symb)    Description   f = factor(n)    returns a row vector containing the prime factors of  n .   Examples   f = factor(123)  f =       3    41    See Also   isprime ,  primes        [  Previous  |  Help Desk  |  Next  ]
GX048-74-9723176	PHP Manual Prev Next mt_rand     (PHP 3>= 3.0.6, PHP 4 >= 4.0.0) mt_rand -- Generate a better random value Description int  mt_rand  (void) int  mt_rand  (int        min, int        max)      Many random number generators of older libcs have dubious or      unknown characteristics and are slow. By default, PHP uses the      libc random number generator with the  rand()       function.   mt_rand()  function is a drop-in      replacement for this.  It uses a random number generator with      known characteristics, the Mersenne Twister, which will produce      random numbers that should be suitable for seeding some kinds      of cryptography (see the home pages for details) and is four      times faster than what the average libc provides. The Homepage      of the Mersenne Twister can be found at       http://www.math.keio.ac.jp/~matumoto/emt.html , and an      optimized version of the MT source is available from       http://www.scp.syr.edu/~marc/hawk/twister.html       .           If called without the optional  min ,       max  arguments  mt_rand()       returns a pseudo-random value between 0 and       RAND_MAX .  If you want a random number      between 5 and 15 (inclusive), for example, use  mt_rand      (5, 15) .           Remember to seed the random number generator before use with       mt_srand() .      Note:         In versions before 3.0.7 the meaning of        max  was  range . To       get the same results in these versions the short example should       be  mt_rand (5, 11)  to get a random number       between 5 and 15.            See also  mt_srand() ,       mt_getrandmax() ,  srand() ,       rand()  and  getrandmax() .      Prev Home Next min Up mt_srand
GX034-03-11249968	First Edition (October 1997)    Trademarks and Acknowledgements    About This Book    Chapter 1. Data Link Controls      Chapter 2. Data Link Provider Interface (DLPI)      DL_ATTACH_REQ Primitive    DL_BIND_ACK Primitive    DL_BIND_REQ Primitive    DL_CONNECT_CON Primitive    DL_CONNECT_IND Primitive    DL_CONNECT_REQ Primitive    DL_CONNECT_RES Primitive    DL_DATA_IND Primitive    DL_DATA_REQ Primitive    DL_DETACH_REQ Primitive    DL_DISABMULTI_REQ Primitive    DL_DISCONNECT_IND Primitive    DL_DISCONNECT_REQ Primitive    DL_ENABMULTI_REQ Primitive    DL_ERROR_ACK Primitive    DL_GET_STATISTICS_ACK Primitive    DL_GET_STATISTICS_REQ    DL_INFO_ACK Primitive    DL_INFO_REQ Primitive    DL_OK_ACK Primitive    DL_PHYS_ADDR_ACK Primitive    DL_PHYS_ADDR_REQ Primitive    DL_PROMISCOFF_REQ Primitive    DL_PROMISCON_REQ Primitive    DL_RESET_CON Primitive    DL_RESET_IND Primitive    DL_RESET_REQ Primitive    DL_RESET_RES Primitive    DL_SUBS_BIND_ACK Primitive    DL_SUBS_BIND_REQ Primitive    DL_SUBS_UNBIND_REQ Primitive    DL_TEST_CON Primitive    DL_TEST_IND Primitive    DL_TEST_REQ Primitive    DL_TEST_RES Primitive    DL_TOKEN_ACK Primitive    DL_TOKEN_REQ Primitive    DL_UDERROR_IND Primitive    DL_UNBIND_REQ Primitive    DL_UNITDATA_IND Primitive    DL_UNITDATA_REQ Primitive    DL_XID_CON Primitive    DL_XID_IND Primitive    DL_XID_REQ Primitive    DL_XID_RES Primitive        Chapter 3. eXternal Data Representation    Chapter 4. AIX 3270 Host Connection Program (HCON)    Chapter 5. Network Computing System (NCS)    Chapter 6.Network Information Services (NIS) and Network Information Services+ (NIS+)    Chapter 7. New Database Manager (NDBM)    Chapter 8. Remote Procedure Calls (RPC)
GX040-40-9455439	GLib Reference Manual <<< Previous Page Home Up Next Page >>> Random Numbers Name Random Numbers -- pseudo random number generator. Synopsis #include <glib.h>   struct       GRand ;  GRand *       g_rand_new_with_seed             ( guint32  seed);  GRand *       g_rand_new                       (void); void         g_rand_free                      ( GRand  *rand); void         g_rand_set_seed                  ( GRand  *rand,                                               guint32  seed); #define      g_rand_boolean                   (rand)  guint32       g_rand_int                       ( GRand  *rand);  gint32        g_rand_int_range                 ( GRand  *rand,                                               gint32  begin,                                               gint32  end);  gdouble       g_rand_double                    ( GRand  *rand);  gdouble       g_rand_double_range              ( GRand  *rand,                                               gdouble  begin,                                               gdouble  end); void         g_random_set_seed                ( guint32  seed); #define      g_random_boolean                 ()  guint32       g_random_int                     (void);  gint32        g_random_int_range               ( gint32  begin,                                               gint32  end);  gdouble       g_random_double                  (void);  gdouble       g_random_double_range            ( gdouble  begin,                                               gdouble  end); Description The following functions allow you to use a portable, fast and good pseudo random number generator (PRNG). It uses the Mersenne Twister PRNG, which was originally developed by Makoto Matsumoto and Takuji Nishimura. Further information can be found at  www.math.keio.ac.jp/~matumoto/emt.html . If you just need a random number, you simply call the   g_random_*  functions, which will create a globally  used  GRand  and use the according  g_rand_*  functions  internally. Whenever you need a stream of reproducible random numbers, you  better create a  GRand  yourself and use the  g_rand_*   functions directly, which will also be slightly faster. Initializing a  GRand   with a certain seed will produce exactly the same series of random numbers  on all platforms. This can thus be used as a seed for e.g. games. The  g_rand*_range  functions will return high quality equally distributed random numbers, whereas for example the  ( g_random_int ()% max )  approach often doesn't yield equally distributed numbers. Details struct GRand struct GRand; The  GRand  struct is an opaque data structure. It should only be accessed through the  g_rand_*  functions. g_rand_new_with_seed () GRand *      g_rand_new_with_seed            ( guint32  seed); Creates a new random number generator initialized with  seed . seed  :  a value to initialize the random number generator. Returns  :  the new  GRand . g_rand_new () GRand *      g_rand_new                      (void); Creates a new random number generator initialized with a seed taken either from  /dev/urandom  (if existing) or from  the current time (as a fallback). Returns  :  the new  GRand . g_rand_free () void        g_rand_free                     ( GRand  *rand); Frees the memory allocated for the  GRand . rand  :  a  GRand . g_rand_set_seed () void        g_rand_set_seed                 ( GRand  *rand,                                               guint32  seed); Sets the seed for the random number generator  GRand  to  seed . rand  :  a  GRand . seed  :  a value to reinitialize the random number generator. g_rand_boolean() #define     g_rand_boolean(rand) Returns a random  gboolean  from  rand . This corresponds to a unbiased coin toss. rand  : a  GRand . Returns  : a random  gboolean .  g_rand_int () guint32      g_rand_int                      ( GRand  *rand); Returns the next random  guint32  from  rand  equally distributed over the range [0..2^32-1]. rand  :  a  GRand . Returns  :  A random number. g_rand_int_range () gint32       g_rand_int_range                ( GRand  *rand,                                               gint32  begin,                                               gint32  end); Returns the next random  gint32  from  rand  equally distributed over the range [ begin .. end -1]. rand  :  a  GRand . begin  :  lower closed bound of the interval. end  :  upper open bound of the interval. Returns  :  A random number. g_rand_double () gdouble      g_rand_double                   ( GRand  *rand); Returns the next random  gdouble  from  rand  equally distributed over the range [0..1). rand  :  a  GRand . Returns  :  A random number. g_rand_double_range () gdouble      g_rand_double_range             ( GRand  *rand,                                               gdouble  begin,                                               gdouble  end); Returns the next random  gdouble  from  rand  equally distributed over the range [ begin .. end ). rand  :  a  GRand . begin  :  lower closed bound of the interval. end  :  upper open bound of the interval. Returns  :  A random number. g_random_set_seed () void        g_random_set_seed               ( guint32  seed); Sets the seed for the global random number generator, which is used by the  g_random_*  functions, to  seed . seed  :  a value to reinitialize the global random number generator. g_random_boolean() #define     g_random_boolean() Returns a random  gboolean . This corresponds to a unbiased coin toss. Returns  : a random  gboolean .  g_random_int () guint32      g_random_int                    (void); Return a random  guint32  equally distributed over the range [0..2^32-1]. Returns  :  A random number. g_random_int_range () gint32       g_random_int_range              ( gint32  begin,                                               gint32  end); Returns a random  gint32  equally distributed over the range [ begin .. end -1]. begin  :  lower closed bound of the interval. end  :  upper open bound of the interval. Returns  :  A random number. g_random_double () gdouble      g_random_double                 (void); Returns a random  gdouble  equally distributed over the range [0..1). Returns  :  A random number. g_random_double_range () gdouble      g_random_double_range           ( gdouble  begin,                                               gdouble  end); Returns a random  gdouble  equally distributed over the range [ begin .. end ). begin  :  lower closed bound of the interval. end  :  upper open bound of the interval. Returns  :  A random number. <<< Previous Page Home Up Next Page >>> Date and Time Functions Hook Functions
GX034-17-9112076	"// @(#)root/base:$Name:  $:$Id:  TRandom3 .cxx,v 1.5 2003/01/26 21:03:16 brun Exp $   // Author: Peter Malzacher   31/08/99    //////////////////////////////////////////////////////////////////////////   //   //  TRandom3   //   // Random number generator class based on   //   M. Matsumoto and T. Nishimura,   //   Mersenne Twistor: A 623-diminsionally equidistributed   //   uniform pseudorandom number generator   //   ACM Transactions on Modeling and Computer Simulation,   //   Vol. 8, No. 1, January 1998, pp 3--30.   //   // For more information see the Mersenne Twistor homepage   //   http://www.math.keio.ac.jp/~matumoto/emt. html   //   // Advantage: large period 2**19937-1   //            relativly fast   //              (only two times slower than  TRandom , but   //               two times faster than  TRandom2 )   // Drawback:  a relative large internal state of 624 integers   //   //   // Aug.99 ROOT implementation based on CLHEP by P.Malzacher   //   // the original code contains the following copyright notice:  /* This library is free software; you can redistribute it and/or   */ /* modify it under the terms of the GNU Library General Public     */ /* License as published by the Free Software Foundation; either    */ /* version 2 of the License, or (at your option) any later         */ /* version.                                                        */ /* This library is distributed in the hope that it will be useful, */ /* but WITHOUT ANY WARRANTY; without even the implied warranty of  */ /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.            */ /* See the GNU Library General Public License for more details.    */ /* You should have received a copy of the GNU Library General      */ /* Public License along with this library; if not, write to the    */ /* Free Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA   */ /* 02111-1307  USA                                                 */ /* Copyright (C) 1997 Makoto Matsumoto and Takuji Nishimura.       */ /* When you use this, send an email to: matumoto@math.keio.ac.jp   */ /* with an appropriate reference to your work.                     */  /////////////////////////////////////////////////////////////////////   #include "" TRandom3.h "" #include "" TClass.h "" #include "" TMath.h ""  ClassImp(TRandom3)   //______________________________________________________________________________     TRandom3::TRandom3 ( UInt_t  seed) {  //*-*-*-*-*-*-*-*-*-*-*default constructor*-*-*-*-*-*-*-*-*-*-*-*-*-*-*   //*-*                  ===================      SetName(""Random3"");    SetTitle(""Random number generator: Mersenne Twistor"");     SetSeed (seed); }   //______________________________________________________________________________     TRandom3 ::~ TRandom3 () {  //*-*-*-*-*-*-*-*-*-*-*default destructor*-*-*-*-*-*-*-*-*-*-*-*-*-*-*   //*-*                  ==================   }   //______________________________________________________________________________     Double_t   TRandom3::Rndm ( Int_t ) {  //  Machine independent random number generator.   //  Produces uniformly-distributed floating points in [0,1]   //  Method: Mersenne Twistor        UInt_t  y;      const  Int_t   kM = 397;     const  Int_t   kN = 624;     const  UInt_t  kTemperingMaskB =  0x9d2c5680;     const  UInt_t  kTemperingMaskC =  0xefc60000;     const  UInt_t  kUpperMask =       0x80000000;     const  UInt_t  kLowerMask =       0x7fffffff;     const  UInt_t  kMatrixA =         0x9908b0df;      if ( fCount624  >= kN) {       register  Int_t  i;        for (i=0; i < kN-kM; i++) {         y = ( fMt [i] & kUpperMask) | ( fMt [i+1] & kLowerMask);          fMt [i] =  fMt [i+kM] ^ (y >> 1) ^ ((y & 0x1) ? kMatrixA : 0x0);       }        for (   ; i < kN-1    ; i++) {         y = ( fMt [i] & kUpperMask) | ( fMt [i+1] & kLowerMask);          fMt [i] =  fMt [i+kM-kN] ^ (y >> 1) ^ ((y & 0x1) ? kMatrixA : 0x0);       }        y = ( fMt [kN-1] & kUpperMask) | ( fMt [0] & kLowerMask);        fMt [kN-1] =  fMt [kM-1] ^ (y >> 1) ^ ((y & 0x1) ? kMatrixA : 0x0);        fCount624  = 0;     }      y =  fMt [ fCount624 ++];     y ^=  (y >> 11);     y ^= ((y << 7 ) & kTemperingMaskB );     y ^= ((y << 15) & kTemperingMaskC );     y ^=  (y >> 18);      if (y) return ( ( Double_t ) y * 2.3283064365386963e-10); // * Power(2,-32)     return  Rndm (); }   //______________________________________________________________________________     void   TRandom3::RndmArray ( Int_t  n,  Float_t  *array) {    // Return an array of n random numbers uniformly distributed in ]0,1]        for( Int_t  i=0; i<n; i++) array[i]=( Float_t ) Rndm (); }   //______________________________________________________________________________     void   TRandom3::RndmArray ( Int_t  n,  Double_t  *array) {    // Return an array of n random numbers uniformly distributed in ]0,1]        for( Int_t  i=0; i<n; i++) array[i]= Rndm (); }   //______________________________________________________________________________     void   TRandom3::SetSeed ( UInt_t  seed) {  //  Set the random generator sequence       TRandom::SetSeed (seed);     fCount624  = 624;     fMt [0] =  fSeed ;     Int_t  i;    for(i=1; i<624; i++) {       fMt [i] = (69069 *  fMt [i-1]) & 0xffffffff;    } }   //______________________________________________________________________________     void   TRandom3::Streamer ( TBuffer  &R__b) {     // Stream an object of class  TRandom3 .      if (R__b.IsReading()) {        UInt_t  R__s, R__c;        Version_t  R__v = R__b.ReadVersion(&R__s, &R__c);       if (R__v > 1) {           TRandom3::Class ()->ReadBuffer(R__b, this, R__v, R__s, R__c);          return;       }        //====process old versions before automatic schema evolution         TRandom::Streamer (R__b);       R__b.ReadStaticArray( fMt );       R__b >>  fCount624 ;       R__b.CheckByteCount(R__s, R__c,  TRandom3::IsA ());        //====end of old versions            } else {        TRandom3::Class ()->WriteBuffer(R__b,this);    } }               ROOT page  -  Home page  -  Class index  -  Top of the page          This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to  ROOT support , or contact  the developers  with any questions or problems regarding ROOT."
GX048-21-1079798	"[   Next Article   |  Previous Article   |  Book Contents  |  Library Home  |  Legal  |  Search  ]      Communications Technical Reference, Volume 1        DL_OK_ACK Primitive         Purpose   Acknowledges that a previously issued primitive was received successfully.     Structure   The message consists of one  M_PCPROTO  message block, which contains the following structure:    typedef struct    {      ulong   dl_primitive ;      ulong   dl_correct_primitive ;   } dl_ok_ack_t;     This structure is defined in  /usr/include/sys/dlpi.h .     Description   The  DL_OK_ACK  primitive acknowledges to the data link service (DLS) user that a previously issued primitive was received successfully. It is only initiated for the primitives listed in the ""States"" section.     Parameters   dl_primitive     Specifies the  DL_OK_ACK  primitive.   dl_correct_primitive     Identifies the received primitive that is being acknowledged.     States   Valid     The primitive is valid in response to the following primitives:   DL_ATTACH_REQ   DL_DETACH_REQ   DL_UNBIND_REQ   DL_SUBS_UNBIND_REQ   DL_PROMISCON_REQ   DL_ENABMULTI_REQ   DL_DISABMULTI_REQ   DL_PROMISCOFF_REQ    New     The resulting state depends on the current state and is fully defined in ""Allowable Sequence of DLPI Primitives"" in your copy of the AT&T DLPI Specifications.       Implementation Specifics   This primitive is part of Base Operating System (BOS) Runtime.     Related Information   The  DL_ATTACH_REQ  primitive,  DL_DETACH_REQ  primitive,  DL_UNBIND_REQ   primitive,  DL_SUBS_UNBIND_REQ  primitive,  DL_PROMISCON_REQ  primitive,  DL_ENABMULTI_REQ  primitive,  DL_DISABMULTI_REQ  primitive,  DL_PROMISCOFF_REQ  primitive.  [   Next Article   |  Previous Article   |  Book Contents  |  Library Home  |  Legal  |  Search  ]"
GX045-67-6152235	"Advanced Bash-Scripting Guide:  Prev Next Chapter 26. Arrays Newer versions of Bash support one-dimensional arrays.  Array elements may be initialized with the   variable[xx]  notation. Alternatively,  a script may introduce the entire array by an explicit   declare -a variable  statement. To  dereference (find the contents of) an array element, use   curly bracket  notation, that is,   ${variable[xx]} . Example 26-1. Simple array usage #!/bin/bash   area[11]=23 area[13]=37 area[51]=UFOs  # Array members need not be consecutive or contiguous.  # Some members of the array can be left uninitialized. # Gaps in the array are o.k.   echo -n ""area[11] = "" echo ${area[11]}    #  {curly brackets} needed  echo -n ""area[13] = "" echo ${area[13]}  echo ""Contents of area[51] are ${area[51]}.""  # Contents of uninitialized array variable print blank. echo -n ""area[43] = "" echo ${area[43]} echo ""(area[43] unassigned)""  echo  # Sum of two array variables assigned to third area[5]=`expr ${area[11]} + ${area[13]}` echo ""area[5] = area[11] + area[13]"" echo -n ""area[5] = "" echo ${area[5]}  area[6]=`expr ${area[11]} + ${area[51]}` echo ""area[6] = area[11] + area[51]"" echo -n ""area[6] = "" echo ${area[6]} # This fails because adding an integer to a string is not permitted.  echo; echo; echo  # ----------------------------------------------------------------- # Another array, ""area2"". # Another way of assigning array variables... # array_name=( XXX YYY ZZZ ... )  area2=( zero one two three four )  echo -n ""area2[0] = "" echo ${area2[0]} # Aha, zero-based indexing (first element of array is [0], not [1]).  echo -n ""area2[1] = "" echo ${area2[1]}    # [1] is second element of array. # -----------------------------------------------------------------  echo; echo; echo  # ----------------------------------------------- # Yet another array, ""area3"". # Yet another way of assigning array variables... # array_name=([xx]=XXX [yy]=YYY ...)  area3=([17]=seventeen [24]=twenty-four)  echo -n ""area3[17] = "" echo ${area3[17]}  echo -n ""area3[24] = "" echo ${area3[24]} # -----------------------------------------------  exit 0 Example 26-2. Formatting a poem #!/bin/bash # poem.sh  # Lines of the poem (single stanza). Line[1]=""I do not know which to prefer,"" Line[2]=""The beauty of inflections"" Line[3]=""Or the beauty of innuendoes,"" Line[4]=""The blackbird whistling"" Line[5]=""Or just after.""  # Attribution. Attrib[1]="" Wallace Stevens"" Attrib[2]=""\""Thirteen Ways of Looking at a Blackbird\""""  for index in 1 2 3 4 5    # Five lines. do   printf ""     %s\n"" ""${Line[index]}"" done  for index in 1 2          # Two attribution lines. do   printf ""          %s\n"" ""${Attrib[index]}"" done  exit 0 Array variables have a syntax all their own, and even  standard Bash commands and operators have special options adapted  for array use.        array=( zero one two three four five )  echo ${array[0]}       #  zero echo ${array:0}        #  zero                        #  Parameter expansion of first element. echo ${array:1}        #  ero                        #  Parameter expansion of first element,                        #+ starting at position #1 (2nd character).  echo ${#array}         #  4                        #  Length of first element of array.         In an array context, some Bash  builtins  have a slightly altered  meaning. For example,  unset   deletes array elements, or even an entire array. Example 26-3. Some special properties of arrays #!/bin/bash  declare -a colors # Permits declaring an array without specifying its size.  echo ""Enter your favorite colors (separated from each other by a space).""  read -a colors    # Enter at least 3 colors to demonstrate features below. #  Special option to 'read' command, #+ allowing assignment of elements in an array.  echo  element_count=${#colors[@]} # Special syntax to extract number of elements in array. #     element_count=${#colors[*]} works also. # #  The ""@"" variable allows word splitting within quotes #+ (extracts variables separated by whitespace).  index=0  while [ ""$index"" -lt ""$element_count"" ] do    # List all the elements in the array.   echo ${colors[$index]}   let ""index = $index + 1"" done # Each array element listed on a separate line. # If this is not desired, use  echo -n ""${colors[$index]} "" # # Doing it with a ""for"" loop instead: #   for i in ""${colors[@]}"" #   do #     echo ""$i"" #   done # (Thanks, S.C.)  echo  # Again, list all the elements in the array, but using a more elegant method.   echo ${colors[@]}          # echo ${colors[*]} also works.  echo  # The ""unset"" command deletes elements of an array, or entire array. unset colors[1]              # Remove 2nd element of array.                              # Same effect as   colors[1]= echo  ${colors[@]}           # List array again, missing 2nd element.  unset colors                 # Delete entire array.                              #  unset colors[*] and                              #+ unset colors[@] also work. echo; echo -n ""Colors gone.""       echo ${colors[@]}            # List array again, now empty.  exit 0 As seen in the previous example, either   ${array_name[@]}  or   ${array_name[*]}  refers to   all  the elements of the array.  Similarly, to get a count of the number of elements in an  array, use either  ${#array_name[@]}   or  ${#array_name[*]} .   ${#array_name}  is the length (number of  characters) of  ${array_name[0]} , the first  element of the array. Example 26-4. Of empty arrays and empty elements #!/bin/bash # empty-array.sh  # An empty array is not the same as an array with empty elements.  array0=( first second third ) array1=( '' )   # ""array1"" has one empty element. array2=( )      # No elements... ""array2"" is empty.  echo  echo ""Elements in array0:  ${array0[@]}"" echo ""Elements in array1:  ${array1[@]}"" echo ""Elements in array2:  ${array2[@]}"" echo echo ""Length of first element in array0 = ${#array0}"" echo ""Length of first element in array1 = ${#array1}"" echo ""Length of first element in array2 = ${#array2}"" echo echo ""Number of elements in array0 = ${#array0[*]}""  # 3 echo ""Number of elements in array1 = ${#array1[*]}""  # 1  (surprise!) echo ""Number of elements in array2 = ${#array2[*]}""  # 0  echo  exit 0  # Thanks, S.C. The relationship of  ${array_name[@]}   and  ${array_name[*]}  is analogous to that  between  $@ and $* . This powerful  array notation has a number of uses.        # Copying an array. array2=( ""${array1[@]}"" ) # or array2=""${array1[@]}""  # Adding an element to an array. array=( ""${array[@]}"" ""new element"" ) # or array[${#array[*]}]=""new element""  # Thanks, S.C.         The  array=( element1 element2 ... elementN )   initialization operation, with the help of  command substitution , makes it  possible to load the contents of a text file into an array.            #!/bin/bash  filename=sample_file  #            cat sample_file # #            1 a b c #            2 d e fg   declare -a array1  array1=( `cat ""$filename"" | tr '\n' ' '`)  # Loads contents                                            # of $filename into array1. #         list file to stdout. #                           change linefeeds in file to spaces.   echo ${array1[@]}            # List the array. #                              1 a b c 2 d e fg # #  Each whitespace-separated ""word"" in the file #+ has been assigned to an element of the array.  element_count=${#array1[*]} echo $element_count          # 8         Arrays permit deploying old familiar algorithms as shell scripts.         Whether this is necessarily a good idea is left to the reader to  decide. Example 26-5. An old friend:               The Bubble Sort #!/bin/bash # bubble.sh: Bubble sort, of sorts.  # Recall the algorithm for a bubble sort. In this particular version...  #  With each successive pass through the array to be sorted, #+ compare two adjacent elements, and swap them if out of order. #  At the end of the first pass, the ""heaviest"" element has sunk to bottom. #  At the end of the second pass, the next ""heaviest"" one has sunk next to bottom. #  And so forth. #  This means that each successive pass needs to traverse less of the array. #  You will therefore notice a speeding up in the printing of the later passes.   exchange() {   # Swaps two members of the array.   local temp=${Countries[$1]} #  Temporary storage                               #+ for element getting swapped out.   Countries[$1]=${Countries[$2]}   Countries[$2]=$temp      return }    declare -a Countries  #  Declare array,                       #+ optional here since it's initialized below.  #  Is it permissable to split an array variable over multiple lines #+ using an escape (\)? #  Yes.  Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \ Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \ Israel Peru Canada Oman Denmark Wales France Kenya \ Xanadu Qatar Liechtenstein Hungary)  # ""Xanadu"" is the mythical place where, according to Coleridge, #+ Kubla Khan did a pleasure dome decree.   clear                      # Clear the screen to start with.   echo ""0: ${Countries[*]}""  # List entire array at pass 0.  number_of_elements=${#Countries[@]} let ""comparisons = $number_of_elements - 1""  count=1 # Pass number.  while [ ""$comparisons"" -gt 0 ]          # Beginning of outer loop do    index=0  # Reset index to start of array after each pass.    while [ ""$index"" -lt ""$comparisons"" ] # Beginning of inner loop   do     if [ ${Countries[$index]} \> ${Countries[`expr $index + 1`]} ]     #  If out of order...     #  Recalling that \> is ASCII comparison operator     #+ within single brackets.      #  if [[ ${Countries[$index]} > ${Countries[`expr $index + 1`]} ]]     #+ also works.     then       exchange $index `expr $index + 1`  # Swap.     fi       let ""index += 1""   done # End of inner loop     let ""comparisons -= 1"" #  Since ""heaviest"" element bubbles to bottom,                        #+ we need do one less comparison each pass.  echo echo ""$count: ${Countries[@]}""  # Print resultant array at end of each pass. echo let ""count += 1""                # Increment pass count.  done                            # End of outer loop                                 # All done.  exit 0 -- Arrays enable implementing a shell script version of the  Sieve of  Eratosthenes . Of course, a resource-intensive application of this  nature should really be written in a compiled language, such as C. It  runs excruciatingly slowly as a script. Example 26-6. Complex array application:               Sieve of Eratosthenes #!/bin/bash # sieve.sh  # Sieve of Eratosthenes # Ancient algorithm for finding prime numbers.  # This runs a couple of orders of magnitude # slower than the equivalent C program.  LOWER_LIMIT=1       # Starting with 1. UPPER_LIMIT=1000    # Up to 1000. # (You may set this higher...  if you have time on your hands.)  PRIME=1 NON_PRIME=0  let SPLIT=UPPER_LIMIT/2 # Optimization: # Need to test numbers only halfway to upper limit.   declare -a Primes # Primes[] is an array.   initialize () { # Initialize the array.  i=$LOWER_LIMIT until [ ""$i"" -gt ""$UPPER_LIMIT"" ] do   Primes[i]=$PRIME   let ""i += 1"" done # Assume all array members guilty (prime) # until proven innocent. }  print_primes () { # Print out the members of the Primes[] array tagged as prime.  i=$LOWER_LIMIT  until [ ""$i"" -gt ""$UPPER_LIMIT"" ] do    if [ ""${Primes[i]}"" -eq ""$PRIME"" ]   then     printf ""%8d"" $i     # 8 spaces per number gives nice, even columns.   fi      let ""i += 1""    done  }  sift () # Sift out the non-primes. {  let i=$LOWER_LIMIT+1 # We know 1 is prime, so let's start with 2.  until [ ""$i"" -gt ""$UPPER_LIMIT"" ] do  if [ ""${Primes[i]}"" -eq ""$PRIME"" ] # Don't bother sieving numbers already sieved (tagged as non-prime). then    t=$i    while [ ""$t"" -le ""$UPPER_LIMIT"" ]   do     let ""t += $i ""     Primes[t]=$NON_PRIME     # Tag as non-prime all multiples.   done  fi      let ""i += 1"" done     }   # Invoke the functions sequentially. initialize sift print_primes # This is what they call structured programming.  echo  exit 0    # ----------------------------------------------- # # Code below line will not execute.  # This improved version of the Sieve, by Stephane Chazelas, # executes somewhat faster.  # Must invoke with command-line argument (limit of primes).  UPPER_LIMIT=$1                  # From command line. let SPLIT=UPPER_LIMIT/2         # Halfway to max number.  Primes=( '' $(seq $UPPER_LIMIT) )  i=1 until (( ( i += 1 ) > SPLIT ))  # Need check only halfway. do   if [[ -n $Primes[i] ]]   then     t=$i     until (( ( t += i ) > UPPER_LIMIT ))     do       Primes[t]=     done   fi   done   echo ${Primes[*]}  exit 0 Compare this array-based prime number generator with an         alternative that does not use arrays,  Example A-17 . -- Arrays lend themselves, to some extent, to emulating data         structures for which Bash has no native support. Example 26-7. Emulating a push-down stack #!/bin/bash # stack.sh: push-down stack simulation  #  Similar to the CPU stack, a push-down stack stores data items #+ sequentially, but releases them in reverse order, last-in first-out.  BP=100            # Base Pointer of stack array.                   # Begin at element 100.  SP=$BP            # Stack Pointer.                   # Initialize it to ""base"" (bottom) of stack.  Data=             # Contents of stack location.                     #  Must use local variable,                   #+ because of limitation on function return range.  declare -a stack   push()            # Push item on stack. { if [ -z ""$1"" ]    # Nothing to push? then   return fi  let ""SP -= 1""     # Bump stack pointer. stack[$SP]=$1  return }  pop()                    # Pop item off stack. { Data=                    # Empty out data item.  if [ ""$SP"" -eq ""$BP"" ]   # Stack empty? then   return fi                       #  This also keeps SP from getting past 100,                          #+ i.e., prevents a runaway stack.  Data=${stack[$SP]} let ""SP += 1""            # Bump stack pointer. return }  status_report()          # Find out what's happening. { echo ""-------------------------------------"" echo ""REPORT"" echo ""Stack Pointer = $SP"" echo ""Just popped \""""$Data""\"" off the stack."" echo ""-------------------------------------"" echo }   # ======================================================= # Now, for some fun.  echo  # See if you can pop anything off empty stack. pop status_report  echo  push garbage pop status_report     # Garbage in, garbage out.        value1=23; push $value1 value2=skidoo; push $value2 value3=FINAL; push $value3  pop              # FINAL status_report pop              # skidoo status_report pop              # 23 status_report    # Last-in, first-out!  #  Notice how the stack pointer decrements with each push, #+ and increments with each pop.  echo # =======================================================   # Exercises: # ---------  # 1)  Modify the ""push()"" function to permit pushing #   + multiple element on the stack with a single function call.  # 2)  Modify the ""pop()"" function to permit popping #   + multiple element from the stack with a single function call.  # 3)  Using this script as a jumping-off point, #   + write a stack-based 4-function calculator.  exit 0 -- Fancy manipulation of array  ""subscripts""  may require         intermediate variables. For projects involving this, again consider  using a more powerful programming language, such as Perl or C. Example 26-8. Complex array application:               Exploring a weird mathematical series #!/bin/bash  # Douglas Hofstadter's notorious ""Q-series"":  # Q(1) = Q(2) = 1 # Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), for n>2  # This is a ""chaotic"" integer series with strange and unpredictable behavior. # The first 20 terms of the series are: # 1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12   # See Hofstadter's book, ""Goedel, Escher, Bach: An Eternal Golden Braid"", # p. 137, ff.   LIMIT=100     # Number of terms to calculate LINEWIDTH=20  # Number of terms printed per line  Q[1]=1        # First two terms of series are 1. Q[2]=1  echo echo ""Q-series [$LIMIT terms]:"" echo -n ""${Q[1]} ""             # Output first two terms. echo -n ""${Q[2]} ""  for ((n=3; n <= $LIMIT; n++))  # C-like loop conditions. do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  for n>2 # Need to break the expression into intermediate terms, # since Bash doesn't handle complex array arithmetic very well.    let ""n1 = $n - 1""        # n-1   let ""n2 = $n - 2""        # n-2      t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]   t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]      T0=${Q[t0]}              # Q[n - Q[n-1]]   T1=${Q[t1]}              # Q[n - Q[n-2]]  Q[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - ![n-2]] echo -n ""${Q[n]} ""  if [ `expr $n % $LINEWIDTH` -eq 0 ]    # Format output. then   #     mod   echo # Break lines into neat chunks. fi  done  echo  exit 0  # This is an iterative implementation of the Q-series. # The more intuitive recursive implementation is left as an exercise. # Warning: calculating this series recursively takes a *very* long time. -- Bash supports only one-dimensional arrays, however a little         trickery permits simulating multi-dimensional ones. Example 26-9. Simulating a two-dimensional array, then tilting it #!/bin/bash # Simulating a two-dimensional array.  # A two-dimensional array stores rows sequentially.  Rows=5 Columns=5  declare -a alpha     # char alpha [Rows] [Columns];                      # Unnecessary declaration.  load_alpha () { local rc=0 local index   for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y do   local row=`expr $rc / $Columns`   local column=`expr $rc % $Rows`   let ""index = $row * $Rows + $column""   alpha[$index]=$i   # alpha[$row][$column]   let ""rc += 1"" done    # Simpler would be #   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y ) # but this somehow lacks the ""flavor"" of a two-dimensional array. }  print_alpha () { local row=0 local index  echo  while [ ""$row"" -lt ""$Rows"" ]   # Print out in ""row major"" order - do                             # columns vary                                # while row (outer loop) remains the same.   local column=0      while [ ""$column"" -lt ""$Columns"" ]   do     let ""index = $row * $Rows + $column""     echo -n ""${alpha[index]} ""  # alpha[$row][$column]     let ""column += 1""   done    let ""row += 1""   echo  done    # The simpler equivalent is #   echo ${alpha[*]} | xargs -n $Columns  echo }  filter ()     # Filter out negative array indices. {  echo -n ""  ""  # Provides the tilt.  if [[ ""$1"" -ge 0 &&  ""$1"" -lt ""$Rows"" && ""$2"" -ge 0 && ""$2"" -lt ""$Columns"" ]] then     let ""index = $1 * $Rows + $2""     # Now, print it rotated.     echo -n "" ${alpha[index]}""  # alpha[$row][$column] fi      }       rotate ()  # Rotate the array 45 degrees {          # (""balance"" it on its lower lefthand corner). local row local column  for (( row = Rows; row > -Rows; row-- ))  # Step through the array backwards. do    for (( column = 0; column < Columns; column++ ))   do      if [ ""$row"" -ge 0 ]     then       let ""t1 = $column - $row""       let ""t2 = $column""     else       let ""t1 = $column""       let ""t2 = $column + $row""     fi        filter $t1 $t2   # Filter out negative array indices.   done    echo; echo  done   # Array rotation inspired by examples (pp. 143-146) in # ""Advanced C Programming on the IBM PC"", by Herbert Mayer # (see bibliography).  }   #-----------------------------------------------------# load_alpha     # Load the array. print_alpha    # Print it out.   rotate         # Rotate it 45 degrees counterclockwise. #-----------------------------------------------------#   # This is a rather contrived, not to mention kludgy simulation. # # Exercises: # --------- # 1)  Rewrite the array loading and printing functions #   + in a more intuitive and elegant fashion. # # 2)  Figure out how the array rotation functions work. #     Hint: think about the implications of backwards-indexing an array.  exit 0 A two-dimensional array is essentially equivalent to a  one-dimensional one, but with additional addressing modes for  referencing and manipulating the individual elements by   ""row""  and  ""column""  position. For an even more elaborate example of simulating a         two-dimensional array, see  Example A-11 . Prev Home Next List Constructs Up Files"
GX044-60-7591054	"[   source navigation   ]   [   identifier search   ]   [   freetext search   ]   [   file search   ]   [   repository   ]         Software     Cross Reference            . / usatlas / packages / dbya / dyLoadFile.pl             Version:      [   current   ]           File /home/lxr/source/current//usatlas/packages/dbya/dyLoadFile.pl     1  #!/usr/bin/env perl    2  #    3  # $Id: dyLoadFile.pl,v 1.17 2002/02/18 20:23:03 wenaus Exp $    4  #    5  # $Log: dyLoadFile.pl,v $    6  # Revision 1.17  2002/02/18 20:23:03  wenaus    7  # Add CERN HPSS    8  #    9  # Revision 1.16  2001/12/08 16:23:08  wenaus   10  # correction for hsm listing behaviour   11  #   12  # Revision 1.15  2001/12/08 15:41:19  wenaus   13  # correction   14  #   15  # Revision 1.14  2001/12/07 22:09:02  wenaus   16  # First pass at DC0 version   17  #   18  # Revision 1.13  2001/11/14 19:18:32  wenaus   19  # General update   20  #   21  # Revision 1.12  2001/09/10 14:29:10  wenaus   22  # Correct for ' in filename   23  #   24  # Revision 1.11  2001/09/08 13:06:31  wenaus   25  # fix to ' tolerance   26  #   27  # Revision 1.10  2001/09/08 12:49:11  wenaus   28  # Protect against files with ' in name   29  #   30  # Revision 1.9  2001/08/24 21:46:09  wdeng   31  # Use MySQL quote function for blob   32  #   33  # Revision 1.8  2001/08/23 16:26:49  wenaus   34  # Use accelerator for Castor   35  #   36  # Revision 1.7  2001/08/23 16:07:32  wenaus   37  # Add Castor support   38  #   39  # Revision 1.6  2001/08/22 22:32:22  wdeng   40  # Extend the usage of sqlAccelerator to cern disk and afs   41  #   42  # Revision 1.5  2001/08/22 16:05:17  wenaus   43  # bug fix in param list   44  #   45  # Revision 1.4  2001/08/21 18:47:17  wenaus   46  # bug fix   47  #   48  # Revision 1.3  2001/08/17 19:51:25  wenaus   49  # Adapt to revised dyLoadRftpFile   50  #   51  # Revision 1.2  2001/08/05 09:08:36  wenaus   52  # bug fix   53  #   54  # Revision 1.1  2001/08/04 20:52:56  wenaus   55  # get/releasefile dev; location scanner changes   56  #   57  #   58  ######################################################################   59  #   60  # dyLoadFile.pl   61  #   62  # Torre Wenaus 3/01   63  #   64  # Magda - MAnager for Grid-based DAta   65  #   66  # Description   67  #   68  #   69     70  use strict;   71  package DBYA;   72  use File::stat;   73  require 'dySetup.pl';   74  require 'dySetLogical.pl';   75  require 'dySqlAccelerator.pl';   76     77  my $debugOn = 0;   78     79  my $suffixpattern = '\.[a-zA-Z_\\-]*';   80     81  my %ignoreDirs = (   82                 ""ignore"" => 0,   83                 ""CVS"" => 0   84                 );   85     86  sub dyLoadRftpFile {   87      my ( $line, $curDir, $lfn, $savename, $PrecentTime, $Plocation, $Plocfiles, $Plochash, $inkeys ) = @_;   88      print ""lochash: $Plochash\n"" if 0;   89      if ( 0 && ($Plochash != 0) ) {   90          foreach my $k ( keys %$Plochash ) {   91              print ""$k $$Plochash{$k}\n"";   92          }   93      }   94      if ( 0 && ($Plocfiles != 0) ) {   95          foreach my $k ( keys %$Plocfiles ) {   96              print ""$k $$Plocfiles{$k}->{logical}\n""  if $debugOn;   97          }   98      }   99      my $ret = 0;  100      my @fields = split(/\s+/, $line);  101      my $access = $fields[0];  102      if (&isListing($access)) {  103          my $unam = $fields[2];  104          my $grpnam = $fields[3];  105          my $size = $fields[4];  106          my %cmo = (  107                     'Jan' => 1,  108                     'Feb' => 2,  109                     'Mar' => 3,  110                     'Apr' => 4,  111                     'May' => 5,  112                     'Jun' => 6,  113                     'Jul' => 7,  114                     'Aug' => 8,  115                     'Sep' => 9,  116                     'Oct' => 10,  117                     'Nov' => 11,  118                     'Dec' =>12  119                     );  120          my $mo = $cmo{$fields[5]};  121          my $dy = $fields[6];                  122          my $yr = $fields[7];                  123          my $hr = 0;  124          my $min = 0;  125          my $sec = 0;  126          if ( $yr =~ m/:/ ) {  127              ( $hr, $min ) = split(/:/,$yr);  128              my ($curdy, $curmo);  129              ($curdy,$curmo,$yr) = (localtime())[3,4,5];  130              # Directory listing shows hour rather than year  131              # if date > current date  132              $curmo = $curmo +1;  133              if ($curmo < $mo) {  134                  $yr = $yr -1;  135              } else {  136                  if ($curmo == $mo && $curdy < $dy) { $yr = $yr -1; }  137              }  138              $yr += 1900;  139          }  140          my $time = sprintf (""%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d"",  141                              $yr,$mo,$dy,$hr,$min,$sec);  142          if ( $time > $$PrecentTime ) { $$PrecentTime = $time }  143          my $name = $fields[8];  144          my $fullname = ""$curDir/$name"";  145          my @suffixlist = ( $suffixpattern );  146          my ( $file, $path, $ext ) = fileparse($fullname, @suffixlist);  147          $path =~ s/\/$//;  148          $file = $file.$ext;  149          $ext =~ s/^\.//;  150          if (&isDirectory($access)) {  151              $DBYA::hpssNDirs += 1;  152              $DBYA::hpssDirs[$DBYA::hpssNDirs-1] = $fullname;  153          } else {  154              print ""File $curDir/$name $time $dy $size\n"" if $debugOn;  155              my %prime;  156              $prime{global} = ""$$Plocation{site}:$fullname"";  157              $prime{site} = ""$$Plocation{site}"";  158              $prime{location} = ""$$Plocation{location}"";  159              $prime{path} = $path;  160              if ( $savename ne '' ) {  161                  $prime{name} = $savename;  162              } else {  163                  $prime{name} = $name;  164              }  165              $prime{name} =~ s/'/\\'/g;  166              $prime{object} = ""file"";  167              $prime{suffix} = $ext;  168              $prime{type} = $$Plocation{type};  169              $prime{'stat'} = 1;  170              $prime{recorder} = ""dyLoadRftpFile"";  171              $prime{size} = $size;  172              $prime{modtime} = $time;  173              $prime{catstatus} = 1;  174              $prime{cattime} = 'NOW()';  175              $prime{vo} = $DBYA::currentVO;  176              $prime{grp} = $grpnam;  177              $prime{owner} = $unam;  178              $prime{activity} = '?';  179              $prime{team} = '?';  180              $prime{version} = &dySetVersion(\%prime, $Plocation);  181              $prime{instance} = &dySetInstance(\%prime, $Plocation);  182              $prime{logical} = &dySetLogical(\%prime,$lfn);  183              if ( $prime{logical} ne '' ) {  184                  my $ky = $inkeys;  185                  my $already_cataloged = 0;  186                  if ( $Plochash != 0 ) {  187                      my $v = $$Plochash{$prime{logical}};  188                      print ""inside: $prime{logical} $v;\n"" if $debugOn;  189                      $already_cataloged = $$Plochash{$prime{logical}};  190                      if ( $already_cataloged ) {  191                          &addKey(\$ky,$$Plocfiles{$prime{logical}}->{kys});  192                      }  193                      print ""Old key of already cataloged file: $ky for log $prime{logical}\n"" if $debugOn;  194                  }  195                  &setKey(\%prime,\$ky);  196                  $prime{kys} = $ky;  197                  if ( $already_cataloged ) {  198                      print ""Updating record for file $prime{logical}  Keys: $prime{kys}\n"" if $debugOn;  199                      my $cond = ""where logical='$prime{logical}' && site='$prime{site}' && location='$prime{location}' && vo='$DBYA::currentVO'"";  200                      &updateDb($DBYA::primeTable,$cond,%prime);  201                  } else {  202                      print ""New record for file $prime{logical}  Keys: $prime{kys}\n"" if $debugOn;  203                      &saveToDb($DBYA::primeTable,%prime);  204                  }  205                  $ret = 1;  206              } else {  207                  # Failure in logical name assignment  208                  print ""Failure in logname assignment: File $prime{global}\n"";  209              }  210          }  211      }  212      return $ret;  213  }  214    215  sub dyLoadNewDiskFileToLocation {  216      my ( $filename, $Plocation, $useAccelerator ) = @_;  217      my $line = ""$$Plocation{location}/$filename"";  218      my $recentTime;  219      # Fetch location  220      my %locfiles;  221      my %lochash;  222      my $recentTime = 0;  223      my $kys = '';  224      &dyLoadDiskFile( $line, $$Plocation{location}, """", """", 0, \$recentTime, $Plocation, \%locfiles, \%lochash, $useAccelerator, $kys );  225  }  226    227  sub dyLoadDiskFile {  228      my ( $line, $dir, $lfn, $savename, $startlevel, $PrecentTime, $Plocation, $Plocfiles, $Plochash, $useAccelerator, $inkeys ) = @_;  229      my $ret = 0;  230      chomp $line;  231      my $fullname = $line;  232      my $hiddenDir = $line =~ m/(\/\.)/;  233      my @tk = split(/\//,$line);  234      my $ntk = @tk;  235      if ( ! -f ""$fullname"" ) {  236          print ""'$fullname' not a file; ignore\n"" if $debugOn;  237          return 0;  238      }  # Only interested in files  239      my $filter = $$Plocation{filter};  240      my $ftest;  241      if ( $filter =~ m/^!/ ) { # negate it  242          $filter =~ s/^!//;  243          $ftest = ! ($fullname =~ m?$filter?);  244      } else {  245          $ftest = $fullname =~ m?$filter?;  246      }  247      if ( $$Plocation{filter} eq '' || $ftest ) {          248          if ((! $hiddenDir) && (! exists($ignoreDirs{$tk[$ntk]}))  249              && (! exists($ignoreDirs{$tk[$startlevel]}))  250              ) {  251              my @suffixlist = ( $suffixpattern );  252              my ( $file, $path, $ext ) = fileparse($fullname, @suffixlist);  253              $path =~ s/\/$//;  254              $file = $file.$ext;  255              $ext =~ s/^\.//;  256              my $name = $file;  257              print ""Load file $_\n"" if $debugOn;  258              my $stats = stat($fullname);  259              my $fmode = $stats->mode;  260              my $uid = $stats->uid;  261              my $gid = $stats->gid;  262              my $size = $stats->size;  263              my $readTime = $stats->atime;  264              my $modTime = $stats->mtime;  265              if ( $modTime > $$PrecentTime ) { $$PrecentTime = $modTime }  266              my $inodeTime = $stats->ctime;  267              my $grpnam = (getgrgid($gid))[0];  268              my $unam = (getpwuid($uid))[0];  269              ## file info to database  270              my %prime;  271              ## believe it or not, there are files with ' in the name  272              $fullname =~ s/\'/\\\'/g;  273              $file =~ s/\'/\\\'/g;  274              $prime{global} = ""$$Plocation{site}:$fullname"";  275              $prime{site} = ""$$Plocation{site}"";  276              $prime{location} = ""$$Plocation{location}"";  277              $prime{path} = $path;  278              if ( $savename ne '' ) {  279                  $prime{name} = $savename;  280              } else {  281                  $prime{name} = $name;  282              }  283              $prime{name} =~ s/'/\\'/g;  284              $prime{object} = ""file"";  285              $prime{suffix} = $ext;  286              $prime{type} = $$Plocation{type};  287              $prime{'stat'} = 1;  288              $prime{recorder} = ""dyLoadDiskFile"";  289              $prime{size} = $size;  290              $prime{modtime} = &mysqlTime($modTime);  291              $prime{readtime} = &mysqlTime($readTime);  292              $prime{inodetime} = &mysqlTime($inodeTime);  293              $prime{catstatus} = 1;  294              $prime{cattime} = 'NOW()';  295              $prime{vo} = $DBYA::currentVO;  296              $prime{grp} = $grpnam;  297              $prime{owner} = $unam;  298              $prime{activity} = '?';  299              $prime{team} = '?';  300              $prime{version} = &dySetVersion(\%prime, $Plocation);  301              $prime{instance} = &dySetInstance(\%prime, $Plocation);  302              $prime{logical} = &dySetLogical(\%prime,$lfn);  303              if ( $prime{logical} ne '' ) {  304                  my $already_cataloged = 0;  305                  my $ky = $inkeys;  306                  if ( $Plochash != 0 ) {  307                      $already_cataloged = $$Plochash{$prime{logical}};  308                      if ( $already_cataloged ) {  309                          &addKey(\$ky,$$Plocfiles{$prime{logical}}->{kys});  310                      }  311                  }  312                  &setKey(\%prime,\$ky);  313                  $prime{kys} = $ky;  314                  if ( $already_cataloged ) {  315                      print ""Updating record for file $prime{logical}  Keys: $prime{kys}\n"" if $debugOn;  316                      my $cond = ""where logical='$prime{logical}' && site='$prime{site}' && location='$prime{location}' && vo='$DBYA::currentVO'"";  317                      if( ! $useAccelerator ) {  318                          &updateDb($DBYA::primeTable,$cond,%prime);  319                      } else {  320                          my $updateString = &updateDbString($DBYA::primeTable,$cond,%prime);  321                          &dySqlAccelerator($updateString);  322                      }  323                      $ret = 1;  324                  } else {  325                      print ""Adding record for file $prime{logical}  Keys: $prime{kys}\n"" if $debugOn;  326                      if( ! $useAccelerator ) {  327                          print ""Direct save, no accel\n"" if $debugOn;  328                          &saveToDb($DBYA::primeTable,%prime);  329                          # check record was really saved  330                          my $cond = ""where logical='$prime{logical}' && location='$prime{location}' && site='$prime{site}'"";  331                          if ( ! &matchInTable($DBYA::primeTable,$cond) ) {  332                              print ""ERROR: File $prime{logical} not successfully loaded\n"";  333                          } else {  334                              print ""Found $cond\n"" if $debugOn;  335                              $ret = 1;  336                          }  337                      } else {  338                          print ""Save with accel\n"" if $debugOn;  339                          my $saveString = &saveToDbString($DBYA::primeTable,%prime);  340                          &dySqlAccelerator($saveString);  341                          $ret = 1;  342                      }  343                  }  344              } else {  345                  # Failure in logical name assignment  346                  print ""Failure in logname assignment: File $prime{global}\n"";  347              }  348          }  349      }  350      return $ret;  351  }  352    353  sub isListing {  354      my ( $char ) = @_;  355      if ( $char =~ m/^[rw\-xdsm]+$/ ) {  356          return 1;  357      } else {  358          return 0;  359      }  360  }  361    362  sub isDirectory {  363      my ( $char ) = @_;  364      if ( $char =~ m/^d/ ) {  365          return 1;  366      } else {  367          return 0;  368      }  369  }  370    371  sub dyLoadHsmFile {  372      my ( $line, $curDir, $lfn, $savename, $PrecentTime, $Plocation, $Plocfiles, $Plochash, $inkeys ) = @_;  373      my $ret = 0;  374      my @fields = split(/\s+/, $line);  375      my $access = $fields[0];  376      if (&isListing($access)) {  377          my $unam = $fields[2];  378          my $grpnam = $fields[3];  379          my $size = $fields[4];  380          my %cmo = (  381                     'Jan' => 1,  382                     'Feb' => 2,  383                     'Mar' => 3,  384                     'Apr' => 4,  385                     'May' => 5,  386                     'Jun' => 6,  387                     'Jul' => 7,  388                     'Aug' => 8,  389                     'Sep' => 9,  390                     'Oct' => 10,  391                     'Nov' => 11,  392                     'Dec' =>12  393                     );  394          my $mo = $cmo{$fields[5]};  395          my $dy = $fields[6];                  396          my $yr = $fields[7];                  397          my $hr = 0;  398          my $min = 0;  399          my $sec = 0;  400          if ( $yr =~ m/:/ ) {  401              ( $hr, $min ) = split(/:/,$yr);  402              my ($curdy, $curmo);  403              ($curdy,$curmo,$yr) = (localtime())[3,4,5];  404              # Directory listing shows hour rather than year  405              # if date > current date  406              $curmo = $curmo +1;  407              if ($curmo < $mo) {  408                  $yr = $yr -1;  409              } else {  410                  if ($curmo == $mo && $curdy < $dy) { $yr = $yr -1; }  411              }  412              $yr = $yr + 1900;  413          }  414          my $time = sprintf (""%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d"",  415                              $yr,$mo,$dy,$hr,$min,$sec);  416          if ( $time > $$PrecentTime ) { $$PrecentTime = $time }  417          my $name = $fields[8];  418          my $fullname;  419          if ( $name =~ m/\// ) {  420              $fullname = ""$name"";  421          } else {  422              $fullname = ""$curDir/$name"";  423          }  424          my @suffixlist = ( $suffixpattern );  425          my ( $file, $path, $ext ) = fileparse($fullname, @suffixlist);  426          $path =~ s/\/$//;  427          $file = $file.$ext;  428          $ext =~ s/^\.//;  429          if (&isDirectory($access)) {  430              print ""'$file' is a directory\n"" if $debugOn;  431              $DBYA::castorNDirs += 1;  432              $DBYA::castorDirs[$DBYA::castorNDirs-1] = $fullname;  433          } else {  434              print ""File $curDir/$name $time $dy $size\n"" if $debugOn;  435              my %prime;  436              $prime{global} = ""$$Plocation{site}:$fullname"";  437              $prime{site} = ""$$Plocation{site}"";  438              $prime{location} = ""$$Plocation{location}"";  439              $prime{path} = $path;  440              if ( $savename ne '' ) {  441                  $prime{name} = $savename;  442              } else {  443                  $prime{name} = $file;  444              }  445              $prime{name} =~ s/'/\\'/g;  446              $prime{object} = ""file"";  447              $prime{suffix} = $ext;  448              $prime{type} = $$Plocation{type};  449              $prime{'stat'} = 1;  450              $prime{recorder} = ""dyLoadHsmFile"";  451              $prime{size} = $size;  452              $prime{modtime} = $time;  453              $prime{catstatus} = 1;  454              $prime{cattime} = 'NOW()';  455              $prime{vo} = $DBYA::currentVO;  456              $prime{grp} = $grpnam;  457              $prime{owner} = $unam;  458              $prime{activity} = '?';  459              $prime{team} = '?';  460              $prime{version} = &dySetVersion(\%prime, $Plocation);  461              $prime{instance} = &dySetInstance(\%prime, $Plocation);  462              $prime{logical} = &dySetLogical(\%prime,$lfn);  463              if ( $prime{logical} ne '' ) {  464                  my $already_cataloged = 0;  465                  my $ky = $inkeys;  466                  if ( $Plochash != 0 ) {  467                      my $v = $$Plochash{$prime{logical}};  468                      print ""inside: $prime{logical} $v;\n"" if $debugOn;  469                      $already_cataloged = $$Plochash{$prime{logical}};  470                      if ( $already_cataloged ) {  471                          &addKey(\$ky,$$Plocfiles{$prime{logical}}->{kys});  472                      }  473                  }  474                  &setKey(\%prime,\$ky);  475                  $prime{kys} = $ky;  476                  if ( $already_cataloged ) {  477                      print ""Updating record for file $prime{logical}  Keys: $prime{kys}\n"" if $debugOn;  478                      my $cond = ""where logical='$prime{logical}' && site='$prime{site}' && location='$prime{location}' && vo='$DBYA::currentVO'"";  479                      my $updateString = &updateDbString($DBYA::primeTable,$cond,%prime);  480                      &dySqlAccelerator($updateString);  481                  } else {  482                      my $saveString = &saveToDbString($DBYA::primeTable,%prime);  483                      &dySqlAccelerator($saveString);  484                  }  485                  $ret = 1;  486              } else {  487                  # Failure in logical name assignment  488                  print ""Failure in logname assignment: File $prime{global}\n"";  489              }  490          }  491      }  492      return $ret;  493  }  494    495  sub dyCheckRftpFile {  496      # Check whether file is already there in rftp  497      my ( $path, $lfn ) = @_;  498      my @dirlisting = &dyReadRftpDir($path,$lfn);  499      my $dirline = '';  500      my $status = 0;  501      foreach my $fl ( @dirlisting ) {  502          my @tokens = split(' ',$fl);  503          if ( $tokens[8] eq $lfn ) {  504              my $size = $tokens[4];  505              if ( $size > 0 ) {  506                  $status = 1;  507              }  508          }  509      }  510      return $status;  511  }  512    513  sub dyCheckHsmFile {  514      # Check whether file is already there in HSM  515      my ( $path, $lfn ) = @_;  516      my @dirlisting = &dyReadHsmDir($path,$lfn);  517      my $dirline = '';  518      my $status = 0;  519      foreach my $fl ( @dirlisting ) {  520          my @tokens = split(' ',$fl);  521          if ( @tokens > 3 ) {  522              my $size = $tokens[4];  523              if ( $size > 0 ) {  524                  $status = 1;  525              }  526          }  527      }  528      return $status;  529  }  530    531  sub dyCheckDiskFile {  532      # Check whether file is there on disk  533      my ( $path, $lfn ) = @_;  534      my @dirlisting = &dyReadDiskDir($path,$lfn);  535      my $dirline = '';  536      my $status = 0;  537      foreach my $fl ( @dirlisting ) {  538          my @tokens = split(' ',$fl);  539          if ( @tokens > 3 ) {  540              my $size = $tokens[4];  541              if ( $size > 0 ) {  542                  $status = 1;  543              }  544          }  545      }  546      return $status;  547  }  548    549  sub dyReadHsmDir {  550      my ( $dir, $file ) = @_;  551      my $pgm = '/usr/local/bin/hsm';  552      my @dirlisting = `$pgm ls $dir/$file`;  553      return @dirlisting;  554  }  555    556  #sub dyReadCastorDir {  557  #    my ( $dir ) = @_;  558  #    my @dirlisting = `nsls -l $dir`;  559  #    return @dirlisting;  560  #}  561    562  sub dyReadDiskDir {  563      my ( $dir, $file ) = @_;  564      my $pgm = 'ls -al 2>&1';  565      my @dirlisting = `$pgm $dir/$file`;  566      return @dirlisting;  567  }  568    569  1;             [   source navigation   ]   [   identifier search   ]   [   freetext search   ]   [   file search   ]   [   repository   ]       This page was automatically generated by the   LXR engine . Visit the  LXR main site  for more information.   This version by  Torre Wenaus ."
GX034-63-9812821	"Advanced Bash-Scripting Guide:  Prev Next Appendix A. Contributed Scripts These scripts, while not fitting into the text of this document, do     illustrate some interesting shell programming techniques. They are useful,     too. Have fun analyzing and running them. Example A-1.  manview : Viewing formatted manpages        #!/bin/bash # manview.sh: Formats the source of a man page for viewing.  #  This is useful when writing man page source and you want to #+ look at the intermediate results on the fly while working on it.  E_WRONGARGS=65  if [ -z ""$1"" ] then   echo ""Usage: `basename $0` filename""   exit $E_WRONGARGS fi  groff -Tascii -man $1 | less # From the man page for groff.  # If the man page includes tables and/or equations, # then the above code will barf. # The following line can handle such cases. # #   gtbl < ""$1"" | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man # #   Thanks, S.C.  exit 0 Example A-2.  mailformat : Formatting an e-mail message #!/bin/bash # mail-format.sh: Format e-mail messages.  # Gets rid of carets, tabs, also fold excessively long lines.  # ================================================================= #                 Standard Check for Script Argument(s) ARGS=1 E_BADARGS=65 E_NOFILE=66  if [ $# -ne $ARGS ]  # Correct number of arguments passed to script? then   echo ""Usage: `basename $0` filename""   exit $E_BADARGS fi  if [ -f ""$1"" ]       # Check if file exists. then     file_name=$1 else     echo ""File \""$1\"" does not exist.""     exit $E_NOFILE fi # =================================================================  MAXWIDTH=70          # Width to fold long lines to.  #  Delete carets and tabs at beginning of lines, #+ then fold lines to $MAXWIDTH characters. sed ' s/^>// s/^  *>// s/^  *// s/  *// ' $1 | fold -s --width=$MAXWIDTH           # -s option to ""fold"" breaks lines at whitespace, if possible.  #  This script was inspired by an article in a well-known trade journal #+ extolling a 164K Windows utility with similar functionality. # #  An nice set of text processing utilities and an efficient #+ scripting language provide an alternative to bloated executables.  exit 0 Example A-3.  rn : A simple-minded file rename utility This script is a modification of  Example 12-15 . #! /bin/bash # # Very simpleminded filename ""rename"" utility (based on ""lowercase.sh""). # #  The ""ren"" utility, by Vladimir Lanin (lanin@csd2.nyu.edu), #+ does a much better job of this.   ARGS=2 E_BADARGS=65 ONE=1                     # For getting singular/plural right (see below).  if [ $# -ne ""$ARGS"" ] then   echo ""Usage: `basename $0` old-pattern new-pattern""   # As in ""rn gif jpg"", which renames all gif files in working directory to jpg.   exit $E_BADARGS fi  number=0                  # Keeps track of how many files actually renamed.   for filename in *$1*      #Traverse all matching files in directory. do    if [ -f ""$filename"" ]  # If finds match...    then      fname=`basename $filename`            # Strip off path.      n=`echo $fname | sed -e ""s/$1/$2/""`   # Substitute new for old in filename.      mv $fname $n                          # Rename.      let ""number += 1""    fi done     if [ ""$number"" -eq ""$ONE"" ]                # For correct grammar. then  echo ""$number file renamed."" else   echo ""$number files renamed."" fi   exit 0   # Exercises: # --------- # What type of files will this not work on? # How can this be fixed? # #  Rewrite this script to process all the files in a directory #+ containing spaces in their names, and to rename them, #+ substituting an underscore for each space. Example A-4.  blank-rename : renames filenames containing         blanks This is an even simpler-minded version of previous script. #! /bin/bash # blank-rename.sh # # Substitutes underscores for blanks in all the filenames in a directory.  ONE=1                     # For getting singular/plural right (see below). number=0                  # Keeps track of how many files actually renamed. FOUND=0                   # Successful return value.  for filename in *         #Traverse all files in directory. do      echo ""$filename"" | grep -q "" ""         #  Check whether filename      if [ $? -eq $FOUND ]                   #+ contains space(s).      then        fname=$filename                      # Strip off path.        n=`echo $fname | sed -e ""s/ /_/g""`   # Substitute underscore for blank.        mv ""$fname"" ""$n""                     # Do the actual renaming.        let ""number += 1""      fi done     if [ ""$number"" -eq ""$ONE"" ]                 # For correct grammar. then  echo ""$number file renamed."" else   echo ""$number files renamed."" fi   exit 0 Example A-5.  encryptedpw : Uploading to an ftp site,       using a locally encrypted password #!/bin/bash  # Example ""ex72.sh"" modified to use encrypted password.  #  Note that this is still somewhat insecure, #+ since the decrypted password is sent in the clear. # Use something like ""ssh"" if this is a concern.  E_BADARGS=65  if [ -z ""$1"" ] then   echo ""Usage: `basename $0` filename""   exit $E_BADARGS fi    Username=bozo           # Change to suit. pword=/home/bozo/secret/password_encrypted.file # File containing encrypted password.  Filename=`basename $1`  # Strips pathname out of file name  Server=""XXX"" Directory=""YYY""         # Change above to actual server name & directory.   Password=`cruft <$pword`          # Decrypt password. #  Uses the author's own ""cruft"" file encryption package, #+ based on the classic ""onetime pad"" algorithm, #+ and obtainable from: #+ Primary-site:   ftp://metalab.unc.edu /pub/Linux/utils/file #+                 cruft-0.2.tar.gz [16k]   ftp -n $Server <<End-Of-Session user $Username $Password binary bell cd $Directory put $Filename bye End-Of-Session # -n option to ""ftp"" disables auto-logon. # ""bell"" rings 'bell' after each file transfer.  exit 0 Example A-6.  copy-cd : Copying a data CD #!/bin/bash # copy-cd.sh: copying a data CD  CDROM=/dev/cdrom                           # CD ROM device OF=/home/bozo/projects/cdimage.iso         # output file #       /xxxx/xxxxxxx/                     Change to suit your system. BLOCKSIZE=2048 SPEED=2                                    # May use higher speed if supported.  echo; echo ""Insert source CD, but do *not* mount it."" echo ""Press ENTER when ready. "" read ready                                 # Wait for input, $ready not used.  echo; echo ""Copying the source CD to $OF."" echo ""This may take a while. Please be patient.""  dd if=$CDROM of=$OF bs=$BLOCKSIZE          # Raw device copy.   echo; echo ""Remove data CD."" echo ""Insert blank CDR."" echo ""Press ENTER when ready. "" read ready                                 # Wait for input, $ready not used.  echo ""Copying $OF to CDR.""  cdrecord -v -isosize speed=$SPEED dev=0,0 $OF # Uses Joerg Schilling's ""cdrecord"" package (see its docs). # http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html   echo; echo ""Done copying $OF to CDR on device $CDROM.""  echo ""Do you want to erase the image file (y/n)? ""  # Probably a huge file. read answer  case ""$answer"" in [yY]) rm -f $OF       echo ""$OF erased.""       ;; *)    echo ""$OF not erased."";; esac  echo  # Exercise: # Change the above ""case"" statement to also accept ""yes"" and ""Yes"" as input.  exit 0 Example A-7. Collatz series #!/bin/bash # collatz.sh  #  The notorious ""hailstone"" or Collatz series. #  ------------------------------------------- #  1) Get the integer ""seed"" from the command line. #  2) NUMBER <--- seed #  3) Print NUMBER. #  4)  If NUMBER is even, divide by 2, or #  5)+ if odd, multiply by 3 and add 1. #  6) NUMBER <--- result  #  7) Loop back to step 3 (for specified number of iterations). # #  The theory is that every sequence, #+ no matter how large the initial value, #+ eventually settles down to repeating ""4,2,1..."" cycles, #+ even after fluctuating through a wide range of values. # #  This is an instance of an ""iterate"", #+ an operation that feeds its output back into the input. #  Sometimes the result is a ""chaotic"" series.   MAX_ITERATIONS=200 # For large seed numbers (>32000), increase MAX_ITERATIONS.  h=${1:-$$}                      #  Seed                                 #  Use $PID as seed,                                 #+ if not specified as command-line arg.  echo echo ""C($h) --- $MAX_ITERATIONS Iterations"" echo  for ((i=1; i<=MAX_ITERATIONS; i++)) do  echo -n ""$h "" #          ^^^^^ #           tab    let ""remainder = h % 2""   if [ ""$remainder"" -eq 0 ]   # Even?   then     let ""h /= 2""              # Divide by 2.   else     let ""h = h*3 + 1""         # Multiply by 3 and add 1.   fi   COLUMNS=10                    # Output 10 values per line. let ""line_break = i % $COLUMNS"" if [ ""$line_break"" -eq 0 ] then   echo fi    done  echo  #  For more information on this mathematical function, #+ see ""Computers, Pattern, Chaos, and Beauty"", by Pickover, p. 185 ff., #+ as listed in the bibliography.  exit 0 Example A-8.  days-between : Calculate number of days         between two dates #!/bin/bash # days-between.sh:    Number of days between two dates. # Usage: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY  ARGS=2                # Two command line parameters expected. E_PARAM_ERR=65        # Param error.  REFYR=1600            # Reference year. CENTURY=100 DIY=365 ADJ_DIY=367           # Adjusted for leap year + fraction. MIY=12 DIM=31 LEAPCYCLE=4  MAXRETVAL=256         # Largest permissable                       # positive return value from a function.  diff=        # Declare global variable for date difference. value=                # Declare global variable for absolute value. day=                  # Declare globals for day, month, year. month= year=   Param_Error ()        # Command line parameters wrong. {   echo ""Usage: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY""   echo ""       (date must be after 1/3/1600)""   exit $E_PARAM_ERR }     Parse_Date ()                 # Parse date from command line params. {   month=${1%%/**}   dm=${1%/**}                 # Day and month.   day=${dm#*/}   let ""year = `basename $1`""  # Not a filename, but works just the same. }     check_date ()                 # Checks for invalid date(s) passed. {   [ ""$day"" -gt ""$DIM"" ] || [ ""$month"" -gt ""$MIY"" ] || [ ""$year"" -lt ""$REFYR"" ] && Param_Error   # Exit script on bad value(s).   # Uses ""or-list / and-list"".   #   # Exercise: Implement more rigorous date checking. }   strip_leading_zero () # Better to strip possible leading zero(s) {                     # from day and/or month   val=${1#0}          # since otherwise Bash will interpret them   return $val         # as octal values (POSIX.2, sect 2.9.2.1). }   day_index ()          # Gauss' Formula: {                     # Days from Jan. 3, 1600 to date passed as param.    day=$1   month=$2   year=$3    let ""month = $month - 2""   if [ ""$month"" -le 0 ]   then     let ""month += 12""     let ""year -= 1""   fi      let ""year -= $REFYR""   let ""indexyr = $year / $CENTURY""     let ""Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM""   # For an in-depth explanation of this algorithm, see   # http://home.t-online.de/home/berndt.schwerdtfeger/cal.htm     if [ ""$Days"" -gt ""$MAXRETVAL"" ]  # If greater than 256,   then                             # then change to negative value     let ""dindex = 0 - $Days""       # which can be returned from function.   else let ""dindex = $Days""   fi    return $dindex  }     calculate_difference ()            # Difference between to day indices. {   let ""diff = $1 - $2""             # Global variable. }     abs ()                             # Absolute value {                                  # Uses global ""value"" variable.   if [ ""$1"" -lt 0 ]                # If negative   then                             # then     let ""value = 0 - $1""           # change sign,   else                             # else     let ""value = $1""               # leave it alone.   fi }    if [ $# -ne ""$ARGS"" ]              # Require two command line params. then   Param_Error fi    Parse_Date $1 check_date $day $month $year      # See if valid date.  strip_leading_zero $day           # Remove any leading zeroes day=$?                            # on day and/or month. strip_leading_zero $month month=$?  day_index $day $month $year date1=$?  abs $date1                         # Make sure it's positive date1=$value                       # by getting absolute value.  Parse_Date $2 check_date $day $month $year  strip_leading_zero $day day=$? strip_leading_zero $month month=$?  day_index $day $month $year date2=$?  abs $date2                         # Make sure it's positive. date2=$value  calculate_difference $date1 $date2  abs $diff                          # Make sure it's positive. diff=$value  echo $diff  exit 0 # Compare this script with the implementation of Gauss' Formula in C at # http://buschencrew.hypermart.net/software/datedif Example A-9. Make a  ""dictionary"" #!/bin/bash # makedict.sh  [make dictionary]  # Modification of /usr/sbin/mkdict script. # Original script copyright 1993, by Alec Muffett. # #  This modified script included in this document in a manner #+ consistent with the ""LICENSE"" document of the ""Crack"" package #+ that the original script is a part of.  #  This script processes text files to produce a sorted list #+ of words found in the files. #  This may be useful for compiling dictionaries #+ and for lexicographic research.   E_BADARGS=65  if [ ! -r ""$1"" ]                     #  Need at least one then                                 #+ valid file argument.   echo ""Usage: $0 files-to-process""   exit $E_BADARGS fi     # SORT=""sort""                        #  No longer necessary to define options                                      #+ to sort. Changed from original script.  cat $* |                             # Contents of specified files to stdout.         tr A-Z a-z |                 # Convert to uppercase.         tr ' ' '\012' |              # New: change spaces to newlines. #       tr -cd '\012[a-z][0-9]' |    #  Get rid of everything non-alphanumeric                                      #+ (original script).         tr -c '\012a-z'  '\012' |    #  Rather than deleting                                      #+ now change non-alpha to newlines.         sort |                       # $SORT options unnecessary now.         uniq |                       # Remove duplicates.         grep -v '^#' |               # Delete lines beginning with a hashmark.         grep -v '^$'                 # Delete blank lines.  exit 0  Example A-10. Soundex conversion #!/bin/bash # soundex.sh: Calculate ""soundex"" code for names  # ======================================================= #        Soundex script #              by #         Mendel Cooper #     thegrendel@theriver.com #       23 January, 2002 # #   Placed in the Public Domain. # # A slightly different version of this script appeared in #+ Ed Schaefer's July, 2002 ""Shell Corner"" column #+ in ""Unix Review"" on-line, #+ http://www.unixreview.com/documents/uni1026336632258/ # =======================================================   ARGCOUNT=1                     # Need name as argument. E_WRONGARGS=70  if [ $# -ne ""$ARGCOUNT"" ] then   echo ""Usage: `basename $0` name""   exit $E_WRONGARGS fi     assign_value ()                #  Assigns numerical value {                              #+ to letters of name.    val1=bfpv                    # 'b,f,p,v' = 1   val2=cgjkqsxz                # 'c,g,j,k,q,s,x,z' = 2   val3=dt                      #  etc.   val4=l   val5=mn   val6=r  # Exceptionally clever use of 'tr' follows. # Try to figure out what is going on here.  value=$( echo ""$1"" \ | tr -d wh \ | tr $val1 1 | tr $val2 2 | tr $val3 3 \ | tr $val4 4 | tr $val5 5 | tr $val6 6 \ | tr -s 123456 \ | tr -d aeiouy )  # Assign letter values. # Remove duplicate numbers, except when separated by vowels. # Ignore vowels, except as separators, so delete them last. # Ignore 'w' and 'h', even as separators, so delete them first. # # The above command substitution lays more pipe than a plumber <g>.  }     input_name=""$1"" echo echo ""Name = $input_name""   # Change all characters of name input to lowercase. # ------------------------------------------------ name=$( echo $input_name | tr A-Z a-z ) # ------------------------------------------------ # Just in case argument to script is mixed case.   # Prefix of soundex code: first letter of name. # --------------------------------------------   char_pos=0                     # Initialize character position.  prefix0=${name:$char_pos:1} prefix=`echo $prefix0 | tr a-z A-Z`                                # Uppercase 1st letter of soundex.  let ""char_pos += 1""            # Bump character position to 2nd letter of name. name1=${name:$char_pos}   # ++++++++++++++++++++++++++ Exception Patch +++++++++++++++++++++++++++++++++ #  Now, we run both the input name and the name shifted one char to the right #+ through the value-assigning function. #  If we get the same value out, that means that the first two characters #+ of the name have the same value assigned, and that one should cancel. #  However, we also need to test whether the first letter of the name #+ is a vowel or 'w' or 'h', because otherwise this would bollix things up.  char1=`echo $prefix | tr A-Z a-z`    # First letter of name, lowercased.  assign_value $name s1=$value assign_value $name1 s2=$value assign_value $char1 s3=$value s3=9$s3                              #  If first letter of name is a vowel                                      #+ or 'w' or 'h',                                      #+ then its ""value"" will be null (unset).          #+ Therefore, set it to 9, an otherwise          #+ unused value, which can be tested for.   if [[ ""$s1"" -ne ""$s2"" || ""$s3"" -eq 9 ]] then   suffix=$s2 else     suffix=${s2:$char_pos} fi   # ++++++++++++++++++++++ end Exception Patch +++++++++++++++++++++++++++++++++   padding=000                    # Use at most 3 zeroes to pad.   soun=$prefix$suffix$padding    # Pad with zeroes.  MAXLEN=4                       # Truncate to maximum of 4 chars. soundex=${soun:0:$MAXLEN}  echo ""Soundex = $soundex""  echo  #  The soundex code is a method of indexing and classifying names #+ by grouping together the ones that sound alike. #  The soundex code for a given name is the first letter of the name, #+ followed by a calculated three-number code. #  Similar sounding names should have almost the same soundex codes.  #   Examples: #   Smith and Smythe both have a ""S-530"" soundex. #   Harrison = H-625 #   Hargison = H-622 #   Harriman = H-655  #  This works out fairly well in practice, but there are numerous anomalies. # # #  The U.S. Census and certain other governmental agencies use soundex, #  as do genealogical researchers. # #  For more information, #+ see the ""National Archives and Records Administration home page"", #+ http://www.nara.gov/genealogy/soundex/soundex.html    # Exercise: # -------- # Simplify the ""Exception Patch"" section of this script.  exit 0 Example A-11.  ""Game of Life"" #!/bin/bash # life.sh: ""Life in the Slow Lane""  # ##################################################################### # # This is the Bash script version of John Conway's ""Game of Life"".      # # ""Life"" is a simple implementation of cellular automata.               # # --------------------------------------------------------------------- # # On a rectangular grid, let each ""cell"" be either ""living"" or ""dead"".  # # Designate a living cell with a dot, and a dead one with a blank space.# #  Begin with an arbitrarily drawn dot-and-blank grid,                  # #+ and let this be the starting generation, ""generation 0"".             # # Determine each successive generation by the following rules:          # # 1) Each cell has 8 neighbors, the adjoining cells                     # #+   left, right, top, bottom, and the 4 diagonals.                     # #                       123                                             # #                       4*5                                             # #                       678                                             # #                                                                       # # 2) A living cell with either 2 or 3 living neighbors remains alive.   # # 3) A dead cell with 3 living neighbors becomes alive (a ""birth"").     # SURVIVE=2                                                               # BIRTH=3                                                                 # # 4) All other cases result in dead cells.                              # # ##################################################################### #   startfile=gen0   # Read the starting generation from the file ""gen0"".                  # Default, if no other file specified when invoking script.                  # if [ -n ""$1"" ]   # Specify another ""generation 0"" file. then   if [ -e ""$1"" ] # Check for existence.   then     startfile=""$1""   fi   fi     ALIVE1=. DEAD1=_                  # Represent living and ""dead"" cells in the start-up file.  #  This script uses a 10 x 10 grid (may be increased, #+ but a large grid will will cause very slow execution). ROWS=10 COLS=10  GENERATIONS=10          #  How many generations to cycle through.                         #  Adjust this upwards,                         #+ if you have time on your hands.  NONE_ALIVE=80           #  Exit status on premature bailout,                         #+ if no cells left alive. TRUE=0 FALSE=1 ALIVE=0 DEAD=1  avar=                   #  Global; holds current generation. generation=0            # Initialize generation count.  # =================================================================   let ""cells = $ROWS * $COLS""                         # How many cells.  declare -a initial      # Arrays containing ""cells"". declare -a current  display () {  alive=0                 # How many cells ""alive"".                         # Initially zero.  declare -a arr arr=( `echo ""$1""` )     # Convert passed arg to array.  element_count=${#arr[*]}  local i local rowcheck  for ((i=0; i<$element_count; i++)) do    # Insert newline at end of each row.   let ""rowcheck = $i % ROWS""   if [ ""$rowcheck"" -eq 0 ]   then     echo                # Newline.     echo -n ""      ""    # Indent.   fi      cell=${arr[i]}    if [ ""$cell"" = . ]   then     let ""alive += 1""   fi      echo -n ""$cell"" | sed -e 's/_/ /g'   # Print out array and change underscores to spaces. done    return  }  IsValid ()                            # Test whether cell coordinate valid. {    if [ -z ""$1""  -o -z ""$2"" ]          # Mandatory arguments missing?   then     return $FALSE   fi  local row local lower_limit=0                   # Disallow negative coordinate. local upper_limit local left local right  let ""upper_limit = $ROWS * $COLS - 1"" # Total number of cells.   if [ ""$1"" -lt ""$lower_limit"" -o ""$1"" -gt ""$upper_limit"" ] then   return $FALSE                       # Out of array bounds. fi    row=$2 let ""left = $row * $ROWS""             # Left limit. let ""right = $left + $COLS - 1""       # Right limit.  if [ ""$1"" -lt ""$left"" -o ""$1"" -gt ""$right"" ] then   return $FALSE                       # Beyond row boundary. fi    return $TRUE                          # Valid coordinate.  }     IsAlive ()              # Test whether cell is alive.                         # Takes array, cell number, state of cell as arguments. {   GetCount ""$1"" $2      # Get alive cell count in neighborhood.   local nhbd=$?     if [ ""$nhbd"" -eq ""$BIRTH"" ]  # Alive in any case.   then     return $ALIVE   fi    if [ ""$3"" = ""."" -a ""$nhbd"" -eq ""$SURVIVE"" ]   then                  # Alive only if previously alive.     return $ALIVE   fi      return $DEAD          # Default.  }     GetCount ()             # Count live cells in passed cell's neighborhood.                         # Two arguments needed:    # $1) variable holding array    # $2) cell number {   local cell_number=$2   local array   local top   local center   local bottom   local r   local row   local i   local t_top   local t_cen   local t_bot   local count=0   local ROW_NHBD=3    array=( `echo ""$1""` )    let ""top = $cell_number - $COLS - 1""    # Set up cell neighborhood.   let ""center = $cell_number - 1""   let ""bottom = $cell_number + $COLS - 1""   let ""r = $cell_number / $ROWS""    for ((i=0; i<$ROW_NHBD; i++))           # Traverse from left to right.    do     let ""t_top = $top + $i""     let ""t_cen = $center + $i""     let ""t_bot = $bottom + $i""       let ""row = $r""                        # Count center row of neighborhood.     IsValid $t_cen $row                   # Valid cell position?     if [ $? -eq ""$TRUE"" ]     then       if [ ${array[$t_cen]} = ""$ALIVE1"" ] # Is it alive?       then                                # Yes?         let ""count += 1""                  # Increment count.       fi      fi        let ""row = $r - 1""                    # Count top row.               IsValid $t_top $row     if [ $? -eq ""$TRUE"" ]     then       if [ ${array[$t_top]} = ""$ALIVE1"" ]        then         let ""count += 1""       fi      fi        let ""row = $r + 1""                    # Count bottom row.     IsValid $t_bot $row     if [ $? -eq ""$TRUE"" ]     then       if [ ${array[$t_bot]} = ""$ALIVE1"" ]        then         let ""count += 1""       fi      fi      done       if [ ${array[$cell_number]} = ""$ALIVE1"" ]   then     let ""count -= 1""        #  Make sure value of tested cell itself   fi                        #+ is not counted.     return $count    }  next_gen ()               # Update generation array. {  local array local i=0  array=( `echo ""$1""` )     # Convert passed arg to array.  while [ ""$i"" -lt ""$cells"" ] do   IsAlive ""$1"" $i ${array[$i]}   # Is cell alive?   if [ $? -eq ""$ALIVE"" ]   then                           #  If alive, then     array[$i]=.                  #+ represent the cell as a period.   else       array[$i]=""_""                #  Otherwise underscore    fi                            #+ (which will later be converted to space).     let ""i += 1""  done      # let ""generation += 1""   # Increment generation count.  # Set variable to pass as parameter to ""display"" function. avar=`echo ${array[@]}`   # Convert array back to string variable. display ""$avar""           # Display it. echo; echo echo ""Generation $generation -- $alive alive""  if [ ""$alive"" -eq 0 ] then   echo   echo ""Premature exit: no more cells alive!""   exit $NONE_ALIVE        #  No point in continuing fi                        #+ if no live cells.  }   # =========================================================  # main ()  # Load initial array with contents of startup file. initial=( `cat ""$startfile"" | sed -e '/#/d' | tr -d '\n' |\ sed -e 's/\./\. /g' -e 's/_/_ /g'` ) # Delete lines containing '#' comment character. # Remove linefeeds and insert space between elements.  clear          # Clear screen.  echo #         Title echo ""======================="" echo ""    $GENERATIONS generations"" echo ""           of"" echo ""\""Life in the Slow Lane\"""" echo ""=======================""   # -------- Display first generation. -------- Gen0=`echo ${initial[@]}` display ""$Gen0""           # Display only. echo; echo echo ""Generation $generation -- $alive alive"" # -------------------------------------------   let ""generation += 1""     # Increment generation count. echo  # ------- Display second generation. ------- Cur=`echo ${initial[@]}` next_gen ""$Cur""          # Update & display. # ------------------------------------------  let ""generation += 1""     # Increment generation count.  # ------ Main loop for displaying subsequent generations ------ while [ ""$generation"" -le ""$GENERATIONS"" ] do   Cur=""$avar""   next_gen ""$Cur""   let ""generation += 1"" done # ==============================================================  echo  exit 0  # -------------------------------------------------------------- # The grid in this script has a ""boundary problem"". # The the top, bottom, and sides border on a void of dead cells. # Exercise: Change the script to have the grid wrap around, # +         so that the left and right sides will ""touch"",       # +         as will the top and bottom. Example A-12. Data file for  ""Game of Life"" # This is an example ""generation 0"" start-up file for ""life.sh"". # -------------------------------------------------------------- #  The ""gen0"" file is a 10 x 10 grid using a period (.) for live cells, #+ and an underscore (_) for dead ones. We cannot simply use spaces #+ for dead cells in this file because of a peculiarity in Bash arrays. #  [Exercise for the reader: explain this.] # # Lines beginning with a '#' are comments, and the script ignores them. __.__..___ ___._.____ ____.___.. _._______. ____._____ ..__...___ ____._____ ___...____ __.._..___ _..___..__ +++ The following two scripts are by Mark Moraes of the University     of Toronto. See the enclosed file  ""Moraes-COPYRIGHT""      for permissions and restrictions. Example A-13.  behead : Removing mail and news message headers        #! /bin/sh # Strips off the header from a mail/News message i.e. till the first # empty line # Mark Moraes, University of Toronto  # ==> These comments added by author of this document.  if [ $# -eq 0 ]; then # ==> If no command line args present, then works on file redirected to stdin.  sed -e '1,/^$/d' -e '/^[  ]*$/d'  # --> Delete empty lines and all lines until   # --> first one beginning with white space. else # ==> If command line args present, then work on files named.  for i do   sed -e '1,/^$/d' -e '/^[  ]*$/d' $i   # --> Ditto, as above.  done fi  # ==> Exercise: Add error checking and other options. # ==> # ==> Note that the small sed script repeats, except for the arg passed. # ==> Does it make sense to embed it in a function? Why or why not? Example A-14.  ftpget : Downloading files via ftp        #! /bin/sh  # $Id: ftpget,v 1.2 91/05/07 21:15:43 moraes Exp $  # Script to perform batch anonymous ftp. Essentially converts a list of # of command line arguments into input to ftp. # Simple, and quick - written as a companion to ftplist  # -h specifies the remote host (default prep.ai.mit.edu)  # -d specifies the remote directory to cd to - you can provide a sequence  # of -d options - they will be cd'ed to in turn. If the paths are relative,  # make sure you get the sequence right. Be careful with relative paths -  # there are far too many symlinks nowadays.   # (default is the ftp login directory) # -v turns on the verbose option of ftp, and shows all responses from the  # ftp server.   # -f remotefile[:localfile] gets the remote file into localfile  # -m pattern does an mget with the specified pattern. Remember to quote  # shell characters.   # -c does a local cd to the specified directory # For example,  #  ftpget -h expo.lcs.mit.edu -d contrib -f xplaces.shar:xplaces.sh \ #  -d ../pub/R3/fixes -c ~/fixes -m 'fix*'  # will get xplaces.shar from ~ftp/contrib on expo.lcs.mit.edu, and put it in # xplaces.sh in the current working directory, and get all fixes from # ~ftp/pub/R3/fixes and put them in the ~/fixes directory.  # Obviously, the sequence of the options is important, since the equivalent # commands are executed by ftp in corresponding order # # Mark Moraes (moraes@csri.toronto.edu), Feb 1, 1989  # ==> Angle brackets changed to parens, so Docbook won't get indigestion. #   # ==> These comments added by author of this document.  # PATH=/local/bin:/usr/ucb:/usr/bin:/bin # export PATH # ==> Above 2 lines from original script probably superfluous.  TMPFILE=/tmp/ftp.$$ # ==> Creates temp file, using process id of script ($$) # ==> to construct filename.  SITE=`domainname`.toronto.edu # ==> 'domainname' similar to 'hostname' # ==> May rewrite this to parameterize this for general use.  usage=""Usage: $0 [-h remotehost] [-d remotedirectory]... [-f remfile:localfile]... \   [-c localdirectory] [-m filepattern] [-v]"" ftpflags=""-i -n"" verbflag= set -f   # So we can use globbing in -m set x `getopt vh:d:c:m:f: $*` if [ $? != 0 ]; then  echo $usage  exit 65 fi shift trap 'rm -f ${TMPFILE} ; exit' 0 1 2 3 15 echo ""user anonymous ${USER-gnu}@${SITE} > ${TMPFILE}"" # ==> Added quotes (recommended in complex echoes). echo binary >> ${TMPFILE} for i in $*   # ==> Parse command line args. do  case $i in  -v) verbflag=-v; echo hash >> ${TMPFILE}; shift;;  -h) remhost=$2; shift 2;;  -d) echo cd $2 >> ${TMPFILE};       if [ x${verbflag} != x ]; then          echo pwd >> ${TMPFILE};      fi;      shift 2;;  -c) echo lcd $2 >> ${TMPFILE}; shift 2;;  -m) echo mget ""$2"" >> ${TMPFILE}; shift 2;;  -f) f1=`expr ""$2"" : ""\([^:]*\).*""`; f2=`expr ""$2"" : ""[^:]*:\(.*\)""`;      echo get ${f1} ${f2} >> ${TMPFILE}; shift 2;;  --) shift; break;;  esac done if [ $# -ne 0 ]; then  echo $usage  exit 65   # ==> Changed from ""exit 2"" to conform with standard. fi if [ x${verbflag} != x ]; then  ftpflags=""${ftpflags} -v"" fi if [ x${remhost} = x ]; then  remhost=prep.ai.mit.edu  # ==> Rewrite to match your favorite ftp site. fi echo quit >> ${TMPFILE} # ==> All commands saved in tempfile.  ftp ${ftpflags} ${remhost} < ${TMPFILE} # ==> Now, tempfile batch processed by ftp.  rm -f ${TMPFILE} # ==> Finally, tempfile deleted (you may wish to copy it to a logfile).   # ==> Exercises: # ==> --------- # ==> 1) Add error checking. # ==> 2) Add bells & whistles. + Antek Sawicki contributed the following script, which makes very       clever use of the parameter substitution operators discussed in        Section 9.3 . Example A-15.  password : Generating random       8-character passwords #!/bin/bash # May need to be invoked with  #!/bin/bash2  on older machines. # # Random password generator for bash 2.x by Antek Sawicki <tenox@tenox.tc>, # who generously gave permission to the document author to use it here. # # ==> Comments added by document author ==>   MATRIX=""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"" LENGTH=""8"" # ==> May change 'LENGTH' for longer password, of course.   while [ ""${n:=1}"" -le ""$LENGTH"" ] # ==> Recall that := is ""default substitution"" operator. # ==> So, if 'n' has not been initialized, set it to 1. do  PASS=""$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}""  # ==> Very clever, but tricky.   # ==> Starting from the innermost nesting...  # ==> ${#MATRIX} returns length of array MATRIX.   # ==> $RANDOM%${#MATRIX} returns random number between 1  # ==> and length of MATRIX - 1.   # ==> ${MATRIX:$(($RANDOM%${#MATRIX})):1}  # ==> returns expansion of MATRIX at random position, by length 1.   # ==> See {var:pos:len} parameter substitution in Section 3.3.1  # ==> and following examples.   # ==> PASS=... simply pastes this result onto previous PASS (concatenation).   # ==> To visualize this more clearly, uncomment the following line  # ==>             echo ""$PASS""  # ==> to see PASS being built up,  # ==> one character at a time, each iteration of the loop.   let n+=1  # ==> Increment 'n' for next pass. done  echo ""$PASS""      # ==> Or, redirect to file, as desired.  exit 0 + James R. Van Zandt contributed this script, which uses named pipes       and, in his words,  ""really exercises quoting and escaping"" .        Example A-16.  fifo : Making daily backups, using named pipes #!/bin/bash # ==> Script by James R. Van Zandt, and used here with his permission.  # ==> Comments added by author of this document.       HERE=`uname -n`    # ==> hostname   THERE=bilbo   echo ""starting remote backup to $THERE at `date +%r`""   # ==> `date +%r` returns time in 12-hour format, i.e. ""08:08:34 PM"".      # make sure /pipe really is a pipe and not a plain file   rm -rf /pipe   mkfifo /pipe       # ==> Create a ""named pipe"", named ""/pipe"".      # ==> 'su xyz' runs commands as user ""xyz"".   # ==> 'ssh' invokes secure shell (remote login client).   su xyz -c ""ssh $THERE \""cat >/home/xyz/backup/${HERE}-daily.tar.gz\"" < /pipe""&   cd /   tar -czf - bin boot dev etc home info lib man root sbin share usr var >/pipe   # ==> Uses named pipe, /pipe, to communicate between processes:   # ==> 'tar/gzip' writes to /pipe and 'ssh' reads from /pipe.    # ==> The end result is this backs up the main directories, from / on down.    # ==> What are the advantages of a ""named pipe"" in this situation,   # ==> as opposed to an ""anonymous pipe"", with |?   # ==> Will an anonymous pipe even work here?     exit 0 + Stephane Chazelas contributed the following script to       demonstrate that generating prime numbers does not require       arrays. Example A-17. Generating prime numbers using the modulo operator #!/bin/bash # primes.sh: Generate prime numbers, without using arrays. # Script contributed by Stephane Chazelas.  #  This does *not* use the classic ""Sieve of Eratosthenes"" algorithm, #+ but instead uses the more intuitive method of testing each candidate number #+ for factors (divisors), using the ""%"" modulo operator.   LIMIT=1000                    # Primes 2 - 1000  Primes() {  (( n = $1 + 1 ))             # Bump to next integer.  shift                        # Next parameter in list. #  echo ""_n=$n i=$i_""    if (( n == LIMIT ))  then echo $*  return  fi   for i; do                    # ""i"" gets set to ""@"", previous values of $n. #   echo ""-n=$n i=$i-""    (( i * i > n )) && break   # Optimization.    (( n % i )) && continue    # Sift out non-primes using modulo operator.    Primes $n $@               # Recursion inside loop.    return    done     Primes $n $@ $n            # Recursion outside loop.                               # Successively accumulate positional parameters.                               # ""$@"" is the accumulating list of primes. }  Primes 1  exit 0  # Uncomment lines 17 and 25 to help figure out what is going on.  # Compare the speed of this algorithm for generating primes # with the Sieve of Eratosthenes (ex68.sh).  # Exercise: Rewrite this script without recursion, for faster execution. + Jordi Sanfeliu gave permission to use his elegant        tree  script. Example A-18.  tree : Displaying a directory tree #!/bin/sh #         @(#) tree      1.1  30/11/95       by Jordi Sanfeliu #                                         email: mikaku@arrakis.es # #         Initial version:  1.0  30/11/95 #         Next version   :  1.1  24/02/97   Now, with symbolic links #         Patch by       :  Ian Kjos, to support unsearchable dirs #                           email: beth13@mail.utexas.edu # #         Tree is a tool for view the directory tree (obvious :-) ) #  # ==> 'Tree' script used here with the permission of its author, Jordi Sanfeliu. # ==> Comments added by the author of this document. # ==> Argument quoting added.   search () {    for dir in `echo *`    # ==> `echo *` lists all the files in current working directory, without line breaks.    # ==> Similar effect to     for dir in *    # ==> but ""dir in `echo *`"" will not handle filenames with blanks.    do       if [ -d ""$dir"" ] ; then   # ==> If it is a directory (-d)...          zz=0   # ==> Temp variable, keeping track of directory level.          while [ $zz != $deep ]    # Keep track of inner nested loop.          do             echo -n ""|   ""    # ==> Display vertical connector symbol,                        # ==> with 2 spaces & no line feed in order to indent.             zz=`expr $zz + 1` # ==> Increment zz.          done          if [ -L ""$dir"" ] ; then   # ==> If directory is a symbolic link...             echo ""+---$dir"" `ls -l $dir | sed 's/^.*'$dir' //'`      # ==> Display horiz. connector and list directory name, but...      # ==> delete date/time part of long listing.          else             echo ""+---$dir""      # ==> Display horizontal connector symbol...                                  # ==> and print directory name.             if cd ""$dir"" ; then  # ==> If can move to subdirectory...                deep=`expr $deep + 1`   # ==> Increment depth.                search     # with recursivity ;-)                    # ==> Function calls itself.                numdirs=`expr $numdirs + 1`   # ==> Increment directory count.             fi          fi       fi    done    cd ..   # ==> Up one directory level.    if [ ""$deep"" ] ; then  # ==> If depth = 0 (returns TRUE)...       swfi=1              # ==> set flag showing that search is done.    fi    deep=`expr $deep - 1`  # ==> Decrement depth. }  # - Main - if [ $# = 0 ] ; then    cd `pwd`    # ==> No args to script, then use current working directory. else    cd $1       # ==> Otherwise, move to indicated directory. fi echo ""Initial directory = `pwd`"" swfi=0      # ==> Search finished flag. deep=0      # ==> Depth of listing. numdirs=0 zz=0  while [ ""$swfi"" != 1 ]   # While flag not set... do    search   # ==> Call function after initializing variables. done echo ""Total directories = $numdirs""  exit 0 # ==> Challenge: try to figure out exactly how this script works. Noah Friedman gave permission to use his  string       function  script, which essentially reproduces some of the       C-library string manipulation functions. Example A-19.  string functions : C-like string functions #!/bin/bash  # string.bash --- bash emulation of string(3) library routines # Author: Noah Friedman <friedman@prep.ai.mit.edu> # ==>     Used with his kind permission in this document. # Created: 1992-07-01 # Last modified: 1993-09-29 # Public domain  # Conversion to bash v2 syntax done by Chet Ramey  # Commentary: # Code:  #:docstring strcat: # Usage: strcat s1 s2 # # Strcat appends the value of variable s2 to variable s1.  # # Example: #    a=""foo"" #    b=""bar"" #    strcat a b #    echo $a #    => foobar # #:end docstring:  ###;;;autoload   ==> Autoloading of function commented out. function strcat () {     local s1_val s2_val      s1_val=${!1}                        # indirect variable expansion     s2_val=${!2}     eval ""$1""=\'""${s1_val}${s2_val}""\'     # ==> eval $1='${s1_val}${s2_val}' avoids problems,     # ==> if one of the variables contains a single quote. }  #:docstring strncat: # Usage: strncat s1 s2 $n #  # Line strcat, but strncat appends a maximum of n characters from the value # of variable s2.  It copies fewer if the value of variabl s2 is shorter # than n characters.  Echoes result on stdout. # # Example: #    a=foo #    b=barbaz #    strncat a b 3 #    echo $a #    => foobar # #:end docstring:  ###;;;autoload function strncat () {     local s1=""$1""     local s2=""$2""     local -i n=""$3""     local s1_val s2_val      s1_val=${!s1}                       # ==> indirect variable expansion     s2_val=${!s2}      if [ ${#s2_val} -gt ${n} ]; then        s2_val=${s2_val:0:$n}            # ==> substring extraction     fi      eval ""$s1""=\'""${s1_val}${s2_val}""\'     # ==> eval $1='${s1_val}${s2_val}' avoids problems,     # ==> if one of the variables contains a single quote. }  #:docstring strcmp: # Usage: strcmp $s1 $s2 # # Strcmp compares its arguments and returns an integer less than, equal to, # or greater than zero, depending on whether string s1 is lexicographically # less than, equal to, or greater than string s2. #:end docstring:  ###;;;autoload function strcmp () {     [ ""$1"" = ""$2"" ] && return 0      [ ""${1}"" '<' ""${2}"" ] > /dev/null && return -1      return 1 }  #:docstring strncmp: # Usage: strncmp $s1 $s2 $n #  # Like strcmp, but makes the comparison by examining a maximum of n # characters (n less than or equal to zero yields equality). #:end docstring:  ###;;;autoload function strncmp () {     if [ -z ""${3}"" -o ""${3}"" -le ""0"" ]; then        return 0     fi         if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then        strcmp ""$1"" ""$2""        return $?     else        s1=${1:0:$3}        s2=${2:0:$3}        strcmp $s1 $s2        return $?     fi }  #:docstring strlen: # Usage: strlen s # # Strlen returns the number of characters in string literal s. #:end docstring:  ###;;;autoload function strlen () {     eval echo ""\${#${1}}""     # ==> Returns the length of the value of the variable     # ==> whose name is passed as an argument. }  #:docstring strspn: # Usage: strspn $s1 $s2 #  # Strspn returns the length of the maximum initial segment of string s1, # which consists entirely of characters from string s2. #:end docstring:  ###;;;autoload function strspn () {     # Unsetting IFS allows whitespace to be handled as normal chars.      local IFS=     local result=""${1%%[!${2}]*}""       echo ${#result} }  #:docstring strcspn: # Usage: strcspn $s1 $s2 # # Strcspn returns the length of the maximum initial segment of string s1, # which consists entirely of characters not from string s2. #:end docstring:  ###;;;autoload function strcspn () {     # Unsetting IFS allows whitspace to be handled as normal chars.      local IFS=     local result=""${1%%[${2}]*}""       echo ${#result} }  #:docstring strstr: # Usage: strstr s1 s2 #  # Strstr echoes a substring starting at the first occurrence of string s2 in # string s1, or nothing if s2 does not occur in the string.  If s2 points to # a string of zero length, strstr echoes s1. #:end docstring:  ###;;;autoload function strstr () {     # if s2 points to a string of zero length, strstr echoes s1     [ ${#2} -eq 0 ] && { echo ""$1"" ; return 0; }      # strstr echoes nothing if s2 does not occur in s1     case ""$1"" in     *$2*) ;;     *) return 1;;     esac      # use the pattern matching code to strip off the match and everything     # following it     first=${1/$2*/}      # then strip off the first unmatched portion of the string     echo ""${1##$first}"" }  #:docstring strtok: # Usage: strtok s1 s2 # # Strtok considers the string s1 to consist of a sequence of zero or more # text tokens separated by spans of one or more characters from the # separator string s2.  The first call (with a non-empty string s1 # specified) echoes a string consisting of the first token on stdout. The # function keeps track of its position in the string s1 between separate # calls, so that subsequent calls made with the first argument an empty # string will work through the string immediately following that token.  In # this way subsequent calls will work through the string s1 until no tokens # remain.  The separator string s2 may be different from call to call. # When no token remains in s1, an empty value is echoed on stdout. #:end docstring:  ###;;;autoload function strtok () {  : }  #:docstring strtrunc: # Usage: strtrunc $n $s1 {$s2} {$...} # # Used by many functions like strncmp to truncate arguments for comparison. # Echoes the first n characters of each string s1 s2 ... on stdout.  #:end docstring:  ###;;;autoload function strtrunc () {     n=$1 ; shift     for z; do         echo ""${z:0:$n}""     done }  # provide string  # string.bash ends here   # ========================================================================== # # ==> Everything below here added by the document author.  # ==> Suggested use of this script is to delete everything below here, # ==> and ""source"" this file into your own scripts.  # strcat string0=one string1=two echo echo ""Testing \""strcat\"" function:"" echo ""Original \""string0\"" = $string0"" echo ""\""string1\"" = $string1"" strcat string0 string1 echo ""New \""string0\"" = $string0"" echo  # strlen echo echo ""Testing \""strlen\"" function:"" str=123456789 echo ""\""str\"" = $str"" echo -n ""Length of \""str\"" = "" strlen str echo    # Exercise: # -------- # Add code to test all the other string functions above.   exit 0 Stephane Chazelas demonstrates object-oriented programming in a       Bash script. Example A-20. Object-oriented database #!/bin/bash # obj-oriented.sh: Object-oriented programming in a shell script. # Script by Stephane Chazelas.   person.new()        # Looks almost like a class declaration in C++. {   local obj_name=$1 name=$2 firstname=$3 birthdate=$4    eval ""$obj_name.set_name() {           eval \""$obj_name.get_name() {                    echo \$1                  }\""         }""    eval ""$obj_name.set_firstname() {           eval \""$obj_name.get_firstname() {                    echo \$1                  }\""         }""    eval ""$obj_name.set_birthdate() {           eval \""$obj_name.get_birthdate() {             echo \$1           }\""           eval \""$obj_name.show_birthdate() {             echo \$(date -d \""1/1/1970 0:0:\$1 GMT\"")           }\""           eval \""$obj_name.get_age() {             echo \$(( (\$(date +%s) - \$1) / 3600 / 24 / 365 ))           }\""         }""    $obj_name.set_name $name   $obj_name.set_firstname $firstname   $obj_name.set_birthdate $birthdate }  echo  person.new self Bozeman Bozo 101272413 # Create an instance of ""person.new"" (actually passing args to the function).  self.get_firstname       #   Bozo self.get_name            #   Bozeman self.get_age             #   28 self.get_birthdate       #   101272413 self.show_birthdate      #   Sat Mar 17 20:13:33 MST 1973  echo  # typeset -f # to see the created functions (careful, it scrolls off the page).  exit 0 Prev Home Next Bibliography   A Sed and Awk Micro-Primer"
GX035-90-15116123	"PHP Manual Prev Next gmp_prob_prime     (PHP 4 >= 4.0.4) gmp_prob_prime -- Check if number is ""probably prime"" Description int  gmp_prob_prime  (resource a [, int reps])      If this function returns 0,  a  is      definitely not prime. If it returns 1, then       a  is ""probably"" prime.  If it returns 2,      then  a  is surely prime. Reasonable values      of  reps  vary from 5 to 10 (default being      10); a higher value lowers the probability for a non-prime to      pass as a ""probable"" prime.           The function uses Miller-Rabin's probabilistic test.      Prev Home Next gmp_powm Up gmp_gcd"
GX060-14-14493576	Go to the  previous ,  next  section.   Amusements          Octave cannot promise that you will actually win the lotto, but it can pick your numbers for you.  The function  texas_lotto  will select six numbers between 1 and 50.         The function  list_primes ( n )  uses a brute-force algorithm to compute the first  n  primes.           Other amusing functions include  casesen ,  flops ,  sombrero ,  exit , and  quit .    Go to the  previous ,  next  section.
GX035-91-8086185	"Index       ColorStruct_t  ......................    Event_t  ............................    GCValues_t  .........................    PictureAttributes_t  ................    Point_t  ............................    Rectangle_t  ........................    seed::TCaloJet  .....................  Generic jet with calorimeter info.   seed::TEventSample  .................  contains and interfaces seed data   seed::TEventSampleInfo  .............    seed::TExampleParticle  .............  A TExampleTrack with a particle ID, that is able to reference children and parent.   seed::TExampleTrack  ................  A TLorentzVector, which is the 4-momentum, plus a position on the track.   seed::THit  .........................  A TVector3 with a Geant track number and a PID cood.   seed::TJet  .........................  generic jet class   seed::TProcessEventABC  .............  ABC for OnTheFly processing of seed data   seed::TSeedABC  .....................  abstract base class for data access objects   seed::TSeedList  ....................  singleton managing all known seeds   seed::TSingleEntryTree  .............  provides access to ntuple data    Segment_t  ..........................    SetWindowAttributes_t  ..............    TApplication  .......................  GUI application singleton   TApplicationImp  ....................  ABC describing application protocol   TArc  ...............................  Arc of a circle   TArray  .............................  Abstract array base class   TArrayC  ............................  Array of chars   TArrayD  ............................  Array of doubles   TArrayF  ............................  Array of floats   TArrayI  ............................  Array of ints   TArrayL  ............................  Array of longs   TArrayS  ............................  Array of shorts   TArrow  .............................  An arrow (line with a arrowhead)   TAssoc  .............................    TAtt3D  .............................  3D attributes   TAttAxis  ...........................  Axis attributes   TAttCanvas  .........................  Canvas attributes   TAttFill  ...........................  Fill area attributes   TAttFillCanvas  .....................  A specialized dialog canvas to set fill attributes.   TAttImage  ..........................  Image attributes   TAttLine  ...........................  Line attributes   TAttLineCanvas  .....................  A specialized dialog canvas to set line attributes.   TAttMarker  .........................  Marker attributes   TAttMarkerCanvas  ...................  A specialized dialog canvas to set marker attributes.   TAttPad  ............................  Pad attributes   TAttParticle  .......................  Particle definition   TAttText  ...........................  Text attributes   TAttTextCanvas  .....................  A specialized dialog canvas to set text attributes.   TAuthenticate  ......................  Class providing remote authentication service   TAxis  ..............................  Axis class   TAxis3D  ............................  3-D ruler painting class   TBaseClass  .........................  Description of a base class   TBasket  ............................  the TBranch buffers   TBenchmark  .........................  ROOT utility to help benchmarking applications   TBits  ..............................  Bit container   TBox  ...............................  Box class   TBranch  ............................  Branch descriptor   TBranchClones  ......................  Branch in case of an array of clone objects   TBranchElement  .....................  Branch in case of an object   TBranchObject  ......................  Branch in case of an object   TBRIK  ..............................  TBRIK shape   TBrowser  ...........................  ROOT Object Browser   TBrowserImp  ........................  ABC describing browser implementation protocol   TBtree  .............................  A B-tree   TBtreeIter  .........................  B-tree iterator   TBuffer  ............................  Buffer base class used for serializing objects   TButton  ............................  A user interface button.   TCache  .............................  Page cache used for remote I/O   TCanvas  ............................  Graphics canvas   TCanvasImp  .........................  ABC describing main window protocol   TChain  .............................  A chain of TTrees   TChainElement  ......................  A chain element   TCint  ..............................  Interface to CINT C/C++ interpreter   TClass  .............................  Dictionary containing class information   TClassMenuItem  .....................  One element of the class context menu   TClassTable  ........................  Table of known classes   TClassTree  .........................  Manager class to draw classes inheritance tree and relations   TClonesArray  .......................  An array of clone objects   TCollection  ........................  Collection abstract base class   TColor  .............................  Color defined by RGB or HLS   TCONE  ..............................  CONE shape   TConfidenceLevel  ...................  output for TLimit functions   TCONS  ..............................  CONS shape   TContextMenu  .......................  Context sensitive popup menu   TContextMenuImp  ....................  Context sensitive popup menu implementation   TControlBar  ........................  Control bar   TControlBarButton  ..................  The Control bar button   TControlBarImp  .....................  GUI independent controlbar abc   TCrown  .............................  A crown or segment of crown   TCTUB  ..............................  The Cut Tube shape   TCurlyArc  ..........................  A curly arc   TCurlyLine  .........................  A curly polyline   TCut  ...............................  A specialized string object used for TTree selections   TCutG  ..............................  A Graphical cut.   TDatabasePDG  .......................  PDG particle database   TDataMember  ........................  Dictionary for a class data member   TDataType  ..........................  Basic data type descriptor   TDatime  ............................  Date and time 950130 124559   TDecayChannel  ......................  Class describing a particle decay channel   TDialogCanvas  ......................  A specialized canvas to set attributes.   TDiamond  ...........................  Diamond class   TDictionary  ........................  ABC defining interface to dictionary   TDirectory  .........................  Describe directory structure in memory   TDrawPanelHist  .....................  Class used to control histogram drawing options   TDSet  ..............................  Data set for remote processing (PROOF)   TDSetElement  .......................  A TDSet element   TEllipse  ...........................  An ellipse   TELTU  ..............................  ELTU shape   TEnv  ...............................  Handle ROOT configuration resources   TEventList  .........................  A list of selected entries in a TTree.   TExec  ..............................  To execute a CINT command   TExMap  .............................  Map with external hash   TExMapIter  .........................  TExMap iterator   TF1  ................................  The Parametric 1-D function   TF2  ................................  The Parametric 2-D function   TF3  ................................  The Parametric 3-D function   TFeldmanCousins  ....................    TFile  ..............................  ROOT file   TFileHandler  .......................  Handles events on file descriptors   TFitPanel  ..........................  Class used to control histograms fit panel   TFitPanelGraph  .....................  Class used to control graphs fit panel   TFitter  ............................  The ROOT standard fitter based on TMinuit   TFolder  ............................  Describe a folder: a list of objects and folders   TFormula  ...........................  The formula base class  f(x,y,z,par)   TFractionFitter  ....................  Fits MC fractions to data histogram   TFrame  .............................  Pad graphics frame   TFree  ..............................  Description of free segments on a file   TFriendElement  .....................  A friend element of another TTree   TFTP  ...............................  File Transfer Protocol class using rootd   TFunction  ..........................  Dictionary for global function   TGaxis  .............................  Graphics axis   TGenerator  .........................  Event generator interface abstract baseclass   TGenPhaseSpace  .....................  Simple Phase Space Generator   TGeometry  ..........................  Structure for Matrices, Shapes and Nodes   TGlobal  ............................  Global variable class   TGLViewerImp  .......................  ROOT OpenGL viewer implementation   TGraph  .............................  Graph graphics class   TGraphAsymmErrors  ..................  A graph with asymmetric error bars   TGraphErrors  .......................  A graph with error bars   TGraphSmooth  .......................  Graph Smoother   TGrid  ..............................  ABC defining interface to GRID services   TGridResult  ........................  ABC defining interface to GRID query result   TGroupButton  .......................  A user interface button in a group of buttons.   TGTRA  ..............................  GTRA shape   TGuiFactory  ........................  Abstract factory for GUI components   TH1  ................................  1-Dim histogram base class   TH1C  ...............................  1-Dim histograms (one char per channel)   TH1D  ...............................  1-Dim histograms (one double per channel)   TH1F  ...............................  1-Dim histograms (one float per channel)   TH1K  ...............................  1-Dim Nearest Kth neighbour method   TH1S  ...............................  1-Dim histograms (one short per channel)   TH2  ................................  2-Dim histogram base class   TH2C  ...............................  2-Dim histograms (one char per channel)   TH2D  ...............................  2-Dim histograms (one double per channel)   TH2F  ...............................  2-Dim histograms (one float per channel)   TH2S  ...............................  2-Dim histograms (one short per channel)   TH3  ................................  3-Dim histogram base class   TH3C  ...............................  3-Dim histograms (one char per channel)   TH3D  ...............................  3-Dim histograms (one double per channel)   TH3F  ...............................  3-Dim histograms (one float per channel)   TH3S  ...............................  3-Dim histograms (one short per channel)   THaarMatrix  ........................  Haar matrix   THaarMatrixD  .......................  Haar matrix with double precision   THashList  ..........................  Doubly linked list with hashtable for lookup   THashTable  .........................  A hash table   THashTableIter  .....................  Hash table iterator   THelix  .............................  A Helix drawn as a PolyLine3D   THilbertMatrix  .....................  Hilbert matrix   THilbertMatrixD  ....................  Hilbert matrix with double precision   THLimitsFinder  .....................  Class to find best axis limits   THStack  ............................  A collection of histograms   THtml  ..............................  Convert class(es) into HTML file(s)   THtml::TDocElement  .................    THtml::TLocalType  ..................  additional types found while parsing   THtml::TParseStack  .................    THtml::TParseStack::TParseElement  ..    THYPE  ..............................  HYPE shape   TImage  .............................  Abstract image class   TImagePalette  ......................  Color Palette for value -> color conversion   timespec  ...........................    TInetAddress  .......................  Represents an Internet Protocol (IP) address   TInspectCanvas  .....................  The canvas Inspector   TInspectorImp  ......................  GUI independent inspector abc   TInterpreter  .......................  ABC defining interface to generic interpreter   TIter  ..............................  Iterator wrapper   TIterator  ..........................  Iterator abstract base class   TKey  ...............................  Header description of a logical record on file   TKeyMapFile  ........................  Utility class for browsing TMapFile objects.   TLatex  .............................  The Latex-style text processor class   TLazyMatrix  ........................  Lazy matrix   TLazyMatrixD  .......................  Lazy matrix with double precision   TLeaf  ..............................  Leaf: description of a Branch data type   TLeafB  .............................  A TLeaf for an 8 bit Integer data type.   TLeafC  .............................  A TLeaf for a variable length string.   TLeafD  .............................  A TLeaf for a 64 bit floating point data type.   TLeafElement  .......................  A TLeaf for a general object derived from TObject.   TLeafF  .............................  A TLeaf for a 32 bit floating point data type.   TLeafI  .............................  A TLeaf for an Integer data type.   TLeafObject  ........................  A TLeaf for a general object derived from TObject.   TLeafS  .............................  A TLeaf for a 16 bit Integer data type.   TLegend  ............................  Legend of markers/lines/boxes to represent obj's   TLegendEntry  .......................  Storage class for one entry of a TLegend   TLimit  .............................  Class to compute 95% CL limits   TLimitDataSource  ...................  input for TLimit routines   TLine  ..............................  A line segment   TLink  ..............................  Link: hypertext link to an object   TList  ..............................  Doubly linked list   TListIter  ..........................  Linked list iterator   TLockGuard  .........................  Exception safe locking/unlocking of mutex   TLorentzRotation  ...................  Lorentz transformations including boosts and rotations   TLorentzVector  .....................  A four vector with (-,-,-,+) metric   TMap  ...............................  A (key,value) map   TMapFile  ...........................  Memory mapped directory structure   TMapIter  ...........................  Map iterator   TMapRec  ............................    TMarker  ............................  Marker   TMarker3DBox  .......................  A special 3-D marker designed for event display   TMaterial  ..........................  Materials used in the Geometry Shapes   TMath  ..............................  Interface to math routines   TMatrix  ............................  Matrix class   TMatrixColumn  ......................  One column of a matrix   TMatrixD  ...........................  Matrix class (double precision)   TMatrixDColumn  .....................  One column of a matrix (double precision)   TMatrixDDiag  .......................  Diagonal of a matrix (double  precision)   TMatrixDFlat  .......................  Flat representation of a matrix   TMatrixDiag  ........................  Diagonal of a matrix   TMatrixDRow  ........................  One row of a matrix (double precision)   TMatrixFlat  ........................  Flat representation of a matrix   TMatrixRow  .........................  One row of a matrix   TMD5  ...............................  MD5 cryptographic hash functions with a 128 bit output   TMemberInspector  ...................  ABC for inspecting class data members   TMessage  ...........................  Message buffer class   TMessageHandler  ....................  Generic message handler   TMethod  ............................  Dictionary for a class member function (method)   TMethodArg  .........................  Dictionary for a method argument   TMethodCall  ........................  Method calling interface   TMinuit  ............................  The MINUIT minimisation package   TMixture  ...........................  Mixtures used in the Geometry Shapes   TMonitor  ...........................  Monitor activity on a set of TSocket objects   TMultiDimFit  .......................  Multi dimensional fit class   TMultiGraph  ........................  A collection of TGraph objects   TNamed  .............................  The basis for a named object (name, title)   TNetFile  ...........................  A ROOT file that reads/writes via a rootd server   TNode  ..............................  Description of parameters to position a 3-D geometry object   TNodeDiv  ...........................  Description of parameters to divide a 3-D geometry object   TNtuple  ............................  A simple tree with branches of floats.   TNtupleD  ...........................  A simple tree with branches of floats.   TObjArray  ..........................  An array of objects   TObjArrayIter  ......................  Object array iterator   TObject  ............................  Basic ROOT object   TObjectTable  .......................  Table of active objects   TObjString  .........................  Collectable string class   TOrdCollection  .....................  An ordered collection   TOrdCollectionIter  .................  Ordered collection iterator   TPad  ...............................  A Graphics pad   TPadOpenGLView  .....................    TPadView3D  .........................    TPaletteEditor  .....................  Base class for palette editor   TPARA  ..............................  PARA shape   TParticle  ..........................  TParticle vertex particle information   TParticleClassPDG  ..................  PDG static particle definition   TParticlePDG  .......................  PDG static particle definition   TPave  ..............................  Pave. A box with shadowing   TPaveClass  .........................  A TPaveLabel specialized for TClassTree objects   TPaveLabel  .........................  PaveLabel. A Pave with a label   TPaveStats  .........................  A special TPaveText to draw histogram statistics.   TPavesText  .........................  Stacked Paves with text strings   TPaveText  ..........................  PaveText. A Pave with several lines of text.   TPCON  ..............................  PCON shape   TPGON  ..............................  PGON shape   TPluginHandler  .....................  Handler for plugin libraries   TPluginManager  .....................  Manager for plugin handlers   TPoint  .............................    TPoints  ............................  2-D graphics point   TPoints3DABC  .......................  A 3-D Points   TPolyLine  ..........................  A PolyLine   TPolyLine3D  ........................  A 3-D polyline   TPolyMarker  ........................  An array of points with the same marker   TPolyMarker3D  ......................  An array of 3-D points with the same marker   TPostScript  ........................  PostScript driver   TPrimary  ...........................  TPrimary vertex particle information   TPrincipal  .........................  Principal Components Analysis   TProcessEventTimer  .................  Process pending events at fixed time intervals   TProcessID  .........................  Process Unique Identifier in time and space   TProcessUUID  .......................  TProcessID managing UUIDs   TProfile  ...........................  Profile histogram class   TProfile2D  .........................  Profile2D histogram class   TPServerSocket  .....................  Parallel server socket   TPSocket  ...........................  Parallel client socket   TQClass  ............................  Class with connections   TQConnection  .......................  Internal class used in the object communication mechanism   TQObject  ...........................  Base class for object communication mechanism   TQObjSender  ........................  Used to ""delegate"" TQObject functionality   TRandom  ............................  Random number generators   TRandom2  ...........................  Random number generators with periodicity > 10**14   TRandom3  ...........................  Random number generator: Mersenne Twistor   TRealData  ..........................  Description of persistent data members   TRef  ...............................  Persistent Reference link to a TObject   TRefArray  ..........................  An array of references to TObjects   TRefArrayIter  ......................  Object array iterator   TRegexp  ............................  Regular expression class   TRint  ..............................  ROOT Interactive Application Interface   TROOT  ..............................  Top level (or root) structure for all classes   TRotation  ..........................  Rotations of TVector3 objects   TRotMatrix  .........................  Rotation Matrix for 3-D geometry objects   TSelector  ..........................  A utility class for tree and object processing   TSelectorCint  ......................  A utility class for tree and object processing (interpreted version)   TSeqCollection  .....................  Sequenceable collection ABC   TServerSocket  ......................  This class implements server sockets   TShape  .............................  Basic shape   TSignalHandler  .....................  Signal event handler   TSlider  ............................  A user interface slider.   TSliderBox  .........................  The moving box of a TSlider   TSocket  ............................  This class implements client sockets   TSortedList  ........................  A sorted list   TSpectrum  ..........................  Peak Finder, background estimator, Deconvolution   TSPHE  ..............................  SPHE shape   TSpline  ............................  Spline base class   TSpline3  ...........................  Class to create third natural splines   TSpline5  ...........................  Class to create quintic natural splines   TSplinePoly  ........................  Spline polynomial terms   TSplinePoly3  .......................  Third spline polynomial terms   TSplinePoly5  .......................  Quintic spline polynomial terms   TSQLResult  .........................  SQL query result   TSQLRow  ............................  One row of an SQL query result   TSQLServer  .........................  Connection to SQL server   TStopwatch  .........................  A stopwatch which times real and cpu time   TStorage  ...........................  Storage manager class   TStreamerBase  ......................  Streamer element of type base class   TStreamerBasicPointer  ..............  Streamer element for a pointer to a basic type   TStreamerBasicType  .................  Streamer element for a basic type   TStreamerElement  ...................  Base class for one element (data member) to be Streamed   TStreamerInfo  ......................  Streamer information for one class version   TStreamerLoop  ......................  Streamer element for a pointer to an array of objects   TStreamerObject  ....................  Streamer element of type object   TStreamerObjectAny  .................  Streamer element of type object other than TObject   TStreamerObjectAnyPointer  ..........  Streamer element of type pointer to a non TObject   TStreamerObjectPointer  .............  Streamer element of type pointer to a TObject   TStreamerSTL  .......................  Streamer element of type STL container   TStreamerSTLstring  .................  Streamer element of type  C++ string   TStreamerString  ....................  Streamer element of type TString   TString  ............................  Basic string class   TStringLong  ........................  Long string class (more than 255 chars)   TStyle  .............................  A collection of all graphics attributes   TSubString  .........................    TSVG  ...............................  SVG driver   TSysEvtHandler  .....................  ABC for handling system events   TSystem  ............................  ABC defining a generic interface to the OS   TSystemDirectory  ...................  A system directory   TSystemFile  ........................  A system file   TTabCom  ............................  Perform comand line completion when hitting <TAB>   TTask  ..............................  Base class for tasks   TText  ..............................  Text   TTF  ................................  Interface to TTF font handling   TTime  ..............................  Basic time type with milli second precision   TTimer  .............................  Handle timer event   TTimeStamp  .........................  Encapsulates seconds and ns since EPOCH   TToggle  ............................  Facility for toggling datamembers on/off   TToggleGroup  .......................  Group of contex-menu toggle objects   TTRAP  ..............................  TRAP shape   TTRD1  ..............................  TRD1 shape   TTRD2  ..............................  TRD2 shape   TTree  ..............................  Tree descriptor (the main ROOT I/O class)   TTreeFriendLeafIter  ................  Linked list iterator   TTreeResult  ........................  TTree query result   TTreeRow  ...........................  One row of an TTree query result   TTUBE  ..............................  TUBE shape   TTUBS  ..............................  TUBS shape   TUnixSystem  ........................  Interface to Unix OS services   TUrl  ...............................  Represents an URL   TUtil3D  ............................  The default 3-D view utility  class   TUtilHist  ..........................  misc. histogram  utilities   TUtilPad  ...........................  misc. pad/canvas  utilities    TUUID  ..............................  Universally Unique IDentifier   TVector  ............................  Vector class   TVector2  ...........................  A 2D physics vector   TVector3  ...........................  A 3D physics vector   TVectorD  ...........................  Vector class with double precision   TView  ..............................  3-D View   TVirtualFitter  .....................  Abstract interface for fitting   TVirtualGL  .........................    TVirtualHistPainter  ................  Abstract interface for histogram painters   TVirtualMutex  ......................  Virtual mutex lock class   TVirtualPad  ........................  Abstract base class for Pads and Canvases   TVirtualProof  ......................  Abstract PROOF interface   TVirtualPS  .........................  Abstract interface to a PostScript driver   TVirtualTreePlayer  .................  Abstract interface for Tree players   TVirtualUtil3D  .....................  Abstract interface to a the 3-D view utility   TVirtualUtilHist  ...................  Abstract interface to the histogram  utilities    TVirtualUtilPad  ....................  Abstract interface to the pad/canvas  utilities   TVirtualX  ..........................  ABC defining a generic interface to graphics system   TWbox  ..............................  A window box (box with 3-D effects)   TWebFile  ...........................  A ROOT file that reads via a http server   TXTRU  ..............................  TXTRU shape   WindowAttributes_t  .................           Last update: Tue Feb 25 12:28:09 2003           ROOT page  -  Class index  -  Top of the page          This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to  ROOT support , or contact  the developers  with any questions or problems regarding ROOT."
GX044-47-10005368	Next:   The Cryptographic Hash Function    Up:   Random Number Generators    Previous:   2 64  -2 10  + 1                  2 62  -2 16  + 1 Modulus Linear Congruential Generator   A second prime modulus generator that addresses the pattern appearing for Mersenne primes is provided by the prime modulus   2 62  -2 16  + 1. This is provided by the recurrence relation:             x [ n ] =  a   x [ n  - 1]   ( mod p )     (8)      Where the multiplier,    a  = 3355703948966806692, is hardwired into the algorithm and   p , the prime modulus, is   2 62  -2 16  + 1. The multiplier was again chosen to obtain maximal period of the generator,   2 62  -2 16    4.6  x  10 18 . The interface routines for this generator are declared as:  Rng_Type RngP62_16Seed( Rng_UInt32 i, Rng_UInt32 j );      Rng_Type RngP62_16Spawn( Rng_Type *x );      int iRngP62_16( Rng_Type *x );      double dRngP62_16( Rng_Type *x );      float fRngP62_16( Rng_Type *x );     This random number generator suffers from no patterns that we are aware of    and we are currently evaluating its quality using statistical tests.
GX043-14-14491727	Index     TApplication  ........  GUI application singleton   TApplicationImp  .....  ABC describing application implementation protocol   TArray  ..............  Abstract array base class   TArrayC  .............  Array of chars   TArrayD  .............  Array of doubles   TArrayF  .............  Array of floats   TArrayI  .............  Array of ints   TArrayL  .............  Array of longs   TArrayS  .............  Array of shorts   TAtt3D  ..............  3D attributes   TAttAxis  ............  Axis attributes   TAttFill  ............  Fill area attributes   TAttLine  ............  Line attributes   TAttMarker  ..........  Marker attributes   TAttPad  .............  Pad attributes   TAttText  ............  Text attributes   TBenchmark  ..........  ROOT utility to help benchmarking applications   TBrowser  ............  ROOT Object Browser   TBrowserImp  .........  ABC describing browser implementation protocol   TBuffer  .............  Buffer base class used for serializing objects   TCanvasImp  ..........  ABC describing main window protocol   TClassTable  .........  Table of known classes   TColor  ..............  Color defined by RGB or HLS   TContextMenu  ........  Context sensitive popup menu   TContextMenuImp  .....  Context sensitive popup menu implementation   TControlBarImp  ......  GUI independent controlbar abc   TDatime  .............  Date and time 950130 124559   TDirectory  ..........  Describe directory structure in memory   TEnv  ................  Handle ROOT configuration resources   TFile  ...............  ROOT file   TFileHandler  ........  Handles events on file descriptors   TFree  ...............  Description of free segments on a file   TGuiFactory  .........  Abstract factory for GUI components   TKey  ................  Header description of a logical record on file   TKeyMapFile  .........  Utility class for browsing TMapFile objects.   TMapFile  ............  Memory mapped directory structure   TMath  ...............  Interface to math routines   TMemberInspector  ....  ABC for inspecting class data members   TMessageHandler  .....  Generic message handler   TNamed  ..............  The basis for a named object (name, title)   TObject  .............  Basic ROOT object   TObjectTable  ........  Table of active objects   TObjString  ..........  Collectable string class   TProcessEventTimer  ..  Process pending events at fixed time intervals   TRandom  .............  Random number generators   TRandom2  ............  Random number generators with periodicity > 10**14   TRandom3  ............  Random number generator: Mersenne Twistor   TRealData  ...........  Description of persistent data members   TRegexp  .............  Regular expression class   TROOT  ...............  Top level (or root) structure for all classes   TSignalHandler  ......  Signal event handler   TStopwatch  ..........  A stopwatch which times real and cpu time   TStorage  ............  Storage manager class   TString  .............  Basic string class   TStringLong  .........  Long string class (more than 255 chars)   TStyle  ..............  A collection of all graphics attributes   TSysEvtHandler  ......  ABC for handling system events   TSystem  .............  ABC defining a generic interface to the OS   TSystemDirectory  ....  A system directory   TSystemFile  .........  A system file   TTime  ...............  Basic time type with milli second precision   TTimer  ..............  Handle timer event   TView  ...............  3-D View   TVirtualFitter  ......  Abstract interface for fitting   TVirtualPad  .........  Abstract base class for Pads and Canvases   TVirtualPS  ..........  Abstract interface to a PostScript driver   TVirtualX  ...........  ABC defining a generic interface to graphics system            Last update: Fri Nov 26 09:30:52 1999           ROOT page  -  Class index  -  Top of the page     This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to  ROOT support , or contact  the developers  with any questions or problems regarding ROOT.
GX042-94-5584085	"Index       ColorStruct_t  ......................    Event_t  ............................    GCValues_t  .........................    PictureAttributes_t  ................    Point_t  ............................    Rectangle_t  ........................    Segment_t  ..........................    SetWindowAttributes_t  ..............    TApplication  .......................  GUI application singleton   TApplicationImp  ....................  ABC describing application protocol   TArc  ...............................  Arc of a circle   TArray  .............................  Abstract array base class   TArrayC  ............................  Array of chars   TArrayD  ............................  Array of doubles   TArrayF  ............................  Array of floats   TArrayI  ............................  Array of ints   TArrayL  ............................  Array of longs   TArrayS  ............................  Array of shorts   TArrow  .............................  An arrow (line with a arrowhead)   TAssoc  .............................    TAtt3D  .............................  3D attributes   TAttAxis  ...........................  Axis attributes   TAttCanvas  .........................  Canvas attributes   TAttFill  ...........................  Fill area attributes   TAttFillCanvas  .....................  A specialized dialog canvas to set fill attributes.   TAttImage  ..........................  Image attributes   TAttLine  ...........................  Line attributes   TAttLineCanvas  .....................  A specialized dialog canvas to set line attributes.   TAttMarker  .........................  Marker attributes   TAttMarkerCanvas  ...................  A specialized dialog canvas to set marker attributes.   TAttPad  ............................  Pad attributes   TAttText  ...........................  Text attributes   TAttTextCanvas  .....................  A specialized dialog canvas to set text attributes.   TAuthenticate  ......................  Class providing remote authentication service   TAxis  ..............................  Axis class   TAxis3D  ............................  3-D ruler painting class   TBaseClass  .........................  Description of a base class   TBasket  ............................  the TBranch buffers   TBenchmark  .........................  ROOT utility to help benchmarking applications   TBits  ..............................  Bit container   TBox  ...............................  Box class   TBranch  ............................  Branch descriptor   TBranchClones  ......................  Branch in case of an array of clone objects   TBranchElement  .....................  Branch in case of an object   TBranchObject  ......................  Branch in case of an object   TBRIK  ..............................  TBRIK shape   TBrowser  ...........................  ROOT Object Browser   TBrowserImp  ........................  ABC describing browser implementation protocol   TBtree  .............................  A B-tree   TBtreeIter  .........................  B-tree iterator   TBuffer  ............................  Buffer base class used for serializing objects   TButton  ............................  A user interface button.   TCache  .............................  Page cache used for remote I/O   TCanvas  ............................  Graphics canvas   TCanvasImp  .........................  ABC describing main window protocol   TChain  .............................  A chain of TTrees   TChainElement  ......................  A chain element   TCint  ..............................  Interface to CINT C/C++ interpreter   TClass  .............................  Dictionary containing class information   TClassMenuItem  .....................  One element of the class context menu   TClassTable  ........................  Table of known classes   TClassTree  .........................  Manager class to draw classes inheritance tree and relations   TClonesArray  .......................  An array of clone objects   TCollection  ........................  Collection abstract base class   TColor  .............................  Color defined by RGB or HLS   TCONE  ..............................  CONE shape   TConfidenceLevel  ...................  output for TLimit functions   TCONS  ..............................  CONS shape   TContextMenu  .......................  Context sensitive popup menu   TContextMenuImp  ....................  Context sensitive popup menu implementation   TControlBar  ........................  Control bar   TControlBarButton  ..................  The Control bar button   TControlBarImp  .....................  GUI independent controlbar abc   TCrown  .............................  A crown or segment of crown   TCTUB  ..............................  The Cut Tube shape   TCurlyArc  ..........................  A curly arc   TCurlyLine  .........................  A curly polyline   TCut  ...............................  A specialized string object used for TTree selections   TCutG  ..............................  A Graphical cut.   TDataMember  ........................  Dictionary for a class data member   TDataType  ..........................  Basic data type descriptor   TDatime  ............................  Date and time 950130 124559   TDialogCanvas  ......................  A specialized canvas to set attributes.   TDiamond  ...........................  Diamond class   TDictionary  ........................  ABC defining interface to dictionary   TDirectory  .........................  Describe directory structure in memory   TDrawPanelHist  .....................  Class used to control histogram drawing options   TDSet  ..............................  Data set for remote processing (PROOF)   TDSetElement  .......................  A TDSet element   TEllipse  ...........................  An ellipse   TELTU  ..............................  ELTU shape   TEnv  ...............................  Handle ROOT configuration resources   TEventList  .........................  A list of selected entries in a TTree.   TExec  ..............................  To execute a CINT command   TExMap  .............................  Map with external hash   TExMapIter  .........................  TExMap iterator   TF1  ................................  The Parametric 1-D function   TF12  ...............................  Projection of a TF2 along x or y   TF2  ................................  The Parametric 2-D function   TF3  ................................  The Parametric 3-D function   TFile  ..............................  ROOT file   TFileHandler  .......................  Handles events on file descriptors   TFitPanel  ..........................  Class used to control histograms fit panel   TFitPanelGraph  .....................  Class used to control graphs fit panel   TFitter  ............................  The ROOT standard fitter based on TMinuit   TFolder  ............................  Describe a folder: a list of objects and folders   TFormula  ...........................  The formula base class  f(x,y,z,par)   TFractionFitter  ....................  Fits MC fractions to data histogram   TFrame  .............................  Pad graphics frame   TFree  ..............................  Description of free segments on a file   TFriendElement  .....................  A friend element of another TTree   TFTP  ...............................  File Transfer Protocol class using rootd   TFunction  ..........................  Dictionary for global function   TG16ColorSelector  ..................  16 color cells   TGApplication  ......................  GUI application singleton   TGaxis  .............................  Graphics axis   TGButton  ...........................  Button widget abstract base class   TGButtonGroup  ......................  Organizes TGButtons in a group   TGCanvas  ...........................  A canvas with two scrollbars and a viewport   TGCheckButton  ......................  A check button widget   TGClient  ...........................  Class making connection to display server   TGColorDialog  ......................  Color selection dialog   TGColorFrame  .......................  Frame for color cell   TGColorPalette  .....................  Color palette widget   TGColorPick  ........................  Color picker widget   TGColorPopup  .......................  Color selector popup   TGColorSelect  ......................  Color selection checkbutton   TGColumnLayout  .....................  Column layout manager   TGComboBox  .........................  Combo box widget   TGComboBoxPopup  ....................  Combobox popup window   TGCompositeFrame  ...................  Base class for composite widgets (menubars, etc.)   TGContainer  ........................  Canvas container   TGDimension  ........................  Dimension object (width, height)   TGDoubleHSlider  ....................  Horizontal double slider widget   TGDoubleSlider  .....................  Double slider widget abstract base class   TGDoubleVSlider  ....................  Vertical double slider widget   TGeometry  ..........................  Structure for Matrices, Shapes and Nodes   TGFileContainer  ....................  Container containing file system objects   TGFileDialog  .......................  File selection dialog   TGFileInfo  .........................    TGFrame  ............................  Base class for simple widgets (button, etc.)   TGFrameElement  .....................    TGFSComboBox  .......................  Combo box widget for file system path   TGGC  ...............................  Graphics context   TGGCPool  ...........................  Graphics context pool   TGGotoDialog  .......................  Goto line dialig used by TGTextEdit widget   TGGroupFrame  .......................  A composite frame with border and title   TGHButtonGroup  .....................  A button group with one horizontal row   TGHorizontal3DLine  .................  A horizontal 3D separator line   TGHorizontalFrame  ..................  Composite frame with horizontal child layout   TGHorizontalLayout  .................  Horizontal layout manager   TGHotString  ........................  Graphics string with hot character   TGHProgressBar  .....................  Horizontal progress bar widget   TGHScrollBar  .......................  Horizontal scrollbar widget   TGHSlider  ..........................  Horizontal slider widget   TGHSplitter  ........................  A horizontal frame splitter   TGIcon  .............................  Icon GUI class   TGImageMap  .........................  Clickable image (like MAP in HTML)   TGLabel  ............................  A label GUI element   TGLayoutHints  ......................  Class describing GUI layout hints   TGLayoutManager  ....................  Layout manager abstract base class   TGLBContainer  ......................  Listbox container   TGLBEntry  ..........................  Basic listbox entry   TGListBox  ..........................  Listbox widget   TGListDetailsLayout  ................  Layout manager for TGListView details   TGListLayout  .......................  Layout manager for TGListView widget   TGListTree  .........................  Show items in a tree structured list   TGListTreeItem  .....................  Item that goes into a TGListTree container   TGListView  .........................  List view widget (iconbox, small icons or tabular view)   TGlobal  ............................  Global variable class   TGLongPosition  .....................  Position object (x and y are Long_t)   TGLVContainer  ......................  Listview container   TGLVEntry  ..........................  Item that goes into a TGListView container   TGLViewerImp  .......................  ROOT OpenGL viewer implementation   TGMainFrame  ........................  Top level window frame   TGMatrixLayout  .....................  Matrix layout manager   TGMenuBar  ..........................  Menu bar class   TGMenuEntry  ........................    TGMenuTitle  ........................  Menu title class   TGMimeTypes  ........................  Pool of mime type objects   TGMsgBox  ...........................  A message dialog box   TGNumberEntry  ......................  Entry field widget for several numeric formats   TGNumberEntryField  .................  A text entry field used by a TGNumberEntry   TGNumberFormat  .....................  Class defining namespace for several enums used by TGNumberEntry   TGObject  ...........................  ROOT GUI base class   TGPicture  ..........................  Pictures and icons used by the GUI classes   TGPictureButton  ....................  A picture button widget   TGPicturePool  ......................  Picture and icon cache   TGPopupMenu  ........................  Popup menu   TGPosition  .........................  Position object (x and y are Int_t)   TGPrintDialog  ......................  Print dialog used by TGTextEdit widget   TGProgressBar  ......................  Progress bar abstract base class   TGRadioButton  ......................  A radio button widget   TGraph  .............................  Graph graphics class   TGraphAsymmErrors  ..................  A graph with asymmetric error bars   TGraphErrors  .......................  A graph with error bars   TGraphSmooth  .......................  Graph Smoother   TGRegion  ...........................  Describes a region   TGRegionWithId  .....................  Region with id, tooltip text and popup menu   TGrid  ..............................  ABC defining interface to GRID services   TGridResult  ........................  ABC defining interface to GRID query result   TGroupButton  .......................  A user interface button in a group of buttons.   TGRowLayout  ........................  Row layout manager   TGScrollBar  ........................  Scrollbar widget   TGScrollBarElement  .................  Scrollbar element (head, tail, slider)   TGSearchDialog  .....................  Text search dialog used by TGTextEdit widget   TGSearchType  .......................    TGSelectedPicture  ..................  Selected looking picture   TGShutter  ..........................  Shutter widget   TGShutterItem  ......................  Shutter widget item   TGSlider  ...........................  Slider widget abstract base class   TGSplitter  .........................  A frame splitter abstract base class   TGStatusBar  ........................  Status bar widget   TGString  ...........................  Graphics string   TGTab  ..............................  Tab widget   TGTabElement  .......................  Little tab on tab widget   TGTabLayout  ........................  Layout manager for TGTab widget   TGTableLayout  ......................  Table layout manager   TGTableLayoutHints  .................  Class describing GUI table layout hints   TGText  .............................  Text used by TGTextEdit   TGTextBuffer  .......................  Text buffer used by widgets like TGTextEntry, etc.   TGTextButton  .......................  A text button widget   TGTextEdit  .........................  Text edit widget   TGTextEntry  ........................  The TGTextEntry widget is a simple line editor for inputting text   TGTextLBEntry  ......................  Text listbox entry   TGTextLine  .........................  Line in TGText   TGTextView  .........................  Editable text widget base class (links TGText to TGEditView)   TGTileLayout  .......................  Tile layout manager   TGToolBar  ..........................  A bar containing picture buttons   TGToolTip  ..........................  One line help text   TGTRA  ..............................  GTRA shape   TGTransientFrame  ...................  Frame for dialog (transient) windows   TGTreeLBEntry  ......................  TGFSComboBox entry   TGuiFactory  ........................  Abstract factory for GUI components   TGUnknownWindowHandler  .............  Abstract event handler for unknown windows   TGVButtonGroup  .....................  A button group with one vertical column   TGVertical3DLine  ...................  A vertical 3D separator line   TGVerticalFrame  ....................  Composite frame with vertical child layout   TGVerticalLayout  ...................  Vertical layout manager   TGView  .............................  Text view widget base class   TGViewFrame  ........................  Frame containing the actual text   TGViewPort  .........................  Viewport through which to look at a container frame   TGVProgressBar  .....................  Vertical progress bar widget   TGVScrollBar  .......................  Vertical scrollbar widget   TGVSlider  ..........................  Vertical slider widget   TGVSplitter  ........................  A vertical frame splitter   TGWidget  ...........................  Widget base class   TGWindow  ...........................  GUI Window base class   TGX11  ..............................  Interface to X11   TGX11TTF  ...........................  Interface to X11 + TTF font handling   TGXYLayout  .........................  X / Y - layout manager   TGXYLayoutHints  ....................  Hits for the X / Y - layout manager   TH1  ................................  1-Dim histogram base class   TH1C  ...............................  1-Dim histograms (one char per channel)   TH1D  ...............................  1-Dim histograms (one double per channel)   TH1F  ...............................  1-Dim histograms (one float per channel)   TH1K  ...............................  1-Dim Nearest Kth neighbour method   TH1S  ...............................  1-Dim histograms (one short per channel)   TH2  ................................  2-Dim histogram base class   TH2C  ...............................  2-Dim histograms (one char per channel)   TH2D  ...............................  2-Dim histograms (one double per channel)   TH2F  ...............................  2-Dim histograms (one float per channel)   TH2S  ...............................  2-Dim histograms (one short per channel)   TH3  ................................  3-Dim histogram base class   TH3C  ...............................  3-Dim histograms (one char per channel)   TH3D  ...............................  3-Dim histograms (one double per channel)   TH3F  ...............................  3-Dim histograms (one float per channel)   TH3S  ...............................  3-Dim histograms (one short per channel)   THaarMatrix  ........................  Haar matrix   THaarMatrixD  .......................  Haar matrix with double precision   THashList  ..........................  Doubly linked list with hashtable for lookup   THashTable  .........................  A hash table   THashTableIter  .....................  Hash table iterator   THelix  .............................  A Helix drawn as a PolyLine3D   THilbertMatrix  .....................  Hilbert matrix   THilbertMatrixD  ....................  Hilbert matrix with double precision   THLimitsFinder  .....................  Class to find best axis limits   THStack  ............................  A collection of histograms   THtml  ..............................  Convert class(es) into HTML file(s)   THtml::TDocElement  .................    THtml::TLocalType  ..................  additional types found while parsing   THtml::TParseStack  .................    THtml::TParseStack::TParseElement  ..    THYPE  ..............................  HYPE shape   TImage  .............................  Abstract image class   TImagePalette  ......................  Color Palette for value -> color conversion   timespec  ...........................    TInetAddress  .......................  Represents an Internet Protocol (IP) address   TInspectCanvas  .....................  The canvas Inspector   TInspectorImp  ......................  GUI independent inspector abc   TInterpreter  .......................  ABC defining interface to generic interpreter   TIter  ..............................  Iterator wrapper   TIterator  ..........................  Iterator abstract base class   TKey  ...............................  Header description of a logical record on file   TKeyMapFile  ........................  Utility class for browsing TMapFile objects.   TLatex  .............................  The Latex-style text processor class   TLazyMatrix  ........................  Lazy matrix   TLazyMatrixD  .......................  Lazy matrix with double precision   TLeaf  ..............................  Leaf: description of a Branch data type   TLeafB  .............................  A TLeaf for an 8 bit Integer data type.   TLeafC  .............................  A TLeaf for a variable length string.   TLeafD  .............................  A TLeaf for a 64 bit floating point data type.   TLeafElement  .......................  A TLeaf for a general object derived from TObject.   TLeafF  .............................  A TLeaf for a 32 bit floating point data type.   TLeafI  .............................  A TLeaf for an Integer data type.   TLeafObject  ........................  A TLeaf for a general object derived from TObject.   TLeafS  .............................  A TLeaf for a 16 bit Integer data type.   TLegend  ............................  Legend of markers/lines/boxes to represent obj's   TLegendEntry  .......................  Storage class for one entry of a TLegend   TLimit  .............................  Class to compute 95% CL limits   TLimitDataSource  ...................  input for TLimit routines   TLine  ..............................  A line segment   TLink  ..............................  Link: hypertext link to an object   TList  ..............................  Doubly linked list   TListIter  ..........................  Linked list iterator   TLockGuard  .........................  Exception safe locking/unlocking of mutex   TMap  ...............................  A (key,value) map   TMapFile  ...........................  Memory mapped directory structure   TMapIter  ...........................  Map iterator   TMapRec  ............................    TMarker  ............................  Marker   TMarker3DBox  .......................  A special 3-D marker designed for event display   TMaterial  ..........................  Materials used in the Geometry Shapes   TMath  ..............................  Interface to math routines   TMatrix  ............................  Matrix class   TMatrixColumn  ......................  One column of a matrix   TMatrixD  ...........................  Matrix class (double precision)   TMatrixDColumn  .....................  One column of a matrix (double precision)   TMatrixDDiag  .......................  Diagonal of a matrix (double  precision)   TMatrixDFlat  .......................  Flat representation of a matrix   TMatrixDiag  ........................  Diagonal of a matrix   TMatrixDRow  ........................  One row of a matrix (double precision)   TMatrixFlat  ........................  Flat representation of a matrix   TMatrixRow  .........................  One row of a matrix   TMD5  ...............................  MD5 cryptographic hash functions with a 128 bit output   TMemberInspector  ...................  ABC for inspecting class data members   TMessage  ...........................  Message buffer class   TMessageHandler  ....................  Generic message handler   TMethod  ............................  Dictionary for a class member function (method)   TMethodArg  .........................  Dictionary for a method argument   TMethodCall  ........................  Method calling interface   TMinuit  ............................  The MINUIT minimisation package   TMixture  ...........................  Mixtures used in the Geometry Shapes   TMonitor  ...........................  Monitor activity on a set of TSocket objects   TMultiDimFit  .......................  Multi dimensional fit class   TMultiGraph  ........................  A collection of TGraph objects   TNamed  .............................  The basis for a named object (name, title)   TNetFile  ...........................  A ROOT file that reads/writes via a rootd server   TNode  ..............................  Description of parameters to position a 3-D geometry object   TNodeDiv  ...........................  Description of parameters to divide a 3-D geometry object   TNtuple  ............................  A simple tree with branches of floats.   TNtupleD  ...........................  A simple tree with branches of floats.   TObjArray  ..........................  An array of objects   TObjArrayIter  ......................  Object array iterator   TObject  ............................  Basic ROOT object   TObjectTable  .......................  Table of active objects   TObjString  .........................  Collectable string class   TOrdCollection  .....................  An ordered collection   TOrdCollectionIter  .................  Ordered collection iterator   TPad  ...............................  A Graphics pad   TPadOpenGLView  .....................    TPadView3D  .........................    TPaletteEditor  .....................  Base class for palette editor   TPARA  ..............................  PARA shape   TPave  ..............................  Pave. A box with shadowing   TPaveClass  .........................  A TPaveLabel specialized for TClassTree objects   TPaveLabel  .........................  PaveLabel. A Pave with a label   TPaveStats  .........................  A special TPaveText to draw histogram statistics.   TPavesText  .........................  Stacked Paves with text strings   TPaveText  ..........................  PaveText. A Pave with several lines of text.   TPCON  ..............................  PCON shape   TPGON  ..............................  PGON shape   TPluginHandler  .....................  Handler for plugin libraries   TPluginManager  .....................  Manager for plugin handlers   TPoint  .............................    TPoints  ............................  2-D graphics point   TPoints3DABC  .......................  A 3-D Points   TPolyLine  ..........................  A PolyLine   TPolyLine3D  ........................  A 3-D polyline   TPolyMarker  ........................  An array of points with the same marker   TPolyMarker3D  ......................  An array of 3-D points with the same marker   TPostScript  ........................  PostScript driver   TPrincipal  .........................  Principal Components Analysis   TProcessEventTimer  .................  Process pending events at fixed time intervals   TProcessID  .........................  Process Unique Identifier in time and space   TProcessUUID  .......................  TProcessID managing UUIDs   TProfile  ...........................  Profile histogram class   TProfile2D  .........................  Profile2D histogram class   TPServerSocket  .....................  Parallel server socket   TPSocket  ...........................  Parallel client socket   TQClass  ............................  Class with connections   TQConnection  .......................  Internal class used in the object communication mechanism   TQObject  ...........................  Base class for object communication mechanism   TQObjSender  ........................  Used to ""delegate"" TQObject functionality   TRandom  ............................  Random number generators   TRandom2  ...........................  Random number generators with periodicity > 10**14   TRandom3  ...........................  Random number generator: Mersenne Twistor   TRealData  ..........................  Description of persistent data members   TRef  ...............................  Persistent Reference link to a TObject   TRefArray  ..........................  An array of references to TObjects   TRefArrayIter  ......................  Object array iterator   TRefCnt  ............................    TRegexp  ............................  Regular expression class   TRint  ..............................  ROOT Interactive Application Interface   TROOT  ..............................  Top level (or root) structure for all classes   TRootApplication  ...................  ROOT native GUI application environment   TRootBrowser  .......................  ROOT native GUI version of browser   TRootCanvas  ........................  ROOT native GUI version of main window with menubar and drawing area   TRootContextMenu  ...................  ROOT native GUI context sensitive popup menu   TRootControlBar  ....................  ROOT native GUI implementation of TControlBar   TRootDialog  ........................  Native GUI method argument prompt dialog box   TRootEmbeddedCanvas  ................  A ROOT TCanvas that can be embedded in a TGFrame   TRootGuiFactory  ....................  Factory for ROOT GUI components   TRootHelpDialog  ....................  Dialog to display help text   TRotMatrix  .........................  Rotation Matrix for 3-D geometry objects   TSelector  ..........................  A utility class for tree and object processing   TSelectorCint  ......................  A utility class for tree and object processing (interpreted version)   TSeqCollection  .....................  Sequenceable collection ABC   TServerSocket  ......................  This class implements server sockets   TShape  .............................  Basic shape   TSignalHandler  .....................  Signal event handler   TSlider  ............................  A user interface slider.   TSliderBox  .........................  The moving box of a TSlider   TSocket  ............................  This class implements client sockets   TSortedList  ........................  A sorted list   TSpectrum  ..........................  Peak Finder, background estimator, Deconvolution   TSpectrum2  .........................  Peak Finder, background estimator, Deconvolution for 2-D histograms   TSPHE  ..............................  SPHE shape   TSpline  ............................  Spline base class   TSpline3  ...........................  Class to create third natural splines   TSpline5  ...........................  Class to create quintic natural splines   TSplinePoly  ........................  Spline polynomial terms   TSplinePoly3  .......................  Third spline polynomial terms   TSplinePoly5  .......................  Quintic spline polynomial terms   TSQLResult  .........................  SQL query result   TSQLRow  ............................  One row of an SQL query result   TSQLServer  .........................  Connection to SQL server   TStopwatch  .........................  A stopwatch which times real and cpu time   TStorage  ...........................  Storage manager class   TStreamerBase  ......................  Streamer element of type base class   TStreamerBasicPointer  ..............  Streamer element for a pointer to a basic type   TStreamerBasicType  .................  Streamer element for a basic type   TStreamerElement  ...................  Base class for one element (data member) to be Streamed   TStreamerInfo  ......................  Streamer information for one class version   TStreamerLoop  ......................  Streamer element for a pointer to an array of objects   TStreamerObject  ....................  Streamer element of type object   TStreamerObjectAny  .................  Streamer element of type object other than TObject   TStreamerObjectAnyPointer  ..........  Streamer element of type pointer to a non TObject   TStreamerObjectPointer  .............  Streamer element of type pointer to a TObject   TStreamerSTL  .......................  Streamer element of type STL container   TStreamerSTLstring  .................  Streamer element of type  C++ string   TStreamerString  ....................  Streamer element of type TString   TString  ............................  Basic string class   TStringLong  ........................  Long string class (more than 255 chars)   TStyle  .............................  A collection of all graphics attributes   TSubString  .........................    TSVG  ...............................  SVG driver   TSysEvtHandler  .....................  ABC for handling system events   TSystem  ............................  ABC defining a generic interface to the OS   TSystemDirectory  ...................  A system directory   TSystemFile  ........................  A system file   TTabCom  ............................  Perform comand line completion when hitting <TAB>   TTask  ..............................  Base class for tasks   TText  ..............................  Text   TTF  ................................  Interface to TTF font handling   TTime  ..............................  Basic time type with milli second precision   TTimer  .............................  Handle timer event   TTimeStamp  .........................  Encapsulates seconds and ns since EPOCH   TToggle  ............................  Facility for toggling datamembers on/off   TToggleGroup  .......................  Group of contex-menu toggle objects   TTRAP  ..............................  TRAP shape   TTRD1  ..............................  TRD1 shape   TTRD2  ..............................  TRD2 shape   TTree  ..............................  Tree descriptor (the main ROOT I/O class)   TTreeFriendLeafIter  ................  Linked list iterator   TTreeResult  ........................  TTree query result   TTreeRow  ...........................  One row of an TTree query result   TTUBE  ..............................  TUBE shape   TTUBS  ..............................  TUBS shape   TUnixSystem  ........................  Interface to Unix OS services   TUrl  ...............................  Represents an URL   TUtil3D  ............................  The default 3-D view utility  class   TUtilHist  ..........................  misc. histogram  utilities   TUtilPad  ...........................  misc. pad/canvas  utilities    TUUID  ..............................  Universally Unique IDentifier   TVector  ............................  Vector class   TVectorD  ...........................  Vector class with double precision   TView  ..............................  3-D View   TVirtualFitter  .....................  Abstract interface for fitting   TVirtualGL  .........................    TVirtualHistPainter  ................  Abstract interface for histogram painters   TVirtualMutex  ......................  Virtual mutex lock class   TVirtualPad  ........................  Abstract base class for Pads and Canvases   TVirtualProof  ......................  Abstract PROOF interface   TVirtualPS  .........................  Abstract interface to a PostScript driver   TVirtualTreePlayer  .................  Abstract interface for Tree players   TVirtualUtil3D  .....................  Abstract interface to a the 3-D view utility   TVirtualUtilHist  ...................  Abstract interface to the histogram  utilities    TVirtualUtilPad  ....................  Abstract interface to the pad/canvas  utilities   TVirtualX  ..........................  ABC defining a generic interface to graphics system   TWbox  ..............................  A window box (box with 3-D effects)   TWebFile  ...........................  A ROOT file that reads via a http server   TXTRU  ..............................  TXTRU shape   WindowAttributes_t  .................           Last update: Fri Aug 29 13:46:45 2003           ROOT page  -  Home page  -  Class index  -  Top of the page          This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to  ROOT support , or contact  the developers  with any questions or problems regarding ROOT."
GX042-89-1756435	"Journal Archiving and Interchange DTD Tag Library 1.0            Digital Archive of Journal Articles               National Center for Biotechnology Information (NCBI)               National Library of Medicine (NLM)                                      <disp-formula>            Formula, Display                            Definition            A mathematical equation, expression, or formula that is to be                    displayed as a block (callout) within the narrative flow. This is not a “formula” in the strict mathematical sense             but can be used for any mathematical expression.                                      Remarks            This element may contain the actual characters that make up an equation or formula, or a graphic that contains the formula.             Thus, the mathematics can be expressed as ASCII characters, MathML or TeX expressions, or as a graphic or series of graphics.                      A display equation may numbered, using automatic numbering or                    storing the number in a  <label>  and a title                     <title> .                                      Attribute            id   Identifier                            Related Elements            For a mathematical equation, expression, or formula that is to                    displayed inline with the text, use the                     Formula, Inline  element.                                      Model Description            Any combination of:                               Text, numbers, or special characters                  Alternate Text Name (For a Figure, Etc.)   <alt-text>                  External Link   <ext-link>                  Long Description   <long-desc>                  Line Break   <break>                  All the emphasis elements:                                           Bold   <bold>                        Italic   <italic>                        Monospace Text (Typewriter Text)   <monospace>                        Overline   <overline>                        Overline Start   <overline-start>                        Overline End   <overline-end>                        Small Caps   <sc>                        Strike Through   <strike>                        Underline   <underline>                        Underline Start   <underline-start>                        Underline End   <underline-end>                                                       Graphic, Inline   <inline-graphic>                  Private Character (Custom or Unicode)   <private-char>                  Label (Of a Figure, Reference, Etc.)   <label>                  Tex Math Equation   <tex-math>                  Math (MathML 2.0 DTD)   <mml:math>                  Array (Simple Tabular Array)   <array>                  Chemical Structure (Display)   <chem-struct>                  Graphic   <graphic>                  Preformatted Text   <preformat>                  Subscript   <sub>                  Superscript   <sup>                                                     Tagged Example            ... <p>...Selected as described for Acc-29  <disp-formula> <tex-math id=""M1"">\documentclass[12pt]{minimal} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \DeclareFontFamily{T1}{linotext}{} \DeclareFontShape{T1}{linotext}{m}{n} { &#x003C;-&#x003E; linotext }{} \DeclareSymbolFont{linotext}{T1}{linotext}{m}{n} \DeclareSymbolFontAlphabet{\mathLINOTEXT}{linotext} \begin{document} $$ {\mathrm{Acc/Acc:\hspace{.5em}}}\frac{{\mathit{ade2-202}}}{{\mathit{ADE2}}}\ hspace{.5em}\frac{{\mathit{ura3-59}}}{{\mathit{ura3-59}}}\hspace{.5em}\frac{{\ mathit{ADE1}}}{{\mathit{adel-201}}}\hspace{.5em}\frac{{\mathit{ter1-Acc}}}{{\ mathit{ter1-Acc}}}\hspace{.5em}\frac{{\mathit{MATa}}}{{\mathit{MAT{\alpha}}}} $$ \end{document} </tex-math> </disp-formula>  TER1/ter1-Acc: Acc-29 crossed with ...</p>...                                   Module            math.ent                            Journal Archiving and Interchange DTD Tag Library 1.0 March 31, 2003"
GX042-16-3467315	[   Previous Article   |  Book Contents  |  Library Home  |  Legal  |  Search  ]      Communications Technical Reference, Volume 1       Data Link Provider Interface (DLPI)    DL_ATTACH_REQ Primitive   DL_BIND_ACK Primitive   DL_BIND_REQ Primitive   DL_CONNECT_CON Primitive   DL_CONNECT_IND Primitive   DL_CONNECT_REQ Primitive   DL_CONNECT_RES Primitive   DL_DATA_IND Primitive   DL_DATA_REQ Primitive   DL_DETACH_REQ Primitive   DL_DISABMULTI_REQ Primitive   DL_DISCONNECT_IND Primitive   DL_DISCONNECT_REQ Primitive   DL_ENABMULTI_REQ Primitive   DL_ERROR_ACK Primitive   DL_GET_STATISTICS_REQ Primitive   DL_GET_STATISTICS_ACK Primitive   DL_INFO_ACK Primitive   DL_INFO_REQ Primitive   DL_OK_ACK Primitive   DL_PHYS_ADDR_REQ Primitive   DL_PHYS_ADDR_ACK Primitive   DL_PROMISCOFF_REQ Primitive   DL_PROMISCON_REQ Primitive   DL_RESET_CON Primitive   DL_RESET_IND Primitive   DL_RESET_REQ Primitive   DL_RESET_RES Primitive   DL_SUBS_BIND_ACK Primitive   DL_SUBS_BIND_REQ Primitive   DL_SUBS_UNBIND_REQ Primitive   DL_TEST_CON Primitive   DL_TEST_IND Primitive   DL_TEST_REQ Primitive   DL_TEST_RES Primitive   DL_TOKEN_ACK Primitive   DL_TOKEN_REQ Primitive   DL_UDERROR_IND Primitive   DL_UNBIND_REQ Primitive   DL_UNITDATA_IND Primitive   DL_UNITDATA_REQ Primitive   DL_XID_CON Primitive   DL_XID_IND Primitive   DL_XID_REQ Primitive   DL_XID_RES Primitive  [   Previous Article   |  Book Contents  |  Library Home  |  Legal  |  Search  ]
GX126-77-15193647	"~  [   source navigation   ]  ~  [   diff markup   ]  ~  [   identifier search   ]  ~  [   freetext search   ]  ~  [   file search   ]  ~        D0 Code        * Comprehensively cross-referenced and searchable code browser *        Produced by        Linux          Cross Reference                Version:     ~  [   development   ]  ~              This release created / updated: Fri Dec 26 02:35:43 CST 2003            <Code Browser> Top of source tree        1  #!/usr/bin/env python    2  PRINTME = """"""    3  ## -----------------------------------------------------------------------------    4  ##     5  ## Authors:  Elizabeth Gallas.  suggestions from Terry Toole    6  ## Purpose:  Output a list of Run Numbers (and other Run related information) for    7  ##           Input option 1: Trigger List Name and/or Version OR    8  ##           Input option 2: Trigger Name and/or Version OR    9  ##           Input option 3: Level (1, 2, or 3) Script Name and/or Version.   10  ##   11  ## date of origin:  January 7, 2003   12  ## last modified:   September 9, 2003   13  ##   14  ## Ultimate goal: make cross section vs time plots   15  ##                for particular triggers or particular level scripts   16  ## Goal of this module: develop and test the functions:   17  ##     ListOfRunsByTriggerList and   18  ##     ListOfRunsByTrigger and   19  ##     ListOfRunsByScript.   20  ##     These functions use function GetRunsByTLTN.   21  ## These functions query the Trigger and Run Summary Databases   22  ##     to get the list of Runs and Triggers which utilize a particular   23  ##     trigger or script name and/or version.   24  ## The above functions return a list of dictionaries, one for each   25  ##     matching trigger in each run in run number order, then trigger order.   26  ## Each Run dictionary (in the output list) contains   27  ##     values for the following keys (Dictionary key names are based on   28  ##     the column names in the relevent database application).   29  ##   30  ## List of keys         - descriptions   31  ##  *  RUN_NUMBER       - Run number   32  ##  *  START_TIME       - Start date and time of run in format:   33  ##  *  DURATION         - a derived quantity (START_TIME-END_TIME) in hours   34  ##  *  STORE            - Accelerator Store number   35  ##  *  PRESCNAME        - prescale file name for the Run   36  ##  *  TRIG_CONFIG_NAME - area and file name in configuration path (Runs Db)   37  ##  *  TRIG_CONFIG_VERS - configuration version as a string        (Runs Db)   38  ##     BIT_NUM          - Trigger bit number assignment   39  ##     BIT_NAME         - Trigger bit name   40  ##     L2_BIT_NUM       - Level 2 bit number assignment   41  ##     L2_BIT_NAME      - Level 2 bit name   42  ##     L1_BIT_NUM       - Level 1 bit number assignment   43  ##     L1_BIT_NAME      - Level 1 bit name   44  ##     L1_PRESCALE      - Level 1 prescale (WHERE TRG_TYPE='L1bit')   45  ##     EG_NUM           - Exposure group number   46  ##  *  TL_NAME          - trigger list name    (Trigger Database)   47  ##  *  TL_VERSION       - trigger list version (Trigger Database)   48  ##     TN_NAME          - trigger name         (Trigger Database)   49  ##     TN_VERSION       - trigger version      (Trigger Database)   50  ##   51  ## Functionality - the output depends on the input:   52  ## Mode 1 Input:  -tlname and/or -tlversion   53  ##                 (trigger list name/version, case insensitive, wildcards allowed)   54  ##        Output:  if a unique trigger list name is found:   55  ##                   list of dictionaries (above keys with *) for Runs   56  ##                   using that trigger list   57  ##                 if more than one unique trigger list names is found:   58  ##                   list of candidates is printed   59  ## Mode 2 Input:  -tnname and/or -tnversion   60  ##                 (trigger name/version, case insensitive, % wildcards allowed)   61  ##        Output:  list of dictionaries (above) for Runs using that trigger   62  ## Mode 3 Input:  -l1sname or -l2sname or -l3sname   63  ##                 (level script name, case insensitive, % wildcards allowed)   64  ##        Output:  list of dictionaries (above) for Runs using that level script   65  ## Mode 4 Input:   -Run (a Run number)   66  ##        Output:  For that Run, prints the trigger list name/version and a table   67  ##                 of trigger and l1script names in that list in index order   68  ##   69  ## EXAMPLES !!!   70  ##   GetRuns.py -tnname EMHI_TK -file - finds 3 runs using this trigger   71  ##   72  ##   GetRuns.py -l1sname 'CEM(1,10)' - finds runs having triggers with this l1 script   73  ##    74  ##   GetRuns.py -tlname global_cmt   - finds runs using trigger list name global_CMT   75  ##   GetRuns.py -tlversion 10        - finds runs using trigger list version = 10.00   76  ##   77  ##   GetRuns.py -tlname global_c%   - prints all trigger list names found    78  ##   GetRuns.py -tlversion 1        - prints all tlnames with tlversion = 1   79  ##   GetRuns.py -Run 180888         - prints the list name/version and a table   80  ##                                    of trigger and l1script names in that list   81  ##   82  ## Other optional input: -file   (writes output to a file)   83  ##                       -header (do NOT include a header in the output)   84  ##                       -debug  (run in DEBUG='yes' mode, printing out progress)   85  ## -----------------------------------------------------------------------------""""""   86  import dcoracle, sys, string, os   87  from time import gmtime,strftime,localtime   88     89  ################################   90  ################################   91  class GetStuff_params:   92    def __init__(self):   93      self.set_debug(0)   94     95      self.set_tnname("""")   96      self.set_tnversion(0)   97     98      self.set_slevel(""L1"")   99      self.set_sname("""")  100      self.set_sversion(0)  101    102      self.set_tlname("""")  103      self.set_tlversion(0.0)  104      self.set_run_number(0)  105    106      self.set_outputfile(""no"")  107      self.set_header(""yes"")  108      self.set_interactive(0)  109    110    #debug  111    def set_debug(self, value):  112      self.the_debug = value  113      return  114    def debug(self):  115      return self.the_debug  116    117    # trigger script level  118    def set_slevel(self, value):  119      self.the_slevel = value  120      return  121    def slevel(self):  122      return self.the_slevel  123    124    # script name  125    def set_sname(self, value):  126      self.the_sname = value  127      return  128    def sname(self):  129      return self.the_sname  130    131    # script version  132    def set_sversion(self, value):  133      self.the_sversion = value  134      return  135    def sversion(self):  136      return self.the_sversion  137    138    # trigger name  139    def set_tnname(self, value):  140      self.the_tnname = value  141      return  142    def tnname(self):  143      return self.the_tnname  144    145    # trigger name version  146    def set_tnversion(self, value):  147      self.the_tnversion = value  148      return  149    def tnversion(self):  150      return self.the_tnversion  151    152    #trigger list name  153    def set_tlname(self, value):  154      self.the_tlname = value  155      return  156    def tlname(self):  157      return self.the_tlname  158    159    #trigger list version  160    def set_tlversion(self, value):  161      self.the_tlversion = value  162      return  163    def tlversion(self):  164      return self.the_tlversion  165    166    #run number  167    def set_run_number(self, value):  168      self.the_run_number = value  169      return  170    def run_number(self):  171      return self.the_run_number  172    173    #file  174    def set_outputfile(self, value):  175      self.the_file = value  176      return  177    def outputfile(self):  178      return self.the_file  179    180    #header  181    def set_header(self, value):  182      self.the_header = value  183      return  184    def header(self):  185      return self.the_header  186    187    #interactive  188    def set_interactive(self, value):  189      self.the_interactive = value  190      return  191    def interactive(self):  192      return self.the_interactive  193  #########################################################  194  ########################################################  195    196  ## programs to run: set to 'no' unless they appear in the arg list  197  ## print a list of Stuff (listed above) about a trigger used in runs  198    199  ## put 30 spaces in SPACE30 for formatting output, there's probably a better way  200  global SPACE30  201  SPACE30 = '                              '  202    203  ## global ALL_XML_PARAMS  204  ALL_XML_PARAMS = ''  205    206  class Sqlbase:  207    def __init__ (self, dbc):  208      self.__dbc = dbc  209      self.__cursor = dbc.cursor()  210      return  211    212    def dbc (self):  213      return self.__dbc  214    215    def sql (self, sqlexpr, args = ()):  216      self.__cursor.execute (sqlexpr, args)  217      return self.__cursor.fetchall ()  218      219  ## -----------------------------------------------------------------------------  220  ## -----------------------------------------------------------------------------  221  def ListOfRunsByTriggerList(p):  222    """"""Return a list (by Run number) of dictionaries (with various Run properties)  223    for all Runs that have an official trigger uniquely matching the input  224    trigger list name and/or version.  225    Also return a list containing informational messages  226    and a list containing error messages (reason why no runs could be found.)""""""  227    228  ## initialize output: list of dictionaries in run order  229    RunsListDict = []  230    OutInfo  = []  231    OutError = []  232    233  ## make the database connection  234    try:  235      dbname = ""d0read/reader@d0ofprd1""  236      DbConn = dcoracle.Connect(dbname)  237      base = Sqlbase(DbConn)  238    except:  239      print """"  240      db = dbname[string.find(dbname,'@'):]  241      OutError.append(""""""Unable to connect to database %s."""""" % db)  242      return RunsListDict,OutInfo,OutError  243    244  ## determine the unique mixed case trigger list name  245    OutInfo.append(""""""\n  246  ################################################################################  247  ## TASK:  finding Unique Trigger List Name ...   248  ################################################################################  249  """""")  250    251  ## query for a single distinct trigger list name matching the input criteria  252  ## if no match is found, try a case insenitive search, then wildcard searches...  253    254  ## trigger list name and version:  255    if p.tlname()!='' and p.tlversion()!=0.:  256      for sqlquery in [\  257      """"""SELECT TL_NAME,TL_VERSION FROM TRIGGER_LISTS WHERE TL_NAME =    '%s'  258      """""" % p.tlname(),\  259      """"""SELECT TL_NAME,TL_VERSION FROM TRIGGER_LISTS WHERE TL_NAME like '%s'  260      """""" % p.tlname(),\  261      """"""SELECT TL_NAME,TL_VERSION FROM TRIGGER_LISTS WHERE upper(TL_NAME)='%s'  262      """""" % string.upper(p.tlname()),\  263      """"""SELECT TL_NAME,TL_VERSION FROM TRIGGER_LISTS WHERE upper(TL_NAME) like '%s'  264      """""" % string.upper(p.tlname()),\  265      """"""SELECT TL_NAME,TL_VERSION FROM TRIGGER_LISTS WHERE upper(TL_NAME) like '%s'  266      """""" % ('%'+string.upper(p.tlname())),\  267      """"""SELECT TL_NAME,TL_VERSION FROM TRIGGER_LISTS WHERE upper(TL_NAME) like '%s'  268      """""" % (string.upper(p.tlname())+'%'),\  269      """"""SELECT TL_NAME,TL_VERSION FROM TRIGGER_LISTS WHERE upper(TL_NAME) like '%s'  270      """""" % ('%'+string.upper(p.tlname())+'%')]:  271        sqlquery = sqlquery + "" AND TL_VERSION = %3.2f "" % p.tlversion()  272        triggerLists = base.sql(sqlquery)  273        if len(triggerLists)>=1:  274          break  275  ## name but no version  276    elif p.tlname()!='' and p.tlversion()==0.:  277      for sqlquery in [\  278      """"""SELECT UNIQUE TL_NAME,0. FROM TRIGGER_LISTS WHERE TL_NAME =    '%s'  279      """""" % p.tlname(),\  280      """"""SELECT UNIQUE TL_NAME,0. FROM TRIGGER_LISTS WHERE TL_NAME like '%s'  281      """""" % p.tlname(),\  282      """"""SELECT UNIQUE TL_NAME,0. FROM TRIGGER_LISTS WHERE upper(TL_NAME)='%s'  283      """""" % string.upper(p.tlname()),\  284      """"""SELECT UNIQUE TL_NAME,0. FROM TRIGGER_LISTS WHERE upper(TL_NAME) like '%s'  285      """""" % string.upper(p.tlname()),\  286      """"""SELECT UNIQUE TL_NAME,0. FROM TRIGGER_LISTS WHERE upper(TL_NAME) like '%s'  287      """""" % ('%'+string.upper(p.tlname())),\  288      """"""SELECT UNIQUE TL_NAME,0. FROM TRIGGER_LISTS WHERE upper(TL_NAME) like '%s'  289      """""" % (string.upper(p.tlname())+'%'),\  290      """"""SELECT UNIQUE TL_NAME,0. FROM TRIGGER_LISTS WHERE upper(TL_NAME) like '%s'  291      """""" % ('%'+string.upper(p.tlname())+'%')]:  292        triggerLists = base.sql(sqlquery)  293        if len(triggerLists)>=1:  294          break  295  ## version with no name  296    elif p.tlname()=='' and p.tlversion()!=0.:  297      sqlquery = """"""SELECT TL_NAME,TL_VERSION FROM TRIGGER_LISTS WHERE  298                    TL_VERSION = %3.2f """""" % p.tlversion()  299      triggerLists = base.sql(sqlquery)  300  ## no name or version - get all the names (but no versions)  301    else:  302      sqlquery = """"""SELECT UNIQUE TL_NAME,0. FROM TRIGGER_LISTS""""""  303      triggerLists = base.sql(sqlquery)  304    305  ## assess whether to continue based on the number of elements found --------------  306    307    printme = """"""Trigger List Name/Version = %s / %d """""" % (p.tlname(),p.tlversion())  308    309  ## in debug mode, print the sql query:  310    if p.debug()==1:  311      print """"""## sqlquery statement for %s is:\n## %s"""""" % (printme,sqlquery)  312      print """"""%d Trigger Lists matched the input criteria %s """""" % \  313            (len(triggerLists),printme)  314    315  ## if no names found, then return an error message  316    if len(triggerLists)<1:  317      OutError.append(""""""No triggerlists found matching input %s !!"""""" % printme)  318      OutInfo.append(""""""No triggerlists found matching input %s !!"""""" % printme)  319      return RunsListDict,OutInfo,OutError  320    321  ## if there are too many trigger name matches, then return the list of names  322    if len(triggerLists)>1:  323      OutError.append(""""""Too many triggerlists matched input %s !!"""""" % printme)  324      for name,version in triggerLists:  325        if version != 0.:  326          OutError.append(""""""\t%s"""""" % (name))  327        else:  328          OutError.append(""""""\t%s / %d """""" % (name,version))  329      return RunsListDict,OutInfo,OutError  330    331  ## set the name to the returned unique name:  332    p.set_tlname(triggerLists[0][0])  333    if p.tlversion()!=0. or len(triggerLists)==1:  334      p.set_tlversion(triggerLists[0][1])  335    else:  336      p.set_tlversion(0.)  337    338    printme = """"""Trigger List Name/Version = %s / %3.2f """""" % (p.tlname(),p.tlversion())  339    OutInfo.append(""""""\nGOOD:  Found Unique %s\n"""""" % printme)  340    341  ## if there are trigger name matches, then return the list of names  342    if len(triggerLists)>=1:  343      OutInfo.append(\  344        """"""\nResults:  These (%d) Trigger Lists matched the input criteria:  345        %s """""" % \  346        (len(triggerLists),printme))  347      OutInfo.append(\  348        """"""\n%-30s %-5s """""" % \  349        (""Trigger List"","" TLV ""))  350      OutInfo.append(\  351        """"""\n%-30s %-5s """""" % \  352        (""------------"",""-----""))  353      for tl_name,tl_version in triggerLists:  354        OutInfo.append(""""""\n%-30s %5.2f """""" % \  355                       (tl_name,tl_version))  356    357  ## now get the runs that used those trigger lists:  358    359    RunsListDict,Info,Errors = GetRunsByTL(base,triggerLists,printme, p)  360    if Info!=[]:  361      for info in Info:  362        OutInfo.append(info)  363    if Errors!=[]:  364      for error in Errors:  365        OutError.append(error)  366      367  ## close the db connection  368    DbConn.close()  369     370    return RunsListDict,OutInfo,OutError  371  ## -----------------------------------------------------------------------------  372  ## -----------------------------------------------------------------------------  373  def GetRunsByTL(base,triggerLists,printme, p):  374    """"""Fill the output list of Dictionaries for each Run_Trigs record that has  375    a trigger list name/version in the input tuple.""""""  376  ## initialize output  377    RunsListDict = []  378    OutInfo      = []  379    OutError     = []  380  ##   381    OutInfo.append(""""""\n  382  ################################################################################  383  ## TASK:  finding all Runs that use Trigger Lists ...   384  ################################################################################  385  """""")  386      387    sql_sel   = """"""SELECT RUN_NUMBER,TO_CHAR(START_TIME,'YYYY-MON-DD HH24:MI'),  388                   TO_CHAR(((END_TIME-START_TIME)*24),'9999.99'),  389                   STORE, PRESCNAME, RECORDING,  390                   TRIG_CONFIG_NAME, TRIG_CONFIG_VERS  391                   FROM RUNS.RUNS rn   392                   WHERE """"""  393  ## add a STORE number requirement  394    sql_sel = sql_sel + """""" (STORE IS NOT NULL) """"""  395  ## add the recording requirement   396    sql_sel = sql_sel + "" AND (RECORDING='1' or RECORDING IS NULL) ""  397  ## to look for runs with no recording  398  ##sql_sel = sql_sel + "" AND (RECORDING='0') ""  399    400  ## define a dictionary to store the trigger name versions   401    tvDict = {}  402  ## add to the WHERE clause in a   403  ## loop over trigger lists/trigger name combinations to select those triggers  404    sql_where = """"  405    for tl_name,tl_version in triggerLists:  406    407      if sql_where != """":  408        sql_where = sql_where + """""" OR """"""  409      if tl_version!=0.:  410        sql_where = sql_where + """"""  411        (TRIG_CONFIG_NAME LIKE %s AND TRIG_CONFIG_VERS = %3.2f)"""""" % \  412        (""'official%s/%s'"" % ('%',tl_name),tl_version)  413    414      else:  415        sql_where = sql_where + """"""  416        (TRIG_CONFIG_NAME LIKE %s)"""""" % (""'official%s/%s'"" % ('%',tl_name))  417    418  ## order by run number  419    sql_order = ' ORDER BY RUN_NUMBER '  420    421    sqlquery = sql_sel + "" AND ("" + sql_where + "")"" + sql_order  422    423    try:  424      triggerRuns = base.sql(sqlquery)  425    except:  426      OutError.append(""""""## sqlquery statement is:\n## %s"""""" % sqlquery)  427      OutError.append(""""""Error getting runs for trigger lists """""")  428      for syserrors in sys.exc_info():  429        OutError.append(syserrors)  430      OutError.append('Unable to proceed.  Stopping execution.\n\n')  431      return RunsListDict,OutInfo,OutError  432    433    if p.debug()==1:  434      print """"""## sqlquery statement is:\n## %s"""""" % sqlquery  435      print """"""%d Runs contained trigger lists matching the input criteria %s """""" % \  436            (len(triggerRuns),printme)  437    438  ## if no runs found, then return an error message  439    if len(triggerRuns)<1:  440      OutError.append('\nNo runs found matching input %s \n' % printme)  441      OutInfo.append('\nNo runs found matching input %s \n' % printme)  442      return RunsListDict,OutInfo,OutError  443    444  ## if there are trigger list matches,  445  ## then put the headers for the list in the OutInfo list  446    if len(triggerRuns)>=1:  447      OutInfo.append(\  448        """"""\nResults:  These %d Official Runs contained trigger lists with %s\n"""""" % \  449                     (len(triggerRuns),printme))  450    451      OutInfo.append(\  452        """"""\n%-10s %-17s %-8s %-5s %-9s %-9s %-24s %-20s """""" % \  453        (""RUN_NUMBER"",""START_TIME"",""DURATION"",""STORE"",""PRESCNAME"",""RECORDING"",\  454         ""TRIG_CONFIG_(NAME)(VERS)"",""TL_(NAME)-(VERSION)""))  455    456      OutInfo.append(\  457        """"""\n%-10s %-17s %-8s %-5s %-9s %-9s %-24s %-20s """""" % \  458        (""----------"",""----------"",""--------"",""-----"",""---------"",""---------"",\  459         ""------------------------"",""-------------------""))  460        461  ## Loop over all the runs, do more queries to Load the list of dictionaries:  462        463    for RUN_NUMBER,START_TIME,DURATION,STORE,PRESCNAME,RECORDING,\  464        TRIG_CONFIG_NAME,TRIG_CONFIG_VERS in triggerRuns:  465    466  ## get the trigger version from tvDict stored from  Trigger DB:  467      for names in string.split(TRIG_CONFIG_NAME,'/'):  468        tl_name = names  469    470  ## fill the dictionary for this run  471          472      ADict = {'RUN_NUMBER':str(RUN_NUMBER),\  473               'START_TIME':START_TIME,\  474               'DURATION':DURATION,\  475               'STORE':str(STORE),\  476               'PRESCNAME':PRESCNAME,\  477               'RECORDING':RECORDING,\  478               'TRIG_CONFIG_NAME':TRIG_CONFIG_NAME,\  479               'TRIG_CONFIG_VERS':TRIG_CONFIG_VERS,\  480               'TL_NAME':tl_name,\  481               'TL_VERSION':TRIG_CONFIG_VERS\  482               }  483  ## add this run to the output list of dictionaries  484      RunsListDict.append(ADict)  485  ## add this run to the OutInfo list  486      try:  487        OutInfo.append(\  488          """"""\n%-10s %-17s %-8s %-5s %-9s %-5s %-28s %-20s """""" % \  489          (str(RUN_NUMBER),START_TIME,DURATION,str(STORE),PRESCNAME,RECORDING,\  490           TRIG_CONFIG_NAME+'-'+TRIG_CONFIG_VERS,tl_name+'-'+TRIG_CONFIG_VERS))  491      except:  492        OutInfo.append(""I'm having printing problems for this Run"")  493        OutInfo.append(str(RUN_NUMBER))  494        break  495    496  ## add the contents of the dictionary for the first run found to the OutList  497    if RunsListDict != []:  498      OutInfo.append('\nHere is the contents of the output dictionary for the first Run found:')  499      for key in RunsListDict[0].keys():  500        OutInfo.append(""""""\nKey name %-20s has value '%s' """""" % (key,RunsListDict[0][key]))  501        502    return RunsListDict,OutInfo,OutError  503    504  ## -----------------------------------------------------------------------------  505  ## -----------------------------------------------------------------------------  506  def ListOfRunsByScript(p):  507    """"""Return a list (by Run number) of dictionaries (with various Run properties)  508    for all Runs that have an official trigger having a script matching the input  509    script name and/or version.  510    Also return a list containing informational messages  511    and a list containing error messages (reason why no runs could be found.)""""""  512    513  ## initialize output: list of dictionaries in run order  514    RunsListDict = []  515    OutInfo  = []  516    OutError = []  517    518  ## make the database connection  519    try:  520      dbname = ""d0read/reader@d0ofprd1""  521      DbConn = dcoracle.Connect(dbname)  522      base = Sqlbase(DbConn)  523    except:  524      print """"  525      db = dbname[string.find(dbname,'@'):]  526      OutError.append(""""""Unable to connect to database %s."""""" % db)  527      return RunsListDict,OutInfo,OutError  528    529  ## determine the unique mixed case trigger name  530    OutInfo.append(""""""\n  531  ################################################################################  532  ## TASK:  finding Unique Script Name ...   533  ################################################################################  534  """""")  535    536  ## query for a single distinct script name matching the input criteria  537  ## if no match is found, try a case insenitive search, then wildcard searches...  538  ## script name  539    540  ## name and version:  541    if p.sname()!='' and p.sversion()!=0:  542      for sqlquery in [\  543      """"""SELECT S_NAME,S_VERSION FROM %s_SCRIPTS WHERE S_NAME =    '%s'  544      """""" % (p.slevel(),p.sname()),\  545      """"""SELECT S_NAME,S_VERSION FROM %s_SCRIPTS WHERE S_NAME like '%s'  546      """""" % (p.slevel(),p.sname()),\  547      """"""SELECT S_NAME,S_VERSION FROM %s_SCRIPTS WHERE upper(S_NAME)='%s'  548      """""" % (p.slevel(),string.upper(p.sname())),\  549      """"""SELECT S_NAME,S_VERSION FROM %s_SCRIPTS WHERE upper(S_NAME) like '%s'  550      """""" % (p.slevel(),string.upper(p.sname())),\  551      """"""SELECT S_NAME,S_VERSION FROM %s_SCRIPTS WHERE upper(S_NAME) like '%s'  552      """""" % (p.slevel(),('%'+string.upper(p.sname()))),\  553      """"""SELECT S_NAME,S_VERSION FROM %s_SCRIPTS WHERE upper(S_NAME) like '%s'  554      """""" % (p.slevel(),(string.upper(p.sname())+'%')),\  555      """"""SELECT S_NAME,S_VERSION FROM %s_SCRIPTS WHERE upper(S_NAME) like '%s'  556      """""" % (p.slevel(),('%'+string.upper(p.sname())+'%'))]:  557        sqlquery = sqlquery + "" AND S_VERSION = %d "" % p.sversion()  558        scriptNames = base.sql(sqlquery)  559        if len(scriptNames)>=1:  560          break  561  ## name but no version  562    elif p.sname()!='' and p.sversion()==0:  563      for sqlquery in [\  564      """"""SELECT UNIQUE S_NAME,0 FROM %s_SCRIPTS WHERE S_NAME =    '%s'  565      """""" % (p.slevel(),p.sname()),\  566      """"""SELECT UNIQUE S_NAME,0 FROM %s_SCRIPTS WHERE S_NAME like '%s'  567      """""" % (p.slevel(),p.sname()),\  568      """"""SELECT UNIQUE S_NAME,0 FROM %s_SCRIPTS WHERE upper(S_NAME)='%s'  569      """""" % (p.slevel(),string.upper(p.sname())),\  570      """"""SELECT UNIQUE S_NAME,0 FROM %s_SCRIPTS WHERE upper(S_NAME) like '%s'  571      """""" % (p.slevel(),string.upper(p.sname())),\  572      """"""SELECT UNIQUE S_NAME,0 FROM %s_SCRIPTS WHERE upper(S_NAME) like '%s'  573      """""" % (p.slevel(),('%'+string.upper(p.sname()))),\  574      """"""SELECT UNIQUE S_NAME,0 FROM %s_SCRIPTS WHERE upper(S_NAME) like '%s'  575      """""" % (p.slevel(),(string.upper(p.sname())+'%')),\  576      """"""SELECT UNIQUE S_NAME,0 FROM %s_SCRIPTS WHERE upper(S_NAME) like '%s'  577      """""" % (p.slevel(),('%'+string.upper(p.sname())+'%'))]:  578        scriptNames = base.sql(sqlquery)  579        if len(scriptNames)>=1:  580          break  581  ## version with no name  582    elif p.sname()=='' and p.sversion()!=0:  583      sqlquery = """"""SELECT S_NAME,S_VERSION FROM %s_SCRIPTS WHERE  584                    S_VERSION = %d """""" % (p.slevel(),p.sversion())  585      scriptNames = base.sql(sqlquery)  586  ## if no name or version - get all names (no versions)  587    else:  588      sqlquery = """"""SELECT UNIQUE S_NAME,0 FROM %s_SCRIPTS""""""  589      scriptNames = base.sql(sqlquery)  590    591  ## assess whether to continue based on the number of elements found --------------  592    593    printme = """"""Script Name/Version = %s / %d """""" % (p.sname(),p.sversion())  594    595  ## in debug mode, print the sql query:  596    if p.debug()==1:  597      print """"""## sqlquery statement for %s is:\n## %s"""""" % (printme,sqlquery)  598      print """"""%d Scripts matched the input criteria %s """""" % \  599            (len(scriptNames),printme)  600    601  ## if no names found, then return an error message  602    if len(scriptNames)<1:  603      OutError.append(""""""No scripts found matching input %s !!"""""" % printme)  604      OutInfo.append(""""""No scripts found matching input %s !!"""""" % printme)  605      return RunsListDict,OutInfo,OutError  606              607  ## if there are too many script name matches, then return the list of names  608    if len(scriptNames)>1:  609      OutError.append(""""""Too many (%d) scripts matched input %s !!"""""" % \  610                      (len(scriptNames),printme))  611      for name,version in scriptNames:  612        if version != 0:  613          OutError.append(""""""\t%s"""""" % (name))  614        else:  615          OutError.append(""""""\t%s / %d """""" % (name,version))  616      return RunsListDict,OutInfo,OutError  617    618  ## set the name to the returned unique name:  619    p.set_sname(scriptNames[0][0])  620    if p.sversion()!=0:  621      p.set_sversion(scriptNames[0][1])  622    else:  623      p.set_sversion(0)  624    625    printme = """"""Script Name/Version = %s / %d """""" % (p.sname(),p.sversion())  626    OutInfo.append(""""""\nGOOD:  Found Unique %s\n"""""" % printme)  627    628  ## Get a list of triggers containing this script name ----------------------  629  ##    using the script version criteria ONLY if the version is not 0  630      631    OutInfo.append(""""""  632  ################################################################################  633  ## TASK:  finding all Trigger Names containing this Script Name ...   634  ################################################################################  635  """""")  636    637    sql_sel   = """"""SELECT NAME,VERSION,%sS_NAME,%sS_VERSION FROM TRIGGER_NAMES"""""" \  638                   % (p.slevel(),p.slevel())  639    sql_where = """"""  640                   WHERE %sS_NAME='%s'"""""" % (p.slevel(),p.sname())  641    if p.sversion() != 0:  642      sql_where = sql_where + """""" AND %sS_VERSION=%d"""""" % (p.slevel(),p.sversion())  643    sql_order = """"""  644                   ORDER BY NAME,VERSION,%sS_NAME,%sS_VERSION"""""" \  645                   % (p.slevel(),p.slevel())  646    647    sqlquery = sql_sel + sql_where + sql_order  648      649  ## in debug mode, print the sql query:  650    if p.debug()==1:  651      print """"""## sqlquery statement for %s is:\n## %s"""""" % (printme,sqlquery)  652    653  ## get the records  654    triggerNames = base.sql(sqlquery)  655    656  ## in debug mode, print the number of records  657    if p.debug()==1:  658      print """"""%d Triggers matched the input criteria %s """""" % \  659            (len(triggerNames),printme)  660    661  ## if no triggers found, then return an error message  662    if len(triggerNames)<1:  663      OutError.append('Hmmm. No triggers found with %s %s !!' % \  664                      (p.slevel(),p.sname()))  665      return RunsListDict,OutInfo,OutError  666              667  ## if there are trigger name matches, then return the list of names in Info  668    tsDict = {}  669    if len(triggerNames)>=1:  670      OutInfo.append(""""""\nResults:  The following %d Triggers contained %s  671      """""" % (len(triggerNames),printme))  672      OutInfo.append(""""""\n%-30s %-5s %-20s %-3s """""" % \  673                     (""Trigger Name"","" TNV "",""Script Name "",""SNV""))  674      OutInfo.append(""""""\n%-30s %-5s %-20s %-3s """""" % \  675                     (""------------"",""-----"",""------------"",""---""))  676      for name,version,sname,sversion in triggerNames:  677        OutInfo.append(""""""\n%-30s %5d  %-20s %-3d"""""" % \  678                       (name,version,sname,sversion))  679    680        ## add to the dictionary containing trigger version numbers  681        tsDict['%s^%d' % (name,version)] = sversion  682    683  ## Get a list of trigger lists containing any of these trigger name/versions -----  684    685    OutInfo.append(""""""  686  ################################################################################  687  ## TASK:  finding all Trigger Lists containing these Trigger Names ...   688  ################################################################################  689  """""")  690    691    sql_sel   = """"""SELECT TL_NAME,TL_VERSION,NAME,VERSION FROM TL_MAPS""""""  692    sql_where = """"""  693                   WHERE (""""""  694    for name,version,sname,sversion in triggerNames:  695      if sql_where != """"""  696                   WHERE ("""""":  697        sql_where = sql_where + """"""  698        OR """"""  699      sql_where = sql_where + """""" (NAME='%s' AND VERSION=%d)"""""" % (name,version)  700    sql_where = sql_where + ')'  701    sql_order = """"""  702                   ORDER BY TL_NAME,TL_VERSION,NAME,VERSION""""""  703    704    sqlquery = sql_sel + sql_where + sql_order  705    706  ## in debug mode, print the sql query:  707    if p.debug()==1:  708      print """"""## sqlquery statement for %s is:\n## %s"""""" % (printme,sqlquery)  709    710  ## get the records  711    triggerLists = base.sql(sqlquery)  712    713  ## in debug mode, print the number of records  714    if p.debug()==1:  715      print """"""%d Trigger Lists matched the input criteria %s """""" % \  716            (len(triggerLists),printme)  717    718  ## if no trigger lists found, then return an error message  719    if len(triggerLists)<1:  720      OutError.append('Hmmm. No Lists found matching input %s !!' % printme)  721      return RunsListDict,OutInfo,OutError  722              723  ## if there are trigger name matches, then return the list of names  724    if len(triggerLists)>=1:  725      OutInfo.append(\  726        """"""\nResults:  These %d Trigger Lists matched the input criteria %s """""" % \  727        (len(triggerLists),printme))  728      OutInfo.append(\  729        """"""\n%-30s %-5s %-20s %-3s """""" % \  730        (""Trigger List"","" TLV "",""Trigger Name"",""TNV""))  731      OutInfo.append(\  732        """"""\n%-30s %-5s %-20s %-3s """""" % \  733        (""------------"",""-----"",""------------"",""---""))  734      for tl_name,tl_version,name,version in triggerLists:  735        OutInfo.append(""""""\n%-30s %5.2f  %-20s %-3d"""""" % \  736                       (tl_name,tl_version,name,version))  737    738  ## now get the runs that used those trigger lists:  739    740    RunsListDict,Info,Errors = GetRunsByTLTN(base,triggerLists,printme, p)  741    if Info!=[]:  742      for info in Info:  743        OutInfo.append(info)  744    if Errors!=[]:  745      for error in Errors:  746        OutError.append(error)  747      748  ## close the db connection  749    DbConn.close()  750     751    return RunsListDict,OutInfo,OutError  752    753  ## -----------------------------------------------------------------------------  754  ## -----------------------------------------------------------------------------  755  def ListOfRunsByTrigger(p):  756    """"""Return a list (by Run number) of dictionaries (with various Run properties)  757    for all Runs that have an official trigger uniquely matching the input  758    trigger name and/or version.  759    Also return a list containing informational messages  760    and a list containing error messages (reason why no runs could be found.)""""""  761    762  ## initialize output: list of dictionaries in run order  763    RunsListDict = []  764    OutInfo  = []  765    OutError = []  766    767  ## make the database connection  768    try:  769      dbname = ""d0read/reader@d0ofprd1""  770      DbConn = dcoracle.Connect(dbname)  771      base = Sqlbase(DbConn)  772    except:  773      print """"  774      db = dbname[string.find(dbname,'@'):]  775      OutError.append(""""""Unable to connect to database %s."""""" % db)  776      return RunsListDict,OutInfo,OutError  777    778  ## determine the unique mixed case trigger name  779    OutInfo.append(""""""\n  780  ################################################################################  781  ## TASK:  finding Unique Trigger Name ...   782  ################################################################################  783  """""")  784    785  ## query for a single distinct trigger name matching the input criteria  786  ## if no match is found, try a case insenitive search, then wildcard searches...  787    788  ## name and version:  789    if p.tnname()!='' and p.tnversion()!=0:  790      for sqlquery in [\  791      """"""SELECT UNIQUE NAME,VERSION FROM TL_MAPS WHERE NAME =    '%s'  792      """""" % p.tnname(),\  793      """"""SELECT UNIQUE NAME,VERSION FROM TL_MAPS WHERE NAME like '%s'  794      """""" % p.tnname(),\  795      """"""SELECT UNIQUE NAME,VERSION FROM TL_MAPS WHERE upper(NAME)='%s'  796      """""" % string.upper(p.tnname()),\  797      """"""SELECT UNIQUE NAME,VERSION FROM TL_MAPS WHERE upper(NAME) like '%s'  798      """""" % string.upper(p.tnname()),\  799      """"""SELECT UNIQUE NAME,VERSION FROM TL_MAPS WHERE upper(NAME) like '%s'  800      """""" % ('%'+string.upper(p.tnname())),\  801      """"""SELECT UNIQUE NAME,VERSION FROM TL_MAPS WHERE upper(NAME) like '%s'  802      """""" % (string.upper(p.tnname())+'%'),\  803      """"""SELECT UNIQUE NAME,VERSION FROM TL_MAPS WHERE upper(NAME) like '%s'  804      """""" % ('%'+string.upper(p.tnname())+'%')]:  805        sqlquery = sqlquery + "" AND VERSION = %d "" % p.tnversion()  806        triggerNames = base.sql(sqlquery)  807        if len(triggerNames)>=1:  808          break  809  ## name but no version  810    elif p.tnname()!='' and p.tnversion()==0:  811      for sqlquery in [\  812      """"""SELECT UNIQUE NAME,0 FROM TL_MAPS WHERE NAME =    '%s'  813      """""" % p.tnname(),\  814      """"""SELECT UNIQUE NAME,0 FROM TL_MAPS WHERE NAME like '%s'  815      """""" % p.tnname(),\  816      """"""SELECT UNIQUE NAME,0 FROM TL_MAPS WHERE upper(NAME)='%s'  817      """""" % string.upper(p.tnname()),\  818      """"""SELECT UNIQUE NAME,0 FROM TL_MAPS WHERE upper(NAME) like '%s'  819      """""" % string.upper(p.tnname()),\  820      """"""SELECT UNIQUE NAME,0 FROM TL_MAPS WHERE upper(NAME) like '%s'  821      """""" % ('%'+string.upper(p.tnname())),\  822      """"""SELECT UNIQUE NAME,0 FROM TL_MAPS WHERE upper(NAME) like '%s'  823      """""" % (string.upper(p.tnname())+'%'),\  824      """"""SELECT UNIQUE NAME,0 FROM TL_MAPS WHERE upper(NAME) like '%s'  825      """""" % ('%'+string.upper(p.tnname())+'%')]:  826        triggerNames = base.sql(sqlquery)  827        if len(triggerNames)>=1:  828          break  829  ## version with no name  830    elif p.tnname()=='' and p.tnversion()!=0:  831      sqlquery = """"""SELECT NAME,VERSION FROM TL_MAPS WHERE  832                    VERSION = %d """""" % p.tnversion()  833      triggerNames = base.sql(sqlquery)  834  ## no name or version - get all the names (but no versions)  835    else:  836      sqlquery = """"""SELECT UNIQUE NAME,0 FROM TL_MAPS""""""  837      triggerNames = base.sql(sqlquery)  838    839  ## assess whether to continue based on the number of elements found --------------  840    841    printme = """"""Trigger Name/Version = %s / %d """""" % (p.tnname(),p.tnversion())  842    843  ## in debug mode, print the sql query:  844    if p.debug()==1:  845      print """"""## sqlquery statement for %s is:\n## %s"""""" % (printme,sqlquery)  846      print """"""%d Triggers matched the input criteria %s """""" % \  847            (len(triggerNames),printme)  848    849  ## if no names found, then return an error message  850    if len(triggerNames)<1:  851      OutError.append(""""""No triggers found matching input %s !!"""""" % printme)  852      OutInfo.append(""""""No triggers found matching input %s !!"""""" % printme)  853      return RunsListDict,OutInfo,OutError  854              855  ## if there are more than one trigger name/version matches,  856  ## return an error if the names are NOT the same OR the input version is NOT 0  857    this_tnname = triggerNames[0][0]  858    this_tnversion = triggerNames[0][1]  859    860    if len(triggerNames)>1:  861    862      for name,version in triggerNames:  863    864  ## if there are too many trigger name matches, then return the list of names  865        if name!=this_tnname:  866          OutError.append(""""""More than one trigger name matched input %s !!"""""" % \  867                          printme)  868          OutError.append(""""""\t%s"""""" % (this_tnname))  869          for name,version in triggerNames:  870            if name!=this_tnname:  871              OutError.append(""""""\t%s"""""" % (name))  872              this_tnname = name  873          return RunsListDict,OutInfo,OutError  874      875  ## if there is more than name/version returned, make input version was 0  876      if this_tnversion!=0:  877        OutError.append(""""""Too many triggers matched input %s !!"""""" % printme)  878        for name,version in triggerNames:  879          OutError.append(""""""\t%s / %d """""" % (name,version))  880        return RunsListDict,OutInfo,OutError  881    882  ## set the name to the returned unique name:  883    p.set_tnname(triggerNames[0][0])  884    if p.tnversion()!=0:  885      p.set_tnversion(triggerNames[0][1])  886    else:  887      p.set_tnversion(0)  888    889    printme = """"""Trigger Name/Version = %s / %d """""" % (p.tnname(),p.tnversion())  890    OutInfo.append(""""""\nGOOD:  Found Unique %s\n"""""" % printme)  891    892  ## Get a list of trigger lists containing this trigger name  893  ##    using the version criteria ONLY if the version is not 0  894      895    OutInfo.append(""""""  896  ################################################################################  897  ## TASK:  finding all Trigger Lists containing these Trigger Names ...   898  ################################################################################  899  """""")  900    901    sql_sel   = """"""SELECT TL_NAME,TL_VERSION,NAME,VERSION FROM TL_MAPS""""""  902    sql_where = """"""  903                   WHERE NAME='%s'"""""" % p.tnname()  904    if p.tnversion() != 0:  905      sql_where = sql_where + """""" AND VERSION=%d"""""" % p.tnversion()  906    sql_order = """"""  907                   ORDER BY TL_NAME,TL_VERSION,NAME,VERSION""""""  908    909    sqlquery = sql_sel + sql_where + sql_order  910    911    printme = """"""Trigger Name/Version = %s / %d """""" % (p.tnname(),p.tnversion())  912  ## in debug mode, print the sql query:  913    if p.debug()==1:  914      print """"""## sqlquery statement for %s is:\n## %s"""""" % (printme,sqlquery)  915    916  ## get the records  917    triggerLists = base.sql(sqlquery)  918    919  ## in debug mode, print the number of records  920    if p.debug()==1:  921      print """"""%d Trigger Lists matched the input criteria %s """""" % \  922            (len(triggerLists),printme)  923    924  ## if no trigger lists found, then return an error message  925    if len(triggerLists)<1:  926      OutError.append('Hmmm. No Lists found matching input %s !!' % printme)  927      return RunsListDict,OutInfo,OutError  928              929  ## if there are trigger name matches, then return the list of names  930    if len(triggerLists)>=1:  931      OutInfo.append(\  932        """"""\nResults:  These %d Trigger Lists matched the input criteria %s """""" % \  933        (len(triggerLists),printme))  934      OutInfo.append(\  935        """"""\n%-30s %-5s %-20s %-3s """""" % \  936        (""Trigger List"","" TLV "",""Trigger Name"",""TNV""))  937      OutInfo.append(\  938        """"""\n%-30s %-5s %-20s %-3s """""" % \  939        (""------------"",""-----"",""------------"",""---""))  940      for tl_name,tl_version,name,version in triggerLists:  941        OutInfo.append(""""""\n%-30s %5.2f  %-20s %-3d"""""" % \  942                       (tl_name,tl_version,name,version))  943    944  ## now get the runs that used those trigger lists:  945    946    RunsListDict,Info,Errors = GetRunsByTLTN(base,triggerLists,printme, p)  947    if Info!=[]:  948      for info in Info:  949        OutInfo.append(info)  950    if Errors!=[]:  951      for error in Errors:  952        OutError.append(error)  953      954  ## close the db connection  955    DbConn.close()  956     957    return RunsListDict,OutInfo,OutError  958    959    960  ## -----------------------------------------------------------------------------  961  ## -----------------------------------------------------------------------------  962  def GetRunsByTLTN(base,triggerLists,printme, p):  963    """"""Fill the output list of Dictionaries for each Run_Trigs record that has  964    a trigger list name/version and trigger name/version in the input tuple.""""""  965  ## initialize output  966    RunsListDict = []  967    OutInfo      = []  968    OutError     = []  969  ##   970    OutInfo.append(""""""\n  971  ################################################################################  972  ## TASK:  finding all Runs that use Trigger Lists containing this Trigger Name ...   973  ################################################################################  974  """""")  975      976    sql_sel   = """"""SELECT rn.RUN_NUMBER,TO_CHAR(rn.START_TIME,'YYYY-MON-DD HH24:MI'),  977                   TO_CHAR(((rn.END_TIME-rn.START_TIME)*24),'9999.99'),  978                   rn.STORE, rn.PRESCNAME, rn.RECORDING,  979                   rn.TRIG_CONFIG_NAME, rn.TRIG_CONFIG_VERS,   980                   trg.BIT_NUM, trg.BIT_NAME, trg.DEPEND_BIT  981                   FROM RUNS.RUNS rn, RUNS.RUN_TRIGS trg  982                   WHERE trg.RUN_NUMBER=rn.RUN_NUMBER AND trg.TRG_TYPE='L3bit' """"""  983  ## add a STORE number requirement  984    sql_sel = sql_sel + """"""  985                   AND (rn.STORE IS NOT NULL) """"""  986  ## add the recording requirement   987    sql_sel = sql_sel + "" AND (rn.RECORDING='1' or rn.RECORDING IS NULL) ""  988  ## to look for runs with no recording  989  ##sql_sel = sql_sel + "" AND (rn.RECORDING='0') ""  990    991  ## define a dictionary to store the trigger name versions   992    tvDict = {}  993  ## add to the WHERE clause in a   994  ## loop over trigger lists/trigger name combinations to select those triggers  995    sql_where = """"  996    for tl_name,tl_version,name,version in triggerLists:  997    998      ## add to the dictionary containing trigger version numbers  999      tvDict['%s^%3.2f^%s' % (tl_name,tl_version,name)] = version  1000        1001      if sql_where != """":  1002        sql_where = sql_where + """""" OR """"""  1003      sql_where = sql_where + """"""  1004        ( (rn.TRIG_CONFIG_NAME LIKE %s AND rn.TRIG_CONFIG_VERS = %3.2f)"""""" % \  1005        (""'official%s/%s'"" % ('%',tl_name),tl_version)  1006      sql_where = sql_where + """"""  1007           AND (trg.BIT_NAME='%s' OR trg.BIT_NAME like '%s') )  1008           """""" % (name,name + '^%')  1009    1010  ## order by run number and trigger bit number  1011    sql_order = ' ORDER BY rn.RUN_NUMBER,trg.BIT_NUM '  1012    sql_order = ' ORDER BY RUN_NUMBER '  1013    1014    sqlquery = sql_sel + "" AND ("" + sql_where + "")"" + sql_order  1015    1016    try:  1017      triggerRuns = base.sql(sqlquery)  1018    except:  1019      OutError.append(""""""## sqlquery statement is:\n## %s"""""" % sqlquery)  1020      OutError.append(""""""Error getting runs for trigger lists """""")  1021      for syserrors in sys.exc_info():  1022        OutError.append(syserrors)  1023      OutError.append('Unable to proceed.  Stopping execution.\n\n')  1024      return RunsListDict,OutInfo,OutError  1025    1026    if p.debug()==1:  1027      print """"""## sqlquery statement is:\n## %s"""""" % sqlquery  1028      print """"""%d Runs contained triggers matching the input criteria %s """""" % \  1029            (len(triggerRuns),printme)  1030    1031  ## if no runs found, then return an error message  1032    if len(triggerRuns)<1:  1033      OutInfo.append('\nNo runs found matching input %s \n' % printme)  1034      OutError.append('\nNo runs found matching input %s \n' % printme)  1035      return RunsListDict,OutInfo,OutError  1036    1037  ## if there are trigger name matches, then put the headers for the list in the OutInfo list  1038    if len(triggerRuns)>=1:  1039      OutInfo.append(\  1040        """"""\nResults:  These %d Official Runs contained triggers with %s\n"""""" % \  1041                     (len(triggerRuns),printme))  1042    1043      OutInfo.append(\  1044        """"""\n%-10s %-17s %-8s %-5s %-9s %-9s %-24s %-20s %-21s %-20s %-20s %-20s %-11s %-6s"""""" % \  1045        (""RUN_NUMBER"",""START_TIME"",""DURATION"",""STORE"",""PRESCNAME"",""RECORDING"",\  1046         ""TRIG_CONFIG_(NAME)(VERS)"",""TL_(NAME)-(VERSION)"",\  1047         ""TN_(NAME)-(VERSION)"",""BIT_(NUM)(NAME)"",\  1048         ""L2_BIT_(NUM)(NAME)"",\  1049         ""L1_BIT_(NUM)(NAME)"",""L1_PRESCALE"",""EG_NUM""))  1050    1051      OutInfo.append(\  1052        """"""\n%-10s %-17s %-8s %-5s %-9s %-9s %-24s %-20s %-21s %-20s %-20s %-20s %-11s %-6s """""" % \  1053        (""----------"",""----------"",""--------"",""-----"",""---------"",""---------"",\  1054         ""------------------------"",""-------------------"",\  1055         ""-------------------"",\  1056         ""--------------------"",\  1057         ""--------------------"",\  1058         ""--------------------"",""-----------"",""------""))  1059        1060  ## Loop over all the runs, do more queries to Load the list of dictionaries:  1061        1062    for RUN_NUMBER,START_TIME,DURATION,STORE,PRESCNAME,RECORDING,\  1063        TRIG_CONFIG_NAME,TRIG_CONFIG_VERS,\  1064        BIT_NUM, BIT_NAME, DEPEND_BIT in triggerRuns:  1065    1066  ## get the trigger name  1067      tnname    = BIT_NAME  1068      if string.find(BIT_NAME,'^'):  1069        tnname = string.split(BIT_NAME,'^')[0]  1070  ## get the trigger version from tvDict stored from  Trigger DB:  1071      for names in string.split(TRIG_CONFIG_NAME,'/'):  1072        tl_name = names  1073      tn_version = tvDict['%s^%s^%s' % (tl_name,TRIG_CONFIG_VERS,tnname)]  1074    1075  ## get the L2 bit number, name and depend bit Runs DB:  1076      sqlquery = """"""SELECT BIT_NUM,BIT_NAME,DEPEND_BIT  1077                    FROM runs.run_trigs  1078                    WHERE BIT_NUM='%s' and RUN_NUMBER='%s' AND TRG_TYPE='L2bit'  1079                    """""" % (DEPEND_BIT,str(RUN_NUMBER))  1080      L2Stuff = base.sql(sqlquery)  1081      if len(L2Stuff) != 1:  1082        OutError.append(""""""ERROR finding unique L2 bit in Run %s  1083        using SQL query: \n%s !"""""" % (str(RUN_NUMBER),sqlquery))  1084        return RunsListDict,OutInfo,OutError  1085    1086      for L2_NUM,L2_NAME,L2_DEPEND in L2Stuff:  1087        L2_BIT_NUM  = L2_NUM  1088        L2_BIT_NAME = L2_NAME  1089        L2D = L2_DEPEND  1090         1091  ## get the L1 bit number, name, prescale and eg number from Runs DB:  1092      sqlquery = """"""SELECT BIT_NUM,BIT_NAME,EG_NUM,PRESCALE  1093                    FROM runs.run_trigs  1094                    WHERE BIT_NUM='%s' and RUN_NUMBER='%s' AND TRG_TYPE='L1bit'  1095                    """""" % (L2D,str(RUN_NUMBER))  1096      L1Stuff = base.sql(sqlquery)  1097      if len(L1Stuff) != 1:  1098        OutError.append(""""""ERROR finding unique L1 bit in Run %s  1099        using SQL query: \n%s !"""""" % (str(RUN_NUMBER),sqlquery))  1100        return RunsListDict,OutInfo,OutError  1101    1102      for L1_NUM,L1_NAME,EG_NUM,L1_PRESCALE in L1Stuff:  1103        L1_BIT_NUM  = L1_NUM  1104        L1_BIT_NAME = L1_NAME  1105        L1_PRESCALE = L1_PRESCALE  1106        EG = EG_NUM  1107  ## fill the dictionary for this run  1108          1109      ADict = {'RUN_NUMBER':str(RUN_NUMBER),\  1110               'START_TIME':START_TIME,\  1111               'DURATION':DURATION,\  1112               'STORE':str(STORE),\  1113               'PRESCNAME':PRESCNAME,\  1114               'RECORDING':RECORDING,\  1115               'TRIG_CONFIG_NAME':TRIG_CONFIG_NAME,\  1116               'TRIG_CONFIG_VERS':TRIG_CONFIG_VERS,\  1117               'TN_NAME':tnname,\  1118               'TN_VERSION':str(tn_version),\  1119               'TL_NAME':tl_name,\  1120               'TL_VERSION':TRIG_CONFIG_VERS,\  1121               'TRIG_BIT_NUM':BIT_NUM,\  1122               'TRIG_BIT_NAME':BIT_NAME,  1123               'L2_BIT_NUM':L2_BIT_NUM,\  1124               'L2_BIT_NAME':L2_BIT_NAME,  1125               'L1_BIT_NUM':L1_BIT_NUM,\  1126               'L1_BIT_NAME':L1_BIT_NAME,\  1127               'L1_PRESCALE':L1_PRESCALE,\  1128               'EG_NUM':EG}  1129  ## add this run to the output list of dictionaries  1130      RunsListDict.append(ADict)  1131  ## add this run to the OutInfo list  1132      try:  1133        OutInfo.append(\  1134          """"""\n%-10s %-17s %-8s %-5s %-9s %-5s %-28s %-20s %-21s %-2s %-17s %-2s %-17s %-2s %-17s %-11s %-6s"""""" % \  1135          (str(RUN_NUMBER),START_TIME,DURATION,str(STORE),PRESCNAME,RECORDING,\  1136           TRIG_CONFIG_NAME+'-'+TRIG_CONFIG_VERS,tl_name+'-'+TRIG_CONFIG_VERS,\  1137           tnname+' / '+str(tn_version),BIT_NUM,BIT_NAME,  1138           L2_BIT_NUM,L2_BIT_NAME,  1139           L1_BIT_NUM,L1_BIT_NAME,L1_PRESCALE,EG))  1140      except:  1141        OutInfo.append(""I'm having printing problems for this Run"")  1142        OutInfo.append(str(RUN_NUMBER))  1143        break  1144    1145  ## add the contents of the dictionary for the first run found to the OutList  1146    if RunsListDict != []:  1147      OutInfo.append('\nHere is the contents of the output dictionary for the first Run found:')  1148      for key in RunsListDict[0].keys():  1149        OutInfo.append(""""""\nKey name %-20s has value '%s' """""" % (key,RunsListDict[0][key]))  1150        1151    return RunsListDict,OutInfo,OutError  1152  ## -----------------------------------------------------------------------------  1153  ## -----------------------------------------------------------------------------  1154  def where_tlwild(intlname,intlversion=0.):  1155    """"""generate the where clause for a wildcard,case-insensitive tl_name  1156    and possibly non-existent tl_version""""""  1157    if intlversion>0.:  1158      clause = """""" upper(tl_name) like '%s'  1159                   and tl_version = '%3.2f'  1160               """""" %(string.upper(intlname), intlversion)  1161    else:  1162      clause = """""" upper(tl_name) like '%s'"""""" %(string.upper(intlname))  1163    return clause  1164    1165  ## -----------------------------------------------------------------------------  1166  def GetHeader(program):  1167    """"""Return a commented header string for the output file""""""  1168    try:  1169      whos = os.getlogin()  1170    except:  1171      whos = 'anonymous'  1172      if p.debug()==1:  1173        print ""\nUnable to get login information. using user anonymous""  1174    format_string = ""%b %d,%Y %H:%M:%S (localtime)""  1175    datime = strftime(format_string,localtime())  1176    Header =\  1177  """"""###########################################################  1178  ## Output of program GetRuns.py -%s generated by %s  1179  ## on Date: %s  1180  ## This file was generated using the following program options:  1181  ##   %s\n##  1182  """""" % (program,whos,datime,ALL_XML_PARAMS)  1183    1184    if p.sname() != '':  1185      Header = Header + """"""## for Level %s Script Name: %s """""" % \  1186               (p.slevel()[1],p.sname())  1187    if p.sversion() != 0:  1188      Header = Header + """"""## Level %s Script Version: %s """""" % \  1189               (p.slevel()[1],p.sversion())  1190    if p.tnname() != '':  1191      Header = Header + """"""## for Trigger Name: %s """""" % p.tnname()  1192    if p.tnversion() != 0:  1193      Header = Header + """""", Version: %s """""" % p.tnversion()  1194    if p.run_number() != 0:  1195      Header = Header + """"""## for RunNumber %d """""" % p.run_number()  1196    if p.tlname() != '':  1197      Header = Header + """"""## for Trigger List:  %s-%3.2f """""" % \  1198               (p.tlname(),p.tlversion())  1199    1200    Header = Header + """"""  1201  ###########################################################""""""  1202      1203    return Header  1204    1205  ## -----------------------------------------------------------------------------  1206  def GetTListForRun(DbConn):  1207    """"""Return a trigger list name, a trigger list version or an error list  1208    for the input run number.""""""  1209  ## initialize output    1210    tl_name    = ''  1211    tl_version = 0.0  1212    error_list = []  1213  ## make the query to the Run Summary Database  1214    base = Sqlbase(DbConn)  1215    sqlquery = ""select runs.trig_config_name,runs.trig_config_vers "" + \  1216          "" from runs.runs where "" + \  1217          "" runs.run_number=%d"" % p.run_number()  1218    results = base.sql(sqlquery)  1219  ## if no results, then exit  1220    if len(results)==0:  1221      error_list.append('\nRun number %d not found.\n' % p.run_number())  1222      return tl_name,tl_version,error_list  1223  ## make some corrections:  1224  ## In the RunSummaryDB: tl_version is a string, tl_name may contain a dir path/:  1225    try:  1226      tl_version = string.atof(results[0][1])  1227      listname   = string.split(results[0][0],'/')  1228      for lists in listname:  1229        tl_name = lists  1230    except:  1231      error_list.append('Error getting trigger list for Run %d' % p.run_number())  1232      for syserrors in sys.exc_info():  1233        error_list.append(syserrors)  1234    1235    return tl_name,tl_version,error_list  1236    1237  ## -----------------------------------------------------------------------------  1238  def GetUniqueTList(DbConn,tlName,tlVersion):  1239    """"""Return a distinct trigger name and version from the Trigger Database  1240    given the input tl_name,tl_version or return a list of errors.""""""  1241  ## initialize output    1242    tl_name    = ''  1243    tl_version = 0.0  1244    error_list = []  1245  ## make the query to the Trigger Database  1246    base = Sqlbase(DbConn)  1247    if tlName=='': tlName = '%'  1248    sqlquery = """"""select unique tl_name,tl_version from trigger_lists  1249             where """""" + where_tlwild(tlName,tlVersion)  1250    triggerListInfo = base.sql(sqlquery)  1251  ## if no triggerlist is found, return an error  1252    if not triggerListInfo:  1253      emsg = 'No official Trigger list found with name/version = %s / %3.2f' % \  1254             (tlName,tlVersion)  1255      error_list.append(emsg)  1256      return tl_name,tl_version,error_list  1257  ## one or more distinct records were found  1258    numtl = len(triggerListInfo)  1259  ## if too many found  1260    if numtl>1:  1261      emsg = 'More than one trigger list found for : %s / %3.2f' % \  1262             (tlName,tlVersion)  1263      error_list.append(emsg)  1264      error_list.append(' ')  1265      for tl_name,tl_version in triggerListInfo:  1266        error_list.append('-tlname %s -tlversion %3.2f ' % (tl_name,tl_version))  1267      error_list.append(' ')  1268    else:  1269      try:  1270        tl_name    = triggerListInfo[0][0]  1271        tl_version = triggerListInfo[0][1]  1272      except:  1273        emsg = 'Error getting distinct trigger list.'  1274        error_list.append(emsg)  1275        for syserrors in sys.exc_info():  1276          error_list.append(syserrors)  1277        1278    return tl_name,tl_version,error_list  1279    1280  ## -----------------------------------------------------------------------------  1281  ## -----------------------------------------------------------------------------  1282  ## -----------------------------------------------------------------------------  1283  def GetTNameList(DbConn):  1284    """"""Return a list of tlIndex,tnName - trigger names in order  1285    for the input trigger list""""""  1286    1287    base = Sqlbase(DbConn)  1288    1289  ## do I put hats in or not ?  1290  ## check the Runs db for any ^ in L3bit names for this trigger list  1291    hats = 'yes'  1292    sql_hats = """"""select unique run_trigs.bit_name  1293                  from runs.run_trigs,runs.runs  1294                  where runs.trig_config_vers='%3.2f'  1295                  and runs.trig_config_name like '%s'  1296                  and runs.run_number=run_trigs.run_number  1297                  and run_trigs.trg_type='L3bit'  1298                  and run_trigs.bit_name like '%s'  1299               """""" % (tlVersion,'%/'+p.tlname(),'%^%')  1300  ## before doing the query looking for hats  1301  ## first I have to see if the run is actually in the offline database:  1302    sql_runs = """"""select runs.run_number  1303                  from runs.runs  1304                  where runs.trig_config_vers='%3.2f'  1305                  and runs.trig_config_name like '%s'  1306               """""" % (tlVersion,'%/'+p.tlname())  1307    results = base.sql(sql_runs)  1308    1309  ## if not in offline database, connect to the online and try there:  1310    if len(results)==0:  1311      try:  1312        dbname = ""d0read/reader@d0on""  1313        dbc_online = dcoracle.Connect (dbname)  1314        base_online = Sqlbase(dbc_online)  1315        results = base_online.sql(sql_runs)  1316        if len(results)==0:  1317          if p.debug()==1:  1318            print 'I give up - this trigger list is not in online database.'  1319            print '  Unable to do hat check so assume hat convention.'  1320        else:  1321          results = base_online.sql(sql_hats)  1322          if len(results)==0:  1323            hats = 'no'  1324          dbc_online.close ()  1325      except:  1326        if p.debug()==1:  1327          print """"  1328          db = dbname[string.find(dbname,'@'):]  1329          print ""Error to connect to database "" + \  1330                db + ' for hat check, assuming hat convention.'  1331          for syserrors in sys.exc_info():  1332            print syserrors  1333            1334    1335  ## okay its in the offline database  1336    else:  1337      results = base.sql(sql_hats)  1338      if len(results)==0:  1339        hats = 'no'  1340    1341  ## now complete the trigger db query  1342    triggers = base.sql(""""""select tl_index,name  1343                       from tl_maps  1344                       where TL_NAME='%s'  1345                       and TL_VERSION='%s'  1346                       and TL_INDEX!=0  1347                       order by TL_INDEX"""""" % \  1348                       (p.tlname(), tlVersion))  1349    ListTriggers  = []  1350    ListIndexName = []  1351    if hats=='yes':  1352      hats = '^'  1353    else:  1354      hats = ''  1355    for tl_index,name in triggers:  1356      if ListTriggers.count(name)==0:  1357        ListIndexName.append([tl_index,name])  1358        ListTriggers.append(name)  1359      else:  1360        ListTriggers.append(name)  1361        newname = name + hats + `ListTriggers.count(name)`  1362        ListIndexName.append([tl_index,newname])  1363    1364    return ListIndexName  1365    1366  ## -----------------------------------------------------------------------------  1367  def RunTLORDER(DbConn):  1368    """"""Return a list of trigger names in tl_index order for a trigger list""""""  1369  ## initialize output  1370    OutputNames = ''  1371    1372  ## get the trigger names in a list  1373    tnlist = GetTNameList(DbConn, TLNAME, TLVERSION)  1374    1375  ## loop over all the triggers returned  1376    for tlIndex,tnName in tnlist:  1377      if tlIndex!=0:  1378        OutputNames = OutputNames + '\n%d\t%s' % (tlIndex,tnName)  1379    1380    return OutputNames  1381  ## -----------------------------------------------------------------------------  1382  ## -----------------------------------------------------------------------------  1383  def GetTBitNameList(DbConn):  1384    """"""Return a list of tlIndex,tnName,L1Bit names in tl_index order  1385    for the input trigger list""""""  1386  ## initialize the output list of lists  1387    ListIndexName = []  1388    hats = '^'  1389    1390  ## query the trigger database using the input database connection DbConn  1391    base     = Sqlbase(DbConn)  1392    triggers = base.sql(""""""select tl_index,tn_name,  1393                       l1s_name,l1s_version,l2s_name,l2s_version  1394                       from v_tlists  1395                       where TL_NAME='%s'  1396                       and TL_VERSION='%s'  1397                       and TL_INDEX!=0  1398                       order by TL_INDEX"""""" % \  1399                       (p.tlname(), p.tlversion()))  1400  ## keep a list of L1L2 script names and versions encountered  1401    ## ListL1L2Bits = []  1402  ## keep the last L1L2 trigger conditions to compare to current trigger  1403    lastL1L2 = ['',0,'',0]  1404  ## append to list of L1 script names whenever a new L1L2 condition is encountered  1405    ListL1SNames = []  1406  ## keep a list of trigger names encountered  1407    ListTriggers = []  1408    1409  ## loop over all triggers in TL_INDEX order  1410    for tl_index,name,l1s_name,l1s_version,l2s_name,l2s_version in triggers:  1411    1412  ## determine the trigger bit name  1413      ListTriggers.append(name)  1414      if ListTriggers.count(name)==1:  1415        newname = name  1416      else:  1417        newname = name + hats + `ListTriggers.count(name)`  1418    1419  ## determine the L1 bit name  1420      if lastL1L2==[l1s_name,l1s_version,l2s_name,l2s_version]:  1421        bitname = lastBitname  1422      else:  1423        ## ListL1L2Bits.append([l1s_name,l1s_version,l2s_name,l2s_version])  1424        ListL1SNames.append(l1s_name)  1425        1426      if ListL1SNames.count(l1s_name)==1:  1427        bitname = l1s_name  1428      else:  1429        bitname = l1s_name + hats + \  1430          `ListL1SNames.count(l1s_name)`  1431    1432      lastL1L2 = [l1s_name,l1s_version,l2s_name,l2s_version]  1433      lastBitname = bitname  1434    1435  ## add this index number, trigger bit name and l1bitname to the output list  1436      ListIndexName.append([tl_index,newname,bitname])  1437      1438    1439    return ListIndexName  1440    1441  ## -----------------------------------------------------------------------------  1442  ## -----------------------------------------------------------------------------  1443  def RunBITNAMES(DbConn):  1444    """"""Return a list of trigger, L1bit names in tl_index order for a trigger list""""""  1445  ## initialize output  1446    OutputNames = ''  1447    1448  ## get the trigger and L1 bit names names in a list  1449    tnlist = GetTBitNameList(DbConn)  1450    1451  ## loop over all the triggers returned  1452    for tlIndex,tnName,l1bit in tnlist:  1453      if tlIndex!=0:  1454        spaces = SPACE30[:len(SPACE30)-len(tnName)]  1455        OutputNames = OutputNames + '\n%d\t%s%s%s' % (tlIndex,tnName,spaces,l1bit)  1456    1457    return OutputNames  1458  ## -----------------------------------------------------------------------------  1459  ## -----------------------------------------------------------------------------  1460  # a function that does the same thing as running this program from the command line  1461  def GetRuns(TNNAME, TNVERSION=0, TLNAME='', TLVERSION=0., RUN_NUMBER=0,  1462                    HEADER='no',DEBUG=0, SLEVEL='L1', SNAME='', SVERSION=0):  1463    1464    p = GetStuff_params()  1465    p.set_debug(DEBUG)  1466    1467    p.set_sname(SNAME)  1468    p.set_sversion(SVERSION)  1469    p.set_slevel(SLEVEL)  1470    1471    p.set_tnname(TNNAME)  1472    p.set_tnversion(TNVERSION)  1473    1474    p.set_tlname(TLNAME)  1475    p.set_tlversion(TLVERSION)  1476    p.set_run_number(RUN_NUMBER)  1477    1478    p.set_outputfile(FILE)  1479    p.set_header(HEADER)  1480      1481    ListRun, ListInfo, ListError = makeit (""d0read/reader@d0ofprd1"", p)  1482    return ListRun, ListInfo, ListError  1483    1484  ## -----------------------------------------------------------------------------  1485  ## -----------------------------------------------------------------------------  1486  # a function that does the same thing as running this program from the command line  1487  # This one accepts a GetStuff_params object as an argument  1488  def GetRuns1(p):  1489      1490    ListRun, ListInfo, ListError = makeit (""d0read/reader@d0ofprd1"", p)  1491    return ListRun, ListInfo, ListError  1492    1493  ## -----------------------------------------------------------------------------  1494  ## -----------------------------------------------------------------------------  1495  def makeit (dbname,p):  1496    """"""This is the main program.  Run the appropriate program based on the inputs.""""""  1497    1498  ## for all programs, a run number, trigger or list name is required input  1499    if p.run_number()==0 and p.tlname()=='' and p.tlversion()==0. and \  1500       p.tnname()=='' and p.tnversion()==0 and p.sname=='' and p.sversion==0:  1501      print ''  1502      print """"""This program requires at least one of the following:  1503        1504      - input trigger list name (-tlname) and/or version (-tlversion), or  1505      - input trigger name (-tnname) and/or version (-tnversion),  1506      - input script name (-l*sname) and/or version (-l*sversion)  1507        where trigger level (* = 1,2, or 3),  1508      - input Run number (-Run).  1509    1510      Wildcards are allowed in any of the named entries.  1511      If a unique list name, trigger name, or script name is identified,  1512      a list of Runs (and other Run information) is produced.  1513      If not, a list of candidate names are produced.  1514    1515      Entry of a Trigger List name and/or version or Run number results in a  1516      list of triggers in that trigger list if a unique list is identified.""""""  1517      print 'Enter -help for help.'  1518      print ''  1519      sys.exit(0)  1520    1521  ## make sure I can connect to the offline database  1522    try:  1523      DbConn = dcoracle.Connect (dbname)  1524    except:  1525      print """"  1526      db = dbname[string.find(dbname,'@'):]  1527      print ""\nUnable to connect to database "" + db + '.'  1528      print ""The database itself may be down or check your python_dcoracle setup.\n""  1529      print """"  1530      sys.exit(0)  1531    1532  ## Runs are found only for script or trigger name input  1533    if p.sname() != '' or p.sversion()!=0 or \  1534       p.tnname() != '' or p.tnversion()!=0 or \  1535       p.tlname() != '' or p.tlversion()!=0.:  1536    1537  ## If there is a trigger name and/or version, then call function ListOfRunsByScript  1538      if p.sname() != '' or p.sversion()!=0:  1539        if p.interactive()==1:  1540          print 'Running Program ListOfRunsByScript'  1541        ListRun,ListInfo,ListError = ListOfRunsByScript(p)  1542        program  = 'ListOfRunsByScript'  1543        filename = 'ListOfRunsByScript-%s-%s-%d.out' % (p.slevel(),p.sname(),p.sversion())  1544    1545  ## If there is a trigger name and/or version, then call function ListOfRunsByTrigger  1546      if p.tnname() != '' or p.tnversion()!=0:  1547        if p.interactive()==1:  1548          print 'Running Program ListOfRunsByTrigger'  1549        ListRun,ListInfo,ListError = ListOfRunsByTrigger(p)  1550        program  = 'ListOfRunsByTrigger'  1551        filename = 'ListOfRunsByTrigger-%s-%d.out' % (p.tnname(),p.tnversion())  1552    1553  ## If there is a trigger list name and/or version, then call function ListOfRunsByTriggerList  1554      if p.tlname() != '' or p.tlversion()!=0.:  1555        if p.interactive()==1:  1556          print 'Running Program ListOfRunsByTriggerList'  1557        ListRun,ListInfo,ListError = ListOfRunsByTriggerList(p)  1558        program  = 'ListOfRunsByTriggerList'  1559        filename = 'ListOfRunsByTriggerList-%s-%d.out' % (p.tnname(),p.tnversion())  1560    1561  ## if there were errors, then no runs were found so print the errors and exit  1562      if ListError != []:  1563        print ""\n""  1564        for error in ListError:  1565          print error  1566        print ""\n""  1567        ## sys.exit(0)  1568  ## if no runs were found, print a message if in debug mode  1569      elif p.debug()==1 and ListRun == []:  1570          print 'No runs returned in the list '  1571  ## put together Output  1572      else:  1573    1574        Output = ''  1575        if ListInfo != []:  1576          for info in ListInfo:  1577            Output = Output + info  1578    ## add the header to the output unless asked not to  1579    ##    if p.header() == 'yes':  1580    ##      Output = GetHeader(program) + Output  1581    ## write the output to the file or the screen  1582        if p.outputfile()=='yes':  1583          print ""Writing Trigger Stuff to filename = "" + filename  1584          outfile = open(filename,'w+')  1585          if p.header() == 'yes': outfile.write(GetHeader(program))  1586          outfile.write(Output)  1587          outfile.close()  1588        else:  1589          print Output  1590    1591      DbConn.close ()  1592      return  1593    1594  ## if there is a Run number, get a trigger list name/version (from Runs Db)  1595    if p.run_number()>0:  1596      tlName,tlVersion,errors = GetTListForRun(DbConn)  1597      if errors!=[]:  1598        for error in errors:  1599          print error  1600          sys.exit(0)  1601      print '\nRun number %d used Trigger List Name/Version = %s / %3.2f' % \  1602            (p.run_number(),tlName,tlVersion)  1603      p.set_tlname(tlName)  1604      p.set_tlversion(tlVersion)  1605  ## determine the unique triggerlist name/version in the Trigger Db  1606  ## using the input triggerlist name/version from user input or from Runs Db above  1607    if p.tlname()!='' or p.tlversion()!=0.:  1608      tlName,tlVersion,error_list = GetUniqueTList(DbConn,p.tlname(),p.tlversion())  1609      if error_list!=[]:  1610        print ''  1611        for error in error_list:  1612          print error  1613        print ''  1614        sys.exit(0)  1615      if p.debug()==1: print 'Unique Trigger List Name/Version found: %s / %3.2f' % \  1616         (tlName,tlVersion)  1617      p.set_tlname(tlName)  1618      p.set_tlversion(tlVersion)  1619    1620  ## if there is a unique trigger list, then get the bitnames for that list  1621    if (p.tlname()!='' or p.tlversion()!=0.):  1622    1623        Output = RunBITNAMES(DbConn)  1624        if Output == '' and p.debug()==1:  1625          ## print something in debug mode if no triggers are found  1626          print 'No triggers were found in this trigger list !! '  1627    ## add the header to the output unless asked not to  1628        if p.header() == 'yes':  1629          Output = GetHeader('GetBitsByTL') + Output  1630    ## write the output to the file or the screen  1631        if p.outputfile()=='yes':  1632          if p.run_number() != 0:  1633            filename = 'GetBitsByRun_' + str(p.run_number()) + '.out'  1634          else:  1635            filename = 'GetBitsByTL_%s-%3.2f.out' % (p.tlname(),p.tlversion())  1636          if p.debug()==1:  1637            print ""Writing trigger, L1bit names in tl_index order to filename = "" + filename  1638          outfile = open(filename,'w+')  1639          outfile.write(Output)  1640          outfile.close()  1641        else:  1642          print Output  1643    1644  ## -----------------------------------------------------------------------------  1645  ## -----------------------------------------------------------------------------  1646  def PrintThenExit(msg,syserror=[]):  1647    print msg + '\n'  1648    if syserror!=[]:  1649      for syserrors in syserror:  1650        print syserrors  1651    print '\nUnable to proceed.  Stopping execution.\n\n'  1652    sys.exit(0)  1653  ## -----------------------------------------------------------------------------  1654  ## -----------------------------------------------------------------------------  1655  if __name__=='__main__':  1656    1657    arg = 1  1658    p = GetStuff_params()  1659      1660        1661    # tell the code to print out some extra comments.  1662    # These are useful in interactive mode  1663    p.set_interactive(1)  1664    1665    if len(sys.argv) < 2:  1666      print PRINTME  1667      sys.exit(0)  1668    1669    while arg < len(sys.argv):  1670      ## read in all the arguments and save them to write to the comment section  1671      if ALL_XML_PARAMS=='':  1672        ALL_XML_PARAMS = ''  1673        for iparams in xrange(0,len(sys.argv)):  1674          ALL_XML_PARAMS = ALL_XML_PARAMS + ' ' + sys.argv[iparams]  1675        if string.find(string.upper(ALL_XML_PARAMS),'DEBUG')!=-1:  1676          p.set_debug(1);  1677          print """"""###########################################################""""""  1678          print '## Program Input:  ';  1679          print '## ' + ALL_XML_PARAMS  1680          print '## '  1681          print '## Mode:   DEBUG'  1682            1683  ## script name and level  1684      if string.find(string.upper(sys.argv[arg]),'-L')!=-1:  1685        if string.find(string.upper(sys.argv[arg]),'-L1')!=-1:  1686          p.set_slevel('L1')  1687        elif string.find(string.upper(sys.argv[arg]),'-L2')!=-1:  1688          p.set_slevel('L2')  1689        elif string.find(string.upper(sys.argv[arg]),'-L3')!=-1:  1690          p.set_slevel('L3')  1691        else:  1692          PrintThenExit('Invalid Level' + sys.argv[arg],sys.exc_info())  1693                          1694        if p.debug()==1: print     '## Input:  Script Level = ' + p.slevel()  1695    1696        if string.find(string.upper(sys.argv[arg]),'SN')!=-1:  1697          try:  1698            p.set_sname(sys.argv[arg+1])  1699            if p.debug()==1: print '## Input:  Script Name  = ' + p.sname()  1700            arg = arg+1  1701          except:  1702            PrintThenExit('\nError !  No script name found !',sys.exc_info())  1703        if string.find(string.upper(sys.argv[arg]),'SV')!=-1:  1704          try:  1705            p.set_sversion(int(sys.argv[arg+1]))  1706            if p.debug()==1: print '## Input:  Script Version = %d' % p.sversion()  1707            arg = arg+1  1708          except:  1709            PrintThenExit('\nError !  No valid version found !\n',sys.exc_info())  1710  ## trigger name  1711      if string.upper(sys.argv[arg]) == '-TNNAME':  1712        try:  1713          p.set_tnname(sys.argv[arg+1])  1714          if p.debug()==1: print '## Input:  Trigger Name = ' + p.tnname()  1715          arg = arg+1  1716        except:  1717          PrintThenExit('\nError !  No trigger name found !',sys.exc_info())  1718      if string.upper(sys.argv[arg]) == '-TNVERSION':  1719        try:  1720          p.set_tnversion(int(sys.argv[arg+1]))  1721          if p.debug()==1: print '## Input:  Trigger Version = %d' % p.tnversion()  1722          arg = arg+1  1723        except:  1724          PrintThenExit('\nError !  No valid version found !\n',sys.exc_info())  1725  ## trigger list  1726      if string.upper(sys.argv[arg]) == '-TLNAME':  1727        try:  1728          p.set_tlname(sys.argv[arg+1])  1729          if p.debug()==1: print '## Input:  Trigger List Name = ' + p.tlname()  1730          arg = arg+1  1731        except:  1732          PrintThenExit('\nError !  No list name found !',sys.exc_info())  1733      if string.upper(sys.argv[arg]) == '-TLVERSION':  1734        try:  1735          p.set_tlversion(float(sys.argv[arg+1]))  1736          if p.debug()==1: print '## Input:  Trigger List Version = %3.2f' % p.tlversion()  1737          arg = arg+1  1738        except:  1739          PrintThenExit('\nError !  No valid version found !',sys.exc_info())  1740  ## run  1741      if string.upper(sys.argv[arg]) == '-RUN':  1742        try:  1743          p.set_run_number(int(sys.argv[arg+1]))  1744          if p.debug()==1: print '## Input:  Run Number = %d' % p.run_number()  1745          arg = arg+1  1746        except:  1747          PrintThenExit('\nError !  Invalid Run Number ',sys.exc_info())  1748  ## optional flags  1749      if string.upper(sys.argv[arg]) == '-FILE':  1750        p.set_outputfile(""yes"")  1751        if p.debug()==1: print '## write output to a file ? ' + p.outputfile()  1752      if string.upper(sys.argv[arg]) == '-HEADER':  1753        p.set_header(""no"")  1754        if p.debug()==1: print '## write header to a output ? ' + p.header()  1755    1756      arg = arg + 1  1757    1758      if p.debug()==1:  1759        print '## \n## Finished reading input.\n## '  1760        print """"""###########################################################""""""  1761    1762      makeit (""d0read/reader@d0ofprd1"",p)        ~  [   source navigation   ]  ~  [   diff markup   ]  ~  [   identifier search   ]  ~  [   freetext search   ]  ~  [   file search   ]  ~      This page was automatically generated by the   LXR engine .   Visit the  LXR main site  for more information."
GX069-04-5200733	"Go forward to  Vector Lisp Functions . Go backward to  Predicates . Go up to  Internals .   Computational Functions .......................  The functions described here do the actual computational work of the Calculator.  In addition to these, note that any function described in the main body of this manual may be called from Lisp; for example, if the documentation refers to the `calc-sqrt' [`sqrt'] command, this means `calc-sqrt' is an interactive stack-based square-root command and `sqrt' (which `defmath' expands to `calcFunc-sqrt') is the actual Lisp function for taking square roots.  The functions `math-add', `math-sub', `math-mul', `math-div', `math-mod', and `math-neg' are not included in this list, since `defmath' allows you to write native Lisp `+', `-', `*', `/', `%', and unary `-', respectively, instead.   -- Function: normalize VAL      (Full form: `math-normalize'.)  Reduce the value VAL to standard      form.  For example, if VAL is a fixnum, it will be converted to a      bignum if it is too large, and if VAL is a bignum it will be      normalized by clipping off trailing (i.e., most-significant) zero      digits and converting to a fixnum if it is small.  All the      various data types are similarly converted to their standard      forms.  Variables are left alone, but function calls are actually      evaluated in formulas.  For example, normalizing `(+ 2      (calcFunc-abs -4))' will return 6.       If a function call fails, because the function is void or has the      wrong number of parameters, or because it returns `nil' or calls      `reject-arg' or `inexact-result', `normalize' returns the formula      still in symbolic form.       If the current Simplification Mode is ""none"" or ""numeric      arguments only,"" `normalize' will act appropriately.  However,      the more powerful simplification modes (like algebraic      simplification) are not handled by `normalize'.  They are handled      by `calc-normalize', which calls `normalize' and possibly some      other routines, such as `simplify' or `simplify-units'.  Programs      generally will never call `calc-normalize' except when popping or      pushing values on the stack.   -- Function: evaluate-expr EXPR      Replace all variables in EXPR that have values with their values,      then use `normalize' to simplify the result.  This is what      happens when you press the `=' key interactively.   -- Macro: with-extra-prec N BODY      Evaluate the Lisp forms in BODY with precision increased by N      digits.  This is a macro which expands to            (math-normalize             (let ((calc-internal-prec (+ calc-internal-prec N)))               BODY))       The surrounding call to `math-normalize' causes a floating-point      result to be rounded down to the original precision afterwards.      This is important because some arithmetic operations assume a      number's mantissa contains no more digits than the current      precision allows.   -- Function: make-frac N D      Build a fraction `N:D'.  This is equivalent to calling      `(normalize (list 'frac N D))', but more efficient.   -- Function: make-float MANT EXP      Build a floating-point value out of MANT and EXP, both of which      are arbitrary integers.  This function will return a properly      normalized float value, or signal an overflow or underflow if EXP      is out of range.   -- Function: make-sdev X SIGMA      Build an error form out of X and the absolute value of SIGMA.  If      SIGMA is zero, the result is the number X directly.  If SIGMA is      negative or complex, its absolute value is used.  If X or SIGMA      is not a valid type of object for use in error forms, this calls      `reject-arg'.   -- Function: make-intv MASK LO HI      Build an interval form out of MASK (which is assumed to be an      integer from 0 to 3), and the limits LO and HI.  If LO is greater      than HI, an empty interval form is returned.  This calls      `reject-arg' if LO or HI is unsuitable.   -- Function: sort-intv MASK LO HI      Build an interval form, similar to `make-intv', except that if LO      is less than HI they are simply exchanged, and the bits of MASK      are swapped accordingly.   -- Function: make-mod N M      Build a modulo form out of N and the modulus M.  Since modulo      forms do not allow formulas as their components, if N or M is not      a real number or HMS form the result will be a formula which is a      call to `makemod', the algebraic version of this function.   -- Function: float X      Convert X to floating-point form.  Integers and fractions are      converted to numerically equivalent floats; components of complex      numbers, vectors, HMS forms, date forms, error forms, intervals,      and modulo forms are recursively floated.  If the argument is a      variable or formula, this calls `reject-arg'.   -- Function: compare X Y      Compare the numbers X and Y, and return -1 if `(lessp X Y)', 1 if      `(lessp Y X)', 0 if `(math-equal X Y)', or 2 if the order is      undefined or cannot be determined.   -- Function: numdigs N      Return the number of digits of integer N, effectively      `ceil(log10(N))', but much more efficient.  Zero is considered to      have zero digits.   -- Function: scale-int X N      Shift integer X left N decimal digits, or right -N digits with      truncation toward zero.   -- Function: scale-rounding X N      Like `scale-int', except that a right shift rounds to the nearest      integer rather than truncating.   -- Function: fixnum N      Return the integer N as a fixnum, i.e., a native Lisp integer.      If N is outside the permissible range for Lisp integers (usually      24 binary bits) the result is undefined.   -- Function: sqr X      Compute the square of X; short for `(* X X)'.   -- Function: quotient X Y      Divide integer X by integer Y; return an integer quotient and      discard the remainder.  If X or Y is negative, the direction of      rounding is undefined.   -- Function: idiv X Y      Perform an integer division; if X and Y are both nonnegative      integers, this uses the `quotient' function, otherwise it      computes `floor(X/Y)'.  Thus the result is well-defined but      slower than for `quotient'.   -- Function: imod X Y      Divide integer X by integer Y; return the integer remainder and      discard the quotient.  Like `quotient', this works only for      integer arguments and is not well-defined for negative arguments.      For a more well-defined result, use `(% X Y)'.   -- Function: idivmod X Y      Divide integer X by integer Y; return a cons cell whose `car' is      `(quotient X Y)' and whose `cdr' is `(imod X Y)'.   -- Function: pow X Y      Compute X to the power Y.  In `defmath' code, this can also be      written `(^ X Y)' or `(expt X Y)'.   -- Function: abs-approx X      Compute a fast approximation to the absolute value of X.  For      example, for a rectangular complex number the result is the sum      of the absolute values of the components.   -- Function: pi      The function `(pi)' computes `pi' to the current precision.      Other related constant-generating functions are `two-pi',      `pi-over-2', `pi-over-4', `pi-over-180', `sqrt-two-pi', `e',      `sqrt-e', `ln-2', and `ln-10'.  Each function returns a      floating-point value in the current precision, and each uses      caching so that all calls after the first are essentially free.   -- Macro: math-defcache FUNC INITIAL FORM      This macro, usually used as a top-level call like `defun' or      `defvar', defines a new cached constant analogous to `pi', etc.      It defines a function `func' which returns the requested value;      if INITIAL is non-`nil' it must be a `(float ...)'  form which      serves as an initial value for the cache.  If FUNC is called when      the cache is empty or does not have enough digits to satisfy the      current precision, the Lisp expression FORM is evaluated with the      current precision increased by four, and the result minus its two      least significant digits is stored in the cache.  For example,      calling `(pi)' with a precision of 30 computes `pi' to 34 digits,      rounds it down to 32 digits for future use, then rounds it again      to 30 digits for use in the present request.   -- Function: full-circle SYMB      If the current angular mode is Degrees or HMS, this function      returns the integer 360.  In Radians mode, this function returns      either the corresponding value in radians to the current      precision, or the formula `2*pi', depending on the Symbolic Mode.      There are also similar function `half-circle' and      `quarter-circle'.   -- Function: power-of-2 N      Compute two to the integer power N, as a (potentially very large)      integer.  Powers of two are cached, so only the first call for a      particular N is expensive.   -- Function: integer-log2 N      Compute the base-2 logarithm of N, which must be an integer which      is a power of two.  If N is not a power of two, this function      will return `nil'.   -- Function: div-mod A B M      Divide A by B, modulo M.  This returns `nil' if there is no      solution, or if any of the arguments are not integers.   -- Function: pow-mod A B M      Compute A to the power B, modulo M.  If A, B, and M are integers,      this uses an especially efficient algorithm.  Otherwise, it      simply computes `(% (^ a b) m)'.   -- Function: isqrt N      Compute the integer square root of N.  This is the square root of      N rounded down toward zero, i.e., `floor(sqrt(N))'.  If N is      itself an integer, the computation is especially efficient.   -- Function: to-hms A ANG      Convert the argument A into an HMS form.  If ANG is specified, it      is the angular mode in which to interpret A, either `deg' or      `rad'.  Otherwise, the current angular mode is used.  If A is      already an HMS form it is returned as-is.   -- Function: from-hms A ANG      Convert the HMS form A into a real number.  If ANG is specified,      it is the angular mode in which to express the result, otherwise      the current angular mode is used.  If A is already a real number,      it is returned as-is.   -- Function: to-radians A      Convert the number or HMS form A to radians from the current      angular mode.   -- Function: from-radians A      Convert the number A from radians to the current angular mode.      If A is a formula, this returns the formula `deg(A)'.   -- Function: to-radians-2 A      Like `to-radians', except that in Symbolic Mode a degrees to      radians conversion yields a formula like `A*pi/180'.   -- Function: from-radians-2 A      Like `from-radians', except that in Symbolic Mode a radians to      degrees conversion yields a formula like `A*180/pi'.   -- Function: random-digit      Produce a random base-1000 digit in the range 0 to 999.   -- Function: random-digits N      Produce a random N-digit integer; this will be an integer in the      interval `[0, 10^N)'.   -- Function: random-float      Produce a random float in the interval `[0, 1)'.   -- Function: prime-test N ITERS      Determine whether the integer N is prime.  Return a list which      has one of these forms: `(nil F)' means the number is non-prime      because it was found to be divisible by F; `(nil)' means it was      found to be non-prime by table look-up (so no factors are known);      `(nil unknown)' means it is definitely non-prime but no factors      are known because N was large enough that Fermat's probabilistic      test had to be used; `(t)' means the number is definitely prime;      and `(maybe I P)' means that Fermat's test, after I iterations,      is P percent sure that the number is prime.  The ITERS parameter      is the number of Fermat iterations to use, in the case that this      is necessary.  If `prime-test' returns ""maybe,"" you can call it      again with the same N to get a greater certainty; `prime-test'      remembers where it left off.   -- Function: to-simple-fraction F      If F is a floating-point number which can be represented exactly      as a small rational number. return that number, else return F.      For example, 0.75 would be converted to 3:4.  This function is      very fast.   -- Function: to-fraction F TOL      Find a rational approximation to floating-point number F to      within a specified tolerance TOL; this corresponds to the      algebraic function `frac', and can be rather slow.   -- Function: quarter-integer N      If N is an integer or integer-valued float, this function returns      zero.  If N is a half-integer (i.e., an integer plus 1:2 or 0.5),      it returns 2.  If N is a quarter-integer, it returns 1 or 3.  If      N is anything else, this function returns `nil'."
GX066-40-0824554	"Click on the banner to return to the user guide home page.   5.4 Example Program - Sieve of Eratosthenes     Obtaining the Source      An example program that illustrates the use of vectors is the classic algorithm, called the  sieve of Eratosthenes , used to discover prime numbers.  A list of all the numbers up to some bound is represented by an integer vector.  The basic idea is to strike out (set to zero) all those values that cannot be primes; thus all the remaining values will be the prime numbers.  To do this, a loop examines each value in turn, and for those that are set to one (and thus have not yet been excluded from the set of candidate primes) strikes out all multiples of the number.  When the outermost loop is finished, all remaining prime values have been discovered.  The program is as follows:   void main() {       // create a sieve of integers, initially set    const int sievesize = 100;    vector<int> sieve(sievesize, 1);        // now search for 1 bit positions    for (int i = 2; i * i < sievesize; i++)       if (sieve[i])          for (int j = i + i; j < sievesize; j += i)             sieve[j] = 0;        // finally, output the values that are set    for (int j = 2; j < sievesize; j++)       if (sieve[j])          cout << j << "" "";    cout << endl; }            ©Copyright 1996, Rogue Wave Software, Inc."
GX109-74-2806109	"Advanced Bash-Scripting HOWTO: A guide to shell scripting, using Bash Prev Chapter 3. Tutorial / Reference Next 3.20. Arrays Newer versions of  bash  support one-dimensional  arrays.  Arrays may be declared with the  variable[xx]   notation or explicitly by a  declare -a variable   statement. To dereference (find the contents of) an array variable, use   curly bracket  notation, that is,  ${variable[xx]} . Example 3-71. Simple array usage #!/bin/bash   area[11]=23 area[13]=37 area[51]=UFOs  # Note that array members need not be consecutive # or contiguous.  # Some members of the array can be left uninitialized. # Gaps in the array are o.k.  echo -n ""area[11] = "" echo ${area[11]} echo -n ""area[13] = "" echo ${area[13]} # Note that {curly brackets} needed echo ""Contents of area[51] are ${area[51]}.""  # Contents of uninitialized array variable print blank. echo -n ""area[43] = "" echo ${area[43]} echo ""(area[43] unassigned)""  echo  # Sum of two array variables assigned to third area[5]=`expr ${area[11]} + ${area[13]}` echo ""area[5] = area[11] + area[13]"" echo -n ""area[5] = "" echo ${area[5]}  area[6]=`expr ${area[11]} + ${area[51]}` echo ""area[6] = area[11] + area[51]"" echo -n ""area[6] = "" echo ${area[6]} # This doesn't work because # adding an integer to a string is not permitted.  exit 0 Arrays variables have a syntax all their own, and even standard bash operators  have special options adapted for array use. Example 3-72. Some special properties of arrays #!/bin/bash  declare -a colors # Permits declaring an array without specifying size.  echo ""Enter your favorite colors (separated from each other by a space).""  read -a colors # Special option to 'read' command, # allowing it to assign elements in an array.  echo    element_count=${#colors[@]} # Special syntax to extract number of elements in array. # element_count=${#colors[*]} works also. index=0  # List all the elements in the array. while [ $index -lt $element_count ] do   echo ${colors[$index]}   let ""index = $index + 1"" done # Each array element listed on a separate line. # If this is not desired, use  echo -n ""${colors[$index]} ""  echo  # Again, list all the elements in the array, but using a more elegant method.   echo ${colors[@]} # echo ${colors[*]} works also.   echo  exit 0 As seen in the previous example, either   ${array_name[@]}  or   ${array_name[*]}  refers to   all  the elements of the array.  Similarly,  to get a count of the number of elements in an array, use either   ${#array_name[@]}  or   ${#array_name[*]} . -- Arrays permit deploying old familiar algorithms as shell scripts.         Whether this is necessarily a good idea is left to the reader to  decide. Example 3-73. An old friend:               The Bubble Sort #!/bin/bash  # Bubble sort, of sorts.  # Recall the algorithm for a bubble sort. In this particular version...  # With each successive pass through the array to be sorted, # compare two adjacent elements, and swap them if out of order. # At the end of the first pass, the ""heaviest"" element has sunk to bottom. # At the end of the second pass, the next ""heaviest"" one has sunk next to bottom. # And so forth. # This means that each successive pass needs to traverse less of the array. # You will therefore notice a speeding up in the printing of the later passes.   exchange() {   # Swaps two members of the array.   local temp=${Countries[$1]} # Temporary storage for element getting swapped out.   Countries[$1]=${Countries[$2]}   Countries[$2]=$temp      return }    declare -a Countries  # Declare array.  Countries=(Netherlands Ukraine Zair Turkey Russia Yemen Syria Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England Israel Peru Canada Oman Denmark Wales France Kashmir Qatar Liechtenstein Hungary) # Couldn't think of one starting with X (darn).  clear  # Clear the screen to start with.   echo ""0: ${Countries[*]}""  # List entire array at pass 0.  number_of_elements=${#Countries[@]} let ""comparisons = $number_of_elements - 1""  count=1 # Pass number.  while [ $comparisons -gt 0 ]   # Beginning of outer loop do    index=0  # Reset index to start of array after each pass.    while [ $index -lt $comparisons ] # Beginning of inner loop   do     if [ ${Countries[$index]} \> ${Countries[`expr $index + 1`]} ]     # If out of order...     # Recalling that \> is ASCII comparison operator.     then       exchange $index `expr $index + 1`  # Swap.     fi       let ""index += 1""   done # End of inner loop     let ""comparisons -= 1"" # Since ""heaviest"" element bubbles to bottom, we need do one less comparison each pass.  echo echo ""$count: ${Countries[@]}"" # Print resultant array at end of each pass. echo let ""count += 1""   # Increment pass count.  done  # End of outer loop  # All done.  exit 0 -- Arrays enable implementing a shell script version of the  Sieve of  Erastosthenes . Of course, a resource-intensive application of this  nature should really be written in a compiled language, such as C. It  runs excruciatingly slowly as a script. Example 3-74. Complex array application:               Sieve of Erastosthenes #!/bin/bash  # sieve.sh # Sieve of Erastosthenes # Ancient algorithm for finding prime numbers.  # This runs a couple of orders of magnitude # slower than equivalent C program.  LOWER_LIMIT=1 # Starting with 1. UPPER_LIMIT=1000 # Up to 1000. # (You may set this higher... #  if you have time on your hands.)  PRIME=1 NON_PRIME=0  let SPLIT=UPPER_LIMIT/2 # Optimization: # Need to test numbers only # halfway to upper limit.   declare -a Primes # Primes[] is an array.   initialize () { # Initialize the array.  i=$LOWER_LIMIT until [ $i -gt $UPPER_LIMIT ] do   Primes[i]=$PRIME   let ""i += 1"" done # Assume all array members guilty (prime) # until proven innocent. }  print_primes () { # Print out the members of the Primes[] array # tagged as prime.  i=$LOWER_LIMIT  until [ $i -gt $UPPER_LIMIT ] do    if [ ${Primes[i]} -eq $PRIME ]   then     printf ""%8d"" $i     # 8 spaces per number     # gives nice, even columns.   fi      let ""i += 1""    done  }  sift () { # Sift out the non-primes.  let i=$LOWER_LIMIT+1 # We know 1 is prime, so # let's start with 2.  until [ $i -gt $UPPER_LIMIT ] do  if [ ${Primes[i]} -eq $PRIME ] # Don't bother sieving numbers # already sieved (tagged as non-prime). then    t=$i    while [ $t -le $UPPER_LIMIT ]   do     let ""t += $i ""     Primes[t]=$NON_PRIME     # Tag as non-prime     # all multiples.   done  fi      let ""i += 1"" done     }   # Invoke the functions sequentially. initialize sift print_primes echo # This is what they call structured programming.  exit 0 Prev Home Next List Constructs Up Files"
GX070-57-9536249	"Go to the  previous ,  next  section.   Certain Changes We Don't Want to Make    This section lists changes that people frequently request, but which we do not make because we think GNU CC is better without them.       Checking the number and type of arguments to a function which has an old-fashioned definition and no prototype.   Such a feature would work only occasionally--only for calls that appear in the same file as the called function, following the definition.  The only way to check all calls reliably is to add a prototype for the function.  But adding a prototype eliminates the motivation for this feature.  So the feature is not worthwhile.     Warning about using an expression whose type is signed as a shift count.   Shift count operands are probably signed more often than unsigned. Warning about this would cause far more annoyance than good.     Warning about assigning a signed value to an unsigned variable.   Such assignments must be very common; warning about them would cause more annoyance than good.     Warning about unreachable code.   It's very common to have unreachable code in machine-generated programs.  For example, this happens normally in some files of GNU C itself.     Warning when a non-void function value is ignored.   Coming as I do from a Lisp background, I balk at the idea that there is something dangerous about discarding a value.  There are functions that return values which some callers may find useful; it makes no sense to clutter the program with a cast to  void  whenever the value isn't useful.     Assuming (for optimization) that the address of an external symbol is never zero.   This assumption is false on certain systems when  `#pragma weak'  is used.     Making  `-fshort-enums'  the default.   This would cause storage layout to be incompatible with most other C compilers.  And it doesn't seem very important, given that you can get the same result in other ways.  The case where it matters most is when the enumeration-valued object is inside a structure, and in that case you can specify a field width explicitly.     Making bitfields unsigned by default on particular machines where ""the ABI standard"" says to do so.   The ANSI C standard leaves it up to the implementation whether a bitfield declared plain  int  is signed or not.  This in effect creates two alternative dialects of C.   The GNU C compiler supports both dialects; you can specify the signed dialect with  `-fsigned-bitfields'  and the unsigned dialect with  `-funsigned-bitfields' .  However, this leaves open the question of which dialect to use by default.   Currently, the preferred dialect makes plain bitfields signed, because this is simplest.  Since  int  is the same as  signed int  in every other context, it is cleanest for them to be the same in bitfields as well.   Some computer manufacturers have published Application Binary Interface standards which specify that plain bitfields should be unsigned.  It is a mistake, however, to say anything about this issue in an ABI.  This is because the handling of plain bitfields distinguishes two dialects of C. Both dialects are meaningful on every type of machine.  Whether a particular object file was compiled using signed bitfields or unsigned is of no concern to other object files, even if they access the same bitfields in the same data structures.   A given program is written in one or the other of these two dialects. The program stands a chance to work on most any machine if it is compiled with the proper dialect.  It is unlikely to work at all if compiled with the wrong dialect.   Many users appreciate the GNU C compiler because it provides an environment that is uniform across machines.  These users would be inconvenienced if the compiler treated plain bitfields differently on certain machines.   Occasionally users write programs intended only for a particular machine type.  On these occasions, the users would benefit if the GNU C compiler were to support by default the same dialect as the other compilers on that machine.  But such applications are rare.  And users writing a program to run on more than one type of machine cannot possibly benefit from this kind of compatibility.   This is why GNU CC does and will treat plain bitfields in the same fashion on all types of machines (by default).   There are some arguments for making bitfields unsigned by default on all machines.  If, for example, this becomes a universal de facto standard, it would make sense for GNU CC to go along with it.  This is something to be considered in the future.   (Of course, users strongly concerned about portability should indicate explicitly in each bitfield whether it is signed or not.  In this way, they write programs which have the same meaning in both C dialects.)     Undefining  __STDC__  when  `-ansi'  is not used.   Currently, GNU CC defines  __STDC__  as long as you don't use  `-traditional' .  This provides good results in practice.   Programmers normally use conditionals on  __STDC__  to ask whether it is safe to use certain features of ANSI C, such as function prototypes or ANSI token concatenation.  Since plain  `gcc'  supports all the features of ANSI C, the correct answer to these questions is ""yes"".   Some users try to use  __STDC__  to check for the availability of certain library facilities.  This is actually incorrect usage in an ANSI C program, because the ANSI C standard says that a conforming freestanding implementation should define  __STDC__  even though it does not have the library facilities.   `gcc -ansi -pedantic'  is a conforming freestanding implementation, and it is therefore required to define  __STDC__ , even though it does not come with an ANSI C library.   Sometimes people say that defining  __STDC__  in a compiler that does not completely conform to the ANSI C standard somehow violates the standard.  This is illogical.  The standard is a standard for compilers that claim to support ANSI C, such as  `gcc -ansi' ---not for other compilers such as plain  `gcc' .  Whatever the ANSI C standard says is relevant to the design of plain  `gcc'  without  `-ansi'  only for pragmatic reasons, not as a requirement.     Undefining  __STDC__  in C++.   Programs written to compile with C++-to-C translators get the value of  __STDC__  that goes with the C compiler that is subsequently used.  These programs must test  __STDC__  to determine what kind of C preprocessor that compiler uses: whether they should concatenate tokens in the ANSI C fashion or in the traditional fashion.   These programs work properly with GNU C++ if  __STDC__  is defined. They would not work otherwise.   In addition, many header files are written to provide prototypes in ANSI C but not in traditional C.  Many of these header files can work without change in C++ provided  __STDC__  is defined.  If  __STDC__  is not defined, they will all fail, and will all need to be changed to test explicitly for C++ as well.     Deleting ""empty"" loops.   GNU CC does not delete ""empty"" loops because the most likely reason you would put one in a program is to have a delay.  Deleting them will not make real programs run any faster, so it would be pointless.   It would be different if optimization of a nonempty loop could produce an empty one.  But this generally can't happen.     Making side effects happen in the same order as in some other compiler.       It is never safe to depend on the order of evaluation of side effects. For example, a function call like this may very well behave differently from one compiler to another:    void func (int, int);  int i = 2; func (i++, i++);     There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order.  Either increment might happen first.   func  might get the arguments  `3, 4' , or it might get  `4, 3' , or even  `3, 3' .     Using the ""canonical"" form of the target configuration name as the directory for installation.   This would be an improvement in some respects, but it would also cause problems.  For one thing, users might expect to use in the  `-b'  option the same name specified at installation; if installation used the canonical form, that would not work.  What's more, the canonical name might be too long for certain file systems.   We suggest you make a link to the installation directory under the canonical name, if you want to use that name in the  `-b'  option.      Go to the  previous ,  next  section."
